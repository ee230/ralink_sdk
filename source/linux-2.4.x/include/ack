acpi/acevents.h: * Name: acevents.h - Event subcomponent prototypes and defines
acpi/acevents.h: * Copyright (C) 2000 - 2004, R. Byron Moore
acpi/acevents.h: * 3. Neither the names of the above-listed copyright holders nor the names
acpi/acevents.h: * Evfixed - Fixed event handling
acpi/acevents.h: * Evgpe - GPE handling and dispatch
acpi/acevents.h: * Evregion - Address Space handling
acpi/acevents.h: * Evregini - Region initialization and setup
acpi/acevents.h: * Evsci - SCI (System Control Interrupt) handling/dispatch
acpi/acoutput.h: * Name: acoutput.h -- debug output
acpi/acoutput.h: * Copyright (C) 2000 - 2004, R. Byron Moore
acpi/acoutput.h: * 3. Neither the names of the above-listed copyright holders nor the names
acpi/acoutput.h: * granularity of the output of the DEBUG_PRINT macro -- on a per-
acpi/acoutput.h: * component basis and a per-exception-type basis.
acpi/acoutput.h:/* Exceptionally verbose output -- also used in the global "debug_level" */
acpi/acoutput.h:/* Exception level -- used in the global "debug_level" */
acpi/acoutput.h:/* Trace level -- also used in the global "debug_level" */
acpi/actypes.h: * Name: actypes.h - Common data types for the entire ACPI subsystem
acpi/actypes.h: * Copyright (C) 2000 - 2004, R. Byron Moore
acpi/actypes.h: * 3. Neither the names of the above-listed copyright holders nor the names
acpi/actypes.h: * working around problems that some 32-bit compilers have with 64-bit
acpi/actypes.h: * cross-platform compilation only.
acpi/actypes.h: * Data types - Fixed across all compilation models (16/32/64)
acpi/actypes.h: * INT8             8-bit  (1 byte) signed value
acpi/actypes.h: * UINT8            8-bit  (1 byte) unsigned value
acpi/actypes.h: * INT16            16-bit (2 byte) signed value
acpi/actypes.h: * UINT16           16-bit (2 byte) unsigned value
acpi/actypes.h: * INT32            32-bit (4 byte) signed value
acpi/actypes.h: * UINT32           32-bit (4 byte) unsigned value
acpi/actypes.h: * INT64            64-bit (8 byte) signed value
acpi/actypes.h: * UINT64           64-bit (8 byte) unsigned value
acpi/actypes.h: * ACPI_NATIVE_INT  32-bit on IA-32, 64-bit on IA-64 signed value
acpi/actypes.h: * ACPI_NATIVE_UINT 32-bit on IA-32, 64-bit on IA-64 unsigned value
acpi/actypes.h: * 64-bit type definitions
acpi/actypes.h:#define ACPI_USE_NATIVE_DIVIDE                          /* Native 64-bit integer support */
acpi/actypes.h: * 16-bit type definitions
acpi/actypes.h:#define ACPI_USE_NATIVE_DIVIDE                          /* No 64-bit integers, ok to use native divide */
acpi/actypes.h: * (16-bit only) internal integers must be 32-bits, so
acpi/actypes.h: * 64-bit integers cannot be supported
acpi/actypes.h: * 32-bit type definitions (default)
acpi/actypes.h:typedef u32                                     acpi_name;      /* 4-byte ACPI name */
acpi/actypes.h:/* 32-bit integers only, no 64-bit support */
acpi/actypes.h:#define ACPI_USE_NATIVE_DIVIDE          /* Use compiler native 32-bit divide */
acpi/actypes.h:/* 64-bit integers */
acpi/actypes.h:#define ACPI_USE_NATIVE_DIVIDE          /* Use compiler native 64-bit divide */
acpi/actypes.h: * Event Status - Per event
acpi/actypes.h: * -------------
acpi/actypes.h: * +-------------+-+-+-+
acpi/actypes.h: * +-------------+-+-+-+
acpi/actypes.h: *          |     | | +- Enabled?
acpi/actypes.h: *          |     | +--- Enabled for wake?
acpi/actypes.h: *          |     +----- Set?
acpi/actypes.h: *          +----------- <Reserved>
acpi/actypes.h: * GPE info flags - Per GPE
acpi/actypes.h: * +---------+-+-+-+
acpi/actypes.h: * +---------+-+-+-+
acpi/actypes.h: *          | | | +- Edge or Level Triggered
acpi/actypes.h: *          | | +--- Type: Wake or Runtime
acpi/actypes.h: *          | +----- Enabled for wake?
acpi/actypes.h: *          +--------<Reserved>
acpi/actypes.h:#define ACPI_ALLOCATE_BUFFER        (acpi_size) (-1)
acpi/actypes.h:#define ACPI_ALLOCATE_LOCAL_BUFFER  (acpi_size) (-2)
acpi/actypes.h: *  The ISA Io ranges are:     n000-n0_ffh, n400-n4_ffh, n800-n8_ffh, n_c00-n_cFFh.
acpi/actypes.h: *  The non-ISA Io ranges are: n100-n3_ffh, n500-n7_ffh, n900-n_bFfh, n_cd0-n_fFFh.
acpi/actypes.h:#define ACPI_DECODE_10                  (u8) 0x00    /* 10-bit IO address decode */
acpi/actypes.h:#define ACPI_DECODE_16                  (u8) 0x01    /* 16-bit IO address decode */
acpi/actypes.h: *  16, 32 and 64-bit Address Descriptor resource types
acpi/actypes.h:#define ACPI_NEXT_RESOURCE(res)             (struct acpi_resource *)((u8 *) res + res->length)
acpi/actypes.h:	acpi_integer                        address;        /* here for 64-bit alignment */
acpi/acutils.h: * Name: acutils.h -- prototypes for the common (subsystem-wide) procedures
acpi/acutils.h: * Copyright (C) 2000 - 2004, R. Byron Moore
acpi/acutils.h: * 3. Neither the names of the above-listed copyright holders nor the names
acpi/acutils.h: * ut_init - miscellaneous initialization and shutdown
acpi/acutils.h: * ut_global - Global data structures and procedures
acpi/acutils.h: * ut_clib - Local implementations of C library functions
acpi/acutils.h:#define _ACPI_XA     0x00    /* extra alphabetic - not supported */
acpi/acutils.h:#define _ACPI_BB     0x00    /* BEL, BS, etc. - not supported */
acpi/acutils.h:#define _ACPI_DI     0x04    /* '0'-'9' */
acpi/acutils.h:#define _ACPI_LO     0x02    /* 'a'-'z' */
acpi/acutils.h:#define _ACPI_UP     0x01    /* 'A'-'Z' */
acpi/acutils.h:#define _ACPI_XD     0x80    /* '0'-'9', 'A'-'F', 'a'-'f' */
acpi/acutils.h: * ut_copy - Object construction and conversion interfaces
acpi/acutils.h: * ut_create - Object creation
acpi/acutils.h: * ut_debug - Debug interfaces
acpi/acutils.h: * ut_delete - Object deletion
acpi/acutils.h: * ut_eval - object evaluation
acpi/acutils.h: * ut_mutex - mutual exclusion interfaces
acpi/acutils.h: * ut_object - internal object create/delete/cache routines
acpi/acutils.h: * ut_ref_cnt - Object reference count management
acpi/acutils.h: * ut_size - Object size routines
acpi/acutils.h: * ut_state - Generic state creation/cache routines
acpi/acutils.h: * Utalloc - memory allocation and object caching
acpi/acobject.h: * Name: acobject.h - Definition of union acpi_operand_object    (Internal object only)
acpi/acobject.h: * Copyright (C) 2000 - 2004, R. Byron Moore
acpi/acobject.h: * 3. Neither the names of the above-listed copyright holders nor the names
acpi/acobject.h:#define ACPI_OBJECT_COMMON_HEADER   /* SIZE/ALIGNMENT: 32 bits, one ptr plus trailing 8-bit flag */\
acpi/acobject.h: * "Field Datum"  -- a datum from the actual field object
acpi/acobject.h: * "Buffer Datum" -- a datum from a user buffer, read from or to be written to the field
acpi/acobject.h:#define ACPI_COMMON_FIELD_INFO      /* SIZE/ALIGNMENT: 24 bits + three 32-bit values */\
acpi/acobject.h:	u8                                      start_field_bit_offset;/* Bit offset within first field datum (0-63) */\
acpi/acobject.h: * Arg[0-6], Local[0-7], index_op, name_op, zero_op, one_op, ones_op, debug_op
acpi/acobject.h:	void                                    *region_context;    /* Region-specific data */
acpi/acobject.h: * union acpi_operand_object Descriptor - a giant union of all of the above
acpi/acobject.h: * union acpi_descriptor - objects that share a common descriptor identifier
acpi/achware.h: * Name: achware.h -- hardware specific interfaces
acpi/achware.h: * Copyright (C) 2000 - 2004, R. Byron Moore
acpi/achware.h: * 3. Neither the names of the above-listed copyright holders nor the names
acpi/amlresrc.h: * Module Name: amlresrc.h - AML resource descriptors
acpi/amlresrc.h: * Copyright (C) 2000 - 2004, R. Byron Moore
acpi/amlresrc.h: * 3. Neither the names of the above-listed copyright holders nor the names
acpi/acstruct.h: * Name: acstruct.h - Internal structs
acpi/acstruct.h: * Copyright (C) 2000 - 2004, R. Byron Moore
acpi/acstruct.h: * 3. Neither the names of the above-listed copyright holders nor the names
acpi/acstruct.h: * Walk state - current state of a parse tree walk.  Used for both a leisurely stroll through
acpi/acpi_drivers.h: *  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
acpi/acpi_drivers.h:/* --------------------------------------------------------------------------
acpi/acpi_drivers.h:   -------------------------------------------------------------------------- */
acpi/acpi_drivers.h:/* --------------------------------------------------------------------------
acpi/acpi_drivers.h:   -------------------------------------------------------------------------- */
acpi/acpi_drivers.h:/* --------------------------------------------------------------------------
acpi/acpi_drivers.h:   -------------------------------------------------------------------------- */
acpi/acpi_drivers.h:/* --------------------------------------------------------------------------
acpi/acpi_drivers.h:   -------------------------------------------------------------------------- */
acpi/acpi_drivers.h:/* --------------------------------------------------------------------------
acpi/acpi_drivers.h:   -------------------------------------------------------------------------- */
acpi/acpi_drivers.h:/* --------------------------------------------------------------------------
acpi/acpi_drivers.h:   -------------------------------------------------------------------------- */
acpi/acpi_drivers.h:/* --------------------------------------------------------------------------
acpi/acpi_drivers.h:   -------------------------------------------------------------------------- */
acpi/acpi_drivers.h:/* --------------------------------------------------------------------------
acpi/acpi_drivers.h:   -------------------------------------------------------------------------- */
acpi/acpi_drivers.h:/* --------------------------------------------------------------------------
acpi/acpi_drivers.h:   -------------------------------------------------------------------------- */
acpi/acpi_drivers.h:/* --------------------------------------------------------------------------
acpi/acpi_drivers.h:   -------------------------------------------------------------------------- */
acpi/acpi_drivers.h:/* --------------------------------------------------------------------------
acpi/acpi_drivers.h:   -------------------------------------------------------------------------- */
acpi/acpi_drivers.h:/* --------------------------------------------------------------------------
acpi/acpi_drivers.h:   -------------------------------------------------------------------------- */
acpi/acpi.h: * Name: acpi.h - Master include file, Publics and external data.
acpi/acpi.h: * Copyright (C) 2000 - 2004, R. Byron Moore
acpi/acpi.h: * 3. Neither the names of the above-listed copyright holders nor the names
acpi/acpi.h:#include "acpiosxf.h"           /* Interfaces to the ACPI-to-OS layer*/
acpi/acinterp.h: * Name: acinterp.h - Interpreter subcomponent prototypes and defines
acpi/acinterp.h: * Copyright (C) 2000 - 2004, R. Byron Moore
acpi/acinterp.h: * 3. Neither the names of the above-listed copyright holders nor the names
acpi/acinterp.h:#define ACPI_WALK_OPERANDS       (&(walk_state->operands [walk_state->num_operands -1]))
acpi/acinterp.h: * exxface - External interpreter interfaces
acpi/acinterp.h: * exconvrt - object conversion
acpi/acinterp.h: * exfield - ACPI AML (p-code) execution - field manipulation
acpi/acinterp.h: * exmisc - ACPI AML (p-code) execution - specific opcodes
acpi/acinterp.h: * exconfig - dynamic table load/unload
acpi/acinterp.h: * exmutex - mutex support
acpi/acinterp.h: * exprep - ACPI AML (p-code) execution - prep utilities
acpi/acinterp.h: * exsystem - Interface to OS services
acpi/acinterp.h: * exmonadic - ACPI AML (p-code) execution, monadic operators
acpi/acinterp.h: * exdyadic - ACPI AML (p-code) execution, dyadic operators
acpi/acinterp.h: * exresolv  - Object resolution and get value functions
acpi/acinterp.h: * exdump - Scanner debug output routines
acpi/acinterp.h: * exnames - interpreter/scanner name load/execute
acpi/acinterp.h: * exstore - Object store support
acpi/acinterp.h: * excopy - object copy
acpi/acinterp.h: * exutils - interpreter/scanner utilities
acpi/acinterp.h: * exregion - default op_region handlers
acpi/acnamesp.h: * Name: acnamesp.h - Namespace subcomponent prototypes and defines
acpi/acnamesp.h: * Copyright (C) 2000 - 2004, R. Byron Moore
acpi/acnamesp.h: * 3. Neither the names of the above-listed copyright holders nor the names
acpi/acnamesp.h: * and should be one-to-one with values of acpi_object_type
acpi/acnamesp.h:/* Namespace init - nsxfinit */
acpi/acnamesp.h:/* Namespace loading - nsload */
acpi/acnamesp.h: * Top-level namespace access - nsaccess
acpi/acnamesp.h: * Named object allocation/deallocation - nsalloc
acpi/acnamesp.h: * Namespace modification - nsmodify
acpi/acnamesp.h: * Namespace dump/print utilities - nsdump
acpi/acnamesp.h: * Namespace evaluation functions - nseval
acpi/acnamesp.h: * Name and Scope manipulation - nsnames
acpi/acnamesp.h: * Object management for namespace nodes - nsobject
acpi/acnamesp.h: * Namespace searching and entry - nssearch
acpi/acnamesp.h: * Utility functions - nsutils
acpi/acdebug.h: * Name: acdebug.h - ACPI/AML debugger
acpi/acdebug.h: * Copyright (C) 2000 - 2004, R. Byron Moore
acpi/acdebug.h: * 3. Neither the names of the above-listed copyright holders nor the names
acpi/acdebug.h: * dbxface - external debugger interfaces
acpi/acdebug.h: * dbcmds - debug commands and output routines
acpi/acdebug.h: * dbdisply - debug display commands
acpi/acdebug.h: * dbexec - debugger control method execution
acpi/acdebug.h: * dbfileio - Debugger file I/O commands
acpi/acdebug.h: * dbhistry - debugger HISTORY command
acpi/acdebug.h: * dbinput - user front-end to the AML debugger
acpi/acdebug.h: * dbstats - Generation and display of ACPI table statistics
acpi/acdebug.h: * dbutils - AML debugger utilities
acpi/acresrc.h: * Name: acresrc.h - Resource Manager function prototypes
acpi/acresrc.h: * Copyright (C) 2000 - 2004, R. Byron Moore
acpi/acresrc.h: * 3. Neither the names of the above-listed copyright holders nor the names
acpi/amlcode.h: * Name: amlcode.h - Definitions for AML, as included in "definition blocks"
acpi/amlcode.h: * Copyright (C) 2000 - 2004, R. Byron Moore
acpi/amlcode.h: * 3. Neither the names of the above-listed copyright holders nor the names
acpi/amlcode.h: * any valid ACPI ASCII values (A-Z, 0-9, '-')
acpi/amlcode.h: * Zero is reserved as end-of-list indicator
acpi/amlcode.h: * There can be up to 31 unique argument types (0 is end-of-arg-list indicator)
acpi/amlcode.h: * to convert to a 6-byte array of argument types, allowing 8 bits per argument.
acpi/amlcode.h:#define ARGI_SIMPLE_TARGET          0x11    /* Name, Local, Arg -- no implicit conversion */
acpi/amlcode.h:#define ARGI_DATAOBJECT             0x12    /* Buffer, String, package or reference to a Node - Used only by size_of operator*/
acpi/amlcode.h: * Bits 00 - 03 : access_type (any_acc, byte_acc, etc.)
acpi/amlcode.h: *      05 - 06 : update_rule
acpi/acpixf.h: * Name: acpixf.h - External interfaces to the ACPI subsystem
acpi/acpixf.h: * Copyright (C) 2000 - 2004, R. Byron Moore
acpi/acpixf.h: * 3. Neither the names of the above-listed copyright holders nor the names
acpi/actbl.h: * Name: actbl.h - Table data structures defined in ACPI specification
acpi/actbl.h: * Copyright (C) 2000 - 2004, R. Byron Moore
acpi/actbl.h: * 3. Neither the names of the above-listed copyright holders nor the names
acpi/actbl.h: * ACPI Version-independent tables
acpi/actbl.h:	u32                             rsdt_physical_address;  /* 32-bit physical address of RSDT */
acpi/actbl.h:	u64                             xsdt_physical_address;  /* 64-bit physical address of XSDT */
acpi/actbl.h: * MADT sub-structures (Follow MULTIPLE_APIC_DESCRIPTION_TABLE)
acpi/actbl.h:#define APIC_HEADER_DEF                     /* Common APIC sub-structure header */\
acpi/actbl.h:/* Sub-structures for MADT */
acpi/actbl.h:	u8                              reserved;               /* Reserved - must be zero */
acpi/actbl.h:	u8                              bus;                    /* 0 - ISA */
acpi/actbl.h:	u16                             reserved;               /* Reserved - must be zero */
acpi/actbl.h:	u8                              reserved;               /* Reserved - must be zero */
acpi/actbl.h:	u8                              reserved [3];           /* Reserved - must be zero */
acpi/actbl.h:	u32                             reserved;               /* Reserved - must be zero */
acpi/actbl.h: * Get the ACPI version-specific tables
acpi/actbl1.h: * Name: actbl1.h - ACPI 1.0 tables
acpi/actbl1.h: * Copyright (C) 2000 - 2004, R. Byron Moore
acpi/actbl1.h: * 3. Neither the names of the above-listed copyright holders nor the names
acpi/actbl1.h:	u8                              resverved3 [40];        /* Reserved - must be zero */
acpi/actbl1.h:	u8                              reserved2;              /* Reserved - must be zero */
acpi/actbl1.h:	u8                              day_alrm;               /* Index to day-of-month alarm in RTC CMOS RAM */
acpi/actbl1.h:	u8                              mon_alrm;               /* Index to month-of-year alarm in RTC CMOS RAM */
acpi/actbl1.h:	u32                             reserved5       : 23;   /* Reserved - must be zero */
acpi/actbl2.h: * Name: actbl2.h - ACPI Specification Revision 2.0 Tables
acpi/actbl2.h: * Copyright (C) 2000 - 2004, R. Byron Moore
acpi/actbl2.h: * 3. Neither the names of the above-listed copyright holders nor the names
acpi/actbl2.h:	u32                             S4bios_f        : 1;    /* S4Bios_f - Indicates if S4BIOS support is present */
acpi/actbl2.h:	u8                              reserved3 [31];         /* Reserved - must be zero */
acpi/actbl2.h:	u64                             address;                /* 64-bit address of struct or register */
acpi/actbl2.h:	u32                             V1_firmware_ctrl;   /* 32-bit physical address of FACS */
acpi/actbl2.h:	u32                             V1_dsdt;            /* 32-bit physical address of DSDT */
acpi/actbl2.h:	u8                              day_alrm;           /* Index to day-of-month alarm in RTC CMOS RAM */
acpi/actbl2.h:	u8                              mon_alrm;           /* Index to month-of-year alarm in RTC CMOS RAM */
acpi/actbl2.h:	u16                             iapc_boot_arch;     /* IA-PC Boot Architecture Flags. See Table 5-10 for description*/
acpi/actbl2.h:	u32                             tmr_val_ext : 1;    /* Indicates tmr_val is 32 bits 0=24-bits*/
acpi/actbl2.h:	u32                             reserved6   : 18;   /* Reserved - must be zero */
acpi/actbl2.h:	u64                             xfirmware_ctrl;     /* 64-bit physical address of FACS */
acpi/actbl2.h:	u64                             Xdsdt;              /* 64-bit physical address of DSDT */
acpi/actbl2.h:	u32                             uid;                /* Unique ID - must be same as the EC _UID method */
acpi/acdisasm.h: * Name: acdisasm.h - AML disassembler
acpi/acdisasm.h: * Copyright (C) 2000 - 2004, R. Byron Moore
acpi/acdisasm.h: * 3. Neither the names of the above-listed copyright holders nor the names
acpi/acpi_bus.h: *  acpi_bus.h - ACPI Bus Driver ($Revision: 1.1.1.1 $)
acpi/acpi_bus.h: *  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
acpi/acpi_bus.h: * -----------
acpi/acpi_bus.h: * -----------
acpi/acpi_bus.h:#define acpi_device_dir(d)	((d)->dir.entry)
acpi/acpi_bus.h:	acpi_device_name	device_name;	         /* Driver-determined */
acpi/acpi_bus.h:#define acpi_device_bid(d)	((d)->pnp.bus_id)
acpi/acpi_bus.h:#define acpi_device_adr(d)	((d)->pnp.bus_address)
acpi/acpi_bus.h:#define acpi_device_hid(d)	((d)->pnp.hardware_id)
acpi/acpi_bus.h:#define acpi_device_uid(d)	((d)->pnp.unique_id)
acpi/acpi_bus.h:#define acpi_device_name(d)	((d)->pnp.device_name)
acpi/acpi_bus.h:#define acpi_device_class(d)	((d)->pnp.device_class)
acpi/acpi_bus.h:	u32			inrush_current:1;	  /* Serialize Dx->D0 */
acpi/acpi_bus.h:	u32			power_removed:1;	   /* Optimize Dx->D0 */
acpi/acpi_bus.h:	int			latency;	/* Dx->D0 time (microseconds) */
acpi/acpi_bus.h:	struct acpi_device_power_state states[4];     /* Power states (D0-D3) */
acpi/acpi_bus.h:	int			latency;	/* Px->P0 time (microseconds) */
acpi/acpi_bus.h:#define acpi_driver_data(d)	((d)->driver_data)
acpi/acpi_bus.h: * ------
acpi/acdispat.h: * Name: acdispat.h - dispatcher (parser to interpreter interface)
acpi/acdispat.h: * Copyright (C) 2000 - 2004, R. Byron Moore
acpi/acdispat.h: * 3. Neither the names of the above-listed copyright holders nor the names
acpi/acdispat.h:/* dsopcode - support for late evaluation */
acpi/acdispat.h:/* dsctrl - Parser/Interpreter interface, control stack routines */
acpi/acdispat.h:/* dsexec - Parser/Interpreter interface, method execution callbacks */
acpi/acdispat.h:/* dsfield - Parser/Interpreter interface for AML fields */
acpi/acdispat.h:/* dsload - Parser/Interpreter interface, namespace load callbacks */
acpi/acdispat.h:/* dsmthdat - method data (locals/args) */
acpi/acdispat.h:/* dsmethod - Parser/Interpreter interface - control method parsing */
acpi/acdispat.h:/* dsobj - Parser/Interpreter interface - object initialization and conversion */
acpi/acdispat.h:/* dsutils - Parser/Interpreter interface utility routines */
acpi/acdispat.h: * dswscope - Scope Stack manipulation
acpi/acdispat.h:/* dswstate - parser WALK_STATE management routines */
acpi/acmacros.h: * Name: acmacros.h - C macros for the entire subsystem.
acpi/acmacros.h: * Copyright (C) 2000 - 2004, R. Byron Moore
acpi/acmacros.h: * 3. Neither the names of the above-listed copyright holders nor the names
acpi/acmacros.h: * For 16-bit addresses, we have to assume that the upper 32 bits
acpi/acmacros.h: * acpi_integer is 32-bits, no 64-bit support on this platform
acpi/acmacros.h: * Full 64-bit address/integer on both 32-bit and 64-bit platforms
acpi/acmacros.h:/* Split 64-bit integer into two 32-bit values. use with %8,8_x%8.8X */
acpi/acmacros.h: * get into potential aligment issues -- see the STORE macros below
acpi/acmacros.h:#define ACPI_PTR_DIFF(a,b)              (acpi_native_uint) ((char *)(a) - (char *)(b))
acpi/acmacros.h:#define ACPI_OFFSET(d,f)                (acpi_size) ACPI_PTR_DIFF (&(((d *)0)->f),(void *) NULL)
acpi/acmacros.h: * Macros for big-endian machines
acpi/acmacros.h:#define ACPI_BUFFER_INDEX(buf_len,buf_offset,byte_gran) ((buf_len) - (((buf_offset)+1) * (byte_gran)))
acpi/acmacros.h:/* These macros reverse the bytes during the move, converting little-endian to big endian */
acpi/acmacros.h:/* 16-bit source, 16/32/64 destination */
acpi/acmacros.h:/* 32-bit source, 16/32/64 destination */
acpi/acmacros.h:/* 64-bit source, 16/32/64 destination */
acpi/acmacros.h: * Macros for little-endian machines
acpi/acmacros.h:/* The hardware supports unaligned transfers, just do the little-endian move */
acpi/acmacros.h:/* No 64-bit integers */
acpi/acmacros.h:/* 16-bit source, 16/32/64 destination */
acpi/acmacros.h:/* 32-bit source, 16/32/64 destination */
acpi/acmacros.h:/* 64-bit source, 16/32/64 destination */
acpi/acmacros.h:/* 16-bit source, 16/32/64 destination */
acpi/acmacros.h:/* 32-bit source, 16/32/64 destination */
acpi/acmacros.h:/* 64-bit source, 16/32/64 destination */
acpi/acmacros.h: * the destination (or both) is/are unaligned.  (Little-endian move)
acpi/acmacros.h:/* 16-bit source, 16/32/64 destination */
acpi/acmacros.h:/* 32-bit source, 16/32/64 destination */
acpi/acmacros.h:/* 64-bit source, 16/32/64 destination */
acpi/acmacros.h: * Fast power-of-two math macros for non-optimized compilers
acpi/acmacros.h:#define _ACPI_MOD(value,divisor)        ((u32) ((value) & ((divisor) -1)))
acpi/acmacros.h:#define ACPI_ROUND_DOWN(value,boundary)      (((acpi_native_uint)(value)) & (~(((acpi_native_uint) boundary)-1)))
acpi/acmacros.h:#define ACPI_ROUND_UP(value,boundary)        ((((acpi_native_uint)(value)) + (((acpi_native_uint) boundary)-1)) & (~(((acpi_native_uint) boundary)-1)))
acpi/acmacros.h:/* Generic (non-power-of-two) rounding */
acpi/acmacros.h:#define ACPI_ROUND_UP_TO(value,boundary)     (((value) + ((boundary)-1)) / (boundary))
acpi/acmacros.h:/* No support for GAS and PCI IDs in 16-bit mode  */
acpi/acmacros.h:#define ACPI_GET_DESCRIPTOR_TYPE(d)     (((union acpi_descriptor *)(void *)(d))->descriptor_id)
acpi/acmacros.h:#define ACPI_SET_DESCRIPTOR_TYPE(d,t)   (((union acpi_descriptor *)(void *)(d))->descriptor_id = t)
acpi/acmacros.h:#define ACPI_GET_OBJECT_TYPE(d)         (((union acpi_operand_object *)(void *)(d))->common.type)
acpi/acmacros.h: * This is the non-debug case -- make everything go away,
acpi/acmacros.h: * For 16-bit code, we want to shrink some things even though
acpi/acmacros.h:#define ACPI_ADD_OBJECT_NAME(a,b)       ACPI_MEMSET (a->common.name, ' ', sizeof (a->common.name));\
acpi/acmacros.h:										ACPI_STRNCPY (a->common.name, acpi_gbl_ns_type_names[b], sizeof (a->common.name))
acpi/aclocal.h: * Name: aclocal.h - Internal data types used across the ACPI subsystem
acpi/aclocal.h: * Copyright (C) 2000 - 2004, R. Byron Moore
acpi/aclocal.h: * 3. Neither the names of the above-listed copyright holders nor the names
acpi/aclocal.h:#define ACPI_MUTEX_NOT_ACQUIRED         (u32) (-1)
acpi/aclocal.h:#define ANOBJ_DATA_WIDTH_32             0x04     /* Parent table is 64-bits */
acpi/aclocal.h:/* Info structure used to convert external<->internal namestrings */
acpi/aclocal.h: * Information about a GPE register block, one per each installed block --
acpi/aclocal.h:#define ACPI_STATE_COMMON                  /* Two 32-bit fields and a pointer */\
acpi/aclocal.h: * Update state - used to traverse complex objects such as packages
acpi/aclocal.h: * Pkg state - used to traverse nested package structures
acpi/aclocal.h: * Control state - one per if/else and while constructs.
acpi/aclocal.h: * Scope state - current scope during namespace lookups
acpi/aclocal.h: * Thread state - one per thread across multiple walk states.  Multiple walk
acpi/aclocal.h: * Result values - used to accumulate the results of nested
acpi/aclocal.h: * Notify info - used to pass info to the deferred notify
acpi/aclocal.h:	struct uint64_struct                integer64;      /* Structure overlay for 2 32-bit Dwords */
acpi/aclocal.h:			   /* NON-DEBUG members below: */\
acpi/aclocal.h:	u32                                 name;           /* 4-byte name or zero if no name */
acpi/aclocal.h: * Parse state - one state per parser invocation and each control
acpi/actbl71.h: * Name: actbl71.h - IA-64 Extensions to the ACPI Spec Rev. 0.71
acpi/actbl71.h: *  Copyright (C) 2000 - 2003, R. Byron Moore
acpi/actbl71.h: *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
acpi/actbl71.h:	u64                             rsdt_physical_address;  /* 64-bit physical address of RSDT */
acpi/actbl71.h:	u8                          reserved3 [28];       /* reserved - must be zero */
acpi/actbl71.h:	u64                         firmware_ctrl;      /* 64-bit Physical address of FACS */
acpi/actbl71.h:	u64                         dsdt;               /* 64-bit Physical address of DSDT */
acpi/actbl71.h:	u8                          reserved2;          /* reserved - must be zero */
acpi/actbl71.h:	u8                          day_alrm;           /* index to day-of-month alarm in RTC CMOS RAM */
acpi/actbl71.h:	u8                          mon_alrm;           /* index to month-of-year alarm in RTC CMOS RAM */
acpi/actbl71.h:	u32                         reserved5   : 1;    /* reserved - must be zero */
acpi/actbl71.h:	u32                         reserved6   : 22;    /* reserved - must be zero */
acpi/platform/acenv.h: * Name: acenv.h - Generation environment specific items
acpi/platform/acenv.h: * Copyright (C) 2000 - 2004, R. Byron Moore
acpi/platform/acenv.h: * 3. Neither the names of the above-listed copyright holders nor the names
acpi/platform/acenv.h: * 1) ACPI_USE_SYSTEM_CLIBRARY - Define this if linking to an actual C library.
acpi/platform/acenv.h: * 2) ACPI_USE_STANDARD_HEADERS - Define this if linking to a C library and
acpi/platform/acenv.h:/* This macro is used to tag functions as "printf-like" because
acpi/platform/acenv.h: * 2) This is NOT a 16-bit version of the code (not enough real-mode memory)
acpi/platform/acenv.h: * multi-threaded if ACPI_APPLICATION is not set.
acpi/platform/acenv.h:#define  _AUPBND                (sizeof (acpi_native_int) - 1)
acpi/platform/acenv.h:#define  _ADNBND                (sizeof (acpi_native_int) - 1)
acpi/platform/acenv.h:#define va_arg(ap, T)           (*(T *)(((ap) += (_bnd (T, _AUPBND))) - (_bnd (T,_ADNBND))))
acpi/platform/acenv.h: * Handle platform- and compiler-specific assembly language differences.
acpi/platform/acenv.h: * ACPI_SYSTEM_XFACE        - Interfaces to host OS (handlers, threads)
acpi/platform/acenv.h: * ACPI_EXTERNAL_XFACE      - External ACPI interfaces
acpi/platform/acenv.h: * ACPI_INTERNAL_XFACE      - Internal ACPI interfaces
acpi/platform/acenv.h: * ACPI_INTERNAL_VAR_XFACE  - Internal variable-parameter list interfaces
acpi/platform/acenv.h: * Compiler-specific information is contained in the compiler-specific
acpi/platform/acgcc.h: * Name: acgcc.h - GCC specific defines, etc.
acpi/platform/acgcc.h: * Copyright (C) 2000 - 2004, R. Byron Moore
acpi/platform/acgcc.h: * 3. Neither the names of the above-listed copyright holders nor the names
acpi/platform/acgcc.h:/* This macro is used to tag functions as "printf-like" because
acpi/platform/acgcc.h: * to to tell the compiler warning in a per-variable manner that a variable
acpi/platform/aclinux.h: * Name: aclinux.h - OS specific defines, etc.
acpi/platform/aclinux.h: * Copyright (C) 2000 - 2004, R. Byron Moore
acpi/platform/aclinux.h: * 3. Neither the names of the above-listed copyright holders nor the names
acpi/acparser.h: * Module Name: acparser.h - AML Parser subcomponent prototypes and defines
acpi/acparser.h: * Copyright (C) 2000 - 2004, R. Byron Moore
acpi/acparser.h: * 3. Neither the names of the above-listed copyright holders nor the names
acpi/acparser.h:/* psargs - Parse AML opcode arguments */
acpi/acparser.h:/* psopcode - AML Opcode information */
acpi/acparser.h:/* psparse - top level parsing routines */
acpi/acparser.h:/* psscope - Scope stack management routines */
acpi/acparser.h:/* pstree - parse tree manipulation routines */
acpi/acparser.h:/* pswalk - parse tree walk routines */
acpi/acparser.h:/* psutils - parser utilities */
acpi/acparser.h:/* psdump - display parser tree */
acpi/acexcep.h: * Name: acexcep.h - Exception codes returned by the ACPI subsystem
acpi/acexcep.h: * Copyright (C) 2000 - 2004, R. Byron Moore
acpi/acexcep.h: * 3. Neither the names of the above-listed copyright holders nor the names
acpi/acglobal.h: * Name: acglobal.h - Declarations for global variables
acpi/acglobal.h: * Copyright (C) 2000 - 2004, R. Byron Moore
acpi/acglobal.h: * 3. Neither the names of the above-listed copyright holders nor the names
acpi/acglobal.h: * Keep local copies of these FADT-based registers.  NOTE: These globals
acpi/acglobal.h: * are first in this file for alignment reasons on 64-bit systems.
acpi/acglobal.h: * Changing this will revert ACPI CA (and machine ASL) to pre-OSI behavior.
acpi/acglobal.h: * These tables are single-table only; meaning that there can be at most one
acpi/acglobal.h: * If we are running a method that exists in a 32-bit ACPI table.
acpi/acconfig.h: * Name: acconfig.h - Global configuration constants
acpi/acconfig.h: * Copyright (C) 2000 - 2004, R. Byron Moore
acpi/acconfig.h: * 3. Neither the names of the above-listed copyright holders nor the names
acpi/acconfig.h: * ACPI_DEBUG_OUTPUT    - This switch enables all the debug facilities of the
acpi/acconfig.h: * ACPI_APPLICATION     - Use this switch if the subsystem is going to be run
acpi/acconfig.h:#define ACPI_DEBUGGER_COMMAND_PROMPT    '-'
acpi/acpiosxf.h: * Name: acpiosxf.h - All interfaces to the OS Services Layer (OSL).  These
acpi/acpiosxf.h: * Copyright (C) 2000 - 2004, R. Byron Moore
acpi/acpiosxf.h: * 3. Neither the names of the above-listed copyright holders nor the names
acpi/acpiosxf.h:#define ACPI_NO_UNIT_LIMIT          ((u32) -1)
acpi/acpiosxf.h: * Platform and hardware-independent I/O interfaces
acpi/acpiosxf.h: * Platform and hardware-independent physical memory interfaces
acpi/acpiosxf.h: * Platform and hardware-independent PCI configuration space access
acpi/actables.h: * Name: actables.h - ACPI table management
acpi/actables.h: * Copyright (C) 2000 - 2004, R. Byron Moore
acpi/actables.h: * 3. Neither the names of the above-listed copyright holders nor the names
acpi/actables.h: * tbconvrt - Table conversion routines
acpi/actables.h: * tbget - Table "get" routines
acpi/actables.h: * tbinstall - Table installation
acpi/actables.h: * tbremove - Table removal and deletion
acpi/actables.h: * tbrsd - RSDP, RSDT utilities
acpi/actables.h: * tbutils - common table utilities
asm/ack:addrspace.h: *  32-bit MIPS address spaces
asm/ack:addrspace.h: * 64-bit address conversions
asm/ack:arc/types.h:/* The pointer types.  Note that we're using a 64-bit compiler but all
asm/ack:arc/types.h:   pointer in the ARC structures are only 32-bit, so we need some disgusting
asm/ack:arc/types.h:/* The pointer types.  We're 64-bit and the firmware is also 64-bit, so
asm/ack:asm.h: * away by gas in -O mode. These nops are however required to fill delay
asm/ack:asm.h: * LEAF - declare leaf routine
asm/ack:asm.h: * NESTED - declare nested routine entry point
asm/ack:asm.h: * END - mark end of function
asm/ack:asm.h:		.size	function,.-function
asm/ack:asm.h: * EXPORT - export definition of symbol
asm/ack:asm.h: * FEXPORT - export definition of a function symbol
asm/ack:asm.h: * ABS - export absolute symbol
asm/ack:asm.h: * Macros to handle different pointer/register sizes for 32/64-bit code
asm/ack:atomic.h: * atomic_read - read atomic variable
asm/ack:atomic.h:#define atomic_read(v)	((v)->counter)
asm/ack:atomic.h: * atomic_set - set atomic variable
asm/ack:atomic.h:#define atomic_set(v,i)	((v)->counter = (i))
asm/ack:atomic.h: * atomic_add - add integer to atomic variable
asm/ack:atomic.h:	v->counter += i;
asm/ack:atomic.h: * atomic_sub - subtract the atomic variable
asm/ack:atomic.h:	v->counter -= i;
asm/ack:atomic.h:	temp = v->counter;
asm/ack:atomic.h:	v->counter = temp;
asm/ack:atomic.h:	temp = v->counter;
asm/ack:atomic.h:	temp -= i;
asm/ack:atomic.h:	v->counter = temp;
asm/ack:atomic.h: * atomic_add - add integer to atomic variable
asm/ack:atomic.h:		: "=&r" (temp), "=m" (v->counter)
asm/ack:atomic.h:		: "Ir" (i), "m" (v->counter));
asm/ack:atomic.h: * atomic_sub - subtract the atomic variable
asm/ack:atomic.h:		: "=&r" (temp), "=m" (v->counter)
asm/ack:atomic.h:		: "Ir" (i), "m" (v->counter));
asm/ack:atomic.h:		: "=&r" (result), "=&r" (temp), "=m" (v->counter)
asm/ack:atomic.h:		: "Ir" (i), "m" (v->counter)
asm/ack:atomic.h:		: "=&r" (result), "=&r" (temp), "=m" (v->counter)
asm/ack:atomic.h:		: "Ir" (i), "m" (v->counter)
asm/ack:atomic.h: * atomic_sub_and_test - subtract value from variable and test result
asm/ack:atomic.h: * atomic_inc_and_test - increment and test
asm/ack:atomic.h: * atomic_dec_and_test - decrement by 1 and test
asm/ack:atomic.h: * atomic_inc - increment atomic variable
asm/ack:atomic.h: * atomic_dec - decrement and test
asm/ack:atomic.h: * atomic_add_negative - add and test if negative
asm/ack:au1000_dma.h:	au_writel(DMA_BE0, chan->io + DMA_MODE_SET);
asm/ack:au1000_dma.h:	au_writel(DMA_BE1, chan->io + DMA_MODE_SET);
asm/ack:au1000_dma.h:	au_writel(DMA_BE0 | DMA_BE1, chan->io + DMA_MODE_SET);
asm/ack:au1000_dma.h:	au_writel(DMA_GO, chan->io + DMA_MODE_SET);
asm/ack:au1000_dma.h:	au_writel(DMA_GO, chan->io + DMA_MODE_CLEAR);
asm/ack:au1000_dma.h:		if (au_readl(chan->io + DMA_MODE_READ) & DMA_HALT)
asm/ack:au1000_dma.h:	au_writel(~DMA_GO, chan->io + DMA_MODE_CLEAR);
asm/ack:au1000_dma.h:	return (au_readl(chan->io + DMA_MODE_READ) & DMA_HALT) ? 1 : 0;
asm/ack:au1000_dma.h:	au_writel(PHYSADDR(chan->fifo_addr),
asm/ack:au1000_dma.h:		  chan->io + DMA_PERIPHERAL_ADDR);
asm/ack:au1000_dma.h:	mode = chan->mode | (chan->dev_id << DMA_DID_BIT);
asm/ack:au1000_dma.h:	if (chan->irq)
asm/ack:au1000_dma.h:	au_writel(~mode, chan->io + DMA_MODE_CLEAR);
asm/ack:au1000_dma.h:	au_writel(mode, chan->io + DMA_MODE_SET);
asm/ack:au1000_dma.h:	chan->mode &= ~(DMA_BE | DMA_DR | DMA_TS8 | DMA_DW_MASK | DMA_NC);
asm/ack:au1000_dma.h:	chan->mode |= mode;
asm/ack:au1000_dma.h:	return chan->mode;
asm/ack:au1000_dma.h:		return -1;
asm/ack:au1000_dma.h:	return (au_readl(chan->io + DMA_MODE_READ) & DMA_AB) ? 1 : 0;
asm/ack:au1000_dma.h: * set the device FIFO address for a specific DMA channel - only
asm/ack:au1000_dma.h:	if (chan->mode & DMA_DS)	/* second bank of device ids */
asm/ack:au1000_dma.h:	if (chan->dev_id != DMA_ID_GP04 && chan->dev_id != DMA_ID_GP05)
asm/ack:au1000_dma.h:	au_writel(PHYSADDR(a), chan->io + DMA_PERIPHERAL_ADDR);
asm/ack:au1000_dma.h:	au_writel(DMA_D0, chan->io + DMA_MODE_CLEAR);
asm/ack:au1000_dma.h:	au_writel(DMA_D1, chan->io + DMA_MODE_CLEAR);
asm/ack:au1000_dma.h: * This does nothing - not applicable to Au1000 DMA.
asm/ack:au1000_dma.h:	au_writel(a, chan->io + DMA_BUFFER0_START);
asm/ack:au1000_dma.h:	au_writel(a, chan->io + DMA_BUFFER1_START);
asm/ack:au1000_dma.h:	au_writel(count, chan->io + DMA_BUFFER0_COUNT);
asm/ack:au1000_dma.h:	au_writel(count, chan->io + DMA_BUFFER1_COUNT);
asm/ack:au1000_dma.h:	au_writel(count, chan->io + DMA_BUFFER0_COUNT);
asm/ack:au1000_dma.h:	au_writel(count, chan->io + DMA_BUFFER1_COUNT);
asm/ack:au1000_dma.h: * Returns -1 if neither or both done bits set.
asm/ack:au1000_dma.h:    return au_readl(chan->io + DMA_MODE_READ) & (DMA_D0 | DMA_D1);
asm/ack:au1000_dma.h:		return -1;
asm/ack:au1000_dma.h:	return chan->irq;
asm/ack:au1000_dma.h:	curBufCntReg = (au_readl(chan->io + DMA_MODE_READ) & DMA_AB) ?
asm/ack:au1000_dma.h:	count = au_readl(chan->io + curBufCntReg) & DMA_COUNT_MASK;
asm/ack:au1000_dma.h:	if ((chan->mode & DMA_DW_MASK) == DMA_DW16)
asm/ack:au1000_dma.h:	else if ((chan->mode & DMA_DW_MASK) == DMA_DW32)
asm/ack:au1000_gpio.h:#define NOT_AVAIL		(-1)
asm/ack:au1000_gpio.h:#define MINOR_TO_GPIOPIN(minor)		((minor < AU1X00_MAX_PRIMARY_GPIO) ? minor : (minor - AU1X00_MAX_PRIMARY_GPIO))
asm/ack:au1000_gpio.h: * GPIO0-GPIO31, minor=0-31.
asm/ack:au1000_gpio.h: * GPIO200-GPIO215, minor=32-47.
asm/ack:au1000_gpio.h:	int data;	// Pin output when itized (0/1), or at the term. 0/1/-1 (tristate).
asm/ack:au1000.h: * Taken from PPC tree.  -- Dan
asm/ack:au1000.h:	return 31 - lz;
asm/ack:au1000.h:	return __ilog2(x & -x);
asm/ack:au1000.h:	return __ilog2(x & -x) + 1;
asm/ack:au1000.h:/* UARTS 0-3 */
asm/ack:au1000.h:#define UART_LSR_THRE	0x20	/* Transmit-hold-register empty */
asm/ack:au1000.h:#define SSI_CONFIG_ALEN_N(N)		((N-1)<<20)
asm/ack:au1000.h:#define SSI_CONFIG_DLEN_N(N)		((N-1)<<16)
asm/ack:au1000.h:  /* FIXME - double check this from asm-ppc/pci-bridge.h */
asm/ack:au1000.h:  ({ long _ctl_ = -1;                                 \
asm/ack:au1000.h:	       _ctl_ = pci_irq_table[idsel - min_idsel][pin-1];               \
asm/ack:au1000_pcmcia.h: *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm/ack:au1000_pcmcia.h: * These really belong in a board-specific header file...
asm/ack:au1000_usbdev.h: *	Au1000 USB Device-Side Driver
asm/ack:au1100_mmc.h: * From "AMD Alchemy Solutions Au1100 Processor Data Book - Preliminary"
asm/ack:au1100_mmc.h:/* support routines required on a platform-specific basis */
asm/ack:au1xxx_dbdma.h:/* Specifics for the Au1xxx Descriptor-Based DMA Controllers, first
asm/ack:au1xxx_dbdma.h:	u32	ddma_desptr;	/* 32-byte aligned pointer to descriptor */
asm/ack:au1xxx_dbdma.h:#define DDMA_CFG_DFN	(1 << 3)	/* Descriptor fetch non-coherent */
asm/ack:au1xxx_dbdma.h: * Must be 32-byte aligned.
asm/ack:au1xxx_dbdma.h:#define DSCR_CMD0_MEM		(1 << 30)	/* mem-mem transfer */
asm/ack:au1xxx_dbdma.h:#define DSCR_CMD0_SN		(0x1 << 12)	/* Source non-coherent */
asm/ack:au1xxx_dbdma.h:#define DSCR_CMD0_DN		(0x1 << 11)	/* Destination non-coherent */
asm/ack:au1xxx_dbdma.h:/* Source1, 1-dimensional stride.
asm/ack:au1xxx_dbdma.h:/* Dest1, 1-dimensional stride.
asm/ack:au1xxx_dbdma.h: 	Some compatibilty macros --
asm/ack:au1xxx_psc.h:/* Enable slots 3-12.
asm/ack:au1xxx_psc.h:#define PSC_AC97CFG_TXSLOT_ENA(x)	(1 << (((x) - 3) + 11))
asm/ack:au1xxx_psc.h:#define PSC_AC97CFG_RXSLOT_ENA(x)	(1 << (((x) - 3) + 1))
asm/ack:au1xxx_psc.h:#define PSC_AC97CFG_SET_LEN(x)	(((((x)-2)/2) & 0xf) << 21)
asm/ack:au1xxx_psc.h:#define PSC_I2SCFG_SET_WS(x)	(((((x) / 2) - 1) & 0x7f) << 16)
asm/ack:au1xxx_psc.h:#define PSC_I2SCFG_SET_LEN(x)	((((x) - 1) & 0x1f) << 4)
asm/ack:au1xxx_psc.h:#define PSC_SPICFG_SET_LEN(x)	(((x-1) & 0x1f) << 4)
asm/ack:baget/vac.h:#define    VAC_CTRL_RECOVERY_IOSELI(x) ((((x)-1)&7)<<8)
asm/ack:baget/vac.h:#define    VAC_CTRL_DELAY_DSACKI(x)    ((((x)-1)&7)<<13)
asm/ack:baget/vic.h:#define    VIC_LOCAL_TIM_PAS_ASSERT(x)   (((x)-2)&0xf)
asm/ack:baget/vic.h:#define    VIC_LOCAT_TIM_DS_DEASSERT(x)  ((((x)-1)&1)<<4)
asm/ack:baget/vic.h:#define    VIC_LOCAL_TIM_PAS_DEASSERT(x) ((((x)-1)&0x7)<<5)
asm/ack:baget/baget.h:#define BAGET_A24M_BASE       0xFC000000      /* VME-master A24 base address  */
asm/ack:baget/baget.h:#define BAGET_A24S_BASE       0x00000000      /* VME-slave A24 base address   */
asm/ack:baget/baget.h:#define BAGET_A24S_MASK       0x00c00000      /* VME-slave A24 address mask   */
asm/ack:baget/baget.h:#define BAGET_IRQ_MASK(x)       ((NR_IRQS-1) & (x))
asm/ack:bcache.h:/* Some R4000 / R4400 / R4600 / R5000 machines may have a non-dma-coherent,
asm/ack:bcache.h:	bcops->bc_enable();
asm/ack:bcache.h:	bcops->bc_disable();
asm/ack:bcache.h:	bcops->bc_wback_inv(page, size);
asm/ack:bcache.h:	bcops->bc_inv(page, size);
asm/ack:bitops.h: * Copyright (c) 1994 - 1997, 1999, 2000  Ralf Baechle (ralf@gnu.org)
asm/ack:bitops.h: * set_bit - Atomically set a bit in memory
asm/ack:bitops.h: * restricted to acting on a single-word quantity.
asm/ack:bitops.h: * __set_bit - Set a bit in memory
asm/ack:bitops.h: * Unlike set_bit(), this function is non-atomic and may be reordered.
asm/ack:bitops.h: * clear_bit - Clears a bit in memory
asm/ack:bitops.h: * change_bit - Toggle a bit in memory
asm/ack:bitops.h: * restricted to acting on a single-word quantity.
asm/ack:bitops.h: * __change_bit - Toggle a bit in memory
asm/ack:bitops.h: * Unlike change_bit(), this function is non-atomic and may be reordered.
asm/ack:bitops.h: * test_and_set_bit - Set a bit and return its old value
asm/ack:bitops.h: * __test_and_set_bit - Set a bit and return its old value
asm/ack:bitops.h: * This operation is non-atomic and can be reordered.
asm/ack:bitops.h: * test_and_clear_bit - Clear a bit and return its old value
asm/ack:bitops.h: * __test_and_clear_bit - Clear a bit and return its old value
asm/ack:bitops.h: * This operation is non-atomic and can be reordered.
asm/ack:bitops.h: * test_and_change_bit - Change a bit and return its new value
asm/ack:bitops.h: * __test_and_change_bit - Change a bit and return its old value
asm/ack:bitops.h: * This operation is non-atomic and can be reordered.
asm/ack:bitops.h: * set_bit - Atomically set a bit in memory
asm/ack:bitops.h: * restricted to acting on a single-word quantity.
asm/ack:bitops.h: * __set_bit - Set a bit in memory
asm/ack:bitops.h: * Unlike set_bit(), this function is non-atomic and may be reordered.
asm/ack:bitops.h: * clear_bit - Clears a bit in memory
asm/ack:bitops.h: * change_bit - Toggle a bit in memory
asm/ack:bitops.h: * restricted to acting on a single-word quantity.
asm/ack:bitops.h: * __change_bit - Toggle a bit in memory
asm/ack:bitops.h: * Unlike change_bit(), this function is non-atomic and may be reordered.
asm/ack:bitops.h: * test_and_set_bit - Set a bit and return its old value
asm/ack:bitops.h: * __test_and_set_bit - Set a bit and return its old value
asm/ack:bitops.h: * This operation is non-atomic and can be reordered.
asm/ack:bitops.h: * test_and_clear_bit - Clear a bit and return its old value
asm/ack:bitops.h: * __test_and_clear_bit - Clear a bit and return its old value
asm/ack:bitops.h: * This operation is non-atomic and can be reordered.
asm/ack:bitops.h: * test_and_change_bit - Change a bit and return its new value
asm/ack:bitops.h: * __test_and_change_bit - Change a bit and return its old value
asm/ack:bitops.h: * This operation is non-atomic and can be reordered.
asm/ack:bitops.h: * test_bit - Determine whether a bit is set
asm/ack:bitops.h: * ffz - find first zero in word.
asm/ack:bitops.h: * ffs - find first bit set
asm/ack:bitops.h: * find_next_zero_bit - find the first zero bit in a memory region
asm/ack:bitops.h:	size -= result;
asm/ack:bitops.h:		tmp |= ~0UL >> (32-offset);
asm/ack:bitops.h:		size -= 32;
asm/ack:bitops.h:		size -= 32;
asm/ack:bitops.h:#if 0 /* Fool kernel-doc since it doesn't do macros yet */
asm/ack:bitops.h: * find_first_zero_bit - find the first zero bit in a memory region
asm/ack:bitops.h: * Returns the bit-number of the first zero bit, not the number of the byte
asm/ack:bitops.h: * hweightN - returns the hamming weight of a N-bit word
asm/ack:bitops.h:	size -= result;
asm/ack:bitops.h:		tmp |= ~0U >> (32-offset); /* bug or feature ? */
asm/ack:bitops.h:		size -= 32;
asm/ack:bitops.h:		size -= 32;
asm/ack:bootinfo.h:#define MACH_GROUP_TITAN       22 /* PMC-Sierra Titan 			    */
asm/ack:bootinfo.h:#define MACH_ACER_PICA_61	0	/* Acer PICA-61 (PICA1)		*/
asm/ack:bootinfo.h:#define MACH_OLIVETTI_M700      2	/* Olivetti M700-10 (-15 ??)    */
asm/ack:bootinfo.h:#define MACH_NEC_DDB5074	0	/* NEC DDB Vrc-5074 */
asm/ack:bootinfo.h:#define MACH_NEC_DDB5476	1	/* NEC DDB Vrc-5476 */
asm/ack:bootinfo.h:#define MACH_NEC_DDB5477	2	/* NEC DDB Vrc-5477 */
asm/ack:bootinfo.h:#define MACH_BAGET201		0	/* BT23-201 */
asm/ack:bootinfo.h:#define MACH_BAGET202		1	/* BT23-202 */
asm/ack:bootinfo.h:#define MACH_TOSHIBA_JMR3927	3	/* JMR-TX3927 CPU/IO board */
asm/ack:bootinfo.h:#define MACH_PB1000		0	/* Au1000-based eval board */
asm/ack:bootinfo.h:#define MACH_PB1100		1	/* Au1100-based eval board */
asm/ack:bootinfo.h:#define MACH_PB1500		2	/* Au1500-based eval board */
asm/ack:bootinfo.h:#define MACH_DB1000		3       /* Au1000-based eval board */
asm/ack:bootinfo.h:#define MACH_DB1100		4       /* Au1100-based eval board */
asm/ack:bootinfo.h:#define MACH_DB1500		5       /* Au1500-based eval board */
asm/ack:bootinfo.h:#define MACH_XXS1500		6       /* Au1500-based eval board */
asm/ack:bootinfo.h:#define MACH_MTX1		7	/* 4G MTX-1 Au1500-based board */
asm/ack:bootinfo.h:#define MACH_PB1550     	9       /* Au1550-based eval board */
asm/ack:bootinfo.h:#define MACH_PB1200     	10      /* Au1200-based eval board */
asm/ack:bootinfo.h:#define MACH_DB1550     	11      /* Au1550-based eval board */
asm/ack:bootinfo.h:#define MACH_DB1200     	12      /* Au1200-based eval board */
asm/ack:bootinfo.h:#define MACH_VICTOR_MPC30X	3	/* Victor MP-C303/304 */
asm/ack:bootinfo.h:#define MACH_CASIO_E55		5	/* CASIO CASSIOPEIA E-10/15/55/65 */
asm/ack:bootinfo.h:#define	MACH_TITAN_YOSEMITE	1 	/* PMC-Sierra Yosemite */
asm/ack:branch.h:	return regs->cp0_cause & CAUSEF_BD;
asm/ack:branch.h:		return regs->cp0_epc;
asm/ack:branch.h:	return regs->cp0_epc + 4;
asm/ack:branch.h:		regs->cp0_epc += 4;
asm/ack:break.h: * non-Linux/MIPS object files or make use of them in the future.
asm/ack:break.h:#define BRK_BD_TAKEN	3	/* For bd slot emulation - not implemented */
asm/ack:break.h:#define BRK_BD_NOTTAKEN	4	/* For bd slot emulation - not implemented */
asm/ack:break.h:#define BRK_NORLD	10	/* No rld found - not used by Linux/MIPS */
asm/ack:bugs.h: * This is included by init/main.c to check for architecture-dependent bugs.
asm/ack:cachectl.h: * cachectl.h -- defines for MIPS cache control system calls
asm/ack:cacheflush.h: *  - flush_cache_all() flushes entire cache
asm/ack:cacheflush.h: *  - flush_cache_mm(mm) flushes the specified mm context's cache lines
asm/ack:cacheflush.h: *  - flush_cache_page(mm, vmaddr) flushes a single page
asm/ack:cacheflush.h: *  - flush_cache_range(mm, start, end) flushes a range of pages
asm/ack:cacheflush.h: *  - flush_page_to_ram(page) write back kernel page to ram
asm/ack:cacheflush.h: *  - flush_icache_range(start, end) flush a range of instructions
asm/ack:cacheflush.h: *  - flush_cache_sigtramp() flush signal trampoline
asm/ack:cacheflush.h: *  - flush_icache_all() flush the entire instruction cache
asm/ack:cacheflush.h: *  - flush_data_cache_page() flushes a page from the data cache
asm/ack:cacheops.h: * Cache Operations available on all MIPS processors with R4000-style caches
asm/ack:cacheops.h: * R4000-specific cacheops
asm/ack:cacheops.h: * R4000SC and R4400SC-specific cacheops
asm/ack:cacheops.h: * R5000-specific cacheops
asm/ack:cacheops.h: * RM7000-specific cacheops
asm/ack:cacheops.h: * R1000-specific cacheops
asm/ack:cacheops.h: * Cacheops 0x02, 0x06, 0x0a, 0x0c-0x0e, 0x16, 0x1a and 0x1e are unused.
asm/ack:checksum.h: * and adds in "sum" (32-bit)
asm/ack:checksum.h: * returns a 32-bit number suitable for feeding into itself
asm/ack:checksum.h: * it's best to have buff aligned on a 32-bit boundary
asm/ack:checksum.h:		*err_ptr = -EFAULT;
asm/ack:checksum.h:		return -1;
asm/ack:checksum.h: * computes the checksum of the TCP/UDP pseudo-header
asm/ack:checksum.h: * returns a 16-bit checksum, already complemented
asm/ack:checksum.h: * this routine is used for miscellaneous IP-like checksums, mainly
asm/ack:cpu.h:  +----------------+----------------+----------------+----------------+
asm/ack:cpu.h:  +----------------+----------------+----------------+----------------+
asm/ack:cpu.h:   that bits 16-23 have been 0 for all MIPS processors before the MIPS32/64
asm/ack:cpu.h: * +---------------------------------+----------------+----------------+
asm/ack:cpu.h: * +---------------------------------+----------------+----------------+
asm/ack:cpu.h: * Bit 15 encodes if an ISA level supports 64-bit operations.
asm/ack:cpu.h:#define MIPS_CPU_SUBSET_CACHES	0x00020000 /* P-cache subset enforced */
asm/ack:csb250.h: *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm/ack:db1200.h: *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm/ack:db1200.h: *    *example: IDE bis pos is  = 64 - 64
asm/ack:db1200.h:                ETH bit pos is  = 65 - 64
asm/ack:db1200.h:#define BOARD_CARD_INSERTED(SOCKET) bcsr->sig_status & (1<<(8+(2*SOCKET)))
asm/ack:db1x00.h: *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm/ack:db1x00.h:#define BOARD_CARD_INSERTED(SOCKET) !(bcsr->status & (1<<(4+SOCKET)))
asm/ack:db1x00.h:#define BOARD_CARD_INSERTED(SOCKET) !(bcsr->status & (1<<(4+SOCKET)))
asm/ack:ddb5074.h: *  include/asm-mips/ddb5074.h -- NEC DDB Vrc-5074 definitions
asm/ack:ddb5xxx/ddb5074.h: *  include/asm-mips/ddb5074.h -- NEC DDB Vrc-5074 definitions
asm/ack:ddb5xxx/ddb5476.h:#define	DDB_DCS5_SIZE		0x00200000	/* 2MB, 8-bit */
asm/ack:ddb5xxx/ddb5476.h:#define	DDB_DCS4_SIZE		0x00200000	/* 2MB, 8-bit */
asm/ack:ddb5xxx/ddb5476.h:#define DDB_BOOTCS_SIZE         0x00200000      /* 2 MB - doc says 4MB */
asm/ack:ddb5xxx/ddb5476.h: *   . CPU itself - 8 sources
asm/ack:ddb5xxx/ddb5476.h: *   . i8259 - 16 sources
asm/ack:ddb5xxx/ddb5476.h: *   . vrc5476 - 16 sources
asm/ack:ddb5xxx/ddb5476.h: *  All VRC5476 PCI interrupts are level-triggered (no ack needed).
asm/ack:ddb5xxx/ddb5476.h: * vrc5476 irq defs, see page 52-64 of Vrc5074 system controller manual
asm/ack:ddb5xxx/ddb5476.h:#define irq_to_nile4(n)         ((n)-NUM_I8259_IRQ)
asm/ack:ddb5xxx/ddb5476.h: * low-level irq functions
asm/ack:ddb5xxx/ddb5477.h: * include/asm-mips/ddb5xxx/ddb5477.h
asm/ack:ddb5xxx/ddb5477.h:#undef  DDB_CPUSTAT		/* duplicate in Vrc-5477 */
asm/ack:ddb5xxx/ddb5477.h:#define	DDB_PCICTL0_L	0x02e0	/* PCI0 Control-L */
asm/ack:ddb5xxx/ddb5477.h:#define	DDB_PCICTL0_H	0x02e4	/* PCI0 Control-H */
asm/ack:ddb5xxx/ddb5477.h:#define	DDB_PCIARB0_L	0x02e8	/* PCI0 Arbitration-L */
asm/ack:ddb5xxx/ddb5477.h:#define	DDB_PCIARB0_H	0x02ec	/* PCI0 Arbitration-H */
asm/ack:ddb5xxx/ddb5477.h:#define	DDB_PCICTL1_L	0x06e0	/* PCI1 Control-L */
asm/ack:ddb5xxx/ddb5477.h:#define	DDB_PCICTL1_H	0x06e4	/* PCI1 Control-H */
asm/ack:ddb5xxx/ddb5477.h:#define	DDB_PCIARB1_L	0x06e8	/* PCI1 Arbitration-L */
asm/ack:ddb5xxx/ddb5477.h:#define	DDB_PCIARB1_H	0x06ec	/* PCI1 Arbitration-H */
asm/ack:ddb5xxx/ddb5477.h:#define DDB_GIUFUNSEL	0x4040  /* select dual-func pins */
asm/ack:ddb5xxx/ddb5477.h:/* the actual ram size is detected at run-time */
asm/ack:ddb5xxx/ddb5477.h:#define	DDB_BOOTCS_SIZE		0x00200000	/* 2 MB - doc says 4MB */
asm/ack:ddb5xxx/ddb5477.h:/* low-level routine for enabling vrc5477 irq, bypassing high-level */
asm/ack:ddb5xxx/ddb5477.h: *   . CPU itself - 8 sources
asm/ack:ddb5xxx/ddb5477.h: *   . i8259 - 16 sources
asm/ack:ddb5xxx/ddb5477.h: *   . vrc5477 - 32 sources
asm/ack:ddb5xxx/ddb5477.h: *  All VRC5477 PCI interrupts are level-triggered (no ack needed).
asm/ack:ddb5xxx/ddb5477.h:#define VRC5477_IRQ_IOPCI_INTA	(16 + VRC5477_IRQ_BASE)      /* USB-H */
asm/ack:ddb5xxx/ddb5477.h:#define VRC5477_IRQ_IOPCI_INTB	(17 + VRC5477_IRQ_BASE)      /* USB-P */
asm/ack:ddb5xxx/ddb5477.h:#define	VRC5477_I8259_CASCADE	(VRC5477_IRQ_INTC - VRC5477_IRQ_BASE)
asm/ack:ddb5xxx/ddb5xxx.h: * include/asm-mips/ddb5xxx/ddb5xxx.h
asm/ack:ddb5xxx/ddb5xxx.h: *	uPD31577(VRC5477) VR5432-SDRAM/PCI Bridge (Luke)
asm/ack:ddb5xxx/ddb5xxx.h:#define DDB_DCS2	0x0010	/* Device Chip-Select 2 [R/W] */
asm/ack:ddb5xxx/ddb5xxx.h:#define DDB_DCS3	0x0018	/* Device Chip-Select 3 [R/W] */
asm/ack:ddb5xxx/ddb5xxx.h:#define DDB_DCS4	0x0020	/* Device Chip-Select 4 [R/W] */
asm/ack:ddb5xxx/ddb5xxx.h:#define DDB_DCS5	0x0028	/* Device Chip-Select 5 [R/W] */
asm/ack:ddb5xxx/ddb5xxx.h:#define DDB_DCS6	0x0030	/* Device Chip-Select 6 [R/W] */
asm/ack:ddb5xxx/ddb5xxx.h:#define DDB_DCS7	0x0038	/* Device Chip-Select 7 [R/W] */
asm/ack:ddb5xxx/ddb5xxx.h:#define DDB_DCS8	0x0040	/* Device Chip-Select 8 [R/W] */
asm/ack:ddb5xxx/ddb5xxx.h:#define DDB_BOOTCS	0x0078	/* Boot ROM Chip-Select [R/W] */
asm/ack:ddb5xxx/ddb5xxx.h: *  Memory-Interface Registers
asm/ack:ddb5xxx/ddb5xxx.h: *  PCI-Bus Registers
asm/ack:ddb5xxx/ddb5xxx.h: *  Local-Bus Registers
asm/ack:ddb5xxx/ddb5xxx.h:#define DDB_LCST2	0x0110	/* Local Bus Chip-Select Timing 2 [R/W] */
asm/ack:ddb5xxx/ddb5xxx.h:#define DDB_LCST3	0x0118	/* Local Bus Chip-Select Timing 3 [R/W] */
asm/ack:ddb5xxx/ddb5xxx.h:#define DDB_LCST4	0x0120	/* Local Bus Chip-Select Timing 4 [R/W] */
asm/ack:ddb5xxx/ddb5xxx.h:#define DDB_LCST5	0x0128	/* Local Bus Chip-Select Timing 5 [R/W] */
asm/ack:ddb5xxx/ddb5xxx.h:#define DDB_LCST6	0x0130	/* Local Bus Chip-Select Timing 6 [R/W] */
asm/ack:ddb5xxx/ddb5xxx.h:#define DDB_LCST7	0x0138	/* Local Bus Chip-Select Timing 7 [R/W] */
asm/ack:ddb5xxx/ddb5xxx.h:#define DDB_LCST8	0x0140	/* Local Bus Chip-Select Timing 8 [R/W] */
asm/ack:ddb5xxx/ddb5xxx.h:#define DDB_DCSFN	0x0150	/* Device Chip-Select Muxing and Output */
asm/ack:ddb5xxx/ddb5xxx.h:#define DDB_DCSIO	0x0158	/* Device Chip-Selects As I/O Bits [R/W] */
asm/ack:ddb5xxx/ddb5xxx.h:#define DDB_BCST	0x0178	/* Local Boot Chip-Select Timing [R/W] */
asm/ack:ddb5xxx/ddb5xxx.h:#define DDB_T1CTRL	0x01D0	/* CPU-Bus Read Time-Out Control [R/W] */
asm/ack:ddb5xxx/ddb5xxx.h:#define DDB_T1CNTR	0x01D8	/* CPU-Bus Read Time-Out Counter [R/W] */
asm/ack:ddb5xxx/ddb5xxx.h:#define DDB_T2CTRL	0x01E0	/* General-Purpose Timer Control [R/W] */
asm/ack:ddb5xxx/ddb5xxx.h:#define DDB_T2CNTR	0x01E8	/* General-Purpose Timer Counter [R/W] */
asm/ack:ddb5xxx/ddb5xxx.h:#define DDB_SSVID	0x022C	/* PCI Sub-System Vendor ID [R/W] */
asm/ack:ddb5xxx/ddb5xxx.h:#define DDB_SSID	0x022E	/* PCI Sub-System ID [R/W] */
asm/ack:debug.h: * Debug macros for run-time debugging.  Turned on/off with 
asm/ack:debug.h: * run-time macros for catching spurious errors.  Eable CONFIG_RUNTIME_DEBUG in
asm/ack:debug.h: * Use them as run-time debugging aid.  NEVER USE THEM AS ERROR HANDLING CODE!!!
asm/ack:dec/tc.h: * of the first card not in use or -ENODEV
asm/ack:dec/kn230.h: *	include/asm-mips/dec/kn230.h
asm/ack:dec/ecc.h: *	include/asm-mips/dec/ecc.h
asm/ack:dec/ecc.h: * The register is r/wc -- any write clears it.
asm/ack:dec/ecc.h: * from the last memory read.  The register is r/wc -- any write clears it.
asm/ack:dec/kn02ba.h: *	include/asm-mips/dec/kn02ba.h
asm/ack:dec/kn02ba.h: *	DECstation 5000/1xx (3min or KN02-BA) definitions.
asm/ack:dec/kn02ba.h: * I/O ASIC interrupt bits.  Star marks denote non-IRQ status bits.
asm/ack:dec/kn02ca.h: *	include/asm-mips/dec/kn02ca.h
asm/ack:dec/kn02ca.h: *	Personal DECstation 5000/xx (Maxine or KN02-CA) definitions.
asm/ack:dec/kn02ca.h: * I/O ASIC interrupt bits.  Star marks denote non-IRQ status bits.
asm/ack:dec/kn02ca.h:#define KN02CA_IO_INR_POWERON	13	/* (*) ACCESS.Bus/power-on reset */
asm/ack:dec/kn02xa.h: * The rest is defined in system-specific headers.
asm/ack:dec/kn02xa.h: * The rest is defined in system-specific headers.
asm/ack:dec/interrupts.h: * with the machine-specific interrupt routines.
asm/ack:dec/interrupts.h:#define DEC_IRQ_TC5		DEC_IRQ_ASC	/* virtual PMAZ-AA */
asm/ack:dec/interrupts.h:#define DEC_IRQ_TC6		DEC_IRQ_LANCE	/* virtual PMAD-AA */
asm/ack:dec/ioasic_addrs.h:#define IO_REG_SCSI_SCR		0x1b0	/* SCSI Partial-Word DMA Control */
asm/ack:dec/ioasic_addrs.h:#define IO_REG_FCTR		0x1e0	/* Free-Running Counter */
asm/ack:dec/ioasic_addrs.h: * The lower 16 bits are system-specific.  Bits 15,11:8 are common and
asm/ack:dec/ioasic_addrs.h: * defined here.  The rest is defined in system-specific headers.
asm/ack:dec/kn01.h:#define KN01_CSR_STATUS		(1<<14)	/* self-test result status output */
asm/ack:dec/kn03.h: * I/O ASIC interrupt bits.  Star marks denote non-IRQ status bits.
asm/ack:dec/kn05.h: *	include/asm-mips/dec/kn05.h
asm/ack:dec/kn05.h: * The register appears read-only.
asm/ack:dec/rtc-dec.h: *	include/asm-mips/dec/rtc-dec.h
asm/ack:dec/tcmodule.h: * EK-TCAAD-FS-004
asm/ack:dec/serial.h: *	include/asm-mips/dec/serial.h
asm/ack:dec/ioasic.h: *	include/asm-mips/dec/ioasic.h
asm/ack:dec/tcinfo.h: * EK-TCAAD-FS-004
asm/ack:dec/ioasic_ints.h: * The lower 16 bits are system-specific and thus defined in
asm/ack:dec/ioasic_ints.h: * system-specific headers.
asm/ack:delay.h: * Copyright (C) 1995 - 1998, 2001 by Ralf Baechle
asm/ack:div64.h:		" addiu	%4, %4, -1\n\t" \
asm/ack:dma.h: *  controller 1: channels 0-3, byte operations, ports 00-1F
asm/ack:dma.h: *  controller 2: channels 4-7, word operations, ports C0-DF
asm/ack:dma.h: *  - ALL registers are 8 bits only, regardless of transfer size
asm/ack:dma.h: *  - channel 4 is not used - cascades 1 into 2.
asm/ack:dma.h: *  - channels 0-3 are byte - addresses/counts are for physical bytes
asm/ack:dma.h: *  - channels 5-7 are word - addresses/counts are for physical words
asm/ack:dma.h: *  - transfers must not cross physical 64K (0-3) or 128K (5-7) boundaries
asm/ack:dma.h: *  - transfer count loaded to registers is 1 less than actual count
asm/ack:dma.h: *  - controller 2 offsets are all even (2x offsets for controller 1)
asm/ack:dma.h: *  - page registers for 5-7 don't use data bit 0, represent 128K pages
asm/ack:dma.h: *  - page registers for 0-3 use bit 0, represent 64K pages
asm/ack:dma.h: *  Address mapping for channels 0-3:
asm/ack:dma.h: *  Address mapping for channels 5-7:
asm/ack:dma.h: * Again, channels 5-7 transfer _physical_ words (16 bits), so addresses
asm/ack:dma.h: * and counts _must_ be word-aligned (the lowest address bit is _ignored_ at
asm/ack:dma.h: * the hardware level, so odd-byte transfers aren't possible).
asm/ack:dma.h: * count - 1 : 64K => 0xFFFF, 1 => 0x0000.  Thus, count is always 1 or more,
asm/ack:dma.h: * and up to 128K bytes may be transferred on channels 5-7 in one operation.
asm/ack:dma.h:#define DMA1_MASK_REG		0x0A	/* single-channel mask (w) */
asm/ack:dma.h:#define DMA1_CLEAR_FF_REG	0x0C	/* clear pointer flip-flop (w) */
asm/ack:dma.h:#define DMA1_MASK_ALL_REG       0x0F    /* all-channels mask (w) */
asm/ack:dma.h:#define DMA2_MASK_REG		0xD4	/* single-channel mask (w) */
asm/ack:dma.h:#define DMA2_CLEAR_FF_REG	0xD8	/* clear pointer flip-flop (w) */
asm/ack:dma.h:#define DMA2_MASK_ALL_REG       0xDE    /* all-channels mask (w) */
asm/ack:dma.h:#define DMA_MODE_CASCADE 0xC0   /* pass thru DREQ->HRQ, DACK<-HLDA only */
asm/ack:dma.h: * After that, keep track of it. :-)
asm/ack:dma.h: * --- In order to do that, the DMA routines below should ---
asm/ack:dma.h: * --- only be used while holding the DMA lock ! ---
asm/ack:dma.h: * Assumes dma flip-flop is clear.
asm/ack:dma.h: * NOTE 2: "count" represents _bytes_ and must be even for channels 5-7.
asm/ack:dma.h:        count--;
asm/ack:dma.h: * Assumes DMA flip-flop is clear.
asm/ack:dma.h:	/* using short to get 16-bit wrap around */
asm/ack:ds1286.h: * mc146818rtc.h - register definitions for the Real-Time-Clock / CMOS RAM
asm/ack:ds1286.h: * Copyright Torsten Duwe <duwe@informatik.uni-erlangen.de> 1993
asm/ack:elf.h:#define EF_MIPS_ARCH_1      0x00000000  /* -mips1 code.  */
asm/ack:elf.h:#define EF_MIPS_ARCH_2      0x10000000  /* -mips2 code.  */
asm/ack:elf.h:#define EF_MIPS_ARCH_3      0x20000000  /* -mips3 code.  */
asm/ack:elf.h:#define EF_MIPS_ARCH_4      0x30000000  /* -mips4 code.  */
asm/ack:elf.h:#define EF_MIPS_ARCH_5      0x40000000  /* -mips5 code.  */
asm/ack:elf.h:	if (__h->e_machine != EM_MIPS)					\
asm/ack:elf.h:	if (__h->e_ident[EI_CLASS] != ELFCLASS32)			\
asm/ack:elf.h:	if ((__h->e_flags & EF_MIPS_ABI2) != 0)				\
asm/ack:elf.h:	if (((__h->e_flags & EF_MIPS_ABI) != 0) &&			\
asm/ack:elf.h:	    ((__h->e_flags & EF_MIPS_ABI) != EF_MIPS_ABI_O32))		\
asm/ack:elf.h:#define irix_elf_check_arch(hdr)	((hdr)->e_machine == EM_MIPS)
asm/ack:elf.h: * See comments in asm-alpha/elf.h, this is the same thing
asm/ack:elf.h:	_r->regs[1] = _r->regs[2] = _r->regs[3] = _r->regs[4] = 0;	\
asm/ack:elf.h:	_r->regs[5] = _r->regs[6] = _r->regs[7] = _r->regs[8] = 0;	\
asm/ack:elf.h:	_r->regs[9] = _r->regs[10] = _r->regs[11] = _r->regs[12] = 0;	\
asm/ack:elf.h:	_r->regs[13] = _r->regs[14] = _r->regs[15] = _r->regs[16] = 0;	\
asm/ack:elf.h:	_r->regs[17] = _r->regs[18] = _r->regs[19] = _r->regs[20] = 0;	\
asm/ack:elf.h:	_r->regs[21] = _r->regs[22] = _r->regs[23] = _r->regs[24] = 0;	\
asm/ack:elf.h:	_r->regs[25] = _r->regs[26] = _r->regs[27] = _r->regs[28] = 0;	\
asm/ack:elf.h:	_r->regs[30] = _r->regs[31] = 0;				\
asm/ack:errno.h:#define	EXDEV		18	/* Cross-device link */
asm/ack:errno.h:#define	EROFS		30	/* Read-only file system */
asm/ack:errno.h:#define	ENOTSOCK	95	/* Socket operation on non-socket */
asm/ack:fcntl.h:/* open/fcntl - O_SYNC is only implemented on blocks devices and on files
asm/ack:fcntl.h:#define F_GETFL		3	/* get file->f_flags */
asm/ack:fcntl.h:#define F_SETFL		4	/* set file->f_flags */
asm/ack:ficmmp.h: *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm/ack:ficmmp.h:#define AU1XXX_ATA_MEM_SIZE		(AU1XXX_ATA_END - AU1XXX_ATA_BASE +1)
asm/ack:fixmap.h: * fixmap.h: compile-time virtual memory allocation
asm/ack:fixmap.h: * Here we define all the compile-time 'special' virtual
asm/ack:fixmap.h: * Also this lets us do fail-safe vmalloc(), we
asm/ack:fixmap.h: * vmalloc()-ed addresses never overlap.
asm/ack:fixmap.h: * these 'compile-time allocated' memory buffers are
asm/ack:fixmap.h: * fixed-size 4k pages. (or larger if used with an increment
asm/ack:fixmap.h: * fix-mapped?
asm/ack:fixmap.h:	FIX_KMAP_END = FIX_KMAP_BEGIN+(KM_TYPE_NR*NR_CPUS)-1,
asm/ack:fixmap.h:#define FIXADDR_START	(FIXADDR_TOP - FIXADDR_SIZE)
asm/ack:fixmap.h:#define __fix_to_virt(x)	(FIXADDR_TOP - ((x) << PAGE_SHIFT))
asm/ack:fixmap.h: * directly without tranlation, we catch the bug with a NULL-deference
asm/ack:fixmap.h:	 * out-of-range indices).
asm/ack:floppy.h: * Copyright (C) 1995 - 2000 Ralf Baechle
asm/ack:floppy.h:#define fd_inb(port)		fd_ops->fd_inb(port)
asm/ack:floppy.h:#define fd_outb(value,port)	fd_ops->fd_outb(value,port)
asm/ack:floppy.h:#define fd_enable_dma()		fd_ops->fd_enable_dma(FLOPPY_DMA)
asm/ack:floppy.h:#define fd_disable_dma()	fd_ops->fd_disable_dma(FLOPPY_DMA)
asm/ack:floppy.h:#define fd_request_dma()	fd_ops->fd_request_dma(FLOPPY_DMA)
asm/ack:floppy.h:#define fd_free_dma()		fd_ops->fd_free_dma(FLOPPY_DMA)
asm/ack:floppy.h:#define fd_clear_dma_ff()	fd_ops->fd_clear_dma_ff(FLOPPY_DMA)
asm/ack:floppy.h:#define fd_set_dma_mode(mode)	fd_ops->fd_set_dma_mode(FLOPPY_DMA, mode)
asm/ack:floppy.h:#define fd_set_dma_addr(addr)	fd_ops->fd_set_dma_addr(FLOPPY_DMA, \
asm/ack:floppy.h:#define fd_set_dma_count(count)	fd_ops->fd_set_dma_count(FLOPPY_DMA,count)
asm/ack:floppy.h:#define fd_get_dma_residue()	fd_ops->fd_get_dma_residue(FLOPPY_DMA)
asm/ack:floppy.h:#define fd_enable_irq()		fd_ops->fd_enable_irq(FLOPPY_IRQ)
asm/ack:floppy.h:#define fd_disable_irq()	fd_ops->fd_disable_irq(FLOPPY_IRQ)
asm/ack:floppy.h:#define fd_dma_mem_alloc(size)	fd_ops->fd_dma_mem_alloc(size)
asm/ack:floppy.h:#define fd_dma_mem_free(mem,size) fd_ops->fd_dma_mem_free(mem,size)
asm/ack:floppy.h:#define fd_drive_type(n)	fd_ops->fd_drive_type(n)
asm/ack:floppy.h:#define FDC1			fd_ops->fd_getfdaddr1();
asm/ack:floppy.h:#define CROSS_64KB(a,s) ((unsigned long)(a)/K_64 != ((unsigned long)(a) + (s) - 1) / K_64)
asm/ack:fpregdef.h: * These definitions only cover the R3000-ish 16/32 register model.
asm/ack:fpu_emulator.h: *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm/ack:fpu.h:#define clear_fpu_owner() do { current->flags &= ~PF_USEDFPU; } while(0)
asm/ack:fpu.h:	return cpu_has_fpu && ((current->flags & PF_USEDFPU) != 0); 
asm/ack:fpu.h:		current->flags |= PF_USEDFPU;
asm/ack:fpu.h:		current->flags &= ~PF_USEDFPU;
asm/ack:fpu.h:		return (unsigned long long *)&tsk->thread.fpu.hard.fp_regs[0];
asm/ack:fpu.h:		return (unsigned long long *)tsk->thread.fpu.soft.regs;
asm/ack:galileo-boards/gt96100.h: *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm/ack:galileo-boards/gt96100.h:/* TDPR0 - Transmit Dual Port RAM. block size 0xff */
asm/ack:galileo-boards/gt96100.h:/* RDPR0 - Receive Dual Port RAM. block size 0xff */
asm/ack:gdb-stub.h: * Derived from the stack layout described in asm-mips/stackframe.h
asm/ack:gdb-stub.h:#define GDB_FR_SIZE		((((GDB_FR_CP0_PRID) + 4) + (PTRSIZE-1)) & ~(PTRSIZE-1))
asm/ack:gdb-stub.h: * This is the same as above, but for the high-level
asm/ack:gfx.h: * This is the user-visible SGI GFX interface.
asm/ack:gfx.h: * any kernel-only bits on it.
asm/ack:gt64120/gt64120.h: *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm/ack:gt64120/gt64120.h:#define MSK(n)                    ((1 << (n)) - 1)
asm/ack:gt64120/gt64120.h: *   GT_WRITE(ofs, data)           - read/write GT64120 registers in 32bit
asm/ack:gt64120/gt64120.h: *   TIMER 	- gt64120 timer irq, temporary solution until
asm/ack:gt64120/gt64120.h:#include <asm/gt64120/mips-boards/gt64120_dep.h>
asm/ack:gt64120/gt64120.h:#include <asm/gt64120/mips-boards/gt64120_dep.h>
asm/ack:gt64120/gt64120.h: * bytes when running bigendian.  We also provide non-swapping versions.
asm/ack:gt64120/gt64120.h: * Board-dependent functions, which must be defined in
asm/ack:hardirq.h:#define irq_exit(cpu, irq)	(local_irq_count(cpu)--)
asm/ack:hardirq.h:	--local_irq_count(cpu);
asm/ack:hazards.h: * mtc0->mfc0 hazard
asm/ack:hazards.h: * mtc0->mfc0 hazard
asm/ack:hazards.h: * R10000 rocks - all hazards handled in hardware, so this becomes a nobrainer.
asm/ack:hazards.h: * care about the irq_enable_hazard - sooner or later the hardware will
asm/ack:hdreg.h: *  Copyright (C) 1994-1996  Linus Torvalds & authors
asm/ack:highmem.h: * Redesigned the x86 32-bit VM architecture to deal with
asm/ack:highmem.h:#define LAST_PKMAP_MASK (LAST_PKMAP-1)
asm/ack:highmem.h:#define PKMAP_NR(virt)  ((virt-PKMAP_BASE) >> PAGE_SHIFT)
asm/ack:highmem.h: * The use of kmap_atomic/kunmap_atomic is discouraged - kmap/kunmap
asm/ack:highmem.h:	set_pte(kmap_pte-idx, mk_pte(page, kmap_prot));
asm/ack:i8259.h: *	include/asm-mips/i8259.h
asm/ack:ide.h: * Copyright (C) 1994-1996  Linus Torvalds & authors
asm/ack:ide.h:	return ide_ops->ide_default_irq(base);
asm/ack:ide.h:	return ide_ops->ide_default_io_base(index);
asm/ack:ide.h:	ide_ops->ide_init_hwif_ports(hw, data_port, ctrl_port, irq);
asm/ack:ide.h:#define ide_ack_intr(hwif)	((hwif)->hw.ack_intr ? (hwif)->hw.ack_intr(hwif) : 1)
asm/ack:ide.h:/* MIPS port and memory-mapped I/O string operations.  */
asm/ack:ide.h:	while (count--) {
asm/ack:ide.h:	while (count--) {
asm/ack:ide.h:	while (count--) {
asm/ack:ide.h:	while (count--) {
asm/ack:init.h:#error "<asm/init.h> should never be used - use <linux/init.h> instead"
asm/ack:inst.h:	 * The others (0x14 - 0x1f) are unused.
asm/ack:inst.h: * Damn ...  bitfields depend from byteorder :-(
asm/ack:ioctl.h:#define _IOC_NRMASK	((1 << _IOC_NRBITS)-1)
asm/ack:ioctl.h:#define _IOC_TYPEMASK	((1 << _IOC_TYPEBITS)-1)
asm/ack:ioctl.h:#define _IOC_SIZEMASK	((1 << _IOC_SIZEBITS)-1)
asm/ack:ioctl.h:#define _IOC_DIRMASK	((1 << _IOC_DIRBITS)-1)
asm/ack:ioctls.h:						/* 127-124 compat */
asm/ack:ioctls.h:#define TIOCGPTN	_IOR('T',0x30, unsigned int) /* Get Pty Number (of pty-mux device) */
asm/ack:io.h: * Copyright (C) 1994 - 2000 Ralf Baechle
asm/ack:io.h:#include <asm/pgtable-bits.h>
asm/ack:io.h:#define bus_to_baddr(bus, addr)	(bus_to_baddr[(bus)->number] + (addr))
asm/ack:io.h:#define baddr_to_bus(bus, addr)	((addr) - bus_to_baddr[(bus)->number])
asm/ack:io.h: * IP22 seems braindead enough to swap 16-bits values in hardware, but not
asm/ack:io.h: * 32-bits.  Go figure... Can't tell without documentation.
asm/ack:io.h: * We only do the swapping to keep the kernel config bits of bi-endian
asm/ack:io.h:#define page_to_phys(page)	((u64)(page - mem_map) << PAGE_SHIFT)
asm/ack:io.h:#define page_to_phys(page)	((page - mem_map) << PAGE_SHIFT)
asm/ack:io.h: *     ioremap         -       map bus memory into CPU space
asm/ack:io.h: *     ioremap_nocache         -       map bus memory into CPU space
asm/ack:io.h: * 24-31 on SNI.
asm/ack:io.h: * to PAGE_OFFSET is pure coincidence - it does not mean ISA values
asm/ack:io.h: * used as the IO-area pointer (it can be iounmapped as well, so the
asm/ack:io.h:#define eth_io_copy_and_sum(skb,src,len,unused) memcpy_fromio((skb)->data,(src),(len))
asm/ack:io.h: *     check_signature         -       find BIOS signatures
asm/ack:io.h:		length--;
asm/ack:io.h: *     isa_check_signature             -       find BIOS signatures
asm/ack:io.h:		length--;
asm/ack:io.h: *     virt_to_phys    -       map virtual addresses to physical
asm/ack:io.h:	return (unsigned long)address - PAGE_OFFSET;
asm/ack:io.h: *     phys_to_virt    -       map physical address to virtual
asm/ack:io.h:	return (unsigned long)address - PAGE_OFFSET;
asm/ack:io.h:	while (count--) {
asm/ack:io.h:	while (count--) {
asm/ack:io.h:	while (count--) {
asm/ack:io.h:	while (count--) {
asm/ack:io.h:	while (count--) {
asm/ack:io.h:	while (count--) {
asm/ack:io.h: * The caches on some architectures aren't dma-coherent and have need to
asm/ack:io.h: *  - dma_cache_wback_inv(start, size) makes caches and coherent by
asm/ack:io.h: *  - dma_cache_wback(start, size) makes caches and coherent by
asm/ack:io.h: *  - dma_cache_inv(start, size) invalidates the affected parts of the
asm/ack:ipcbuf.h: * - 32-bit seq
asm/ack:ipcbuf.h: * - 2 miscellaneous 64-bit values
asm/ack:irq_cpu.h: *	include/asm-mips/irq_cpu.h
asm/ack:it8172/it8172_int.h: * and the non-maskable ints from 48 to 53.
asm/ack:it8172/it8172_int.h:/* 12 - 15 reserved */
asm/ack:it8172/it8172_int.h:#define MIPS_CPU_TIMER_IRQ       (NR_IRQS-1)
asm/ack:jazzdma.h: * Helpfile for jazzdma.c -- Mips Jazz R4030 DMA controller support
asm/ack:jazzdma.h:#define VDMA_OFFSET(a)          ((unsigned int)(a) & (VDMA_PAGESIZE-1))
asm/ack:jazz.h: * Copyright (C) 1995 - 1998 by Andreas Busse and Ralf Baechle
asm/ack:jazz.h: * 0xf0000000 - Rev1
asm/ack:jazz.h: * 0xf0000001 - Rev2
asm/ack:jazz.h: * 0xf0000002 - Rev3
asm/ack:jazz.h: *      ---------
asm/ack:jazz.h: *      ---------
asm/ack:jazz.h: *      --------- . (0)
asm/ack:jazz.h: * Note: Channels 4...7 are not used with respect to the Acer PICA-61
asm/ack:jmr3927/irq.h: *  linux/include/asm-mips/tx3927/irq.h
asm/ack:jmr3927/irq.h:	sp->next = tb_irq_spaces;
asm/ack:jmr3927/pci.h: * include/asm-mips/jmr3927/pci.h
asm/ack:jmr3927/pci.h: * Based on include/asm-mips/ddb5xxx/pci.h
asm/ack:jmr3927/pci.h: * Each pci channel is a top-level PCI bus seem by CPU.  A machine  with
asm/ack:jmr3927/tx3927.h:#define TX3927_PCIC_IDSEL_AD_TO_SLOT(ad)	((ad) - 11)
asm/ack:jmr3927/ds1742rtc.h: * ds1742rtc.h - register definitions for the Real-Time-Clock / CMOS RAM
asm/ack:jmr3927/ds1742rtc.h: *   Based on include/asm-mips/ds1643rtc.h.
asm/ack:jmr3927/ds1742rtc.h: * Copyright (C) 1999-2001 Toshiba Corporation
asm/ack:jmr3927/jmr3927.h: * Defines for the TJSYS JMR-TX3927/JMI-3927IO2/JMY-1394IF.
asm/ack:jmr3927/jmr3927.h: * Copyright (C) 2000-2001 Toshiba Corporation
asm/ack:jmr3927/jmr3927.h:	romcr3 = tx3927_romcptr->cr[3];
asm/ack:jmr3927/jmr3927.h:	tx3927_romcptr->cr[3] &= 0xffffefff;	/* do not wait infinitely */
asm/ack:jmr3927/jmr3927.h:	tx3927_romcptr->cr[3] = romcr3;
asm/ack:jmr3927/jmr3927.h:#define jmr3927_led_set(n/*0-16*/)	jmr3927_ioc_reg_out(~(n), JMR3927_IOC_LED_ADDR)
asm/ack:jmr3927/jmr3927.h:#define jmr3927_io_led_set(n/*0-3*/)	jmr3927_isac_reg_out((n), JMR3927_ISAC_LED_ADDR)
asm/ack:jmr3927/jmr3927.h:#define jmr3927_led_and_set(n/*0-16*/)	jmr3927_ioc_reg_out((~(n)) & jmr3927_ioc_reg_in(JMR3927_IOC_LED_ADDR), JMR3927_IOC_LED_ADDR)
asm/ack:jmr3927/jmr3927.h:#define jmr3927_dipsw1()	((tx3927_pioptr->din & (1 << 11)) == 0)
asm/ack:jmr3927/jmr3927.h:#define jmr3927_dipsw2()	((tx3927_pioptr->din & (1 << 10)) == 0)
asm/ack:jmr3927/jmr3927.h:/* use Pre-scaler T0 (1/2) */
asm/ack:jmr3927/jmr3927.h:#define JMR3927_NR_IRQ_IRC	16	/* On-Chip IRC */
asm/ack:jmr3927/jmr3927.h:/* RTL8019AS 10M Ether (JMI-3927IO2:JPW2:1-2 Short) */
asm/ack:jmr3927/jmr3927.h:/* TC35815 100M Ether (JMR-TX3912:JPW4:2-3 Short) */
asm/ack:jmr3927/jmr3927.h:#define JMR3927_ETHER1_PORT	(JMR3927_ISAIO_BASE - JMR3927_PORT_BASE + 0x280)
asm/ack:jmr3927/jmr3927.h:#define JMR3927_KBD_PORT	(JMR3927_ISAIO_BASE - JMR3927_PORT_BASE + 0x00800060)
asm/ack:jmr3927/jmr3927.h:#define JMR3927_IDE_PORT	(JMR3927_ISAIO_BASE - JMR3927_PORT_BASE + 0x001001f0)
asm/ack:keyboard.h: * Copyright (C) 1994 - 1999 Ralf Baechle
asm/ack:keyboard.h:#define kbd_request_region() kbd_ops->kbd_request_region()
asm/ack:keyboard.h:#define kbd_request_irq(handler) kbd_ops->kbd_request_irq(handler)
asm/ack:keyboard.h:#define aux_request_irq(hand, dev_id) kbd_ops->aux_request_irq(hand)
asm/ack:keyboard.h:#define aux_free_irq(dev_id) kbd_ops->aux_free_irq()
asm/ack:keyboard.h:#define kbd_read_input() kbd_ops->kbd_read_input()
asm/ack:keyboard.h:#define kbd_write_output(val) kbd_ops->kbd_write_output(val)
asm/ack:keyboard.h:#define kbd_write_command(val) kbd_ops->kbd_write_command(val)
asm/ack:keyboard.h:#define kbd_read_status() kbd_ops->kbd_read_status()
asm/ack:lasat/lasat.h: *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm/ack:lasat/lasat.h:/* Configuration descriptor encoding - see the doc for details */
asm/ack:linux_logo_dec.h: * include/asm-mips/linux_logo_dec.h: This is a linux logo
asm/ack:linux_logo_dec.h: * Copyright (C) 2001 Jan-Benedict Glaw <jbglaw@lug-owl.de>
asm/ack:linux_logo.h: * include/asm-mips/linux_logo.h: This is a linux logo
asm/ack:linux_logo_sgi.h: * include/asm-mips/linux_logo_sgi.h: This is a linux logo
asm/ack:linux_logo_sgi.h: * Copyright (C) 2001 Jan-Benedict Glaw <jbglaw@lug-owl.de>
asm/ack:mc146818rtc.h:rtc_ops->rtc_read_data(addr); \
asm/ack:mc146818rtc.h:rtc_ops->rtc_write_data(val, addr); \
asm/ack:mc146818rtc.h:rtc_ops->rtc_bcd_mode()
asm/ack:mc146818rtc.h:#include <asm/dec/rtc-dec.h>
asm/ack:mips-boards/msc01_pci.h:#define MSC01_PCI_HEAD11_OFS		0x2058  /* SubSystem ID, -VendorID */
asm/ack:mips-boards/msc01_pci.h: * FIXME - are these macros specific to Malta and co or to the MSC?  If the
asm/ack:mips-boards/atlasint.h: *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm/ack:mips-boards/atlasint.h: * Atlas registers are memory mapped on 64-bit aligned boundaries and
asm/ack:mips-boards/malta.h: *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm/ack:mips-boards/malta.h: * Defines of the Malta board specific address-MAP, registers, etc.
asm/ack:mips-boards/malta.h: * Malta RTC-device indirect register access.
asm/ack:mips-boards/saa9730_uart.h: *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm/ack:mips-boards/generic.h: * 59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm/ack:mips-boards/generic.h: * Defines of the MIPS boards specific address-MAP, registers, etc.
asm/ack:mips-boards/generic.h:#include <asm/mips-boards/bonito64.h>
asm/ack:mips-boards/seadint.h: *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm/ack:mips-boards/prom.h: *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm/ack:mips-boards/sead.h: *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm/ack:mips-boards/sead.h: * Defines of the SEAD board specific address-MAP, registers, etc.
asm/ack:mips-boards/maltaint.h: *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm/ack:mips-boards/bonito64.h:#define BONITO_BOOT_TOP 		(BONITO_BOOT_BASE+BONITO_BOOT_SIZE-1)
asm/ack:mips-boards/bonito64.h:#define BONITO_FLASH_TOP		(BONITO_FLASH_BASE+BONITO_FLASH_SIZE-1)
asm/ack:mips-boards/bonito64.h:#define BONITO_SOCKET_TOP		(BONITO_SOCKET_BASE+BONITO_SOCKET_SIZE-1)
asm/ack:mips-boards/bonito64.h:#define BONITO_REG_TOP			(BONITO_REG_BASE+BONITO_REG_SIZE-1)
asm/ack:mips-boards/bonito64.h:#define BONITO_DEV_TOP			(BONITO_DEV_BASE+BONITO_DEV_SIZE-1)
asm/ack:mips-boards/bonito64.h:#define BONITO_PCILO_TOP		(BONITO_PCILO_BASE+BONITO_PCILO_SIZE-1)
asm/ack:mips-boards/bonito64.h:#define BONITO_PCIHI_TOP		(BONITO_PCIHI_BASE+BONITO_PCIHI_SIZE-1)
asm/ack:mips-boards/bonito64.h:#define BONITO_PCIIO_TOP		(BONITO_PCIIO_BASE+BONITO_PCIIO_SIZE-1)
asm/ack:mips-boards/bonito64.h:#define BONITO_PCICFG_TOP		(BONITO_PCICFG_BASE+BONITO_PCICFG_SIZE-1)
asm/ack:mips-boards/bonito64.h:/* Added by RPF 11-9-00 */
asm/ack:mips-boards/bonito64.h:/* --- */
asm/ack:mips-boards/bonito64.h:/* GPIO Regs - r/w */
asm/ack:mips-boards/bonito64.h:/* ICU Configuration Regs - r/w */
asm/ack:mips-boards/bonito64.h:/* ICU Enable Regs - IntEn & IntISR are r/o. */
asm/ack:mips-boards/bonito64.h:/* DRAM - sdCfg */
asm/ack:mips-boards/bonito64.h:/* Changed by RPF 11-9-00 */
asm/ack:mips-boards/bonito64.h:/* --- */
asm/ack:mips-boards/bonito64.h:/* Added by RPF 11-9-00 */
asm/ack:mips-boards/bonito64.h:/* --- */
asm/ack:mips-boards/bonito64.h:/* PCI Cache - pciCacheCtrl */
asm/ack:mips-boards/bonito64.h:/* Added by RPF 11-9-00 */
asm/ack:mips-boards/bonito64.h:/* --- */
asm/ack:mips-boards/bonito64.h:#define BONITO_PCIMAP_WINOFFSET(ADDR)	((ADDR) & (BONITO_PCIMAP_WINSIZE - 1))
asm/ack:mips-boards/bonito64.h:#define BONITO_PCIMEMBASECFGSIZE(WIN,SIZE)	(((~((SIZE)-1))>>(BONITO_PCIMEMBASECFG_ASHIFT-BONITO_PCIMEMBASECFG_MEMBASE##WIN##_MASK_SHIFT)) & BONITO_PCIMEMBASECFG_MEMBASE##WIN##_MASK)
asm/ack:mips-boards/bonito64.h:#define BONITO_PCIMEMBASECFGBASE(WIN,BASE)	(((BASE)>>(BONITO_PCIMEMBASECFG_ASHIFT-BONITO_PCIMEMBASECFG_MEMBASE##WIN##_TRANS_SHIFT)) & BONITO_PCIMEMBASECFG_MEMBASE##WIN##_TRANS)
asm/ack:mips-boards/bonito64.h:#define BONITO_PCIMEMBASECFG_SIZE(WIN,CFG)  (((((~(CFG)) & BONITO_PCIMEMBASECFG_MEMBASE##WIN##_MASK)) << (BONITO_PCIMEMBASECFG_ASHIFT - BONITO_PCIMEMBASECFG_MEMBASE##WIN##_MASK_SHIFT)) | BONITO_PCIMEMBASECFG_AMASK)
asm/ack:mips-boards/atlas.h: *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm/ack:mips-boards/atlas.h: * Defines of the Atlas board specific address-MAP, registers, etc.
asm/ack:mips-boards/atlas.h: * Atlas RTC-device indirect register access.
asm/ack:mips-boards/piix4.h: *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm/ack:mipsregs.h:#define FPU_CSR_RD      0x3     /* towards -Infinity */
asm/ack:mipsregs.h: * physical address space running the 32-bit kernel.  That's none atm :-)
asm/ack:mman.h:/* These are linux-specific */
asm/ack:mman.h:#define MAP_GROWSDOWN	0x1000		/* stack-like segment */
asm/ack:mman.h:#define MADV_NORMAL	0x0		/* default page-in behavior */
asm/ack:mman.h:#define MADV_RANDOM	0x1		/* page-in minimum required */
asm/ack:mman.h:#define MADV_SEQUENTIAL	0x2		/* read-ahead aggressively */
asm/ack:mman.h:#define MADV_WILLNEED	0x3		/* pre-fault pages */
asm/ack:mmu_context.h: * use the processor id via current->processor, where current is stored
asm/ack:mmu_context.h:#define cpu_context(cpu, mm)	((mm)->context[cpu])
asm/ack:mmu_context.h:#define ASID_VERSION_MASK  ((unsigned long)~(ASID_MASK|(ASID_MASK-1)))
asm/ack:mmu_context.h:	TLBMISS_HANDLER_SETUP_PGD(next->pgd);
asm/ack:mmu_context.h:	 * Mark current->active_mm as not "active" anymore.
asm/ack:mmu_context.h:	clear_bit(cpu, &prev->cpu_vm_mask);
asm/ack:mmu_context.h:	set_bit(cpu, &next->cpu_vm_mask);
asm/ack:mmu_context.h: * After we have set current->mm to a new value, this activates
asm/ack:mmu_context.h:	TLBMISS_HANDLER_SETUP_PGD(next->pgd);
asm/ack:mmu_context.h:	clear_bit(cpu, &prev->cpu_vm_mask);
asm/ack:mmu_context.h:	set_bit(cpu, &next->cpu_vm_mask);
asm/ack:mmu_context.h:	if (test_bit(cpu, &mm->cpu_vm_mask))  {
asm/ack:module.h: * modutils/obj/obj-mips.c
asm/ack:module.h:	archdata = (struct archdata *)(mod->archdata_start);
asm/ack:module.h:	if (archdata->dbe_table_start > archdata->dbe_table_end ||
asm/ack:module.h:	    (archdata->dbe_table_start &&
asm/ack:module.h:	     !((unsigned long)archdata->dbe_table_start >=
asm/ack:module.h:	       ((unsigned long)mod + mod->size_of_struct) &&
asm/ack:module.h:	       ((unsigned long)archdata->dbe_table_end <
asm/ack:module.h:	        (unsigned long)mod + mod->size))) ||
asm/ack:module.h:            (((unsigned long)archdata->dbe_table_start -
asm/ack:module.h:	      (unsigned long)archdata->dbe_table_end) %
asm/ack:module.h:			"module_arch_init: archdata->dbe_table_* invalid.\n");
asm/ack:module.h:	mod->archdata_start = (char *)&archdata;
asm/ack:module.h:	mod->archdata_end = mod->archdata_start + sizeof(archdata);
asm/ack:msgbuf.h: * - extension of time_t to 64-bit on 32-bitsystem to solve the y2038 problem
asm/ack:msgbuf.h: * - 2 miscellaneous unsigned long values
asm/ack:mv64340_dep.h: * include/asm-mips/mv64340-dep.h
asm/ack:mv64340_dep.h: *     Board-dependent definitions for MV-64340 chip.
asm/ack:mv64340.h:* mv64340.h - MV-64340 Internal registers definition file.
asm/ack:namei.h: * linux/include/asm-mips/namei.h
asm/ack:namei.h:	if (current->personality != PER_IRIX32)
asm/ack:ng1hw.h:#define REX3WAIT(rex3)  while ((rex3)->p1.set.status & GFXBUSY)
asm/ack:ng1hw.h:#define BFIFOWAIT(rex3)  while ((rex3)->p1.set.status & BACKBUSY)
asm/ack:nile4.h: *  asm-mips/nile4.h -- NEC Vrc-5074 Nile 4 definitions
asm/ack:nile4.h:#define NILE4_DCS2	0x0010	/* Device Chip-Select 2 [R/W] */
asm/ack:nile4.h:#define NILE4_DCS3	0x0018	/* Device Chip-Select 3 [R/W] */
asm/ack:nile4.h:#define NILE4_DCS4	0x0020	/* Device Chip-Select 4 [R/W] */
asm/ack:nile4.h:#define NILE4_DCS5	0x0028	/* Device Chip-Select 5 [R/W] */
asm/ack:nile4.h:#define NILE4_DCS6	0x0030	/* Device Chip-Select 6 [R/W] */
asm/ack:nile4.h:#define NILE4_DCS7	0x0038	/* Device Chip-Select 7 [R/W] */
asm/ack:nile4.h:#define NILE4_DCS8	0x0040	/* Device Chip-Select 8 [R/W] */
asm/ack:nile4.h:#define NILE4_BOOTCS	0x0078	/* Boot ROM Chip-Select [R/W] */
asm/ack:nile4.h:     *  Memory-Interface Registers
asm/ack:nile4.h:     *  PCI-Bus Registers
asm/ack:nile4.h:     *  Local-Bus Registers
asm/ack:nile4.h:#define NILE4_LCST2	0x0110	/* Local Bus Chip-Select Timing 2 [R/W] */
asm/ack:nile4.h:#define NILE4_LCST3	0x0118	/* Local Bus Chip-Select Timing 3 [R/W] */
asm/ack:nile4.h:#define NILE4_LCST4	0x0120	/* Local Bus Chip-Select Timing 4 [R/W] */
asm/ack:nile4.h:#define NILE4_LCST5	0x0128	/* Local Bus Chip-Select Timing 5 [R/W] */
asm/ack:nile4.h:#define NILE4_LCST6	0x0130	/* Local Bus Chip-Select Timing 6 [R/W] */
asm/ack:nile4.h:#define NILE4_LCST7	0x0138	/* Local Bus Chip-Select Timing 7 [R/W] */
asm/ack:nile4.h:#define NILE4_LCST8	0x0140	/* Local Bus Chip-Select Timing 8 [R/W] */
asm/ack:nile4.h:#define NILE4_DCSFN	0x0150	/* Device Chip-Select Muxing and Output */
asm/ack:nile4.h:#define NILE4_DCSIO	0x0158	/* Device Chip-Selects As I/O Bits [R/W] */
asm/ack:nile4.h:#define NILE4_BCST	0x0178	/* Local Boot Chip-Select Timing [R/W] */
asm/ack:nile4.h:#define NILE4_T1CTRL	0x01D0	/* CPU-Bus Read Time-Out Control [R/W] */
asm/ack:nile4.h:#define NILE4_T1CNTR	0x01D8	/* CPU-Bus Read Time-Out Counter [R/W] */
asm/ack:nile4.h:#define NILE4_T2CTRL	0x01E0	/* General-Purpose Timer Control [R/W] */
asm/ack:nile4.h:#define NILE4_T2CNTR	0x01E8	/* General-Purpose Timer Counter [R/W] */
asm/ack:nile4.h:#define NILE4_SSVID	0x022C	/* PCI Sub-System Vendor ID [R/W] */
asm/ack:nile4.h:#define NILE4_SSID	0x022E	/* PCI Sub-System ID [R/W] */
asm/ack:nile4.h:     *  Serial-Port Registers
asm/ack:nile4.h:#define NILE4_INT_CPCE	0	/* CPU-Interface Parity-Error Interrupt */
asm/ack:nile4.h:#define NILE4_INT_CNTD	1	/* CPU No-Target Decode Interrupt */
asm/ack:nile4.h:#define NILE4_INT_MCE	2	/* Memory-Check Error Interrupt */
asm/ack:nile4.h:#define NILE4_INT_GPT	6	/* General-Purpose Timer Interrupt */
asm/ack:nile4.h:#define NILE4_INT_LBRTD	7	/* Local-Bus Ready Timer Interrupt */
asm/ack:nile4.h:#define irq_to_nile4(n)		((n)-NUM_I8259_INTERRUPTS)
asm/ack:paccess.h: * by sending a DBE error like accessing possibly non-existant memory or
asm/ack:paccess.h:	".word\t1b-4,3b\n\t" \
asm/ack:paccess.h:	:"o" (__mp(__gu_addr)), "i" (-EFAULT)); })
asm/ack:paccess.h:	".word\t1b-4,3b\n\t" \
asm/ack:paccess.h:	:"r" (__pu_val), "o" (__mp(__pu_addr)), "i" (-EFAULT)); })
asm/ack:page.h: * Copyright (C) 1994 - 1999, 2003 by Ralf Baechle
asm/ack:page.h:#define PAGE_MASK	(~(PAGE_SIZE-1))
asm/ack:page.h: * These are used to make use of C type-checking..
asm/ack:page.h:	size = (size-1) >> (PAGE_SHIFT-1);
asm/ack:page.h:	order = -1;
asm/ack:page.h:#define PAGE_ALIGN(addr)	(((addr) + PAGE_SIZE - 1) & PAGE_MASK)
asm/ack:page.h:#define __pa(x)		((unsigned long) (x) - PAGE_OFFSET)
asm/ack:page.h:#define VALID_PAGE(page)	((page - mem_map) < max_mapnr)
asm/ack:page.h:#define UNCAC_ADDR(addr)	((addr) - PAGE_OFFSET + UNCAC_BASE)
asm/ack:page.h:#define CAC_ADDR(addr)		((addr) - UNCAC_BASE + PAGE_OFFSET)
asm/ack:param.h:    * Ye olde division-by-multiplication trick.
asm/ack:param.h:#  define QUOTIENT ((1UL << (32 - LOG_2_HZ)) * 100)
asm/ack:param.h:   unless you know what you're doing - changing breaks binary compatibility.  */
asm/ack:param.h:#define NOGROUP		(-1)
asm/ack:pb1000.h: *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm/ack:pb1000.h:/* VPPEN1 - VPPEN0 */
asm/ack:pb1000.h:/* VCCEN1 - VCCEN0 */
asm/ack:pb1100.h: *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm/ack:pb1200.h: *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm/ack:pb1200.h: *    *example: IDE bis pos is  = 64 - 64
asm/ack:pb1200.h:                ETH bit pos is  = 65 - 64
asm/ack:pb1200.h:#define BOARD_CARD_INSERTED(SOCKET) bcsr->sig_status & (1<<(8+(2*SOCKET)))
asm/ack:pb1500.h: *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm/ack:pb1550.h: *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm/ack:pb1550.h:#define DAUGHTER_CARD_MEM_SIZE		(0xADFFFFFF - DAUGHTER_CARD_BASE + 1)
asm/ack:pci_channel.h: * Each pci channel is a top-level PCI bus seem by CPU.  A machine  with
asm/ack:pci.h:   already-configured bus numbers - to be used for buggy BIOSes
asm/ack:pci.h: * NULL for PCI-like buses (ISA, EISA).
asm/ack:pci.h: * Returns non-NULL cpu-view pointer to the buffer if successful and
asm/ack:pci.h: * The 32-bit bus address to use is returned.
asm/ack:pci.h:	return bus_to_baddr(hwdev->bus, __pa(ptr));
asm/ack:pci.h:		addr = baddr_to_bus(hwdev->bus, dma_addr) + PAGE_OFFSET;
asm/ack:pci.h:	return bus_to_baddr(hwdev->bus, page_to_phys(page) + offset);
asm/ack:pci.h:		addr = baddr_to_bus(hwdev->bus, dma_address) + PAGE_OFFSET;
asm/ack:pci.h: * mode for DMA.  This is the scather-gather version of the
asm/ack:pci.h:		if (sg->address && sg->page)
asm/ack:pci.h:		else if (!sg->address && !sg->page)
asm/ack:pci.h:		if (sg->address) {
asm/ack:pci.h:			dma_cache_wback_inv((unsigned long)sg->address,
asm/ack:pci.h:			                    sg->length);
asm/ack:pci.h:			sg->dma_address = bus_to_baddr(hwdev->bus, __pa(sg->address));
asm/ack:pci.h:			sg->dma_address = page_to_bus(sg->page) +
asm/ack:pci.h:			                  sg->offset;
asm/ack:pci.h:				(page_address(sg->page) + sg->offset),
asm/ack:pci.h:				sg->length);
asm/ack:pci.h:		if (sg->address && sg->page)
asm/ack:pci.h:		else if (!sg->address && !sg->page)
asm/ack:pci.h:		if (!sg->address)
asm/ack:pci.h:		dma_cache_wback_inv((unsigned long)sg->address, sg->length);
asm/ack:pci.h:	addr = baddr_to_bus(hwdev->bus, dma_handle) + PAGE_OFFSET;
asm/ack:pci.h: * The same as pci_dma_sync_single but for a scatter-gather list,
asm/ack:pci.h:		dma_cache_wback_inv((unsigned long)sg->address, sg->length);
asm/ack:pci.h: * only drive the low 24-bits during PCI bus mastering, then
asm/ack:pci.h:	return (dma64_addr_t) bus_to_baddr(pdev->bus, addr);
asm/ack:pci.h:	unsigned long poff = baddr_to_bus(pdev->bus, dma_addr) >> PAGE_SHIFT;
asm/ack:pci.h:	addr = baddr_to_bus(pdev->bus, dma_addr) + PAGE_OFFSET;
asm/ack:pci.h:#define sg_dma_address(sg)	((sg)->dma_address)
asm/ack:pci.h:#define sg_dma_len(sg)		((sg)->length)
asm/ack:pgalloc.h: * Copyright (C) 1994 - 2001 by Ralf Baechle
asm/ack:pgalloc.h: *  - flush_tlb_all() flushes all processes TLB entries
asm/ack:pgalloc.h: *  - flush_tlb_mm(mm) flushes the specified mm context TLB entries
asm/ack:pgalloc.h: *  - flush_tlb_page(mm, vmaddr) flushes a single page
asm/ack:pgalloc.h: *  - flush_tlb_range(mm, start, end) flushes a range of pages
asm/ack:pgalloc.h: *  - flush_tlb_pgtables(mm, start, end) flushes a range of page tables
asm/ack:pgalloc.h: *  - flush_tlb_one(page) flushes a single kernel page
asm/ack:pgalloc.h:			(PTRS_PER_PGD - USER_PTRS_PER_PGD) * sizeof(pgd_t));
asm/ack:pgalloc.h:		pgtable_cache_size--;
asm/ack:pgalloc.h:		pgtable_cache_size--;
asm/ack:pgalloc.h:		pgtable_cache_size--;
asm/ack:pgalloc.h: * allocating and freeing a pmd is trivial: the 1-entry pmd is
asm/ack:pgtable-32.h: * traditional mips two-level paging structure:
asm/ack:pgtable-32.h:#define PMD_SHIFT       (2 * PAGE_SHIFT - PTE_T_LOG2)
asm/ack:pgtable-32.h:        pte_val(__pte) = ((phys_t)(page - mem_map) << (PAGE_SHIFT + 2)) | \
asm/ack:pgtable-32.h:	pte_val(__pte) = ((phys_t)(page - mem_map) << PAGE_SHIFT) | \
asm/ack:pgtable-64.h:#define mk_pte(page, pgprot) __mk_pte((page) - mem_map, (pgprot))
asm/ack:pgtable-64.h: * value and then use set_pte to update it.  -ben
asm/ack:pgtable-64.h:	ptep->pte_high = pte.pte_high;
asm/ack:pgtable-64.h:	ptep->pte_low = pte.pte_low;
asm/ack:pgtable-64.h:			buddy->pte_low |= _PAGE_GLOBAL;
asm/ack:pgtable-bits.h: * Copyright (C) 1994 - 2002 by Ralf Baechle
asm/ack:pgtable-bits.h:/* bobtseng --, 2005.12.16 */
asm/ack:pgtable.h:	test_bit(PG_dcache_dirty, &(page)->flags)
asm/ack:pgtable.h:	set_bit(PG_dcache_dirty, &(page)->flags)
asm/ack:pgtable.h:	clear_bit(PG_dcache_dirty, &(page)->flags)
asm/ack:pgtable.h: * - add_wired_entry() add a fixed TLB entry, and move wired register
asm/ack:pgtable.h: * - add_temporary_entry() add a temporary TLB entry. We use TLB entries
asm/ack:pgtable.h:/* Basically we have the same two-level (which is the logical three level
asm/ack:pgtable.h:/* PMD_SHIFT determines the size of the area a second-level page table can map */
asm/ack:pgtable.h:#define PMD_MASK	(~(PMD_SIZE-1))
asm/ack:pgtable.h:/* PGDIR_SHIFT determines what a third-level page table entry can map */
asm/ack:pgtable.h:#define PGDIR_MASK	(~(PGDIR_SIZE-1))
asm/ack:pgtable.h:# define VMALLOC_END	(PKMAP_BASE-2*PAGE_SIZE)
asm/ack:pgtable.h:# define VMALLOC_END	(FIXADDR_START-2*PAGE_SIZE)
asm/ack:pgtable.h:#include <asm/pgtable-bits.h>
asm/ack:pgtable.h:#include <asm/pgtable-64.h>
asm/ack:pgtable.h:#include <asm/pgtable-32.h>
asm/ack:pgtable.h: * The "pgd_xxx()" functions here are trivial for a folded two-level
asm/ack:pgtable.h:	(((address) >> PMD_SHIFT) & (PTRS_PER_PMD-1))
asm/ack:pgtable.h:/* to find an entry in a kernel page-table-directory */
asm/ack:pgtable.h:/* to find an entry in a page-table-directory */
asm/ack:pgtable.h:	return mm->pgd + pgd_index(address);
asm/ack:pgtable.h:/* Find an entry in the second-level page table.. */
asm/ack:pgtable.h:/* Find an entry in the third-level page table.. */
asm/ack:pgtable.h:	       ((address >> PAGE_SHIFT) & (PTRS_PER_PTE - 1));
asm/ack:pgtable.h:#include <asm-generic/pgtable.h>
asm/ack:poll.h:/* XXX This one seems to be more-or-less nonstandard.  */
asm/ack:posix_types.h: * This file is generally used by user-level software, so you need to
asm/ack:posix_types.h:	__fdsetp->fds_bits[__tmp] |= (1UL<<__rem);
asm/ack:posix_types.h:	__fdsetp->fds_bits[__tmp] &= ~(1UL<<__rem);
asm/ack:posix_types.h:	return (__p->fds_bits[__tmp] & (1UL<<__rem)) != 0;
asm/ack:posix_types.h: * for a 256-bit fd_set)
asm/ack:posix_types.h:	unsigned long *__tmp = __p->fds_bits;
asm/ack:posix_types.h:		__i--;
asm/ack:processor.h:#define MIPS_CACHE_IC_F_DC	0x00000008	/* Ic can refill from D-cache */
asm/ack:processor.h:	struct cache_desc icache;	/* Primary I-cache */
asm/ack:processor.h: * Size of io_bitmap in longwords: 32 is ports 0-0x3ff.
asm/ack:processor.h: * the FPU emulator for now.  See asm-mips/fpu_emulator.h.
asm/ack:processor.h:	if (t->reg31 == (unsigned long) ret_from_fork)
asm/ack:processor.h:		return t->reg31;
asm/ack:processor.h:	return ((unsigned long *)t->reg29)[schedule_frame.pc_offset];
asm/ack:processor.h:#define __PT_REG(reg) ((long)&((struct pt_regs *)0)->reg - sizeof(struct pt_regs))
asm/ack:processor.h:#define __KSTK_TOS(tsk) ((unsigned long)(tsk) + KERNEL_STACK_SIZE - 32)
asm/ack:processor.h:#define THREAD_MASK		(THREAD_SIZE - 1UL)
asm/ack:processor.h:#define get_task_struct(tsk)      atomic_inc(&virt_to_page(tsk)->count)
asm/ack:processor.h: * (MIPS, Alpha) or is unuseable with -fomit-frame-pointer (i386).
asm/ack:processor.h: * __builtin_return_address works only for non-leaf functions.  We avoid the
asm/ack:ptrace.h:/* 0 - 31 are integer registers, 32 - 63 are fp registers.  */
asm/ack:ptrace.h:        ".size\t" #symbol",. - " #symbol)
asm/ack:ptrace.h:#define user_mode(regs) (((regs)->cp0_status & KU_MASK) == KU_USER)
asm/ack:ptrace.h:#define instruction_pointer(regs) ((regs)->cp0_epc)
asm/ack:r4kcache.h: * Copyright (C) 1997 - 2002 Ralf Baechle (ralf@gnu.org)
asm/ack:r4kcache.h: * Copyright (C) 2004 Ralf Baechle (ralf@linux-mips.org)
asm/ack:r4kcache.h: * R10000 / R12000 hazard - these processors don't support the Hit_Writeback_D
asm/ack:r4kcache.h: * cacheop so we use Hit_Writeback_Inv_D which is supported by all R4000-style
asm/ack:r4kcache.h: * This one is RM7000-specific
asm/ack:regdef.h: * include/asm-mips/regdefs.h
asm/ack:regdef.h:#define AT      $1      /* assembler temp  - uppercase because of ".set at" */
asm/ack:reg.h: * This defines/structures correspond to the register layout on stack -
asm/ack:reg.h: * include/asm-mips/stackframe.h
asm/ack:resource.h:#define RLIMIT_MEMLOCK 9		/* max locked-in-memory address space */
asm/ack:riscos-syscall.h: * The syscalls 0 - 3999 are reserved for a down to the root syscall
asm/ack:rt2880/surfboard.h: *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm/ack:rt2880/surfboardint.bob: *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm/ack:rt2880/surfboardint.bob: * Surfboard registers are memory mapped on 32-bit aligned boundaries and
asm/ack:rt2880/surfboardint.bob:/* bobtseng added --, 2006.3.6. */
asm/ack:rt2880/surfboardint.org: *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm/ack:rt2880/surfboardint.org: * Surfboard registers are memory mapped on 32-bit aligned boundaries and
asm/ack:rt2880/generic.h: * 59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm/ack:rt2880/generic.h: * Defines of the Palmchip boards specific address-MAP, registers, etc.
asm/ack:rt2880/generic.h: * Power-off register
asm/ack:rt2880/prom.h: *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm/ack:rt2880/surfboardint.h: *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm/ack:rt2880/surfboardint.h: * Surfboard registers are memory mapped on 32-bit aligned boundaries and
asm/ack:rt2880/surfboardint.h:/* bobtseng added --, 2006.3.6. */
asm/ack:semaphore.h:	atomic_set(&sem->count, val);
asm/ack:semaphore.h:	atomic_set(&sem->waking, 0);
asm/ack:semaphore.h:	init_waitqueue_head(&sem->wait);
asm/ack:semaphore.h:	sem->__magic = (long)&sem->__magic;
asm/ack:semaphore.h: * sem->count and sem->waking atomic.
asm/ack:semaphore.h:	CHECK_MAGIC(sem->__magic);
asm/ack:semaphore.h:	count = atomic_dec_return(&sem->count);
asm/ack:semaphore.h: * it, return zero.  If we were interrupted, returns -EINTR
asm/ack:semaphore.h:	CHECK_MAGIC(sem->__magic);
asm/ack:semaphore.h:	count = atomic_dec_return(&sem->count);
asm/ack:semaphore.h: * Here, we do this by using lld/scd on the pair of 32-bit words.
asm/ack:semaphore.h: *   Decrement(sem->count)
asm/ack:semaphore.h: *   If(sem->count >=0) {
asm/ack:semaphore.h: *	If(sem->waking <= 0) {		// if no wakeup pending
asm/ack:semaphore.h: *	   Increment(sem->count)	// undo decrement
asm/ack:semaphore.h: *	   Decrement(sem->waking)	// otherwise "steal" wakeup
asm/ack:semaphore.h:	CHECK_MAGIC(sem->__magic);
asm/ack:semaphore.h:	"	dli	%3, 0x0000000100000000	# count -= 1		\n"
asm/ack:semaphore.h:	"	blez	%2, 1f			# if waking < 0 -> 1f	\n"
asm/ack:semaphore.h:	"	daddiu	%1, %1, -1		# waking -= 1		\n"
asm/ack:semaphore.h:	CHECK_MAGIC(sem->__magic);
asm/ack:semaphore.h:	"	dsll32 %1, %1, 0	# zero-extend %1	\n"
asm/ack:semaphore.h: * Non-blockingly attempt to down() a semaphore.
asm/ack:semaphore.h:	CHECK_MAGIC(sem->__magic);
asm/ack:semaphore.h:	count = atomic_read(&sem->count) - 1;
asm/ack:semaphore.h:	atomic_set(&sem->count, count);
asm/ack:semaphore.h:		waking = atomic_read(&sem->waking);
asm/ack:semaphore.h:			atomic_set(&sem->count, count + 1);
asm/ack:semaphore.h:			atomic_set(&sem->waking, waking - 1);
asm/ack:semaphore.h:	CHECK_MAGIC(sem->__magic);
asm/ack:semaphore.h:	count = atomic_read(&sem->count) + 1;
asm/ack:semaphore.h:	waking = atomic_read(&sem->waking);
asm/ack:semaphore.h:	atomic_set(&sem->count, count);
asm/ack:semaphore.h:	atomic_set(&sem->waking, waking);
asm/ack:semaphore.h:	return atomic_read(&sem->count);
asm/ack:sembuf.h: * - 2 miscellaneous 64-bit values
asm/ack:serial.h:#include <asm/mips-boards/atlas.h>
asm/ack:serial.h:#include <asm/mips-boards/atlasint.h>
asm/ack:serial.h:#include <asm/mips-boards/sead.h>
asm/ack:serial.h:#include <asm/mips-boards/seadint.h>
asm/ack:serial.h:#include <asm/galileo-boards/ev96100int.h>
asm/ack:serial.h: * Also look in ip27-pci.c:pci_fixuop_ioc3() for some comments on working
asm/ack:sfp-machine.h:#define _FP_NANFRAC_S		((_FP_QNANBIT_S << 1) - 1)
asm/ack:sfp-machine.h:#define _FP_NANFRAC_D		((_FP_QNANBIT_D << 1) - 1), -1
asm/ack:sfp-machine.h:#define _FP_NANFRAC_Q		((_FP_QNANBIT_Q << 1) - 1), -1, -1, -1
asm/ack:sgi/mc.h:#define SGIMC_CCTRL0_LENDIAN	0x00020000 /* Put MC in little-endian mode */
asm/ack:sgi/mc.h:#define SGIMC_EEPROM_SDATAO	0x00000008 /* Serial EEPROM data-out */
asm/ack:sgi/mc.h:#define SGIMC_EEPROM_SDATAI	0x00000010 /* Serial EEPROM data-in */
asm/ack:sgi/mc.h:#define SGIMC_GIOPAR_HPC64	0x00000001 /* HPC talks to GIO using 64-bits */
asm/ack:sgi/mc.h:#define SGIMC_GIOPAR_GFX64	0x00000002 /* GFX talks to GIO using 64-bits */
asm/ack:sgi/mc.h:#define SGIMC_GIOPAR_EXP064	0x00000004 /* EXP(slot0) talks using 64-bits */
asm/ack:sgi/mc.h:#define SGIMC_GIOPAR_EXP164	0x00000008 /* EXP(slot1) talks using 64-bits */
asm/ack:sgi/mc.h:#define SGIMC_GIOPAR_EISA64	0x00000010 /* EISA bus talks 64-bits to GIO */
asm/ack:sgi/mc.h:#define SGIMC_GIOPAR_HPC264	0x00000020 /* 2nd HPX talks 64-bits to GIO */
asm/ack:sgi/mc.h:	volatile u32 syssembit;		/* Uni-bit system semaphore */
asm/ack:sgi/mc.h:	u32 _unused36[0x1000/4-2*4];
asm/ack:sgi/gio.h: * -----   --------- ----------------------- -----
asm/ack:sgi/gio.h: *   0     GFX       0x1f000000 - 0x1f3fffff   4MB
asm/ack:sgi/gio.h: *   1     EXP0      0x1f400000 - 0x1f5fffff   2MB
asm/ack:sgi/gio.h: *   2     EXP1      0x1f600000 - 0x1f9fffff   4MB
asm/ack:sgi/gio.h: * There are un-slotted devices, HPC, I/O and misc devices, which are grouped
asm/ack:sgi/gio.h: *   -     MISC      0x1fb00000 - 0x1fbfffff   1MB
asm/ack:sgi/gio.h: *   -     RESERVED  0x18000000 - 0x1effffff 112MB
asm/ack:sgi/gio.h: * 32-bit IDs are divided into
asm/ack:sgi/gio.h: *	bit 16		0=GIO32 and GIO32-bis, 1=GIO64.
asm/ack:sgi/gio.h: * 8-bit IDs
asm/ack:sgi/gio.h: *	0x0e		E-Plex 8-port Ethernet
asm/ack:sgi/gio.h: * [*] Device provide 32-bit ID.
asm/ack:sgi/ioc.h: * All registers are 8-bit wide alligned on 32-bit boundary. Bad things
asm/ack:sgi/ioc.h:#define SGINT_TCWORD_MOS	0x02	/* One-shot IRQ mode. */
asm/ack:sgi/pi1.h:#define PI1_STAT_DEVID		0x03	/* bits 0-1 */
asm/ack:sgi/pi1.h:#define PI1_DMACTRL_STDMODE	0x00    /* bits 2-3 */
asm/ack:sgi/pi1.h:#define PI1_DMACTRL_SGIMODE	0x04    /* bits 2-3 */
asm/ack:sgi/pi1.h:#define PI1_DMACTRL_RICOHMODE	0x08    /* bits 2-3 */
asm/ack:sgi/pi1.h:#define PI1_DMACTRL_HPMODE	0x0c    /* bits 2-3 */
asm/ack:sgi/hpc3.h:	u32 _unused0[0x1000/4 - 2];	/* padding */
asm/ack:sgi/hpc3.h:#define HPC3_PDMACTRL_HW	0x0000ff00 /* DMA High-water mark */
asm/ack:sgi/hpc3.h:	u32 _unused1[0x1000/4 - 1];	/* padding */
asm/ack:sgi/hpc3.h:	u32 _unused0[0x1000/4 - 2];	/* padding */
asm/ack:sgi/hpc3.h:#define HPC3_SDCFG_HW   0x01000 /* Enable 16-bit halfword DMA accesses to scsi */
asm/ack:sgi/hpc3.h:#define HPC3_SPCFG_HW   0x1000 /* Enable 16-bit halfword PIO accesses to scsi */
asm/ack:sgi/hpc3.h:	u32 _unused1[0x1000/4 - 6];	/* padding */
asm/ack:sgi/hpc3.h:	u32 _unused0[0x1000/4 - 2];	/* padding */
asm/ack:sgi/hpc3.h:	u32 _unused2[0x1000/4 - 8];	/* padding */
asm/ack:sgi/hpc3.h:	u32 _unused3[0x1000/4 - 2];	/* padding */
asm/ack:sgi/hpc3.h:	u32 _unused4[0x1000/4 - 4];	/* padding */
asm/ack:sgi/hpc3.h:	 * you it was a peculiar bug. ;-)
asm/ack:sgi/hpc3.h:#define HPC3_ISTAT_PBIMASK	0x0ff	/* irq bits for pbus devs 0 --> 7 */
asm/ack:sgi/hpc3.h:	u32 _unused1[0x14000/4 - 5];	/* padding */
asm/ack:sgi/hpc3.h:	/* Now direct PIO per-HPC3 peripheral access to external regs. */
asm/ack:sgi/hpc3.h:	/* Per-peripheral device external registers and DMA/PIO control. */
asm/ack:sgi/hpc3.h:	/* Enable 16-bit DMA access mode */
asm/ack:sgi/hpc3.h:	/* Enable 16-bit PIO accesses */
asm/ack:sgi/hpc3.h:	u32 _unused5[0x0800/4 - 1];
asm/ack:sgi/hpc3.h:	u32 _unused6[0x0800/4 - 1];
asm/ack:sgi/hpc3.h:	u32 _unused7[0x1000/4 - 1];
asm/ack:sgi/hpc3.h:	volatile u32 bbram[8192-50-14];	/* Battery backed ram */
asm/ack:sgi/ip22.h: * HAL2 driver). This will prevent many complications, trust me ;-)
asm/ack:sgi/ip22.h:#define SGI_GIO_0_IRQ	SGI_FIFO_IRQ		/* GIO-0 */
asm/ack:sgi/ip22.h:#define SGI_GIO_1_IRQ	SGINT_LOCAL0 + 6	/* GE / GIO-1 / 2nd-HPC */
asm/ack:sgi/ip22.h:#define SGI_GIO_2_IRQ	SGINT_LOCAL1 + 7	/* Vert retrace / GIO-2 */
asm/ack:sgi/ip22.h:#define ip22_is_fullhouse()	(sgioc->sysid & SGIOC_SYSID_FULLHOUSE)
asm/ack:sgialib.h:/* A 32-bit ARC PROM pass arguments and environment as 32-bit pointer.
asm/ack:sgialib.h:/* Simple char-by-char console I/O. */
asm/ack:sgialib.h:/* Running stand-along programs. */
asm/ack:sgiarcs.h:#define ROMVECTOR ((struct linux_romvec *) (long)(PROMBLOCK)->romvec)
asm/ack:sgiarcs.h:#define SGIPROM_ROFILE    0x01  /* read-only file */
asm/ack:sgiarcs.h: * Macros for calling a 32-bit ARC implementation from 64-bit code
asm/ack:sgiarcs.h:	long __vec = (long) romvec->dest;				\
asm/ack:sgiarcs.h:	long __vec = (long) romvec->dest;				\
asm/ack:sgiarcs.h:	long __vec = (long) romvec->dest;				\
asm/ack:sgiarcs.h:	long __vec = (long) romvec->dest;				\
asm/ack:sgiarcs.h:	long __vec = (long) romvec->dest;				\
asm/ack:sgiarcs.h:	long __vec = (long) romvec->dest;				\
asm/ack:sgiarcs.h:	long (*__vec)(void) = (void *) romvec->dest;			\
asm/ack:sgiarcs.h:	long (*__vec)(long) = (void *) romvec->dest;			\
asm/ack:sgiarcs.h:	long (*__vec)(long, long) = (void *) romvec->dest;		\
asm/ack:sgiarcs.h:	long (*__vec)(long, long, long)	= (void *) romvec->dest;	\
asm/ack:sgiarcs.h:	long (*__vec)(long, long, long, long) = (void *) romvec->dest;	\
asm/ack:sgiarcs.h:	__vec = (void *) romvec->dest;					\
asm/ack:sgiarcs.h:#endif /* both kernel and ARC either 32-bit or 64-bit */
asm/ack:shmbuf.h: * - 2 miscellaneous 32-bit values
asm/ack:shmiq.h:        volatile unsigned int flags; /* place for out-of-band data */
asm/ack:shmiq.h:/* -------------------- iDev stuff -------------------- */
asm/ack:shmiq.h:/* These are only interpreted by SHMIQ-attacheable devices and are internal
asm/ack:sibyte/sb1250_dma.h:    *  MA 02111-1307 USA
asm/ack:sibyte/sb1250_dma.h: * Ethernet and Serial DMA Configuration Register 0  (Table 7-4)
asm/ack:sibyte/sb1250_dma.h: * Ethernet and Serial DMA Configuration Register 1 (Table 7-5)
asm/ack:sibyte/sb1250_dma.h: * Ethernet and Serial DMA Descriptor base address (Table 7-6)
asm/ack:sibyte/sb1250_dma.h: * ASIC Mode Base Address (Table 7-7)
asm/ack:sibyte/sb1250_dma.h: * DMA Descriptor Count Registers (Table 7-8)
asm/ack:sibyte/sb1250_dma.h: * Current Descriptor Address Register (Table 7-11)
asm/ack:sibyte/sb1250_dma.h: * Descriptor doubleword "A"  (Table 7-12)
asm/ack:sibyte/sb1250_dma.h: * Descriptor doubleword "B"  (Table 7-13)
asm/ack:sibyte/sb1250_dma.h: * Ethernet Descriptor Status Bits (Table 7-15)
asm/ack:sibyte/sb1250_dma.h: * Ethernet Transmit Status Bits (Table 7-16)
asm/ack:sibyte/sb1250_dma.h: * Ethernet Transmit Options (Table 7-17)
asm/ack:sibyte/sb1250_dma.h: * Serial Receive Options (Table 7-18)
asm/ack:sibyte/sb1250_dma.h: * Serial Transmit Status Bits (Table 7-20)
asm/ack:sibyte/sb1250_dma.h: * Serial Transmit Options (Table 7-21)
asm/ack:sibyte/sb1250_dma.h: * Data Mover Descriptor Base Address Register (Table 7-22)
asm/ack:sibyte/sb1250_dma.h: * Data Mover Descriptor Count Register (Table 7-25)
asm/ack:sibyte/sb1250_dma.h: * Data Mover Current Descriptor Address (Table 7-24)
asm/ack:sibyte/sb1250_dma.h: * Data Mover Descriptor Doubleword "A"  (Table 7-26)
asm/ack:sibyte/sb1250_dma.h: * Data Mover Descriptor Doubleword "B"  (Table 7-25)
asm/ack:sibyte/sb1250_l2c.h:    *  MA 02111-1307 USA
asm/ack:sibyte/sb1250_l2c.h: * Level 2 Cache Tag register (Table 5-3)
asm/ack:sibyte/sb1250_l2c.h: * Format of level 2 cache management address (table 5-2)
asm/ack:sibyte/sb1250_int.h:    *  MA 02111-1307 USA
asm/ack:sibyte/sb1250_int.h: * Interrupt sources (Table 4-8, UM 0.2)
asm/ack:sibyte/sb1250_int.h: * LDT Interrupt Set Register (table 4-5)
asm/ack:sibyte/sb1250_int.h: * Vector format (Table 4-6)
asm/ack:sibyte/sb1250_ldt.h:    *  MA 02111-1307 USA
asm/ack:sibyte/sb1250_ldt.h: * LDT Command Register (Table 8-13)
asm/ack:sibyte/sb1250_ldt.h: * LDT Status Register (Table 8-14).  Note that these constants
asm/ack:sibyte/sb1250_ldt.h: * together (32-bit read at offset 0x04)
asm/ack:sibyte/sb1250_ldt.h: * register (Table 8-15), offset 0x1C
asm/ack:sibyte/sb1250_ldt.h: * Bridge Control Register (Table 8-16).  Note that these 
asm/ack:sibyte/sb1250_ldt.h: * constants assume you've read the register as a 32-bit 
asm/ack:sibyte/sb1250_ldt.h: * LDT Command Register (Table 8-17).  Note that these constants
asm/ack:sibyte/sb1250_ldt.h: * 32-bit read at offset 0x40
asm/ack:sibyte/sb1250_ldt.h: * LDT link control register (Table 8-18), and (Table 8-19)
asm/ack:sibyte/sb1250_ldt.h: * LDT Link frequency register  (Table 8-20) offset 0x48
asm/ack:sibyte/sb1250_ldt.h: * LDT SRI Command Register (Table 8-21).  Note that these constants
asm/ack:sibyte/sb1250_ldt.h: * 32-bit read at offset 0x50
asm/ack:sibyte/sb1250_ldt.h: * LDT Error control and status register (Table 8-22) (Table 8-23)
asm/ack:sibyte/sb1250_ldt.h: * SRI Control register (Table 8-24, 8-25)  Offset 0x6C
asm/ack:sibyte/sb1250_ldt.h: * LDT SRI Transmit Buffer Count register (Table 8-26)
asm/ack:sibyte/sb1250_mac.h:    *  MA 02111-1307 USA
asm/ack:sibyte/sb1250_mac.h: * MAC Configuration Register (Table 9-13)
asm/ack:sibyte/sb1250_mac.h: * MAC Fifo Threshhold registers (Table 9-14)
asm/ack:sibyte/sb1250_mac.h: * MAC Frame Configuration Registers (Table 9-15)
asm/ack:sibyte/sb1250_mac.h: * MAC VLAN Tag Registers (Table 9-16)
asm/ack:sibyte/sb1250_mac.h: * MAC Status Registers (Table 9-17)
asm/ack:sibyte/sb1250_mac.h: * Also used for the MAC Interrupt Mask Register (Table 9-18)
asm/ack:sibyte/sb1250_mac.h: *  and pass just the six bits to a DMA-channel-specific ISR
asm/ack:sibyte/sb1250_mac.h: * MAC Fifo Pointer Registers (Table 9-19)    [Debug register]
asm/ack:sibyte/sb1250_mac.h: * MAC Fifo End Of Packet Count Registers (Table 9-20)  [Debug register]
asm/ack:sibyte/sb1250_mac.h: * MAC Recieve Address Filter Exact Match Registers (Table 9-21)
asm/ack:sibyte/sb1250_mac.h: * MAC Recieve Address Filter Hash Match Registers (Table 9-22)
asm/ack:sibyte/sb1250_mac.h: * MAC Transmit Source Address Registers (Table 9-23)
asm/ack:sibyte/sb1250_mac.h: * MAC Receive Address Filter Control Registers (Table 9-24)
asm/ack:sibyte/sb1250_mac.h: * MAC Receive Channel Select Registers (Table 9-25)
asm/ack:sibyte/sb1250_mac.h: * MAC MII Management Interface Registers (Table 9-26)
asm/ack:sibyte/sb1250_scd.h:    *  MA 02111-1307 USA
asm/ack:sibyte/sb1250_scd.h: * System Revision Register (Table 4-1)
asm/ack:sibyte/sb1250_scd.h: * System Config Register (Table 4-2)
asm/ack:sibyte/sb1250_scd.h: * Mailbox Registers (Table 4-3)
asm/ack:sibyte/sb1250_scd.h: * Watchdog Registers (Table 4-8) (Table 4-9) (Table 4-10)
asm/ack:sibyte/sb1250_scd.h: * Timer Registers (Table 4-11) (Table 4-12) (Table 4-13)
asm/ack:sibyte/trace_prof.h: * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
asm/ack:sibyte/trace_prof.h: * Routines for using 40-bit SCD cycle counter
asm/ack:sibyte/trace_prof.h: * zclk_timer_init(0) at least every 2^40 - 1 ZCLKs.
asm/ack:sibyte/sb1250_syncser.h:    *  MA 02111-1307 USA
asm/ack:sibyte/sb1250.h: * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
asm/ack:sibyte/sb1250_mc.h:    *  MA 02111-1307 USA
asm/ack:sibyte/sb1250_mc.h: * Memory Channel Config Register (table 6-14)
asm/ack:sibyte/sb1250_mc.h: * Memory clock config register (Table 6-15)
asm/ack:sibyte/sb1250_mc.h: * DRAM Command Register (Table 6-13)
asm/ack:sibyte/sb1250_mc.h: * DRAM Mode Register (Table 6-14)
asm/ack:sibyte/sb1250_mc.h: * SDRAM Timing Register  (Table 6-15)
asm/ack:sibyte/sb1250_mc.h: * Chip Select Start Address Register (Table 6-17)
asm/ack:sibyte/sb1250_mc.h: * Chip Select End Address Register (Table 6-18)
asm/ack:sibyte/sb1250_mc.h: * Chip Select Interleave Register (Table 6-19)
asm/ack:sibyte/sb1250_mc.h: * Row Address Bits Register (Table 6-20)
asm/ack:sibyte/sb1250_mc.h: * Column Address Bits Register (Table 6-21)
asm/ack:sibyte/sb1250_mc.h: * Bank Address Address Bits Register (Table 6-22)
asm/ack:sibyte/sb1250_mc.h: * Chip Select Attribute Register (Table 6-23)
asm/ack:sibyte/sb1250_mc.h: * ECC Test ECC Register (Table 6-25)
asm/ack:sibyte/swarm.h: * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
asm/ack:sibyte/carmel.h: * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
asm/ack:sibyte/sb1250_smbus.h:    *  MA 02111-1307 USA
asm/ack:sibyte/sb1250_smbus.h: * SMBus Clock Frequency Register (Table 14-2)
asm/ack:sibyte/sb1250_smbus.h: * SMBus control register (Table 14-4)
asm/ack:sibyte/sb1250_smbus.h: * SMBus status registers (Table 14-5)
asm/ack:sibyte/sb1250_smbus.h: * SMBus Start/Command registers (Table 14-9)
asm/ack:sibyte/sb1250_smbus.h: * SMBus Data Register (Table 14-6) and SMBus Extra Register (Table 14-7)
asm/ack:sibyte/sb1250_smbus.h: * SMBus Packet Error Check register (Table 14-8)
asm/ack:sibyte/sentosa.h: * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
asm/ack:sibyte/64bit.h: * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
asm/ack:sibyte/64bit.h: * This is annoying...we can't actually write the 64-bit IO register properly
asm/ack:sibyte/64bit.h: * without having access to 64-bit registers...  which doesn't work by default
asm/ack:sibyte/64bit.h: * driver code for the 32-bit and 64-bit trees
asm/ack:sibyte/64bit.h: * Avoid interrupt mucking, just adjust the address for 4-byte access.
asm/ack:sibyte/64bit.h: * Assume the addresses are 8-byte aligned.
asm/ack:sibyte/sb1250_defs.h:    *  MA 02111-1307 USA
asm/ack:sibyte/sb1250_defs.h: * 'long long' (64-bit integer) support.
asm/ack:sibyte/sb1250_defs.h:    ((SIBYTE_HDR_FMASK(chip, pass) - 1) & SIBYTE_HDR_FMASK_ALLREVS(chip))
asm/ack:sibyte/sb1250_defs.h:     | (SIBYTE_HDR_FMASK(chip, pass) - 1)) & SIBYTE_HDR_FMASK_ALLREVS(chip))
asm/ack:sibyte/sb1250_defs.h:    *                  For multi-bit fields, all bits in the field will
asm/ack:sibyte/sb1250_defs.h:    *  K_xxx           "Code" constant (value for data in a multi-bit
asm/ack:sibyte/sb1250_defs.h:    *  G_xxx(X)        GET value.  This macro obtains a multi-bit field
asm/ack:sibyte/sb1250_defs.h: * Cast to 64-bit number.  Presumably the syntax is different in 
asm/ack:sibyte/sb1250_defs.h:#define _SB_MAKEMASK(v,n) (_SB_MAKE64((_SB_MAKE64(1)<<(v))-1) << _SB_MAKE64(n))
asm/ack:sibyte/sb1250_defs.h:#define _SB_MAKEMASK_32(v,n) (_SB_MAKE32((_SB_MAKE32(1)<<(v))-1) << _SB_MAKE32(n))
asm/ack:sibyte/sb1250_defs.h: * Macros to read/write on-chip registers
asm/ack:sibyte/sb1250_genbus.h:    *  MA 02111-1307 USA
asm/ack:sibyte/sb1250_genbus.h: * Generic Bus Region Configuration Registers (Table 11-4)
asm/ack:sibyte/sb1250_genbus.h: * Generic Bus Region Size register (Table 11-5)
asm/ack:sibyte/sb1250_genbus.h: * Generic Bus Region Address (Table 11-6)
asm/ack:sibyte/sb1250_genbus.h: * Generic Bus Region 0 Timing Registers (Table 11-7)
asm/ack:sibyte/sb1250_genbus.h: * Generic Bus Timing 1 Registers (Table 11-8)
asm/ack:sibyte/sb1250_genbus.h: * Generic Bus Interrupt Status Register (Table 11-9)
asm/ack:sibyte/sb1250_genbus.h: * PCMCIA configuration register (Table 12-6)
asm/ack:sibyte/sb1250_genbus.h: * PCMCIA status register (Table 12-7)
asm/ack:sibyte/sb1250_genbus.h: * GPIO Interrupt Type Register (table 13-3)
asm/ack:sibyte/board.h: * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
asm/ack:sibyte/sb1250_regs.h:    *  This module contains the addresses of the on-chip peripherals
asm/ack:sibyte/sb1250_regs.h:    *  MA 02111-1307 USA
asm/ack:sibyte/sb1250_regs.h:/* Backward-compatibility definitions.  */
asm/ack:sibyte/sb1250_uart.h:    *  MA 02111-1307 USA
asm/ack:sibyte/sb1250_uart.h: * DUART Mode Register #1 (Table 10-3)
asm/ack:sibyte/sb1250_uart.h: * DUART Mode Register #2 (Table 10-4)
asm/ack:sibyte/sb1250_uart.h: * DUART Command Register (Table 10-5)
asm/ack:sibyte/sb1250_uart.h: * DUART Status Register (Table 10-6)
asm/ack:sibyte/sb1250_uart.h: * READ-ONLY
asm/ack:sibyte/sb1250_uart.h: * DUART Baud Rate Register (Table 10-7)
asm/ack:sibyte/sb1250_uart.h:#define V_DUART_BAUD_RATE(x)        (100000000/((x)*20)-1)
asm/ack:sibyte/sb1250_uart.h: * DUART Data Registers (Table 10-8 and 10-9)
asm/ack:sibyte/sb1250_uart.h: * DUART Input Port Register (Table 10-10)
asm/ack:sibyte/sb1250_uart.h: * DUART Input Port Change Status Register (Tables 10-11, 10-12, and 10-13)
asm/ack:sibyte/sb1250_uart.h: * DUART Output port control register (Table 10-14)
asm/ack:sibyte/sb1250_uart.h: * DUART Aux Control Register (Table 10-15)
asm/ack:sibyte/sb1250_uart.h: * DUART Interrupt Status Register (Table 10-16)
asm/ack:sibyte/sb1250_uart.h: * DUART Channel A Interrupt Status Register (Table 10-17)
asm/ack:sibyte/sb1250_uart.h: * DUART Channel B Interrupt Status Register (Table 10-18)
asm/ack:sibyte/sb1250_uart.h: * DUART Interrupt Mask Register (Table 10-19)
asm/ack:sibyte/sb1250_uart.h: * DUART Channel A Interrupt Mask Register (Table 10-20)
asm/ack:sibyte/sb1250_uart.h: * DUART Channel B Interrupt Mask Register (Table 10-21)
asm/ack:sibyte/sb1250_uart.h: * DUART Output Port Set Register (Table 10-22)
asm/ack:sibyte/sb1250_uart.h: * DUART Output Port Clear Register (Table 10-23)
asm/ack:sibyte/sb1250_uart.h: * DUART Output Port RTS Register (Table 10-24)
asm/ack:siginfo.h:#define SI_PAD_SIZE	((SI_MAX_SIZE/sizeof(int)) - 3)
asm/ack:siginfo.h:#define SI_PAD_SIZE	((SI_MAX_SIZE/sizeof(int)) - 4)
asm/ack:siginfo.h:	int __pad0[SI_MAX_SIZE / sizeof(int) - SI_PAD_SIZE - 3];
asm/ack:siginfo.h:#define SI_QUEUE	-1	/* sent by sigqueue */
asm/ack:siginfo.h:#define SI_ASYNCIO	-2	/* sent by AIO completion */
asm/ack:siginfo.h:#define SI_TIMER __SI_CODE(__SI_TIMER,-3) /* sent by timer expiration */
asm/ack:siginfo.h:#define SI_MESGQ	-4	/* sent by real time mesq state change */
asm/ack:siginfo.h:#define SI_SIGIO	-5	/* sent by queued SIGIO */
asm/ack:siginfo.h:#define SI_TKILL	-6	/* sent by tkill system call */
asm/ack:siginfo.h:#define SI_FROMUSER(siptr)	((siptr)->si_code <= 0)
asm/ack:siginfo.h:#define SI_FROMKERNEL(siptr)	((siptr)->si_code > 0)
asm/ack:siginfo.h:#define BUS_ADRERR	(__SI_FAULT|2)	/* non-existant physical address */
asm/ack:siginfo.h:#define SIGEV_PAD_SIZE	((SIGEV_MAX_SIZE-SIGEV_HEAD_SIZE) / sizeof(int))
asm/ack:siginfo.h:	if (from->si_code < 0)
asm/ack:siginfo.h:		memcpy(to, from, 3*sizeof(int) + sizeof(from->_sifields._sigchld));
asm/ack:signal.h:#define SIGFPE		 8	/* Floating-point exception (ANSI).  */
asm/ack:signal.h:#define SIGUSR1		16	/* User-defined signal 1 (POSIX).  */
asm/ack:signal.h:#define SIGUSR2		17	/* User-defined signal 2 (POSIX).  */
asm/ack:signal.h:#define SIGRTMAX	(_NSIG-1)
asm/ack:signal.h: * SA_INTERRUPT is a no-op, but left due to historical reasons. Use the
asm/ack:signal.h:#define SA_INTERRUPT	0x20000000	/* dummy -- ignored */
asm/ack:signal.h:#define SIG_ERR	((__sighandler_t)-1)	/* error return from signal */
asm/ack:signal.h: * non-Linux/MIPS object files or make use of them in the future.
asm/ack:signal.h:#define BRK_BD_TAKEN	3	/* For bd slot emulation - not implemented */
asm/ack:signal.h:#define BRK_BD_NOTTAKEN	4	/* For bd slot emulation - not implemented */
asm/ack:signal.h:#define BRK_NORLD	10	/* No rld found - not used by Linux/MIPS */
asm/ack:smp.h: * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
asm/ack:smp.h: * Copyright (C) 2000 - 2001 by Kanoj Sarcar (kanoj@sgi.com)
asm/ack:smp.h: * Copyright (C) 2000 - 2001 by Silicon Graphics, Inc.
asm/ack:smp.h:#define smp_processor_id()	(current->processor)
asm/ack:smp.h:   not be idempotent when cpus failed to come on-line.  */
asm/ack:smp.h:#define NO_PROC_ID	(-1)
asm/ack:smp.h:/* These are defined by the board-specific code. */
asm/ack:smplock.h:	if (task->lock_depth >= 0) \
asm/ack:smplock.h: * Re-acquire the kernel lock
asm/ack:smplock.h:	if (task->lock_depth >= 0) \
asm/ack:smplock.h:	if (!++current->lock_depth)
asm/ack:smplock.h:	if (--current->lock_depth < 0)
asm/ack:sni.h: * Interrupt 0-16 are EISA interrupts.  Interrupts from 16 on are assigned
asm/ack:socket.h:#define SO_OOBINLINE 0x0100	/* Receive out-of-band data in-band.  */
asm/ack:socket.h:#define SO_SNDLOWAT	0x1003	/* send low-water mark */
asm/ack:socket.h:#define SO_RCVLOWAT	0x1004	/* receive low-water mark */
asm/ack:socket.h:/* linux-specific, might as well be the same as on i386 */
asm/ack:socket.h:/* Security levels - as per NRL IPv6 - don't actually do anything */
asm/ack:socket.h:/* Nast libc5 fixup - bletch */
asm/ack:socket.h:#define SOCK_RDM	4		/* reliably-delivered message	*/
asm/ack:sockios.h: * Socket-level I/O control calls.
asm/ack:sockios.h:/* Socket-level I/O control calls. */
asm/ack:sockios.h:#define SIOCGSTAMP	0x8906			/* Get stamp - linux-specific */
asm/ack:softirq.h:	local_bh_count(cpu)--;
asm/ack:softirq.h:	if (!--local_bh_count(cpu) && softirq_pending(cpu))	\
asm/ack:spinlock.h:#define spin_lock_init(x)	do { (x)->lock = 0; } while(0)
asm/ack:spinlock.h:#define spin_is_locked(x)	((x)->lock != 0)
asm/ack:spinlock.h:#define spin_unlock_wait(x)	do { barrier(); } while ((x)->lock)
asm/ack:spinlock.h:	: "=m" (lock->lock), "=&r" (tmp)
asm/ack:spinlock.h:	: "m" (lock->lock)
asm/ack:spinlock.h:	: "=m" (lock->lock)
asm/ack:spinlock.h:	: "m" (lock->lock)
asm/ack:spinlock.h: * Read-write spinlocks, allowing multiple readers but only one writer.
asm/ack:spinlock.h: * writers. For those circumstances we can "mix" irq-safe locks - any writer
asm/ack:spinlock.h: * needs to get a irq-safe write-lock, but readers can get non-irqsafe
asm/ack:spinlock.h: * read-locks.
asm/ack:spinlock.h:	: "=m" (rw->lock), "=&r" (tmp)
asm/ack:spinlock.h:	: "m" (rw->lock)
asm/ack:spinlock.h:	: "=m" (rw->lock), "=&r" (tmp)
asm/ack:spinlock.h:	: "m" (rw->lock)
asm/ack:spinlock.h:	: "=m" (rw->lock), "=&r" (tmp)
asm/ack:spinlock.h:	: "m" (rw->lock)
asm/ack:spinlock.h:	: "=m" (rw->lock)
asm/ack:spinlock.h:	: "m" (rw->lock)
asm/ack:statfs.h:	long		f_frsize;	/* Fragment size - unsupported */
asm/ack:stat.h: * struct stat of the 64-bit kernel.
asm/ack:string.h:		"lbu\t$1,-1(%0)\n\t"
asm/ack:sysmips.h: * sysmips(2) is deprecated - though some existing software uses it.
asm/ack:system.h: * Copyright (C) 1994 - 1999 by Ralf Baechle
asm/ack:system.h: * Copyright (C) 1994 - 1999 by Ralf Baechle
asm/ack:system.h:#endif /* Processor-dependent optimization */
asm/ack:termbits.h:#define VKILL		 3		/* Kill-line character [ICANON].  */
asm/ack:termbits.h:#define VTIME		 5		/* Time-out value (tenths of a second) [!ICANON].  */
asm/ack:termbits.h:#define VSTART		 8		/* Start (X-ON) character [IXON, IXOFF].  */
asm/ack:termbits.h:#define VSTOP		 9		/* Stop (X-OFF) character [IXON, IXOFF].  */
asm/ack:termbits.h:#define VREPRINT	12		/* Reprint-line character [ICANON].  */
asm/ack:termbits.h:#define VWERASE		14		/* Word-erase character [ICANON].  */
asm/ack:termbits.h:#define VLNEXT		15		/* Literal-next character [IEXTEN].  */
asm/ack:termbits.h:#define VEOF		16		/* End-of-file character [ICANON].  */
asm/ack:termbits.h:#define VEOL		17		/* End-of-line character [ICANON].  */
asm/ack:termbits.h:#define ONLCR	0000004		/* Map NL to CR-NL on output.  */
asm/ack:termios.h:	int	sg_flags;	/* SGI special - int, not short */
asm/ack:termios.h:#define N_IRDA		11	/* Linux IrDa - http://irda.sourceforge.net/ */
asm/ack:termios.h:#define N_SMSBLOCK	12	/* SMS block mode - for talking to GSM data cards about SMS messages */
asm/ack:termios.h:	get_user(tmp, &(termio)->c_iflag); \
asm/ack:termios.h:	(termios)->c_iflag = (0xffff0000 & ((termios)->c_iflag)) | tmp; \
asm/ack:termios.h:	get_user(tmp, &(termio)->c_oflag); \
asm/ack:termios.h:	(termios)->c_oflag = (0xffff0000 & ((termios)->c_oflag)) | tmp; \
asm/ack:termios.h:	get_user(tmp, &(termio)->c_cflag); \
asm/ack:termios.h:	(termios)->c_cflag = (0xffff0000 & ((termios)->c_cflag)) | tmp; \
asm/ack:termios.h:	get_user(tmp, &(termio)->c_lflag); \
asm/ack:termios.h:	(termios)->c_lflag = (0xffff0000 & ((termios)->c_lflag)) | tmp; \
asm/ack:termios.h:	get_user((termios)->c_line, &(termio)->c_line); \
asm/ack:termios.h:	copy_from_user((termios)->c_cc, (termio)->c_cc, NCC); \
asm/ack:termios.h:	put_user((termios)->c_iflag, &(termio)->c_iflag); \
asm/ack:termios.h:	put_user((termios)->c_oflag, &(termio)->c_oflag); \
asm/ack:termios.h:	put_user((termios)->c_cflag, &(termio)->c_cflag); \
asm/ack:termios.h:	put_user((termios)->c_lflag, &(termio)->c_lflag); \
asm/ack:termios.h:	put_user((termios)->c_line, &(termio)->c_line); \
asm/ack:termios.h:	copy_to_user((termio)->c_cc, (termios)->c_cc, NCC); \
asm/ack:time.h: * include/asm-mips/time.h
asm/ack:time.h: * RTC ops.  By default, they point to no-RTC functions.
asm/ack:time.h: *	rtc_get_time - mktime(year, mon, day, hour, min, sec) in seconds.
asm/ack:time.h: *	rtc_set_time - reverse the above translation and set time to RTC.
asm/ack:time.h: *	rtc_set_mmss - similar to rtc_set_time, but only min and sec need
asm/ack:time.h: *			to be set.  Used by RTC sync-up.
asm/ack:time.h: * mips_timer_ack may be NULL if the interrupt is self-recoverable.
asm/ack:time.h: * If mips_hpt_read is NULL, an R4k-compatible timer setup is attempted.
asm/ack:time.h: * high-level timer interrupt routines.
asm/ack:time.h: * the corresponding low-level timer interrupt routine.
asm/ack:time.h: * mips_hpt_frequency - must be set if you intend to use an R4k-compatible
asm/ack:titan_dep.h: * Copyright 2003 PMC-Sierra
asm/ack:titan_dep.h: * Author: Manish Lachwani (lachwani@pmc-sierra.com)
asm/ack:titan_dep.h: * Board specific definititions for the PMC-Sierra Yosemite
asm/ack:tlb.h:#include <asm-generic/tlb.h>
asm/ack:traps.h: *	include/asm-mips/traps.h
asm/ack:tx3912.h: *  include/asm-mips/tx3912.h
asm/ack:tx3912.h: *	---------------                                                      *
asm/ack:tx3912.h: *	-------------------                                                  *
asm/ack:tx3912.h: *	---------------                                                      *
asm/ack:tx3912.h: *	---------------                                                      *
asm/ack:tx3912.h: *	--------------                                                       *
asm/ack:tx3912.h: *	---------------                                                      *
asm/ack:tx4927/tx4927.h: * Copyright 2001-2002 MontaVista Software Inc.
asm/ack:tx4927/tx4927.h: followed by the device name from table 4.2.2 on page 4-3 and then followed
asm/ack:tx4927/tx4927.h: by the register name from table 4.2.3 on pages 4-4 to 4-8.  The manaul
asm/ack:tx4927/tx4927.h:/* TX4927 SDRAM controller (64-bit registers) */
asm/ack:tx4927/tx4927.h:/* TX4927 external bus controller (64-bit registers) */
asm/ack:tx4927/tx4927.h:/* TX4927 SDRRAM Error Check Correction (64-bit registers) */
asm/ack:tx4927/tx4927.h:/* TX4927 DMA Controller (64-bit registers) */
asm/ack:tx4927/tx4927.h:/* TX4927 PCI Controller (32-bit registers) */
asm/ack:tx4927/tx4927.h:/* TX4927 Configuration registers (64-bit registers) */
asm/ack:tx4927/tx4927.h:/* TX4927 Timer 0 (32-bit registers) */
asm/ack:tx4927/tx4927.h:/* TX4927 Timer 1 (32-bit registers) */
asm/ack:tx4927/tx4927.h:/* TX4927 Timer 2 (32-bit registers) */
asm/ack:tx4927/tx4927.h:/* TX4927 serial port 0 (32-bit registers) */
asm/ack:tx4927/tx4927.h:/* TX4927 serial port 1 (32-bit registers) */
asm/ack:tx4927/tx4927.h:/* TX4927 parallel port (32-bit registers) */
asm/ack:tx4927/tx4927.h:/* TX4927 Interrupt Controller (32-bit registers) */
asm/ack:tx4927/tx4927.h:/* TX4927 AC-link controller (32-bit registers) */
asm/ack:tx4927/tx4927.h:#define TX4927_IRQ_CP0_RAW_BEG   0    /* tx4927 cpu built-in cp0 */
asm/ack:tx4927/tx4927.h:#define TX4927_IRQ_PIC_RAW_BEG   0    /* tx4927 cpu build-in pic */
asm/ack:tx4927/tx4927_pci.h: * Copyright (C) 2000-2001 Toshiba Corporation
asm/ack:tx4927/tx4927_pci.h:#define TX4927_NR_IRQ_IRC       32      /* On-Chip IRC */
asm/ack:tx4927/tx4927_pci.h:#define TX4927_PCIC_IDSEL_AD_TO_SLOT(ad)        ((ad) - 11)
asm/ack:tx4927/toshiba_rbtx4927.h: * Copyright 2001-2002 MontaVista Software Inc.
asm/ack:tx4927/toshiba_rbtx4927.h:#define RBTX4927_RTL_8019_BASE (0x1c020280-TBTX4927_ISA_IO_OFFSET)
asm/ack:tx4927/tx4927_mips.h: * Copyright 2001-2002 MontaVista Software Inc.
asm/ack:uaccess.h:#define __UA_LIMIT	(- TASK_SIZE)
asm/ack:uaccess.h: * userspace address.  Note that we limit 32-bit userspace to 0x7fff8000 but
asm/ack:uaccess.h: * we use 0x80000000 here on 32-bit kernels.  If a process passes an invalid
asm/ack:uaccess.h: * address in this range it's the process's problem, not ours :-)
asm/ack:uaccess.h:#define get_fs()	(current->thread.current_ds)
asm/ack:uaccess.h:#define set_fs(x)	(current->thread.current_ds = (x))
asm/ack:uaccess.h: *  - "addr" doesn't have any high-bits set
asm/ack:uaccess.h: *  - AND "size" doesn't have any high-bits set
asm/ack:uaccess.h: *  - AND "addr+size" doesn't have any high-bits set
asm/ack:uaccess.h: *  - OR we are in kernel mode.
asm/ack:uaccess.h: * access_ok: - Checks if a user space pointer is valid
asm/ack:uaccess.h: *        %VERIFY_WRITE is a superset of %VERIFY_READ - if it is safe
asm/ack:uaccess.h: * checks that the pointer is in the user space range - after calling
asm/ack:uaccess.h: * this function, memory access functions may still return -EFAULT.
asm/ack:uaccess.h: * verify_area: - Obsolete, use access_ok()
asm/ack:uaccess.h: * Returns zero if the memory block may be valid, -EFAULT
asm/ack:uaccess.h:	return access_ok(type, addr, size) ? 0 : -EFAULT;
asm/ack:uaccess.h: * put_user: - Write a simple value into user space.
asm/ack:uaccess.h: * @ptr must have pointer-to-simple-variable type, and @x must be assignable
asm/ack:uaccess.h: * Returns zero on success, or -EFAULT on error.
asm/ack:uaccess.h: * get_user: - Get a simple variable from user space.
asm/ack:uaccess.h: * @ptr must have pointer-to-simple-variable type, and the result of
asm/ack:uaccess.h: * Returns zero on success, or -EFAULT on error.
asm/ack:uaccess.h: * __put_user: - Write a simple value into user space, with less checking.
asm/ack:uaccess.h: * @ptr must have pointer-to-simple-variable type, and @x must be assignable
asm/ack:uaccess.h: * Returns zero on success, or -EFAULT on error.
asm/ack:uaccess.h: * __get_user: - Get a simple variable from user space, with less checking.
asm/ack:uaccess.h: * @ptr must have pointer-to-simple-variable type, and the result of
asm/ack:uaccess.h: * Returns zero on success, or -EFAULT on error.
asm/ack:uaccess.h:	: "0" (__gu_err), "o" (__m(__gu_addr)), "i" (-EFAULT));		\
asm/ack:uaccess.h:	  "o" (__m(__gu_addr + 4)), "i" (-EFAULT));			\
asm/ack:uaccess.h:	  "i" (-EFAULT));						\
asm/ack:uaccess.h:	  "o" (__m(__pu_addr + 4)), "i" (-EFAULT));			\
asm/ack:uaccess.h: * __copy_to_user: - Copy a block of data into user space, with less checking.
asm/ack:uaccess.h: * copy_to_user: - Copy a block of data into user space.
asm/ack:uaccess.h: * __copy_from_user: - Copy a block of data from user space, with less checking. * @to:   Destination address, in kernel space.
asm/ack:uaccess.h: * copy_from_user: - Copy a block of data from user space.
asm/ack:uaccess.h: * __clear_user: - Zero a block of memory in user space, with less checking.
asm/ack:uaccess.h: * __strncpy_from_user: - Copy a NUL terminated string from userspace, with less checking.
asm/ack:uaccess.h: * Copies a NUL-terminated string from userspace to kernel space.
asm/ack:uaccess.h: * If access to userspace fails, returns -EFAULT (some data may have been
asm/ack:uaccess.h: * strncpy_from_user: - Copy a NUL terminated string from userspace.
asm/ack:uaccess.h: * Copies a NUL-terminated string from userspace to kernel space.
asm/ack:uaccess.h: * If access to userspace fails, returns -EFAULT (some data may have been
asm/ack:uaccess.h: * strlen_user: - Get the size of a string in user space.
asm/ack:uaccess.h: * Get the size of a NUL-terminated string in user space.
asm/ack:uaccess.h: * strlen_user: - Get the size of a string in user space.
asm/ack:uaccess.h: * Get the size of a NUL-terminated string in user space.
asm/ack:unaligned.h: * get_unaligned - get value from possibly mis-aligned location
asm/ack:unaligned.h: * e.g. retrieving a u16 value from a location not u16-aligned.
asm/ack:unaligned.h: * put_unaligned - put value to a possibly mis-aligned location
asm/ack:unaligned.h: * e.g. writing a u16 value to a location not u16-aligned.
asm/ack:unaligned.h:	return ptr->x;
asm/ack:unaligned.h:	return ptr->x;
asm/ack:unaligned.h:	return ptr->x;
asm/ack:unaligned.h:	ptr->x = r5;
asm/ack:unaligned.h:	ptr->x = r5;
asm/ack:unaligned.h:	ptr->x = r5;
asm/ack:unistd.h: * Linux 64-bit syscalls are in the range from 5000 to 5999.
asm/ack:unistd.h: * Offset of the last Linux 64-bit flavoured syscall
asm/ack:unistd.h:/* XXX - _foo needs to be __foo, while __NR_bar could be _NR_bar. */
asm/ack:unistd.h:	return (type)-1; \
asm/ack:unistd.h:	return (type)-1; \
asm/ack:unistd.h:	return (type)-1; \
asm/ack:unistd.h:	return (type)-1; \
asm/ack:unistd.h:	return (type)-1; \
asm/ack:unistd.h: * Using those means your brain needs more than an oil change ;-)
asm/ack:unistd.h:	return (type)-1; \
asm/ack:unistd.h:	return (type)-1; \
asm/ack:unistd.h:	return (type)-1; \
asm/ack:unistd.h:	return (type)-1; \
asm/ack:unistd.h: * we need this inline - forking from kernel space will result
asm/ack:unistd.h: * calls - which means inline code for fork too, as otherwise we
asm/ack:unistd.h:	return waitpid(-1, wait_stat, 0);
asm/ack:user.h: * linux we use the `trad-core' bfd, NOT the irix-core).  The file
asm/ack:user.h: *  data: The data segment follows next.  We use current->end_text to
asm/ack:user.h: *	current->brk to pick up all of the user variables, plus any memory
asm/ack:user.h: *	page is demand-zero or if a page is totally unused, we just cover
asm/ack:user.h: *	current->start_stack, so we round each of these in order to be able
asm/ack:usioctl.h: * usema/usemaclone-related stuff.
asm/ack:vr4181/irq.h:   IP0 - Software interrupt
asm/ack:vr4181/irq.h:   IP1 - Software interrupt
asm/ack:vr4181/irq.h:   IP2 - All but battery, high speed modem, and real time clock
asm/ack:vr4181/irq.h:   IP3 - RTC Long1 (system timer)
asm/ack:vr4181/irq.h:   IP4 - RTC Long2
asm/ack:vr4181/irq.h:   IP5 - High Speed Modem (unused on VR4181)
asm/ack:vr4181/irq.h:   IP6 - Unused
asm/ack:vr4181/irq.h:   IP7 - Timer interrupt from CPO_COMPARE
asm/ack:vr4181/irq.h:   IP2 - same as VR4181_IRQ_INT1
asm/ack:vr4181/irq.h:   IP8 - This is a cascade to GPIO IRQ's. Do not use.
asm/ack:vr4181/irq.h:   IP16 - same as VR4181_IRQ_INT2
asm/ack:vr4181/irq.h:   IP18 - CompactFlash
asm/ack:vr4181/vr4181.h:#define VR4181_MISCREG0		__preg16(KSEG1 + 0x0B000330)	/* Misc. R/W Battery Backed Registers for Non-Volatile Storage (R/W) */
asm/ack:vr4181/vr4181.h:#define VR4181_MISCREG1		__preg16(KSEG1 + 0x0B000332)	/* Misc. R/W Battery Backed Registers for Non-Volatile Storage (R/W) */
asm/ack:vr4181/vr4181.h:#define VR4181_MISCREG2		__preg16(KSEG1 + 0x0B000334)	/* Misc. R/W Battery Backed Registers for Non-Volatile Storage (R/W) */
asm/ack:vr4181/vr4181.h:#define VR4181_MISCREG3		__preg16(KSEG1 + 0x0B000336)	/* Misc. R/W Battery Backed Registers for Non-Volatile Storage (R/W) */
asm/ack:vr4181/vr4181.h:#define VR4181_MISCREG4		__preg16(KSEG1 + 0x0B000338)	/* Misc. R/W Battery Backed Registers for Non-Volatile Storage (R/W) */
asm/ack:vr4181/vr4181.h:#define VR4181_MISCREG5		__preg16(KSEG1 + 0x0B00033A)	/* Misc. R/W Battery Backed Registers for Non-Volatile Storage (R/W) */
asm/ack:vr4181/vr4181.h:#define VR4181_MISCREG6		__preg16(KSEG1 + 0x0B00033C)	/* Misc. R/W Battery Backed Registers for Non-Volatile Storage (R/W) */
asm/ack:vr4181/vr4181.h:#define VR4181_MISCREG7		__preg16(KSEG1 + 0x0B00033D)	/* Misc. R/W Battery Backed Registers for Non-Volatile Storage (R/W) */
asm/ack:vr4181/vr4181.h:#define VR4181_MISCREG8		__preg16(KSEG1 + 0x0B000340)	/* Misc. R/W Battery Backed Registers for Non-Volatile Storage (R/W) */
asm/ack:vr4181/vr4181.h:#define VR4181_MISCREG9		__preg16(KSEG1 + 0x0B000342)	/* Misc. R/W Battery Backed Registers for Non-Volatile Storage (R/W) */
asm/ack:vr4181/vr4181.h:#define VR4181_MISCREG10	__preg16(KSEG1 + 0x0B000344)	/* Misc. R/W Battery Backed Registers for Non-Volatile Storage (R/W) */
asm/ack:vr4181/vr4181.h:#define VR4181_MISCREG11	__preg16(KSEG1 + 0x0B000346)	/* Misc. R/W Battery Backed Registers for Non-Volatile Storage (R/W) */
asm/ack:vr4181/vr4181.h:#define VR4181_MISCREG12	__preg16(KSEG1 + 0x0B000348)	/* Misc. R/W Battery Backed Registers for Non-Volatile Storage (R/W) */
asm/ack:vr4181/vr4181.h:#define VR4181_MISCREG13	__preg16(KSEG1 + 0x0B00034A)	/* Misc. R/W Battery Backed Registers for Non-Volatile Storage (R/W) */
asm/ack:vr4181/vr4181.h:#define VR4181_MISCREG14	__preg16(KSEG1 + 0x0B00034C)	/* Misc. R/W Battery Backed Registers for Non-Volatile Storage (R/W) */
asm/ack:vr4181/vr4181.h:#define VR4181_MISCREG15	__preg16(KSEG1 + 0x0B00034E)	/* Misc. R/W Battery Backed Registers for Non-Volatile Storage (R/W) */
asm/ack:vr4181/vr4181.h:#define VR4181_SIUCSEL_2	__preg8(KSEG1 + 0x0C00000A)	/* IrDA Echo-back Control (R/W) */
asm/ack:vr41xx/e55.h: *	include/asm-mips/vr41xx/e55.h
asm/ack:vr41xx/e55.h: *	Include file for CASIO CASSIOPEIA E-10/15/55/65.
asm/ack:vr41xx/eagle.h: *	include/asm-mips/vr41xx/eagle.h
asm/ack:vr41xx/eagle.h: * Copyright 2001-2003 MontaVista Software Inc.
asm/ack:vr41xx/eagle.h: * General-Purpose I/O Pin Number
asm/ack:vr41xx/capcella.h: *	include/asm-mips/vr41xx/capcella.h
asm/ack:vr41xx/capcella.h: * General-Purpose I/O Pin Number
asm/ack:vr41xx/workpad.h: *	include/asm-mips/vr41xx/workpad.h
asm/ack:vr41xx/mpc30x.h: *	include/asm-mips/vr41xx/mpc30x.h
asm/ack:vr41xx/mpc30x.h: *	Include file for Victor MP-C303/304.
asm/ack:vr41xx/mpc30x.h: * General-Purpose I/O Pin Number
asm/ack:vr41xx/vr41xx.h: * include/asm-mips/vr41xx/vr41xx.h
asm/ack:vr41xx/vr41xx.h:/* VR4122 0x00000c70-0x00000c72 */
asm/ack:vr41xx/vr41xx.h:/* VR4181A 0x00000c73-0x00000c7f */
asm/ack:vr41xx/vr41xx.h:/* VR4131 0x00000c80-0x00000c83 */
asm/ack:vr41xx/vr41xx.h:/* VR4133 0x00000c84- */
asm/ack:vr41xx/vr41xx.h:#define GIU_IRQ(x)		(GIU_IRQ_BASE + (x))	/* IRQ 40-71 */
asm/ack:vr41xx/vr41xx.h:#define GIU_IRQ_TO_PIN(x)	((x) - GIU_IRQ_BASE)	/* Pin 0-31 */
asm/ack:vr41xx/vr41xx.h: * General-Purpose I/O Unit
asm/ack:vr41xx/vrc4171.h: *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
asm/ack:vr41xx/vrc4173.h: *	include/asm-mips/vr41xx/vrc4173.h
asm/ack:vr41xx/vrc4173.h: * Copyright 2001-2003 Montavista Software Inc.
asm/ack:vr41xx/vrc4173.h: * General-Purpose I/O Unit
asm/ack:vr41xx/tb0226.h: *	include/asm-mips/vr41xx/tb0226.h
asm/ack:vr41xx/tb0226.h: * General-Purpose I/O Pin Number
asm/ack:vr41xx/tb0229.h: *	include/asm-mips/vr41xx/tb0229.h
asm/ack:vr41xx/tb0229.h: * General-Purpose I/O Pin Number
asm/ack:war.h: * interrupts during indexed I-cache flushes seems to be sufficient to deal
asm/ack:war.h: * pre-conditions for this problem.
asm/ack:xor.h:#include <asm-generic/xor.h>
asm/ack:xxs1500.h: *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm/arc/types.h:/* The pointer types.  Note that we're using a 64-bit compiler but all
asm/arc/types.h:   pointer in the ARC structures are only 32-bit, so we need some disgusting
asm/arc/types.h:/* The pointer types.  We're 64-bit and the firmware is also 64-bit, so
asm/dec/tc.h: * of the first card not in use or -ENODEV
asm/dec/kn230.h: *	include/asm-mips/dec/kn230.h
asm/dec/ecc.h: *	include/asm-mips/dec/ecc.h
asm/dec/ecc.h: * The register is r/wc -- any write clears it.
asm/dec/ecc.h: * from the last memory read.  The register is r/wc -- any write clears it.
asm/dec/kn02ba.h: *	include/asm-mips/dec/kn02ba.h
asm/dec/kn02ba.h: *	DECstation 5000/1xx (3min or KN02-BA) definitions.
asm/dec/kn02ba.h: * I/O ASIC interrupt bits.  Star marks denote non-IRQ status bits.
asm/dec/kn02ca.h: *	include/asm-mips/dec/kn02ca.h
asm/dec/kn02ca.h: *	Personal DECstation 5000/xx (Maxine or KN02-CA) definitions.
asm/dec/kn02ca.h: * I/O ASIC interrupt bits.  Star marks denote non-IRQ status bits.
asm/dec/kn02ca.h:#define KN02CA_IO_INR_POWERON	13	/* (*) ACCESS.Bus/power-on reset */
asm/dec/kn02xa.h: * The rest is defined in system-specific headers.
asm/dec/kn02xa.h: * The rest is defined in system-specific headers.
asm/dec/interrupts.h: * with the machine-specific interrupt routines.
asm/dec/interrupts.h:#define DEC_IRQ_TC5		DEC_IRQ_ASC	/* virtual PMAZ-AA */
asm/dec/interrupts.h:#define DEC_IRQ_TC6		DEC_IRQ_LANCE	/* virtual PMAD-AA */
asm/dec/ioasic_addrs.h:#define IO_REG_SCSI_SCR		0x1b0	/* SCSI Partial-Word DMA Control */
asm/dec/ioasic_addrs.h:#define IO_REG_FCTR		0x1e0	/* Free-Running Counter */
asm/dec/ioasic_addrs.h: * The lower 16 bits are system-specific.  Bits 15,11:8 are common and
asm/dec/ioasic_addrs.h: * defined here.  The rest is defined in system-specific headers.
asm/dec/kn01.h:#define KN01_CSR_STATUS		(1<<14)	/* self-test result status output */
asm/dec/kn03.h: * I/O ASIC interrupt bits.  Star marks denote non-IRQ status bits.
asm/dec/kn05.h: *	include/asm-mips/dec/kn05.h
asm/dec/kn05.h: * The register appears read-only.
asm/dec/rtc-dec.h: *	include/asm-mips/dec/rtc-dec.h
asm/dec/tcmodule.h: * EK-TCAAD-FS-004
asm/dec/serial.h: *	include/asm-mips/dec/serial.h
asm/dec/ioasic.h: *	include/asm-mips/dec/ioasic.h
asm/dec/tcinfo.h: * EK-TCAAD-FS-004
asm/dec/ioasic_ints.h: * The lower 16 bits are system-specific and thus defined in
asm/dec/ioasic_ints.h: * system-specific headers.
asm/sgi/mc.h:#define SGIMC_CCTRL0_LENDIAN	0x00020000 /* Put MC in little-endian mode */
asm/sgi/mc.h:#define SGIMC_EEPROM_SDATAO	0x00000008 /* Serial EEPROM data-out */
asm/sgi/mc.h:#define SGIMC_EEPROM_SDATAI	0x00000010 /* Serial EEPROM data-in */
asm/sgi/mc.h:#define SGIMC_GIOPAR_HPC64	0x00000001 /* HPC talks to GIO using 64-bits */
asm/sgi/mc.h:#define SGIMC_GIOPAR_GFX64	0x00000002 /* GFX talks to GIO using 64-bits */
asm/sgi/mc.h:#define SGIMC_GIOPAR_EXP064	0x00000004 /* EXP(slot0) talks using 64-bits */
asm/sgi/mc.h:#define SGIMC_GIOPAR_EXP164	0x00000008 /* EXP(slot1) talks using 64-bits */
asm/sgi/mc.h:#define SGIMC_GIOPAR_EISA64	0x00000010 /* EISA bus talks 64-bits to GIO */
asm/sgi/mc.h:#define SGIMC_GIOPAR_HPC264	0x00000020 /* 2nd HPX talks 64-bits to GIO */
asm/sgi/mc.h:	volatile u32 syssembit;		/* Uni-bit system semaphore */
asm/sgi/mc.h:	u32 _unused36[0x1000/4-2*4];
asm/sgi/gio.h: * -----   --------- ----------------------- -----
asm/sgi/gio.h: *   0     GFX       0x1f000000 - 0x1f3fffff   4MB
asm/sgi/gio.h: *   1     EXP0      0x1f400000 - 0x1f5fffff   2MB
asm/sgi/gio.h: *   2     EXP1      0x1f600000 - 0x1f9fffff   4MB
asm/sgi/gio.h: * There are un-slotted devices, HPC, I/O and misc devices, which are grouped
asm/sgi/gio.h: *   -     MISC      0x1fb00000 - 0x1fbfffff   1MB
asm/sgi/gio.h: *   -     RESERVED  0x18000000 - 0x1effffff 112MB
asm/sgi/gio.h: * 32-bit IDs are divided into
asm/sgi/gio.h: *	bit 16		0=GIO32 and GIO32-bis, 1=GIO64.
asm/sgi/gio.h: * 8-bit IDs
asm/sgi/gio.h: *	0x0e		E-Plex 8-port Ethernet
asm/sgi/gio.h: * [*] Device provide 32-bit ID.
asm/sgi/ioc.h: * All registers are 8-bit wide alligned on 32-bit boundary. Bad things
asm/sgi/ioc.h:#define SGINT_TCWORD_MOS	0x02	/* One-shot IRQ mode. */
asm/sgi/pi1.h:#define PI1_STAT_DEVID		0x03	/* bits 0-1 */
asm/sgi/pi1.h:#define PI1_DMACTRL_STDMODE	0x00    /* bits 2-3 */
asm/sgi/pi1.h:#define PI1_DMACTRL_SGIMODE	0x04    /* bits 2-3 */
asm/sgi/pi1.h:#define PI1_DMACTRL_RICOHMODE	0x08    /* bits 2-3 */
asm/sgi/pi1.h:#define PI1_DMACTRL_HPMODE	0x0c    /* bits 2-3 */
asm/sgi/hpc3.h:	u32 _unused0[0x1000/4 - 2];	/* padding */
asm/sgi/hpc3.h:#define HPC3_PDMACTRL_HW	0x0000ff00 /* DMA High-water mark */
asm/sgi/hpc3.h:	u32 _unused1[0x1000/4 - 1];	/* padding */
asm/sgi/hpc3.h:	u32 _unused0[0x1000/4 - 2];	/* padding */
asm/sgi/hpc3.h:#define HPC3_SDCFG_HW   0x01000 /* Enable 16-bit halfword DMA accesses to scsi */
asm/sgi/hpc3.h:#define HPC3_SPCFG_HW   0x1000 /* Enable 16-bit halfword PIO accesses to scsi */
asm/sgi/hpc3.h:	u32 _unused1[0x1000/4 - 6];	/* padding */
asm/sgi/hpc3.h:	u32 _unused0[0x1000/4 - 2];	/* padding */
asm/sgi/hpc3.h:	u32 _unused2[0x1000/4 - 8];	/* padding */
asm/sgi/hpc3.h:	u32 _unused3[0x1000/4 - 2];	/* padding */
asm/sgi/hpc3.h:	u32 _unused4[0x1000/4 - 4];	/* padding */
asm/sgi/hpc3.h:	 * you it was a peculiar bug. ;-)
asm/sgi/hpc3.h:#define HPC3_ISTAT_PBIMASK	0x0ff	/* irq bits for pbus devs 0 --> 7 */
asm/sgi/hpc3.h:	u32 _unused1[0x14000/4 - 5];	/* padding */
asm/sgi/hpc3.h:	/* Now direct PIO per-HPC3 peripheral access to external regs. */
asm/sgi/hpc3.h:	/* Per-peripheral device external registers and DMA/PIO control. */
asm/sgi/hpc3.h:	/* Enable 16-bit DMA access mode */
asm/sgi/hpc3.h:	/* Enable 16-bit PIO accesses */
asm/sgi/hpc3.h:	u32 _unused5[0x0800/4 - 1];
asm/sgi/hpc3.h:	u32 _unused6[0x0800/4 - 1];
asm/sgi/hpc3.h:	u32 _unused7[0x1000/4 - 1];
asm/sgi/hpc3.h:	volatile u32 bbram[8192-50-14];	/* Battery backed ram */
asm/sgi/ip22.h: * HAL2 driver). This will prevent many complications, trust me ;-)
asm/sgi/ip22.h:#define SGI_GIO_0_IRQ	SGI_FIFO_IRQ		/* GIO-0 */
asm/sgi/ip22.h:#define SGI_GIO_1_IRQ	SGINT_LOCAL0 + 6	/* GE / GIO-1 / 2nd-HPC */
asm/sgi/ip22.h:#define SGI_GIO_2_IRQ	SGINT_LOCAL1 + 7	/* Vert retrace / GIO-2 */
asm/sgi/ip22.h:#define ip22_is_fullhouse()	(sgioc->sysid & SGIOC_SYSID_FULLHOUSE)
asm/io.h: * Copyright (C) 1994 - 2000 Ralf Baechle
asm/io.h:#include <asm/pgtable-bits.h>
asm/io.h:#define bus_to_baddr(bus, addr)	(bus_to_baddr[(bus)->number] + (addr))
asm/io.h:#define baddr_to_bus(bus, addr)	((addr) - bus_to_baddr[(bus)->number])
asm/io.h: * IP22 seems braindead enough to swap 16-bits values in hardware, but not
asm/io.h: * 32-bits.  Go figure... Can't tell without documentation.
asm/io.h: * We only do the swapping to keep the kernel config bits of bi-endian
asm/io.h:#define page_to_phys(page)	((u64)(page - mem_map) << PAGE_SHIFT)
asm/io.h:#define page_to_phys(page)	((page - mem_map) << PAGE_SHIFT)
asm/io.h: *     ioremap         -       map bus memory into CPU space
asm/io.h: *     ioremap_nocache         -       map bus memory into CPU space
asm/io.h: * 24-31 on SNI.
asm/io.h: * to PAGE_OFFSET is pure coincidence - it does not mean ISA values
asm/io.h: * used as the IO-area pointer (it can be iounmapped as well, so the
asm/io.h:#define eth_io_copy_and_sum(skb,src,len,unused) memcpy_fromio((skb)->data,(src),(len))
asm/io.h: *     check_signature         -       find BIOS signatures
asm/io.h:		length--;
asm/io.h: *     isa_check_signature             -       find BIOS signatures
asm/io.h:		length--;
asm/io.h: *     virt_to_phys    -       map virtual addresses to physical
asm/io.h:	return (unsigned long)address - PAGE_OFFSET;
asm/io.h: *     phys_to_virt    -       map physical address to virtual
asm/io.h:	return (unsigned long)address - PAGE_OFFSET;
asm/io.h:	while (count--) {
asm/io.h:	while (count--) {
asm/io.h:	while (count--) {
asm/io.h:	while (count--) {
asm/io.h:	while (count--) {
asm/io.h:	while (count--) {
asm/io.h: * The caches on some architectures aren't dma-coherent and have need to
asm/io.h: *  - dma_cache_wback_inv(start, size) makes caches and coherent by
asm/io.h: *  - dma_cache_wback(start, size) makes caches and coherent by
asm/io.h: *  - dma_cache_inv(start, size) invalidates the affected parts of the
asm/ddb5xxx/ddb5074.h: *  include/asm-mips/ddb5074.h -- NEC DDB Vrc-5074 definitions
asm/ddb5xxx/ddb5476.h:#define	DDB_DCS5_SIZE		0x00200000	/* 2MB, 8-bit */
asm/ddb5xxx/ddb5476.h:#define	DDB_DCS4_SIZE		0x00200000	/* 2MB, 8-bit */
asm/ddb5xxx/ddb5476.h:#define DDB_BOOTCS_SIZE         0x00200000      /* 2 MB - doc says 4MB */
asm/ddb5xxx/ddb5476.h: *   . CPU itself - 8 sources
asm/ddb5xxx/ddb5476.h: *   . i8259 - 16 sources
asm/ddb5xxx/ddb5476.h: *   . vrc5476 - 16 sources
asm/ddb5xxx/ddb5476.h: *  All VRC5476 PCI interrupts are level-triggered (no ack needed).
asm/ddb5xxx/ddb5476.h: * vrc5476 irq defs, see page 52-64 of Vrc5074 system controller manual
asm/ddb5xxx/ddb5476.h:#define irq_to_nile4(n)         ((n)-NUM_I8259_IRQ)
asm/ddb5xxx/ddb5476.h: * low-level irq functions
asm/ddb5xxx/ddb5477.h: * include/asm-mips/ddb5xxx/ddb5477.h
asm/ddb5xxx/ddb5477.h:#undef  DDB_CPUSTAT		/* duplicate in Vrc-5477 */
asm/ddb5xxx/ddb5477.h:#define	DDB_PCICTL0_L	0x02e0	/* PCI0 Control-L */
asm/ddb5xxx/ddb5477.h:#define	DDB_PCICTL0_H	0x02e4	/* PCI0 Control-H */
asm/ddb5xxx/ddb5477.h:#define	DDB_PCIARB0_L	0x02e8	/* PCI0 Arbitration-L */
asm/ddb5xxx/ddb5477.h:#define	DDB_PCIARB0_H	0x02ec	/* PCI0 Arbitration-H */
asm/ddb5xxx/ddb5477.h:#define	DDB_PCICTL1_L	0x06e0	/* PCI1 Control-L */
asm/ddb5xxx/ddb5477.h:#define	DDB_PCICTL1_H	0x06e4	/* PCI1 Control-H */
asm/ddb5xxx/ddb5477.h:#define	DDB_PCIARB1_L	0x06e8	/* PCI1 Arbitration-L */
asm/ddb5xxx/ddb5477.h:#define	DDB_PCIARB1_H	0x06ec	/* PCI1 Arbitration-H */
asm/ddb5xxx/ddb5477.h:#define DDB_GIUFUNSEL	0x4040  /* select dual-func pins */
asm/ddb5xxx/ddb5477.h:/* the actual ram size is detected at run-time */
asm/ddb5xxx/ddb5477.h:#define	DDB_BOOTCS_SIZE		0x00200000	/* 2 MB - doc says 4MB */
asm/ddb5xxx/ddb5477.h:/* low-level routine for enabling vrc5477 irq, bypassing high-level */
asm/ddb5xxx/ddb5477.h: *   . CPU itself - 8 sources
asm/ddb5xxx/ddb5477.h: *   . i8259 - 16 sources
asm/ddb5xxx/ddb5477.h: *   . vrc5477 - 32 sources
asm/ddb5xxx/ddb5477.h: *  All VRC5477 PCI interrupts are level-triggered (no ack needed).
asm/ddb5xxx/ddb5477.h:#define VRC5477_IRQ_IOPCI_INTA	(16 + VRC5477_IRQ_BASE)      /* USB-H */
asm/ddb5xxx/ddb5477.h:#define VRC5477_IRQ_IOPCI_INTB	(17 + VRC5477_IRQ_BASE)      /* USB-P */
asm/ddb5xxx/ddb5477.h:#define	VRC5477_I8259_CASCADE	(VRC5477_IRQ_INTC - VRC5477_IRQ_BASE)
asm/ddb5xxx/ddb5xxx.h: * include/asm-mips/ddb5xxx/ddb5xxx.h
asm/ddb5xxx/ddb5xxx.h: *	uPD31577(VRC5477) VR5432-SDRAM/PCI Bridge (Luke)
asm/ddb5xxx/ddb5xxx.h:#define DDB_DCS2	0x0010	/* Device Chip-Select 2 [R/W] */
asm/ddb5xxx/ddb5xxx.h:#define DDB_DCS3	0x0018	/* Device Chip-Select 3 [R/W] */
asm/ddb5xxx/ddb5xxx.h:#define DDB_DCS4	0x0020	/* Device Chip-Select 4 [R/W] */
asm/ddb5xxx/ddb5xxx.h:#define DDB_DCS5	0x0028	/* Device Chip-Select 5 [R/W] */
asm/ddb5xxx/ddb5xxx.h:#define DDB_DCS6	0x0030	/* Device Chip-Select 6 [R/W] */
asm/ddb5xxx/ddb5xxx.h:#define DDB_DCS7	0x0038	/* Device Chip-Select 7 [R/W] */
asm/ddb5xxx/ddb5xxx.h:#define DDB_DCS8	0x0040	/* Device Chip-Select 8 [R/W] */
asm/ddb5xxx/ddb5xxx.h:#define DDB_BOOTCS	0x0078	/* Boot ROM Chip-Select [R/W] */
asm/ddb5xxx/ddb5xxx.h: *  Memory-Interface Registers
asm/ddb5xxx/ddb5xxx.h: *  PCI-Bus Registers
asm/ddb5xxx/ddb5xxx.h: *  Local-Bus Registers
asm/ddb5xxx/ddb5xxx.h:#define DDB_LCST2	0x0110	/* Local Bus Chip-Select Timing 2 [R/W] */
asm/ddb5xxx/ddb5xxx.h:#define DDB_LCST3	0x0118	/* Local Bus Chip-Select Timing 3 [R/W] */
asm/ddb5xxx/ddb5xxx.h:#define DDB_LCST4	0x0120	/* Local Bus Chip-Select Timing 4 [R/W] */
asm/ddb5xxx/ddb5xxx.h:#define DDB_LCST5	0x0128	/* Local Bus Chip-Select Timing 5 [R/W] */
asm/ddb5xxx/ddb5xxx.h:#define DDB_LCST6	0x0130	/* Local Bus Chip-Select Timing 6 [R/W] */
asm/ddb5xxx/ddb5xxx.h:#define DDB_LCST7	0x0138	/* Local Bus Chip-Select Timing 7 [R/W] */
asm/ddb5xxx/ddb5xxx.h:#define DDB_LCST8	0x0140	/* Local Bus Chip-Select Timing 8 [R/W] */
asm/ddb5xxx/ddb5xxx.h:#define DDB_DCSFN	0x0150	/* Device Chip-Select Muxing and Output */
asm/ddb5xxx/ddb5xxx.h:#define DDB_DCSIO	0x0158	/* Device Chip-Selects As I/O Bits [R/W] */
asm/ddb5xxx/ddb5xxx.h:#define DDB_BCST	0x0178	/* Local Boot Chip-Select Timing [R/W] */
asm/ddb5xxx/ddb5xxx.h:#define DDB_T1CTRL	0x01D0	/* CPU-Bus Read Time-Out Control [R/W] */
asm/ddb5xxx/ddb5xxx.h:#define DDB_T1CNTR	0x01D8	/* CPU-Bus Read Time-Out Counter [R/W] */
asm/ddb5xxx/ddb5xxx.h:#define DDB_T2CTRL	0x01E0	/* General-Purpose Timer Control [R/W] */
asm/ddb5xxx/ddb5xxx.h:#define DDB_T2CNTR	0x01E8	/* General-Purpose Timer Counter [R/W] */
asm/ddb5xxx/ddb5xxx.h:#define DDB_SSVID	0x022C	/* PCI Sub-System Vendor ID [R/W] */
asm/ddb5xxx/ddb5xxx.h:#define DDB_SSID	0x022E	/* PCI Sub-System ID [R/W] */
asm/jmr3927/irq.h: *  linux/include/asm-mips/tx3927/irq.h
asm/jmr3927/irq.h:	sp->next = tb_irq_spaces;
asm/jmr3927/pci.h: * include/asm-mips/jmr3927/pci.h
asm/jmr3927/pci.h: * Based on include/asm-mips/ddb5xxx/pci.h
asm/jmr3927/pci.h: * Each pci channel is a top-level PCI bus seem by CPU.  A machine  with
asm/jmr3927/tx3927.h:#define TX3927_PCIC_IDSEL_AD_TO_SLOT(ad)	((ad) - 11)
asm/jmr3927/ds1742rtc.h: * ds1742rtc.h - register definitions for the Real-Time-Clock / CMOS RAM
asm/jmr3927/ds1742rtc.h: *   Based on include/asm-mips/ds1643rtc.h.
asm/jmr3927/ds1742rtc.h: * Copyright (C) 1999-2001 Toshiba Corporation
asm/jmr3927/jmr3927.h: * Defines for the TJSYS JMR-TX3927/JMI-3927IO2/JMY-1394IF.
asm/jmr3927/jmr3927.h: * Copyright (C) 2000-2001 Toshiba Corporation
asm/jmr3927/jmr3927.h:	romcr3 = tx3927_romcptr->cr[3];
asm/jmr3927/jmr3927.h:	tx3927_romcptr->cr[3] &= 0xffffefff;	/* do not wait infinitely */
asm/jmr3927/jmr3927.h:	tx3927_romcptr->cr[3] = romcr3;
asm/jmr3927/jmr3927.h:#define jmr3927_led_set(n/*0-16*/)	jmr3927_ioc_reg_out(~(n), JMR3927_IOC_LED_ADDR)
asm/jmr3927/jmr3927.h:#define jmr3927_io_led_set(n/*0-3*/)	jmr3927_isac_reg_out((n), JMR3927_ISAC_LED_ADDR)
asm/jmr3927/jmr3927.h:#define jmr3927_led_and_set(n/*0-16*/)	jmr3927_ioc_reg_out((~(n)) & jmr3927_ioc_reg_in(JMR3927_IOC_LED_ADDR), JMR3927_IOC_LED_ADDR)
asm/jmr3927/jmr3927.h:#define jmr3927_dipsw1()	((tx3927_pioptr->din & (1 << 11)) == 0)
asm/jmr3927/jmr3927.h:#define jmr3927_dipsw2()	((tx3927_pioptr->din & (1 << 10)) == 0)
asm/jmr3927/jmr3927.h:/* use Pre-scaler T0 (1/2) */
asm/jmr3927/jmr3927.h:#define JMR3927_NR_IRQ_IRC	16	/* On-Chip IRC */
asm/jmr3927/jmr3927.h:/* RTL8019AS 10M Ether (JMI-3927IO2:JPW2:1-2 Short) */
asm/jmr3927/jmr3927.h:/* TC35815 100M Ether (JMR-TX3912:JPW4:2-3 Short) */
asm/jmr3927/jmr3927.h:#define JMR3927_ETHER1_PORT	(JMR3927_ISAIO_BASE - JMR3927_PORT_BASE + 0x280)
asm/jmr3927/jmr3927.h:#define JMR3927_KBD_PORT	(JMR3927_ISAIO_BASE - JMR3927_PORT_BASE + 0x00800060)
asm/jmr3927/jmr3927.h:#define JMR3927_IDE_PORT	(JMR3927_ISAIO_BASE - JMR3927_PORT_BASE + 0x001001f0)
asm/atomic.h: * atomic_read - read atomic variable
asm/atomic.h:#define atomic_read(v)	((v)->counter)
asm/atomic.h: * atomic_set - set atomic variable
asm/atomic.h:#define atomic_set(v,i)	((v)->counter = (i))
asm/atomic.h: * atomic_add - add integer to atomic variable
asm/atomic.h:	v->counter += i;
asm/atomic.h: * atomic_sub - subtract the atomic variable
asm/atomic.h:	v->counter -= i;
asm/atomic.h:	temp = v->counter;
asm/atomic.h:	v->counter = temp;
asm/atomic.h:	temp = v->counter;
asm/atomic.h:	temp -= i;
asm/atomic.h:	v->counter = temp;
asm/atomic.h: * atomic_add - add integer to atomic variable
asm/atomic.h:		: "=&r" (temp), "=m" (v->counter)
asm/atomic.h:		: "Ir" (i), "m" (v->counter));
asm/atomic.h: * atomic_sub - subtract the atomic variable
asm/atomic.h:		: "=&r" (temp), "=m" (v->counter)
asm/atomic.h:		: "Ir" (i), "m" (v->counter));
asm/atomic.h:		: "=&r" (result), "=&r" (temp), "=m" (v->counter)
asm/atomic.h:		: "Ir" (i), "m" (v->counter)
asm/atomic.h:		: "=&r" (result), "=&r" (temp), "=m" (v->counter)
asm/atomic.h:		: "Ir" (i), "m" (v->counter)
asm/atomic.h: * atomic_sub_and_test - subtract value from variable and test result
asm/atomic.h: * atomic_inc_and_test - increment and test
asm/atomic.h: * atomic_dec_and_test - decrement by 1 and test
asm/atomic.h: * atomic_inc - increment atomic variable
asm/atomic.h: * atomic_dec - decrement and test
asm/atomic.h: * atomic_add_negative - add and test if negative
asm/au1xxx_dbdma.h:/* Specifics for the Au1xxx Descriptor-Based DMA Controllers, first
asm/au1xxx_dbdma.h:	u32	ddma_desptr;	/* 32-byte aligned pointer to descriptor */
asm/au1xxx_dbdma.h:#define DDMA_CFG_DFN	(1 << 3)	/* Descriptor fetch non-coherent */
asm/au1xxx_dbdma.h: * Must be 32-byte aligned.
asm/au1xxx_dbdma.h:#define DSCR_CMD0_MEM		(1 << 30)	/* mem-mem transfer */
asm/au1xxx_dbdma.h:#define DSCR_CMD0_SN		(0x1 << 12)	/* Source non-coherent */
asm/au1xxx_dbdma.h:#define DSCR_CMD0_DN		(0x1 << 11)	/* Destination non-coherent */
asm/au1xxx_dbdma.h:/* Source1, 1-dimensional stride.
asm/au1xxx_dbdma.h:/* Dest1, 1-dimensional stride.
asm/au1xxx_dbdma.h: 	Some compatibilty macros --
asm/debug.h: * Debug macros for run-time debugging.  Turned on/off with 
asm/debug.h: * run-time macros for catching spurious errors.  Eable CONFIG_RUNTIME_DEBUG in
asm/debug.h: * Use them as run-time debugging aid.  NEVER USE THEM AS ERROR HANDLING CODE!!!
asm/delay.h: * Copyright (C) 1995 - 1998, 2001 by Ralf Baechle
asm/mc146818rtc.h:rtc_ops->rtc_read_data(addr); \
asm/mc146818rtc.h:rtc_ops->rtc_write_data(val, addr); \
asm/mc146818rtc.h:rtc_ops->rtc_bcd_mode()
asm/mc146818rtc.h:#include <asm/dec/rtc-dec.h>
asm/ipcbuf.h: * - 32-bit seq
asm/ipcbuf.h: * - 2 miscellaneous 64-bit values
asm/r4kcache.h: * Copyright (C) 1997 - 2002 Ralf Baechle (ralf@gnu.org)
asm/r4kcache.h: * Copyright (C) 2004 Ralf Baechle (ralf@linux-mips.org)
asm/r4kcache.h: * R10000 / R12000 hazard - these processors don't support the Hit_Writeback_D
asm/r4kcache.h: * cacheop so we use Hit_Writeback_Inv_D which is supported by all R4000-style
asm/r4kcache.h: * This one is RM7000-specific
asm/shmbuf.h: * - 2 miscellaneous 32-bit values
asm/sfp-machine.h:#define _FP_NANFRAC_S		((_FP_QNANBIT_S << 1) - 1)
asm/sfp-machine.h:#define _FP_NANFRAC_D		((_FP_QNANBIT_D << 1) - 1), -1
asm/sfp-machine.h:#define _FP_NANFRAC_Q		((_FP_QNANBIT_Q << 1) - 1), -1, -1, -1
asm/bitops.h: * Copyright (c) 1994 - 1997, 1999, 2000  Ralf Baechle (ralf@gnu.org)
asm/bitops.h: * set_bit - Atomically set a bit in memory
asm/bitops.h: * restricted to acting on a single-word quantity.
asm/bitops.h: * __set_bit - Set a bit in memory
asm/bitops.h: * Unlike set_bit(), this function is non-atomic and may be reordered.
asm/bitops.h: * clear_bit - Clears a bit in memory
asm/bitops.h: * change_bit - Toggle a bit in memory
asm/bitops.h: * restricted to acting on a single-word quantity.
asm/bitops.h: * __change_bit - Toggle a bit in memory
asm/bitops.h: * Unlike change_bit(), this function is non-atomic and may be reordered.
asm/bitops.h: * test_and_set_bit - Set a bit and return its old value
asm/bitops.h: * __test_and_set_bit - Set a bit and return its old value
asm/bitops.h: * This operation is non-atomic and can be reordered.
asm/bitops.h: * test_and_clear_bit - Clear a bit and return its old value
asm/bitops.h: * __test_and_clear_bit - Clear a bit and return its old value
asm/bitops.h: * This operation is non-atomic and can be reordered.
asm/bitops.h: * test_and_change_bit - Change a bit and return its new value
asm/bitops.h: * __test_and_change_bit - Change a bit and return its old value
asm/bitops.h: * This operation is non-atomic and can be reordered.
asm/bitops.h: * set_bit - Atomically set a bit in memory
asm/bitops.h: * restricted to acting on a single-word quantity.
asm/bitops.h: * __set_bit - Set a bit in memory
asm/bitops.h: * Unlike set_bit(), this function is non-atomic and may be reordered.
asm/bitops.h: * clear_bit - Clears a bit in memory
asm/bitops.h: * change_bit - Toggle a bit in memory
asm/bitops.h: * restricted to acting on a single-word quantity.
asm/bitops.h: * __change_bit - Toggle a bit in memory
asm/bitops.h: * Unlike change_bit(), this function is non-atomic and may be reordered.
asm/bitops.h: * test_and_set_bit - Set a bit and return its old value
asm/bitops.h: * __test_and_set_bit - Set a bit and return its old value
asm/bitops.h: * This operation is non-atomic and can be reordered.
asm/bitops.h: * test_and_clear_bit - Clear a bit and return its old value
asm/bitops.h: * __test_and_clear_bit - Clear a bit and return its old value
asm/bitops.h: * This operation is non-atomic and can be reordered.
asm/bitops.h: * test_and_change_bit - Change a bit and return its new value
asm/bitops.h: * __test_and_change_bit - Change a bit and return its old value
asm/bitops.h: * This operation is non-atomic and can be reordered.
asm/bitops.h: * test_bit - Determine whether a bit is set
asm/bitops.h: * ffz - find first zero in word.
asm/bitops.h: * ffs - find first bit set
asm/bitops.h: * find_next_zero_bit - find the first zero bit in a memory region
asm/bitops.h:	size -= result;
asm/bitops.h:		tmp |= ~0UL >> (32-offset);
asm/bitops.h:		size -= 32;
asm/bitops.h:		size -= 32;
asm/bitops.h:#if 0 /* Fool kernel-doc since it doesn't do macros yet */
asm/bitops.h: * find_first_zero_bit - find the first zero bit in a memory region
asm/bitops.h: * Returns the bit-number of the first zero bit, not the number of the byte
asm/bitops.h: * hweightN - returns the hamming weight of a N-bit word
asm/bitops.h:	size -= result;
asm/bitops.h:		tmp |= ~0U >> (32-offset); /* bug or feature ? */
asm/bitops.h:		size -= 32;
asm/bitops.h:		size -= 32;
asm/i8259.h: *	include/asm-mips/i8259.h
asm/div64.h:		" addiu	%4, %4, -1\n\t" \
asm/resource.h:#define RLIMIT_MEMLOCK 9		/* max locked-in-memory address space */
asm/ptrace.h:/* 0 - 31 are integer registers, 32 - 63 are fp registers.  */
asm/ptrace.h:        ".size\t" #symbol",. - " #symbol)
asm/ptrace.h:#define user_mode(regs) (((regs)->cp0_status & KU_MASK) == KU_USER)
asm/ptrace.h:#define instruction_pointer(regs) ((regs)->cp0_epc)
asm/pgalloc.h: * Copyright (C) 1994 - 2001 by Ralf Baechle
asm/pgalloc.h: *  - flush_tlb_all() flushes all processes TLB entries
asm/pgalloc.h: *  - flush_tlb_mm(mm) flushes the specified mm context TLB entries
asm/pgalloc.h: *  - flush_tlb_page(mm, vmaddr) flushes a single page
asm/pgalloc.h: *  - flush_tlb_range(mm, start, end) flushes a range of pages
asm/pgalloc.h: *  - flush_tlb_pgtables(mm, start, end) flushes a range of page tables
asm/pgalloc.h: *  - flush_tlb_one(page) flushes a single kernel page
asm/pgalloc.h:			(PTRS_PER_PGD - USER_PTRS_PER_PGD) * sizeof(pgd_t));
asm/pgalloc.h:		pgtable_cache_size--;
asm/pgalloc.h:		pgtable_cache_size--;
asm/pgalloc.h:		pgtable_cache_size--;
asm/pgalloc.h: * allocating and freeing a pmd is trivial: the 1-entry pmd is
asm/unistd.h: * Linux 64-bit syscalls are in the range from 5000 to 5999.
asm/unistd.h: * Offset of the last Linux 64-bit flavoured syscall
asm/unistd.h:/* XXX - _foo needs to be __foo, while __NR_bar could be _NR_bar. */
asm/unistd.h:	return (type)-1; \
asm/unistd.h:	return (type)-1; \
asm/unistd.h:	return (type)-1; \
asm/unistd.h:	return (type)-1; \
asm/unistd.h:	return (type)-1; \
asm/unistd.h: * Using those means your brain needs more than an oil change ;-)
asm/unistd.h:	return (type)-1; \
asm/unistd.h:	return (type)-1; \
asm/unistd.h:	return (type)-1; \
asm/unistd.h:	return (type)-1; \
asm/unistd.h: * we need this inline - forking from kernel space will result
asm/unistd.h: * calls - which means inline code for fork too, as otherwise we
asm/unistd.h:	return waitpid(-1, wait_stat, 0);
asm/baget/vac.h:#define    VAC_CTRL_RECOVERY_IOSELI(x) ((((x)-1)&7)<<8)
asm/baget/vac.h:#define    VAC_CTRL_DELAY_DSACKI(x)    ((((x)-1)&7)<<13)
asm/baget/vic.h:#define    VIC_LOCAL_TIM_PAS_ASSERT(x)   (((x)-2)&0xf)
asm/baget/vic.h:#define    VIC_LOCAT_TIM_DS_DEASSERT(x)  ((((x)-1)&1)<<4)
asm/baget/vic.h:#define    VIC_LOCAL_TIM_PAS_DEASSERT(x) ((((x)-1)&0x7)<<5)
asm/baget/baget.h:#define BAGET_A24M_BASE       0xFC000000      /* VME-master A24 base address  */
asm/baget/baget.h:#define BAGET_A24S_BASE       0x00000000      /* VME-slave A24 base address   */
asm/baget/baget.h:#define BAGET_A24S_MASK       0x00c00000      /* VME-slave A24 address mask   */
asm/baget/baget.h:#define BAGET_IRQ_MASK(x)       ((NR_IRQS-1) & (x))
asm/asm.h: * away by gas in -O mode. These nops are however required to fill delay
asm/asm.h: * LEAF - declare leaf routine
asm/asm.h: * NESTED - declare nested routine entry point
asm/asm.h: * END - mark end of function
asm/asm.h:		.size	function,.-function
asm/asm.h: * EXPORT - export definition of symbol
asm/asm.h: * FEXPORT - export definition of a function symbol
asm/asm.h: * ABS - export absolute symbol
asm/asm.h: * Macros to handle different pointer/register sizes for 32/64-bit code
asm/cpu.h:  +----------------+----------------+----------------+----------------+
asm/cpu.h:  +----------------+----------------+----------------+----------------+
asm/cpu.h:   that bits 16-23 have been 0 for all MIPS processors before the MIPS32/64
asm/cpu.h: * +---------------------------------+----------------+----------------+
asm/cpu.h: * +---------------------------------+----------------+----------------+
asm/cpu.h: * Bit 15 encodes if an ISA level supports 64-bit operations.
asm/cpu.h:#define MIPS_CPU_SUBSET_CACHES	0x00020000 /* P-cache subset enforced */
asm/dma.h: *  controller 1: channels 0-3, byte operations, ports 00-1F
asm/dma.h: *  controller 2: channels 4-7, word operations, ports C0-DF
asm/dma.h: *  - ALL registers are 8 bits only, regardless of transfer size
asm/dma.h: *  - channel 4 is not used - cascades 1 into 2.
asm/dma.h: *  - channels 0-3 are byte - addresses/counts are for physical bytes
asm/dma.h: *  - channels 5-7 are word - addresses/counts are for physical words
asm/dma.h: *  - transfers must not cross physical 64K (0-3) or 128K (5-7) boundaries
asm/dma.h: *  - transfer count loaded to registers is 1 less than actual count
asm/dma.h: *  - controller 2 offsets are all even (2x offsets for controller 1)
asm/dma.h: *  - page registers for 5-7 don't use data bit 0, represent 128K pages
asm/dma.h: *  - page registers for 0-3 use bit 0, represent 64K pages
asm/dma.h: *  Address mapping for channels 0-3:
asm/dma.h: *  Address mapping for channels 5-7:
asm/dma.h: * Again, channels 5-7 transfer _physical_ words (16 bits), so addresses
asm/dma.h: * and counts _must_ be word-aligned (the lowest address bit is _ignored_ at
asm/dma.h: * the hardware level, so odd-byte transfers aren't possible).
asm/dma.h: * count - 1 : 64K => 0xFFFF, 1 => 0x0000.  Thus, count is always 1 or more,
asm/dma.h: * and up to 128K bytes may be transferred on channels 5-7 in one operation.
asm/dma.h:#define DMA1_MASK_REG		0x0A	/* single-channel mask (w) */
asm/dma.h:#define DMA1_CLEAR_FF_REG	0x0C	/* clear pointer flip-flop (w) */
asm/dma.h:#define DMA1_MASK_ALL_REG       0x0F    /* all-channels mask (w) */
asm/dma.h:#define DMA2_MASK_REG		0xD4	/* single-channel mask (w) */
asm/dma.h:#define DMA2_CLEAR_FF_REG	0xD8	/* clear pointer flip-flop (w) */
asm/dma.h:#define DMA2_MASK_ALL_REG       0xDE    /* all-channels mask (w) */
asm/dma.h:#define DMA_MODE_CASCADE 0xC0   /* pass thru DREQ->HRQ, DACK<-HLDA only */
asm/dma.h: * After that, keep track of it. :-)
asm/dma.h: * --- In order to do that, the DMA routines below should ---
asm/dma.h: * --- only be used while holding the DMA lock ! ---
asm/dma.h: * Assumes dma flip-flop is clear.
asm/dma.h: * NOTE 2: "count" represents _bytes_ and must be even for channels 5-7.
asm/dma.h:        count--;
asm/dma.h: * Assumes DMA flip-flop is clear.
asm/dma.h:	/* using short to get 16-bit wrap around */
asm/elf.h:#define EF_MIPS_ARCH_1      0x00000000  /* -mips1 code.  */
asm/elf.h:#define EF_MIPS_ARCH_2      0x10000000  /* -mips2 code.  */
asm/elf.h:#define EF_MIPS_ARCH_3      0x20000000  /* -mips3 code.  */
asm/elf.h:#define EF_MIPS_ARCH_4      0x30000000  /* -mips4 code.  */
asm/elf.h:#define EF_MIPS_ARCH_5      0x40000000  /* -mips5 code.  */
asm/elf.h:	if (__h->e_machine != EM_MIPS)					\
asm/elf.h:	if (__h->e_ident[EI_CLASS] != ELFCLASS32)			\
asm/elf.h:	if ((__h->e_flags & EF_MIPS_ABI2) != 0)				\
asm/elf.h:	if (((__h->e_flags & EF_MIPS_ABI) != 0) &&			\
asm/elf.h:	    ((__h->e_flags & EF_MIPS_ABI) != EF_MIPS_ABI_O32))		\
asm/elf.h:#define irix_elf_check_arch(hdr)	((hdr)->e_machine == EM_MIPS)
asm/elf.h: * See comments in asm-alpha/elf.h, this is the same thing
asm/elf.h:	_r->regs[1] = _r->regs[2] = _r->regs[3] = _r->regs[4] = 0;	\
asm/elf.h:	_r->regs[5] = _r->regs[6] = _r->regs[7] = _r->regs[8] = 0;	\
asm/elf.h:	_r->regs[9] = _r->regs[10] = _r->regs[11] = _r->regs[12] = 0;	\
asm/elf.h:	_r->regs[13] = _r->regs[14] = _r->regs[15] = _r->regs[16] = 0;	\
asm/elf.h:	_r->regs[17] = _r->regs[18] = _r->regs[19] = _r->regs[20] = 0;	\
asm/elf.h:	_r->regs[21] = _r->regs[22] = _r->regs[23] = _r->regs[24] = 0;	\
asm/elf.h:	_r->regs[25] = _r->regs[26] = _r->regs[27] = _r->regs[28] = 0;	\
asm/elf.h:	_r->regs[30] = _r->regs[31] = 0;				\
asm/cachectl.h: * cachectl.h -- defines for MIPS cache control system calls
asm/fpu.h:#define clear_fpu_owner() do { current->flags &= ~PF_USEDFPU; } while(0)
asm/fpu.h:	return cpu_has_fpu && ((current->flags & PF_USEDFPU) != 0); 
asm/fpu.h:		current->flags |= PF_USEDFPU;
asm/fpu.h:		current->flags &= ~PF_USEDFPU;
asm/fpu.h:		return (unsigned long long *)&tsk->thread.fpu.hard.fp_regs[0];
asm/fpu.h:		return (unsigned long long *)tsk->thread.fpu.soft.regs;
asm/gfx.h: * This is the user-visible SGI GFX interface.
asm/gfx.h: * any kernel-only bits on it.
asm/ide.h: * Copyright (C) 1994-1996  Linus Torvalds & authors
asm/ide.h:	return ide_ops->ide_default_irq(base);
asm/ide.h:	return ide_ops->ide_default_io_base(index);
asm/ide.h:	ide_ops->ide_init_hwif_ports(hw, data_port, ctrl_port, irq);
asm/ide.h:#define ide_ack_intr(hwif)	((hwif)->hw.ack_intr ? (hwif)->hw.ack_intr(hwif) : 1)
asm/ide.h:/* MIPS port and memory-mapped I/O string operations.  */
asm/ide.h:	while (count--) {
asm/ide.h:	while (count--) {
asm/ide.h:	while (count--) {
asm/ide.h:	while (count--) {
asm/lasat/lasat.h: *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm/lasat/lasat.h:/* Configuration descriptor encoding - see the doc for details */
asm/pci.h:   already-configured bus numbers - to be used for buggy BIOSes
asm/pci.h: * NULL for PCI-like buses (ISA, EISA).
asm/pci.h: * Returns non-NULL cpu-view pointer to the buffer if successful and
asm/pci.h: * The 32-bit bus address to use is returned.
asm/pci.h:	return bus_to_baddr(hwdev->bus, __pa(ptr));
asm/pci.h:		addr = baddr_to_bus(hwdev->bus, dma_addr) + PAGE_OFFSET;
asm/pci.h:	return bus_to_baddr(hwdev->bus, page_to_phys(page) + offset);
asm/pci.h:		addr = baddr_to_bus(hwdev->bus, dma_address) + PAGE_OFFSET;
asm/pci.h: * mode for DMA.  This is the scather-gather version of the
asm/pci.h:		if (sg->address && sg->page)
asm/pci.h:		else if (!sg->address && !sg->page)
asm/pci.h:		if (sg->address) {
asm/pci.h:			dma_cache_wback_inv((unsigned long)sg->address,
asm/pci.h:			                    sg->length);
asm/pci.h:			sg->dma_address = bus_to_baddr(hwdev->bus, __pa(sg->address));
asm/pci.h:			sg->dma_address = page_to_bus(sg->page) +
asm/pci.h:			                  sg->offset;
asm/pci.h:				(page_address(sg->page) + sg->offset),
asm/pci.h:				sg->length);
asm/pci.h:		if (sg->address && sg->page)
asm/pci.h:		else if (!sg->address && !sg->page)
asm/pci.h:		if (!sg->address)
asm/pci.h:		dma_cache_wback_inv((unsigned long)sg->address, sg->length);
asm/pci.h:	addr = baddr_to_bus(hwdev->bus, dma_handle) + PAGE_OFFSET;
asm/pci.h: * The same as pci_dma_sync_single but for a scatter-gather list,
asm/pci.h:		dma_cache_wback_inv((unsigned long)sg->address, sg->length);
asm/pci.h: * only drive the low 24-bits during PCI bus mastering, then
asm/pci.h:	return (dma64_addr_t) bus_to_baddr(pdev->bus, addr);
asm/pci.h:	unsigned long poff = baddr_to_bus(pdev->bus, dma_addr) >> PAGE_SHIFT;
asm/pci.h:	addr = baddr_to_bus(pdev->bus, dma_addr) + PAGE_OFFSET;
asm/pci.h:#define sg_dma_address(sg)	((sg)->dma_address)
asm/pci.h:#define sg_dma_len(sg)		((sg)->length)
asm/fpregdef.h: * These definitions only cover the R3000-ish 16/32 register model.
asm/reg.h: * This defines/structures correspond to the register layout on stack -
asm/reg.h: * include/asm-mips/stackframe.h
asm/cacheops.h: * Cache Operations available on all MIPS processors with R4000-style caches
asm/cacheops.h: * R4000-specific cacheops
asm/cacheops.h: * R4000SC and R4400SC-specific cacheops
asm/cacheops.h: * R5000-specific cacheops
asm/cacheops.h: * RM7000-specific cacheops
asm/cacheops.h: * R1000-specific cacheops
asm/cacheops.h: * Cacheops 0x02, 0x06, 0x0a, 0x0c-0x0e, 0x16, 0x1a and 0x1e are unused.
asm/smp.h: * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
asm/smp.h: * Copyright (C) 2000 - 2001 by Kanoj Sarcar (kanoj@sgi.com)
asm/smp.h: * Copyright (C) 2000 - 2001 by Silicon Graphics, Inc.
asm/smp.h:#define smp_processor_id()	(current->processor)
asm/smp.h:   not be idempotent when cpus failed to come on-line.  */
asm/smp.h:#define NO_PROC_ID	(-1)
asm/smp.h:/* These are defined by the board-specific code. */
asm/sni.h: * Interrupt 0-16 are EISA interrupts.  Interrupts from 16 on are assigned
asm/tlb.h:#include <asm-generic/tlb.h>
asm/war.h: * interrupts during indexed I-cache flushes seems to be sufficient to deal
asm/war.h: * pre-conditions for this problem.
asm/xor.h:#include <asm-generic/xor.h>
asm/branch.h:	return regs->cp0_cause & CAUSEF_BD;
asm/branch.h:		return regs->cp0_epc;
asm/branch.h:	return regs->cp0_epc + 4;
asm/branch.h:		regs->cp0_epc += 4;
asm/signal.h:#define SIGFPE		 8	/* Floating-point exception (ANSI).  */
asm/signal.h:#define SIGUSR1		16	/* User-defined signal 1 (POSIX).  */
asm/signal.h:#define SIGUSR2		17	/* User-defined signal 2 (POSIX).  */
asm/signal.h:#define SIGRTMAX	(_NSIG-1)
asm/signal.h: * SA_INTERRUPT is a no-op, but left due to historical reasons. Use the
asm/signal.h:#define SA_INTERRUPT	0x20000000	/* dummy -- ignored */
asm/signal.h:#define SIG_ERR	((__sighandler_t)-1)	/* error return from signal */
asm/signal.h: * non-Linux/MIPS object files or make use of them in the future.
asm/signal.h:#define BRK_BD_TAKEN	3	/* For bd slot emulation - not implemented */
asm/signal.h:#define BRK_BD_NOTTAKEN	4	/* For bd slot emulation - not implemented */
asm/signal.h:#define BRK_NORLD	10	/* No rld found - not used by Linux/MIPS */
asm/tx3912.h: *  include/asm-mips/tx3912.h
asm/tx3912.h: *	---------------                                                      *
asm/tx3912.h: *	-------------------                                                  *
asm/tx3912.h: *	---------------                                                      *
asm/tx3912.h: *	---------------                                                      *
asm/tx3912.h: *	--------------                                                       *
asm/tx3912.h: *	---------------                                                      *
asm/fpu_emulator.h: *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm/ficmmp.h: *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm/ficmmp.h:#define AU1XXX_ATA_MEM_SIZE		(AU1XXX_ATA_END - AU1XXX_ATA_BASE +1)
asm/hardirq.h:#define irq_exit(cpu, irq)	(local_irq_count(cpu)--)
asm/hardirq.h:	--local_irq_count(cpu);
asm/au1000_pcmcia.h: *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm/au1000_pcmcia.h: * These really belong in a board-specific header file...
asm/au1000.h: * Taken from PPC tree.  -- Dan
asm/au1000.h:	return 31 - lz;
asm/au1000.h:	return __ilog2(x & -x);
asm/au1000.h:	return __ilog2(x & -x) + 1;
asm/au1000.h:/* UARTS 0-3 */
asm/au1000.h:#define UART_LSR_THRE	0x20	/* Transmit-hold-register empty */
asm/au1000.h:#define SSI_CONFIG_ALEN_N(N)		((N-1)<<20)
asm/au1000.h:#define SSI_CONFIG_DLEN_N(N)		((N-1)<<16)
asm/au1000.h:  /* FIXME - double check this from asm-ppc/pci-bridge.h */
asm/au1000.h:  ({ long _ctl_ = -1;                                 \
asm/au1000.h:	       _ctl_ = pci_irq_table[idsel - min_idsel][pin-1];               \
asm/shmiq.h:        volatile unsigned int flags; /* place for out-of-band data */
asm/shmiq.h:/* -------------------- iDev stuff -------------------- */
asm/shmiq.h:/* These are only interpreted by SHMIQ-attacheable devices and are internal
asm/mv64340.h:* mv64340.h - MV-64340 Internal registers definition file.
asm/processor.h:#define MIPS_CACHE_IC_F_DC	0x00000008	/* Ic can refill from D-cache */
asm/processor.h:	struct cache_desc icache;	/* Primary I-cache */
asm/processor.h: * Size of io_bitmap in longwords: 32 is ports 0-0x3ff.
asm/processor.h: * the FPU emulator for now.  See asm-mips/fpu_emulator.h.
asm/processor.h:	if (t->reg31 == (unsigned long) ret_from_fork)
asm/processor.h:		return t->reg31;
asm/processor.h:	return ((unsigned long *)t->reg29)[schedule_frame.pc_offset];
asm/processor.h:#define __PT_REG(reg) ((long)&((struct pt_regs *)0)->reg - sizeof(struct pt_regs))
asm/processor.h:#define __KSTK_TOS(tsk) ((unsigned long)(tsk) + KERNEL_STACK_SIZE - 32)
asm/processor.h:#define THREAD_MASK		(THREAD_SIZE - 1UL)
asm/processor.h:#define get_task_struct(tsk)      atomic_inc(&virt_to_page(tsk)->count)
asm/processor.h: * (MIPS, Alpha) or is unuseable with -fomit-frame-pointer (i386).
asm/processor.h: * __builtin_return_address works only for non-leaf functions.  We avoid the
asm/linux_logo.h: * include/asm-mips/linux_logo.h: This is a linux logo
asm/mmu_context.h: * use the processor id via current->processor, where current is stored
asm/mmu_context.h:#define cpu_context(cpu, mm)	((mm)->context[cpu])
asm/mmu_context.h:#define ASID_VERSION_MASK  ((unsigned long)~(ASID_MASK|(ASID_MASK-1)))
asm/mmu_context.h:	TLBMISS_HANDLER_SETUP_PGD(next->pgd);
asm/mmu_context.h:	 * Mark current->active_mm as not "active" anymore.
asm/mmu_context.h:	clear_bit(cpu, &prev->cpu_vm_mask);
asm/mmu_context.h:	set_bit(cpu, &next->cpu_vm_mask);
asm/mmu_context.h: * After we have set current->mm to a new value, this activates
asm/mmu_context.h:	TLBMISS_HANDLER_SETUP_PGD(next->pgd);
asm/mmu_context.h:	clear_bit(cpu, &prev->cpu_vm_mask);
asm/mmu_context.h:	set_bit(cpu, &next->cpu_vm_mask);
asm/mmu_context.h:	if (test_bit(cpu, &mm->cpu_vm_mask))  {
asm/sysmips.h: * sysmips(2) is deprecated - though some existing software uses it.
asm/db1200.h: *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm/db1200.h: *    *example: IDE bis pos is  = 64 - 64
asm/db1200.h:                ETH bit pos is  = 65 - 64
asm/db1200.h:#define BOARD_CARD_INSERTED(SOCKET) bcsr->sig_status & (1<<(8+(2*SOCKET)))
asm/pgtable-32.h: * traditional mips two-level paging structure:
asm/pgtable-32.h:#define PMD_SHIFT       (2 * PAGE_SHIFT - PTE_T_LOG2)
asm/pgtable-32.h:        pte_val(__pte) = ((phys_t)(page - mem_map) << (PAGE_SHIFT + 2)) | \
asm/pgtable-32.h:	pte_val(__pte) = ((phys_t)(page - mem_map) << PAGE_SHIFT) | \
asm/pgtable-64.h:#define mk_pte(page, pgprot) __mk_pte((page) - mem_map, (pgprot))
asm/pgtable-64.h: * value and then use set_pte to update it.  -ben
asm/pgtable-64.h:	ptep->pte_high = pte.pte_high;
asm/pgtable-64.h:	ptep->pte_low = pte.pte_low;
asm/pgtable-64.h:			buddy->pte_low |= _PAGE_GLOBAL;
asm/semaphore.h:	atomic_set(&sem->count, val);
asm/semaphore.h:	atomic_set(&sem->waking, 0);
asm/semaphore.h:	init_waitqueue_head(&sem->wait);
asm/semaphore.h:	sem->__magic = (long)&sem->__magic;
asm/semaphore.h: * sem->count and sem->waking atomic.
asm/semaphore.h:	CHECK_MAGIC(sem->__magic);
asm/semaphore.h:	count = atomic_dec_return(&sem->count);
asm/semaphore.h: * it, return zero.  If we were interrupted, returns -EINTR
asm/semaphore.h:	CHECK_MAGIC(sem->__magic);
asm/semaphore.h:	count = atomic_dec_return(&sem->count);
asm/semaphore.h: * Here, we do this by using lld/scd on the pair of 32-bit words.
asm/semaphore.h: *   Decrement(sem->count)
asm/semaphore.h: *   If(sem->count >=0) {
asm/semaphore.h: *	If(sem->waking <= 0) {		// if no wakeup pending
asm/semaphore.h: *	   Increment(sem->count)	// undo decrement
asm/semaphore.h: *	   Decrement(sem->waking)	// otherwise "steal" wakeup
asm/semaphore.h:	CHECK_MAGIC(sem->__magic);
asm/semaphore.h:	"	dli	%3, 0x0000000100000000	# count -= 1		\n"
asm/semaphore.h:	"	blez	%2, 1f			# if waking < 0 -> 1f	\n"
asm/semaphore.h:	"	daddiu	%1, %1, -1		# waking -= 1		\n"
asm/semaphore.h:	CHECK_MAGIC(sem->__magic);
asm/semaphore.h:	"	dsll32 %1, %1, 0	# zero-extend %1	\n"
asm/semaphore.h: * Non-blockingly attempt to down() a semaphore.
asm/semaphore.h:	CHECK_MAGIC(sem->__magic);
asm/semaphore.h:	count = atomic_read(&sem->count) - 1;
asm/semaphore.h:	atomic_set(&sem->count, count);
asm/semaphore.h:		waking = atomic_read(&sem->waking);
asm/semaphore.h:			atomic_set(&sem->count, count + 1);
asm/semaphore.h:			atomic_set(&sem->waking, waking - 1);
asm/semaphore.h:	CHECK_MAGIC(sem->__magic);
asm/semaphore.h:	count = atomic_read(&sem->count) + 1;
asm/semaphore.h:	waking = atomic_read(&sem->waking);
asm/semaphore.h:	atomic_set(&sem->count, count);
asm/semaphore.h:	atomic_set(&sem->waking, waking);
asm/semaphore.h:	return atomic_read(&sem->count);
asm/fcntl.h:/* open/fcntl - O_SYNC is only implemented on blocks devices and on files
asm/fcntl.h:#define F_GETFL		3	/* get file->f_flags */
asm/fcntl.h:#define F_SETFL		4	/* set file->f_flags */
asm/au1000_dma.h:	au_writel(DMA_BE0, chan->io + DMA_MODE_SET);
asm/au1000_dma.h:	au_writel(DMA_BE1, chan->io + DMA_MODE_SET);
asm/au1000_dma.h:	au_writel(DMA_BE0 | DMA_BE1, chan->io + DMA_MODE_SET);
asm/au1000_dma.h:	au_writel(DMA_GO, chan->io + DMA_MODE_SET);
asm/au1000_dma.h:	au_writel(DMA_GO, chan->io + DMA_MODE_CLEAR);
asm/au1000_dma.h:		if (au_readl(chan->io + DMA_MODE_READ) & DMA_HALT)
asm/au1000_dma.h:	au_writel(~DMA_GO, chan->io + DMA_MODE_CLEAR);
asm/au1000_dma.h:	return (au_readl(chan->io + DMA_MODE_READ) & DMA_HALT) ? 1 : 0;
asm/au1000_dma.h:	au_writel(PHYSADDR(chan->fifo_addr),
asm/au1000_dma.h:		  chan->io + DMA_PERIPHERAL_ADDR);
asm/au1000_dma.h:	mode = chan->mode | (chan->dev_id << DMA_DID_BIT);
asm/au1000_dma.h:	if (chan->irq)
asm/au1000_dma.h:	au_writel(~mode, chan->io + DMA_MODE_CLEAR);
asm/au1000_dma.h:	au_writel(mode, chan->io + DMA_MODE_SET);
asm/au1000_dma.h:	chan->mode &= ~(DMA_BE | DMA_DR | DMA_TS8 | DMA_DW_MASK | DMA_NC);
asm/au1000_dma.h:	chan->mode |= mode;
asm/au1000_dma.h:	return chan->mode;
asm/au1000_dma.h:		return -1;
asm/au1000_dma.h:	return (au_readl(chan->io + DMA_MODE_READ) & DMA_AB) ? 1 : 0;
asm/au1000_dma.h: * set the device FIFO address for a specific DMA channel - only
asm/au1000_dma.h:	if (chan->mode & DMA_DS)	/* second bank of device ids */
asm/au1000_dma.h:	if (chan->dev_id != DMA_ID_GP04 && chan->dev_id != DMA_ID_GP05)
asm/au1000_dma.h:	au_writel(PHYSADDR(a), chan->io + DMA_PERIPHERAL_ADDR);
asm/au1000_dma.h:	au_writel(DMA_D0, chan->io + DMA_MODE_CLEAR);
asm/au1000_dma.h:	au_writel(DMA_D1, chan->io + DMA_MODE_CLEAR);
asm/au1000_dma.h: * This does nothing - not applicable to Au1000 DMA.
asm/au1000_dma.h:	au_writel(a, chan->io + DMA_BUFFER0_START);
asm/au1000_dma.h:	au_writel(a, chan->io + DMA_BUFFER1_START);
asm/au1000_dma.h:	au_writel(count, chan->io + DMA_BUFFER0_COUNT);
asm/au1000_dma.h:	au_writel(count, chan->io + DMA_BUFFER1_COUNT);
asm/au1000_dma.h:	au_writel(count, chan->io + DMA_BUFFER0_COUNT);
asm/au1000_dma.h:	au_writel(count, chan->io + DMA_BUFFER1_COUNT);
asm/au1000_dma.h: * Returns -1 if neither or both done bits set.
asm/au1000_dma.h:    return au_readl(chan->io + DMA_MODE_READ) & (DMA_D0 | DMA_D1);
asm/au1000_dma.h:		return -1;
asm/au1000_dma.h:	return chan->irq;
asm/au1000_dma.h:	curBufCntReg = (au_readl(chan->io + DMA_MODE_READ) & DMA_AB) ?
asm/au1000_dma.h:	count = au_readl(chan->io + curBufCntReg) & DMA_COUNT_MASK;
asm/au1000_dma.h:	if ((chan->mode & DMA_DW_MASK) == DMA_DW16)
asm/au1000_dma.h:	else if ((chan->mode & DMA_DW_MASK) == DMA_DW32)
asm/module.h: * modutils/obj/obj-mips.c
asm/module.h:	archdata = (struct archdata *)(mod->archdata_start);
asm/module.h:	if (archdata->dbe_table_start > archdata->dbe_table_end ||
asm/module.h:	    (archdata->dbe_table_start &&
asm/module.h:	     !((unsigned long)archdata->dbe_table_start >=
asm/module.h:	       ((unsigned long)mod + mod->size_of_struct) &&
asm/module.h:	       ((unsigned long)archdata->dbe_table_end <
asm/module.h:	        (unsigned long)mod + mod->size))) ||
asm/module.h:            (((unsigned long)archdata->dbe_table_start -
asm/module.h:	      (unsigned long)archdata->dbe_table_end) %
asm/module.h:			"module_arch_init: archdata->dbe_table_* invalid.\n");
asm/module.h:	mod->archdata_start = (char *)&archdata;
asm/module.h:	mod->archdata_end = mod->archdata_start + sizeof(archdata);
asm/pgtable-bits.h: * Copyright (C) 1994 - 2002 by Ralf Baechle
asm/pgtable-bits.h:/* bobtseng --, 2005.12.16 */
asm/spinlock.h:#define spin_lock_init(x)	do { (x)->lock = 0; } while(0)
asm/spinlock.h:#define spin_is_locked(x)	((x)->lock != 0)
asm/spinlock.h:#define spin_unlock_wait(x)	do { barrier(); } while ((x)->lock)
asm/spinlock.h:	: "=m" (lock->lock), "=&r" (tmp)
asm/spinlock.h:	: "m" (lock->lock)
asm/spinlock.h:	: "=m" (lock->lock)
asm/spinlock.h:	: "m" (lock->lock)
asm/spinlock.h: * Read-write spinlocks, allowing multiple readers but only one writer.
asm/spinlock.h: * writers. For those circumstances we can "mix" irq-safe locks - any writer
asm/spinlock.h: * needs to get a irq-safe write-lock, but readers can get non-irqsafe
asm/spinlock.h: * read-locks.
asm/spinlock.h:	: "=m" (rw->lock), "=&r" (tmp)
asm/spinlock.h:	: "m" (rw->lock)
asm/spinlock.h:	: "=m" (rw->lock), "=&r" (tmp)
asm/spinlock.h:	: "m" (rw->lock)
asm/spinlock.h:	: "=m" (rw->lock), "=&r" (tmp)
asm/spinlock.h:	: "m" (rw->lock)
asm/spinlock.h:	: "=m" (rw->lock)
asm/spinlock.h:	: "m" (rw->lock)
asm/errno.h:#define	EXDEV		18	/* Cross-device link */
asm/errno.h:#define	EROFS		30	/* Read-only file system */
asm/errno.h:#define	ENOTSOCK	95	/* Socket operation on non-socket */
asm/db1x00.h: *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm/db1x00.h:#define BOARD_CARD_INSERTED(SOCKET) !(bcsr->status & (1<<(4+SOCKET)))
asm/db1x00.h:#define BOARD_CARD_INSERTED(SOCKET) !(bcsr->status & (1<<(4+SOCKET)))
asm/hazards.h: * mtc0->mfc0 hazard
asm/hazards.h: * mtc0->mfc0 hazard
asm/hazards.h: * R10000 rocks - all hazards handled in hardware, so this becomes a nobrainer.
asm/hazards.h: * care about the irq_enable_hazard - sooner or later the hardware will
asm/galileo-boards/gt96100.h: *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm/galileo-boards/gt96100.h:/* TDPR0 - Transmit Dual Port RAM. block size 0xff */
asm/galileo-boards/gt96100.h:/* RDPR0 - Receive Dual Port RAM. block size 0xff */
asm/usioctl.h: * usema/usemaclone-related stuff.
asm/softirq.h:	local_bh_count(cpu)--;
asm/softirq.h:	if (!--local_bh_count(cpu) && softirq_pending(cpu))	\
asm/au1000_usbdev.h: *	Au1000 USB Device-Side Driver
asm/bugs.h: * This is included by init/main.c to check for architecture-dependent bugs.
asm/namei.h: * linux/include/asm-mips/namei.h
asm/namei.h:	if (current->personality != PER_IRIX32)
asm/ng1hw.h:#define REX3WAIT(rex3)  while ((rex3)->p1.set.status & GFXBUSY)
asm/ng1hw.h:#define BFIFOWAIT(rex3)  while ((rex3)->p1.set.status & BACKBUSY)
asm/termbits.h:#define VKILL		 3		/* Kill-line character [ICANON].  */
asm/termbits.h:#define VTIME		 5		/* Time-out value (tenths of a second) [!ICANON].  */
asm/termbits.h:#define VSTART		 8		/* Start (X-ON) character [IXON, IXOFF].  */
asm/termbits.h:#define VSTOP		 9		/* Stop (X-OFF) character [IXON, IXOFF].  */
asm/termbits.h:#define VREPRINT	12		/* Reprint-line character [ICANON].  */
asm/termbits.h:#define VWERASE		14		/* Word-erase character [ICANON].  */
asm/termbits.h:#define VLNEXT		15		/* Literal-next character [IEXTEN].  */
asm/termbits.h:#define VEOF		16		/* End-of-file character [ICANON].  */
asm/termbits.h:#define VEOL		17		/* End-of-line character [ICANON].  */
asm/termbits.h:#define ONLCR	0000004		/* Map NL to CR-NL on output.  */
asm/riscos-syscall.h: * The syscalls 0 - 3999 are reserved for a down to the root syscall
asm/highmem.h: * Redesigned the x86 32-bit VM architecture to deal with
asm/highmem.h:#define LAST_PKMAP_MASK (LAST_PKMAP-1)
asm/highmem.h:#define PKMAP_NR(virt)  ((virt-PKMAP_BASE) >> PAGE_SHIFT)
asm/highmem.h: * The use of kmap_atomic/kunmap_atomic is discouraged - kmap/kunmap
asm/highmem.h:	set_pte(kmap_pte-idx, mk_pte(page, kmap_prot));
asm/au1xxx_psc.h:/* Enable slots 3-12.
asm/au1xxx_psc.h:#define PSC_AC97CFG_TXSLOT_ENA(x)	(1 << (((x) - 3) + 11))
asm/au1xxx_psc.h:#define PSC_AC97CFG_RXSLOT_ENA(x)	(1 << (((x) - 3) + 1))
asm/au1xxx_psc.h:#define PSC_AC97CFG_SET_LEN(x)	(((((x)-2)/2) & 0xf) << 21)
asm/au1xxx_psc.h:#define PSC_I2SCFG_SET_WS(x)	(((((x) / 2) - 1) & 0x7f) << 16)
asm/au1xxx_psc.h:#define PSC_I2SCFG_SET_LEN(x)	((((x) - 1) & 0x1f) << 4)
asm/au1xxx_psc.h:#define PSC_SPICFG_SET_LEN(x)	(((x-1) & 0x1f) << 4)
asm/fixmap.h: * fixmap.h: compile-time virtual memory allocation
asm/fixmap.h: * Here we define all the compile-time 'special' virtual
asm/fixmap.h: * Also this lets us do fail-safe vmalloc(), we
asm/fixmap.h: * vmalloc()-ed addresses never overlap.
asm/fixmap.h: * these 'compile-time allocated' memory buffers are
asm/fixmap.h: * fixed-size 4k pages. (or larger if used with an increment
asm/fixmap.h: * fix-mapped?
asm/fixmap.h:	FIX_KMAP_END = FIX_KMAP_BEGIN+(KM_TYPE_NR*NR_CPUS)-1,
asm/fixmap.h:#define FIXADDR_START	(FIXADDR_TOP - FIXADDR_SIZE)
asm/fixmap.h:#define __fix_to_virt(x)	(FIXADDR_TOP - ((x) << PAGE_SHIFT))
asm/fixmap.h: * directly without tranlation, we catch the bug with a NULL-deference
asm/fixmap.h:	 * out-of-range indices).
asm/jazz.h: * Copyright (C) 1995 - 1998 by Andreas Busse and Ralf Baechle
asm/jazz.h: * 0xf0000000 - Rev1
asm/jazz.h: * 0xf0000001 - Rev2
asm/jazz.h: * 0xf0000002 - Rev3
asm/jazz.h: *      ---------
asm/jazz.h: *      ---------
asm/jazz.h: *      --------- . (0)
asm/jazz.h: * Note: Channels 4...7 are not used with respect to the Acer PICA-61
asm/init.h:#error "<asm/init.h> should never be used - use <linux/init.h> instead"
asm/inst.h:	 * The others (0x14 - 0x1f) are unused.
asm/inst.h: * Damn ...  bitfields depend from byteorder :-(
asm/it8172/it8172_int.h: * and the non-maskable ints from 48 to 53.
asm/it8172/it8172_int.h:/* 12 - 15 reserved */
asm/it8172/it8172_int.h:#define MIPS_CPU_TIMER_IRQ       (NR_IRQS-1)
asm/uaccess.h:#define __UA_LIMIT	(- TASK_SIZE)
asm/uaccess.h: * userspace address.  Note that we limit 32-bit userspace to 0x7fff8000 but
asm/uaccess.h: * we use 0x80000000 here on 32-bit kernels.  If a process passes an invalid
asm/uaccess.h: * address in this range it's the process's problem, not ours :-)
asm/uaccess.h:#define get_fs()	(current->thread.current_ds)
asm/uaccess.h:#define set_fs(x)	(current->thread.current_ds = (x))
asm/uaccess.h: *  - "addr" doesn't have any high-bits set
asm/uaccess.h: *  - AND "size" doesn't have any high-bits set
asm/uaccess.h: *  - AND "addr+size" doesn't have any high-bits set
asm/uaccess.h: *  - OR we are in kernel mode.
asm/uaccess.h: * access_ok: - Checks if a user space pointer is valid
asm/uaccess.h: *        %VERIFY_WRITE is a superset of %VERIFY_READ - if it is safe
asm/uaccess.h: * checks that the pointer is in the user space range - after calling
asm/uaccess.h: * this function, memory access functions may still return -EFAULT.
asm/uaccess.h: * verify_area: - Obsolete, use access_ok()
asm/uaccess.h: * Returns zero if the memory block may be valid, -EFAULT
asm/uaccess.h:	return access_ok(type, addr, size) ? 0 : -EFAULT;
asm/uaccess.h: * put_user: - Write a simple value into user space.
asm/uaccess.h: * @ptr must have pointer-to-simple-variable type, and @x must be assignable
asm/uaccess.h: * Returns zero on success, or -EFAULT on error.
asm/uaccess.h: * get_user: - Get a simple variable from user space.
asm/uaccess.h: * @ptr must have pointer-to-simple-variable type, and the result of
asm/uaccess.h: * Returns zero on success, or -EFAULT on error.
asm/uaccess.h: * __put_user: - Write a simple value into user space, with less checking.
asm/uaccess.h: * @ptr must have pointer-to-simple-variable type, and @x must be assignable
asm/uaccess.h: * Returns zero on success, or -EFAULT on error.
asm/uaccess.h: * __get_user: - Get a simple variable from user space, with less checking.
asm/uaccess.h: * @ptr must have pointer-to-simple-variable type, and the result of
asm/uaccess.h: * Returns zero on success, or -EFAULT on error.
asm/uaccess.h:	: "0" (__gu_err), "o" (__m(__gu_addr)), "i" (-EFAULT));		\
asm/uaccess.h:	  "o" (__m(__gu_addr + 4)), "i" (-EFAULT));			\
asm/uaccess.h:	  "i" (-EFAULT));						\
asm/uaccess.h:	  "o" (__m(__pu_addr + 4)), "i" (-EFAULT));			\
asm/uaccess.h: * __copy_to_user: - Copy a block of data into user space, with less checking.
asm/uaccess.h: * copy_to_user: - Copy a block of data into user space.
asm/uaccess.h: * __copy_from_user: - Copy a block of data from user space, with less checking. * @to:   Destination address, in kernel space.
asm/uaccess.h: * copy_from_user: - Copy a block of data from user space.
asm/uaccess.h: * __clear_user: - Zero a block of memory in user space, with less checking.
asm/uaccess.h: * __strncpy_from_user: - Copy a NUL terminated string from userspace, with less checking.
asm/uaccess.h: * Copies a NUL-terminated string from userspace to kernel space.
asm/uaccess.h: * If access to userspace fails, returns -EFAULT (some data may have been
asm/uaccess.h: * strncpy_from_user: - Copy a NUL terminated string from userspace.
asm/uaccess.h: * Copies a NUL-terminated string from userspace to kernel space.
asm/uaccess.h: * If access to userspace fails, returns -EFAULT (some data may have been
asm/uaccess.h: * strlen_user: - Get the size of a string in user space.
asm/uaccess.h: * Get the size of a NUL-terminated string in user space.
asm/uaccess.h: * strlen_user: - Get the size of a string in user space.
asm/uaccess.h: * Get the size of a NUL-terminated string in user space.
asm/traps.h: *	include/asm-mips/traps.h
asm/nile4.h: *  asm-mips/nile4.h -- NEC Vrc-5074 Nile 4 definitions
asm/nile4.h:#define NILE4_DCS2	0x0010	/* Device Chip-Select 2 [R/W] */
asm/nile4.h:#define NILE4_DCS3	0x0018	/* Device Chip-Select 3 [R/W] */
asm/nile4.h:#define NILE4_DCS4	0x0020	/* Device Chip-Select 4 [R/W] */
asm/nile4.h:#define NILE4_DCS5	0x0028	/* Device Chip-Select 5 [R/W] */
asm/nile4.h:#define NILE4_DCS6	0x0030	/* Device Chip-Select 6 [R/W] */
asm/nile4.h:#define NILE4_DCS7	0x0038	/* Device Chip-Select 7 [R/W] */
asm/nile4.h:#define NILE4_DCS8	0x0040	/* Device Chip-Select 8 [R/W] */
asm/nile4.h:#define NILE4_BOOTCS	0x0078	/* Boot ROM Chip-Select [R/W] */
asm/nile4.h:     *  Memory-Interface Registers
asm/nile4.h:     *  PCI-Bus Registers
asm/nile4.h:     *  Local-Bus Registers
asm/nile4.h:#define NILE4_LCST2	0x0110	/* Local Bus Chip-Select Timing 2 [R/W] */
asm/nile4.h:#define NILE4_LCST3	0x0118	/* Local Bus Chip-Select Timing 3 [R/W] */
asm/nile4.h:#define NILE4_LCST4	0x0120	/* Local Bus Chip-Select Timing 4 [R/W] */
asm/nile4.h:#define NILE4_LCST5	0x0128	/* Local Bus Chip-Select Timing 5 [R/W] */
asm/nile4.h:#define NILE4_LCST6	0x0130	/* Local Bus Chip-Select Timing 6 [R/W] */
asm/nile4.h:#define NILE4_LCST7	0x0138	/* Local Bus Chip-Select Timing 7 [R/W] */
asm/nile4.h:#define NILE4_LCST8	0x0140	/* Local Bus Chip-Select Timing 8 [R/W] */
asm/nile4.h:#define NILE4_DCSFN	0x0150	/* Device Chip-Select Muxing and Output */
asm/nile4.h:#define NILE4_DCSIO	0x0158	/* Device Chip-Selects As I/O Bits [R/W] */
asm/nile4.h:#define NILE4_BCST	0x0178	/* Local Boot Chip-Select Timing [R/W] */
asm/nile4.h:#define NILE4_T1CTRL	0x01D0	/* CPU-Bus Read Time-Out Control [R/W] */
asm/nile4.h:#define NILE4_T1CNTR	0x01D8	/* CPU-Bus Read Time-Out Counter [R/W] */
asm/nile4.h:#define NILE4_T2CTRL	0x01E0	/* General-Purpose Timer Control [R/W] */
asm/nile4.h:#define NILE4_T2CNTR	0x01E8	/* General-Purpose Timer Counter [R/W] */
asm/nile4.h:#define NILE4_SSVID	0x022C	/* PCI Sub-System Vendor ID [R/W] */
asm/nile4.h:#define NILE4_SSID	0x022E	/* PCI Sub-System ID [R/W] */
asm/nile4.h:     *  Serial-Port Registers
asm/nile4.h:#define NILE4_INT_CPCE	0	/* CPU-Interface Parity-Error Interrupt */
asm/nile4.h:#define NILE4_INT_CNTD	1	/* CPU No-Target Decode Interrupt */
asm/nile4.h:#define NILE4_INT_MCE	2	/* Memory-Check Error Interrupt */
asm/nile4.h:#define NILE4_INT_GPT	6	/* General-Purpose Timer Interrupt */
asm/nile4.h:#define NILE4_INT_LBRTD	7	/* Local-Bus Ready Timer Interrupt */
asm/nile4.h:#define irq_to_nile4(n)		((n)-NUM_I8259_INTERRUPTS)
asm/pb1000.h: *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm/pb1000.h:/* VPPEN1 - VPPEN0 */
asm/pb1000.h:/* VCCEN1 - VCCEN0 */
asm/pb1100.h: *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm/pb1200.h: *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm/pb1200.h: *    *example: IDE bis pos is  = 64 - 64
asm/pb1200.h:                ETH bit pos is  = 65 - 64
asm/pb1200.h:#define BOARD_CARD_INSERTED(SOCKET) bcsr->sig_status & (1<<(8+(2*SOCKET)))
asm/pb1500.h: *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm/pb1550.h: *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm/pb1550.h:#define DAUGHTER_CARD_MEM_SIZE		(0xADFFFFFF - DAUGHTER_CARD_BASE + 1)
asm/mman.h:/* These are linux-specific */
asm/mman.h:#define MAP_GROWSDOWN	0x1000		/* stack-like segment */
asm/mman.h:#define MADV_NORMAL	0x0		/* default page-in behavior */
asm/mman.h:#define MADV_RANDOM	0x1		/* page-in minimum required */
asm/mman.h:#define MADV_SEQUENTIAL	0x2		/* read-ahead aggressively */
asm/mman.h:#define MADV_WILLNEED	0x3		/* pre-fault pages */
asm/linux_logo_dec.h: * include/asm-mips/linux_logo_dec.h: This is a linux logo
asm/linux_logo_dec.h: * Copyright (C) 2001 Jan-Benedict Glaw <jbglaw@lug-owl.de>
asm/addrspace.h: *  32-bit MIPS address spaces
asm/addrspace.h: * 64-bit address conversions
asm/posix_types.h: * This file is generally used by user-level software, so you need to
asm/posix_types.h:	__fdsetp->fds_bits[__tmp] |= (1UL<<__rem);
asm/posix_types.h:	__fdsetp->fds_bits[__tmp] &= ~(1UL<<__rem);
asm/posix_types.h:	return (__p->fds_bits[__tmp] & (1UL<<__rem)) != 0;
asm/posix_types.h: * for a 256-bit fd_set)
asm/posix_types.h:	unsigned long *__tmp = __p->fds_bits;
asm/posix_types.h:		__i--;
asm/smplock.h:	if (task->lock_depth >= 0) \
asm/smplock.h: * Re-acquire the kernel lock
asm/smplock.h:	if (task->lock_depth >= 0) \
asm/smplock.h:	if (!++current->lock_depth)
asm/smplock.h:	if (--current->lock_depth < 0)
asm/linux_logo_sgi.h: * include/asm-mips/linux_logo_sgi.h: This is a linux logo
asm/linux_logo_sgi.h: * Copyright (C) 2001 Jan-Benedict Glaw <jbglaw@lug-owl.de>
asm/mv64340_dep.h: * include/asm-mips/mv64340-dep.h
asm/mv64340_dep.h: *     Board-dependent definitions for MV-64340 chip.
asm/page.h: * Copyright (C) 1994 - 1999, 2003 by Ralf Baechle
asm/page.h:#define PAGE_MASK	(~(PAGE_SIZE-1))
asm/page.h: * These are used to make use of C type-checking..
asm/page.h:	size = (size-1) >> (PAGE_SHIFT-1);
asm/page.h:	order = -1;
asm/page.h:#define PAGE_ALIGN(addr)	(((addr) + PAGE_SIZE - 1) & PAGE_MASK)
asm/page.h:#define __pa(x)		((unsigned long) (x) - PAGE_OFFSET)
asm/page.h:#define VALID_PAGE(page)	((page - mem_map) < max_mapnr)
asm/page.h:#define UNCAC_ADDR(addr)	((addr) - PAGE_OFFSET + UNCAC_BASE)
asm/page.h:#define CAC_ADDR(addr)		((addr) - UNCAC_BASE + PAGE_OFFSET)
asm/gt64120/gt64120.h: *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm/gt64120/gt64120.h:#define MSK(n)                    ((1 << (n)) - 1)
asm/gt64120/gt64120.h: *   GT_WRITE(ofs, data)           - read/write GT64120 registers in 32bit
asm/gt64120/gt64120.h: *   TIMER 	- gt64120 timer irq, temporary solution until
asm/gt64120/gt64120.h:#include <asm/gt64120/mips-boards/gt64120_dep.h>
asm/gt64120/gt64120.h:#include <asm/gt64120/mips-boards/gt64120_dep.h>
asm/gt64120/gt64120.h: * bytes when running bigendian.  We also provide non-swapping versions.
asm/gt64120/gt64120.h: * Board-dependent functions, which must be defined in
asm/hdreg.h: *  Copyright (C) 1994-1996  Linus Torvalds & authors
asm/poll.h:/* XXX This one seems to be more-or-less nonstandard.  */
asm/rt2880/surfboard.h: *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm/rt2880/surfboardint.bob: *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm/rt2880/surfboardint.bob: * Surfboard registers are memory mapped on 32-bit aligned boundaries and
asm/rt2880/surfboardint.bob:/* bobtseng added --, 2006.3.6. */
asm/rt2880/surfboardint.org: *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm/rt2880/surfboardint.org: * Surfboard registers are memory mapped on 32-bit aligned boundaries and
asm/rt2880/generic.h: * 59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm/rt2880/generic.h: * Defines of the Palmchip boards specific address-MAP, registers, etc.
asm/rt2880/generic.h: * Power-off register
asm/rt2880/prom.h: *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm/rt2880/surfboardint.h: *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm/rt2880/surfboardint.h: * Surfboard registers are memory mapped on 32-bit aligned boundaries and
asm/rt2880/surfboardint.h:/* bobtseng added --, 2006.3.6. */
asm/sembuf.h: * - 2 miscellaneous 64-bit values
asm/sibyte/sb1250_dma.h:    *  MA 02111-1307 USA
asm/sibyte/sb1250_dma.h: * Ethernet and Serial DMA Configuration Register 0  (Table 7-4)
asm/sibyte/sb1250_dma.h: * Ethernet and Serial DMA Configuration Register 1 (Table 7-5)
asm/sibyte/sb1250_dma.h: * Ethernet and Serial DMA Descriptor base address (Table 7-6)
asm/sibyte/sb1250_dma.h: * ASIC Mode Base Address (Table 7-7)
asm/sibyte/sb1250_dma.h: * DMA Descriptor Count Registers (Table 7-8)
asm/sibyte/sb1250_dma.h: * Current Descriptor Address Register (Table 7-11)
asm/sibyte/sb1250_dma.h: * Descriptor doubleword "A"  (Table 7-12)
asm/sibyte/sb1250_dma.h: * Descriptor doubleword "B"  (Table 7-13)
asm/sibyte/sb1250_dma.h: * Ethernet Descriptor Status Bits (Table 7-15)
asm/sibyte/sb1250_dma.h: * Ethernet Transmit Status Bits (Table 7-16)
asm/sibyte/sb1250_dma.h: * Ethernet Transmit Options (Table 7-17)
asm/sibyte/sb1250_dma.h: * Serial Receive Options (Table 7-18)
asm/sibyte/sb1250_dma.h: * Serial Transmit Status Bits (Table 7-20)
asm/sibyte/sb1250_dma.h: * Serial Transmit Options (Table 7-21)
asm/sibyte/sb1250_dma.h: * Data Mover Descriptor Base Address Register (Table 7-22)
asm/sibyte/sb1250_dma.h: * Data Mover Descriptor Count Register (Table 7-25)
asm/sibyte/sb1250_dma.h: * Data Mover Current Descriptor Address (Table 7-24)
asm/sibyte/sb1250_dma.h: * Data Mover Descriptor Doubleword "A"  (Table 7-26)
asm/sibyte/sb1250_dma.h: * Data Mover Descriptor Doubleword "B"  (Table 7-25)
asm/sibyte/sb1250_l2c.h:    *  MA 02111-1307 USA
asm/sibyte/sb1250_l2c.h: * Level 2 Cache Tag register (Table 5-3)
asm/sibyte/sb1250_l2c.h: * Format of level 2 cache management address (table 5-2)
asm/sibyte/sb1250_int.h:    *  MA 02111-1307 USA
asm/sibyte/sb1250_int.h: * Interrupt sources (Table 4-8, UM 0.2)
asm/sibyte/sb1250_int.h: * LDT Interrupt Set Register (table 4-5)
asm/sibyte/sb1250_int.h: * Vector format (Table 4-6)
asm/sibyte/sb1250_ldt.h:    *  MA 02111-1307 USA
asm/sibyte/sb1250_ldt.h: * LDT Command Register (Table 8-13)
asm/sibyte/sb1250_ldt.h: * LDT Status Register (Table 8-14).  Note that these constants
asm/sibyte/sb1250_ldt.h: * together (32-bit read at offset 0x04)
asm/sibyte/sb1250_ldt.h: * register (Table 8-15), offset 0x1C
asm/sibyte/sb1250_ldt.h: * Bridge Control Register (Table 8-16).  Note that these 
asm/sibyte/sb1250_ldt.h: * constants assume you've read the register as a 32-bit 
asm/sibyte/sb1250_ldt.h: * LDT Command Register (Table 8-17).  Note that these constants
asm/sibyte/sb1250_ldt.h: * 32-bit read at offset 0x40
asm/sibyte/sb1250_ldt.h: * LDT link control register (Table 8-18), and (Table 8-19)
asm/sibyte/sb1250_ldt.h: * LDT Link frequency register  (Table 8-20) offset 0x48
asm/sibyte/sb1250_ldt.h: * LDT SRI Command Register (Table 8-21).  Note that these constants
asm/sibyte/sb1250_ldt.h: * 32-bit read at offset 0x50
asm/sibyte/sb1250_ldt.h: * LDT Error control and status register (Table 8-22) (Table 8-23)
asm/sibyte/sb1250_ldt.h: * SRI Control register (Table 8-24, 8-25)  Offset 0x6C
asm/sibyte/sb1250_ldt.h: * LDT SRI Transmit Buffer Count register (Table 8-26)
asm/sibyte/sb1250_mac.h:    *  MA 02111-1307 USA
asm/sibyte/sb1250_mac.h: * MAC Configuration Register (Table 9-13)
asm/sibyte/sb1250_mac.h: * MAC Fifo Threshhold registers (Table 9-14)
asm/sibyte/sb1250_mac.h: * MAC Frame Configuration Registers (Table 9-15)
asm/sibyte/sb1250_mac.h: * MAC VLAN Tag Registers (Table 9-16)
asm/sibyte/sb1250_mac.h: * MAC Status Registers (Table 9-17)
asm/sibyte/sb1250_mac.h: * Also used for the MAC Interrupt Mask Register (Table 9-18)
asm/sibyte/sb1250_mac.h: *  and pass just the six bits to a DMA-channel-specific ISR
asm/sibyte/sb1250_mac.h: * MAC Fifo Pointer Registers (Table 9-19)    [Debug register]
asm/sibyte/sb1250_mac.h: * MAC Fifo End Of Packet Count Registers (Table 9-20)  [Debug register]
asm/sibyte/sb1250_mac.h: * MAC Recieve Address Filter Exact Match Registers (Table 9-21)
asm/sibyte/sb1250_mac.h: * MAC Recieve Address Filter Hash Match Registers (Table 9-22)
asm/sibyte/sb1250_mac.h: * MAC Transmit Source Address Registers (Table 9-23)
asm/sibyte/sb1250_mac.h: * MAC Receive Address Filter Control Registers (Table 9-24)
asm/sibyte/sb1250_mac.h: * MAC Receive Channel Select Registers (Table 9-25)
asm/sibyte/sb1250_mac.h: * MAC MII Management Interface Registers (Table 9-26)
asm/sibyte/sb1250_scd.h:    *  MA 02111-1307 USA
asm/sibyte/sb1250_scd.h: * System Revision Register (Table 4-1)
asm/sibyte/sb1250_scd.h: * System Config Register (Table 4-2)
asm/sibyte/sb1250_scd.h: * Mailbox Registers (Table 4-3)
asm/sibyte/sb1250_scd.h: * Watchdog Registers (Table 4-8) (Table 4-9) (Table 4-10)
asm/sibyte/sb1250_scd.h: * Timer Registers (Table 4-11) (Table 4-12) (Table 4-13)
asm/sibyte/trace_prof.h: * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
asm/sibyte/trace_prof.h: * Routines for using 40-bit SCD cycle counter
asm/sibyte/trace_prof.h: * zclk_timer_init(0) at least every 2^40 - 1 ZCLKs.
asm/sibyte/sb1250_syncser.h:    *  MA 02111-1307 USA
asm/sibyte/sb1250.h: * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
asm/sibyte/sb1250_mc.h:    *  MA 02111-1307 USA
asm/sibyte/sb1250_mc.h: * Memory Channel Config Register (table 6-14)
asm/sibyte/sb1250_mc.h: * Memory clock config register (Table 6-15)
asm/sibyte/sb1250_mc.h: * DRAM Command Register (Table 6-13)
asm/sibyte/sb1250_mc.h: * DRAM Mode Register (Table 6-14)
asm/sibyte/sb1250_mc.h: * SDRAM Timing Register  (Table 6-15)
asm/sibyte/sb1250_mc.h: * Chip Select Start Address Register (Table 6-17)
asm/sibyte/sb1250_mc.h: * Chip Select End Address Register (Table 6-18)
asm/sibyte/sb1250_mc.h: * Chip Select Interleave Register (Table 6-19)
asm/sibyte/sb1250_mc.h: * Row Address Bits Register (Table 6-20)
asm/sibyte/sb1250_mc.h: * Column Address Bits Register (Table 6-21)
asm/sibyte/sb1250_mc.h: * Bank Address Address Bits Register (Table 6-22)
asm/sibyte/sb1250_mc.h: * Chip Select Attribute Register (Table 6-23)
asm/sibyte/sb1250_mc.h: * ECC Test ECC Register (Table 6-25)
asm/sibyte/swarm.h: * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
asm/sibyte/carmel.h: * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
asm/sibyte/sb1250_smbus.h:    *  MA 02111-1307 USA
asm/sibyte/sb1250_smbus.h: * SMBus Clock Frequency Register (Table 14-2)
asm/sibyte/sb1250_smbus.h: * SMBus control register (Table 14-4)
asm/sibyte/sb1250_smbus.h: * SMBus status registers (Table 14-5)
asm/sibyte/sb1250_smbus.h: * SMBus Start/Command registers (Table 14-9)
asm/sibyte/sb1250_smbus.h: * SMBus Data Register (Table 14-6) and SMBus Extra Register (Table 14-7)
asm/sibyte/sb1250_smbus.h: * SMBus Packet Error Check register (Table 14-8)
asm/sibyte/sentosa.h: * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
asm/sibyte/64bit.h: * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
asm/sibyte/64bit.h: * This is annoying...we can't actually write the 64-bit IO register properly
asm/sibyte/64bit.h: * without having access to 64-bit registers...  which doesn't work by default
asm/sibyte/64bit.h: * driver code for the 32-bit and 64-bit trees
asm/sibyte/64bit.h: * Avoid interrupt mucking, just adjust the address for 4-byte access.
asm/sibyte/64bit.h: * Assume the addresses are 8-byte aligned.
asm/sibyte/sb1250_defs.h:    *  MA 02111-1307 USA
asm/sibyte/sb1250_defs.h: * 'long long' (64-bit integer) support.
asm/sibyte/sb1250_defs.h:    ((SIBYTE_HDR_FMASK(chip, pass) - 1) & SIBYTE_HDR_FMASK_ALLREVS(chip))
asm/sibyte/sb1250_defs.h:     | (SIBYTE_HDR_FMASK(chip, pass) - 1)) & SIBYTE_HDR_FMASK_ALLREVS(chip))
asm/sibyte/sb1250_defs.h:    *                  For multi-bit fields, all bits in the field will
asm/sibyte/sb1250_defs.h:    *  K_xxx           "Code" constant (value for data in a multi-bit
asm/sibyte/sb1250_defs.h:    *  G_xxx(X)        GET value.  This macro obtains a multi-bit field
asm/sibyte/sb1250_defs.h: * Cast to 64-bit number.  Presumably the syntax is different in 
asm/sibyte/sb1250_defs.h:#define _SB_MAKEMASK(v,n) (_SB_MAKE64((_SB_MAKE64(1)<<(v))-1) << _SB_MAKE64(n))
asm/sibyte/sb1250_defs.h:#define _SB_MAKEMASK_32(v,n) (_SB_MAKE32((_SB_MAKE32(1)<<(v))-1) << _SB_MAKE32(n))
asm/sibyte/sb1250_defs.h: * Macros to read/write on-chip registers
asm/sibyte/sb1250_genbus.h:    *  MA 02111-1307 USA
asm/sibyte/sb1250_genbus.h: * Generic Bus Region Configuration Registers (Table 11-4)
asm/sibyte/sb1250_genbus.h: * Generic Bus Region Size register (Table 11-5)
asm/sibyte/sb1250_genbus.h: * Generic Bus Region Address (Table 11-6)
asm/sibyte/sb1250_genbus.h: * Generic Bus Region 0 Timing Registers (Table 11-7)
asm/sibyte/sb1250_genbus.h: * Generic Bus Timing 1 Registers (Table 11-8)
asm/sibyte/sb1250_genbus.h: * Generic Bus Interrupt Status Register (Table 11-9)
asm/sibyte/sb1250_genbus.h: * PCMCIA configuration register (Table 12-6)
asm/sibyte/sb1250_genbus.h: * PCMCIA status register (Table 12-7)
asm/sibyte/sb1250_genbus.h: * GPIO Interrupt Type Register (table 13-3)
asm/sibyte/board.h: * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
asm/sibyte/sb1250_regs.h:    *  This module contains the addresses of the on-chip peripherals
asm/sibyte/sb1250_regs.h:    *  MA 02111-1307 USA
asm/sibyte/sb1250_regs.h:/* Backward-compatibility definitions.  */
asm/sibyte/sb1250_uart.h:    *  MA 02111-1307 USA
asm/sibyte/sb1250_uart.h: * DUART Mode Register #1 (Table 10-3)
asm/sibyte/sb1250_uart.h: * DUART Mode Register #2 (Table 10-4)
asm/sibyte/sb1250_uart.h: * DUART Command Register (Table 10-5)
asm/sibyte/sb1250_uart.h: * DUART Status Register (Table 10-6)
asm/sibyte/sb1250_uart.h: * READ-ONLY
asm/sibyte/sb1250_uart.h: * DUART Baud Rate Register (Table 10-7)
asm/sibyte/sb1250_uart.h:#define V_DUART_BAUD_RATE(x)        (100000000/((x)*20)-1)
asm/sibyte/sb1250_uart.h: * DUART Data Registers (Table 10-8 and 10-9)
asm/sibyte/sb1250_uart.h: * DUART Input Port Register (Table 10-10)
asm/sibyte/sb1250_uart.h: * DUART Input Port Change Status Register (Tables 10-11, 10-12, and 10-13)
asm/sibyte/sb1250_uart.h: * DUART Output port control register (Table 10-14)
asm/sibyte/sb1250_uart.h: * DUART Aux Control Register (Table 10-15)
asm/sibyte/sb1250_uart.h: * DUART Interrupt Status Register (Table 10-16)
asm/sibyte/sb1250_uart.h: * DUART Channel A Interrupt Status Register (Table 10-17)
asm/sibyte/sb1250_uart.h: * DUART Channel B Interrupt Status Register (Table 10-18)
asm/sibyte/sb1250_uart.h: * DUART Interrupt Mask Register (Table 10-19)
asm/sibyte/sb1250_uart.h: * DUART Channel A Interrupt Mask Register (Table 10-20)
asm/sibyte/sb1250_uart.h: * DUART Channel B Interrupt Mask Register (Table 10-21)
asm/sibyte/sb1250_uart.h: * DUART Output Port Set Register (Table 10-22)
asm/sibyte/sb1250_uart.h: * DUART Output Port Clear Register (Table 10-23)
asm/sibyte/sb1250_uart.h: * DUART Output Port RTS Register (Table 10-24)
asm/system.h: * Copyright (C) 1994 - 1999 by Ralf Baechle
asm/system.h: * Copyright (C) 1994 - 1999 by Ralf Baechle
asm/system.h:#endif /* Processor-dependent optimization */
asm/stat.h: * struct stat of the 64-bit kernel.
asm/time.h: * include/asm-mips/time.h
asm/time.h: * RTC ops.  By default, they point to no-RTC functions.
asm/time.h: *	rtc_get_time - mktime(year, mon, day, hour, min, sec) in seconds.
asm/time.h: *	rtc_set_time - reverse the above translation and set time to RTC.
asm/time.h: *	rtc_set_mmss - similar to rtc_set_time, but only min and sec need
asm/time.h: *			to be set.  Used by RTC sync-up.
asm/time.h: * mips_timer_ack may be NULL if the interrupt is self-recoverable.
asm/time.h: * If mips_hpt_read is NULL, an R4k-compatible timer setup is attempted.
asm/time.h: * high-level timer interrupt routines.
asm/time.h: * the corresponding low-level timer interrupt routine.
asm/time.h: * mips_hpt_frequency - must be set if you intend to use an R4k-compatible
asm/checksum.h: * and adds in "sum" (32-bit)
asm/checksum.h: * returns a 32-bit number suitable for feeding into itself
asm/checksum.h: * it's best to have buff aligned on a 32-bit boundary
asm/checksum.h:		*err_ptr = -EFAULT;
asm/checksum.h:		return -1;
asm/checksum.h: * computes the checksum of the TCP/UDP pseudo-header
asm/checksum.h: * returns a 16-bit checksum, already complemented
asm/checksum.h: * this routine is used for miscellaneous IP-like checksums, mainly
asm/xxs1500.h: *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm/tx4927/tx4927.h: * Copyright 2001-2002 MontaVista Software Inc.
asm/tx4927/tx4927.h: followed by the device name from table 4.2.2 on page 4-3 and then followed
asm/tx4927/tx4927.h: by the register name from table 4.2.3 on pages 4-4 to 4-8.  The manaul
asm/tx4927/tx4927.h:/* TX4927 SDRAM controller (64-bit registers) */
asm/tx4927/tx4927.h:/* TX4927 external bus controller (64-bit registers) */
asm/tx4927/tx4927.h:/* TX4927 SDRRAM Error Check Correction (64-bit registers) */
asm/tx4927/tx4927.h:/* TX4927 DMA Controller (64-bit registers) */
asm/tx4927/tx4927.h:/* TX4927 PCI Controller (32-bit registers) */
asm/tx4927/tx4927.h:/* TX4927 Configuration registers (64-bit registers) */
asm/tx4927/tx4927.h:/* TX4927 Timer 0 (32-bit registers) */
asm/tx4927/tx4927.h:/* TX4927 Timer 1 (32-bit registers) */
asm/tx4927/tx4927.h:/* TX4927 Timer 2 (32-bit registers) */
asm/tx4927/tx4927.h:/* TX4927 serial port 0 (32-bit registers) */
asm/tx4927/tx4927.h:/* TX4927 serial port 1 (32-bit registers) */
asm/tx4927/tx4927.h:/* TX4927 parallel port (32-bit registers) */
asm/tx4927/tx4927.h:/* TX4927 Interrupt Controller (32-bit registers) */
asm/tx4927/tx4927.h:/* TX4927 AC-link controller (32-bit registers) */
asm/tx4927/tx4927.h:#define TX4927_IRQ_CP0_RAW_BEG   0    /* tx4927 cpu built-in cp0 */
asm/tx4927/tx4927.h:#define TX4927_IRQ_PIC_RAW_BEG   0    /* tx4927 cpu build-in pic */
asm/tx4927/tx4927_pci.h: * Copyright (C) 2000-2001 Toshiba Corporation
asm/tx4927/tx4927_pci.h:#define TX4927_NR_IRQ_IRC       32      /* On-Chip IRC */
asm/tx4927/tx4927_pci.h:#define TX4927_PCIC_IDSEL_AD_TO_SLOT(ad)        ((ad) - 11)
asm/tx4927/toshiba_rbtx4927.h: * Copyright 2001-2002 MontaVista Software Inc.
asm/tx4927/toshiba_rbtx4927.h:#define RBTX4927_RTL_8019_BASE (0x1c020280-TBTX4927_ISA_IO_OFFSET)
asm/tx4927/tx4927_mips.h: * Copyright 2001-2002 MontaVista Software Inc.
asm/termios.h:	int	sg_flags;	/* SGI special - int, not short */
asm/termios.h:#define N_IRDA		11	/* Linux IrDa - http://irda.sourceforge.net/ */
asm/termios.h:#define N_SMSBLOCK	12	/* SMS block mode - for talking to GSM data cards about SMS messages */
asm/termios.h:	get_user(tmp, &(termio)->c_iflag); \
asm/termios.h:	(termios)->c_iflag = (0xffff0000 & ((termios)->c_iflag)) | tmp; \
asm/termios.h:	get_user(tmp, &(termio)->c_oflag); \
asm/termios.h:	(termios)->c_oflag = (0xffff0000 & ((termios)->c_oflag)) | tmp; \
asm/termios.h:	get_user(tmp, &(termio)->c_cflag); \
asm/termios.h:	(termios)->c_cflag = (0xffff0000 & ((termios)->c_cflag)) | tmp; \
asm/termios.h:	get_user(tmp, &(termio)->c_lflag); \
asm/termios.h:	(termios)->c_lflag = (0xffff0000 & ((termios)->c_lflag)) | tmp; \
asm/termios.h:	get_user((termios)->c_line, &(termio)->c_line); \
asm/termios.h:	copy_from_user((termios)->c_cc, (termio)->c_cc, NCC); \
asm/termios.h:	put_user((termios)->c_iflag, &(termio)->c_iflag); \
asm/termios.h:	put_user((termios)->c_oflag, &(termio)->c_oflag); \
asm/termios.h:	put_user((termios)->c_cflag, &(termio)->c_cflag); \
asm/termios.h:	put_user((termios)->c_lflag, &(termio)->c_lflag); \
asm/termios.h:	put_user((termios)->c_line, &(termio)->c_line); \
asm/termios.h:	copy_to_user((termio)->c_cc, (termios)->c_cc, NCC); \
asm/titan_dep.h: * Copyright 2003 PMC-Sierra
asm/titan_dep.h: * Author: Manish Lachwani (lachwani@pmc-sierra.com)
asm/titan_dep.h: * Board specific definititions for the PMC-Sierra Yosemite
asm/au1000_gpio.h:#define NOT_AVAIL		(-1)
asm/au1000_gpio.h:#define MINOR_TO_GPIOPIN(minor)		((minor < AU1X00_MAX_PRIMARY_GPIO) ? minor : (minor - AU1X00_MAX_PRIMARY_GPIO))
asm/au1000_gpio.h: * GPIO0-GPIO31, minor=0-31.
asm/au1000_gpio.h: * GPIO200-GPIO215, minor=32-47.
asm/au1000_gpio.h:	int data;	// Pin output when itized (0/1), or at the term. 0/1/-1 (tristate).
asm/user.h: * linux we use the `trad-core' bfd, NOT the irix-core).  The file
asm/user.h: *  data: The data segment follows next.  We use current->end_text to
asm/user.h: *	current->brk to pick up all of the user variables, plus any memory
asm/user.h: *	page is demand-zero or if a page is totally unused, we just cover
asm/user.h: *	current->start_stack, so we round each of these in order to be able
asm/paccess.h: * by sending a DBE error like accessing possibly non-existant memory or
asm/paccess.h:	".word\t1b-4,3b\n\t" \
asm/paccess.h:	:"o" (__mp(__gu_addr)), "i" (-EFAULT)); })
asm/paccess.h:	".word\t1b-4,3b\n\t" \
asm/paccess.h:	:"r" (__pu_val), "o" (__mp(__pu_addr)), "i" (-EFAULT)); })
asm/vr4181/irq.h:   IP0 - Software interrupt
asm/vr4181/irq.h:   IP1 - Software interrupt
asm/vr4181/irq.h:   IP2 - All but battery, high speed modem, and real time clock
asm/vr4181/irq.h:   IP3 - RTC Long1 (system timer)
asm/vr4181/irq.h:   IP4 - RTC Long2
asm/vr4181/irq.h:   IP5 - High Speed Modem (unused on VR4181)
asm/vr4181/irq.h:   IP6 - Unused
asm/vr4181/irq.h:   IP7 - Timer interrupt from CPO_COMPARE
asm/vr4181/irq.h:   IP2 - same as VR4181_IRQ_INT1
asm/vr4181/irq.h:   IP8 - This is a cascade to GPIO IRQ's. Do not use.
asm/vr4181/irq.h:   IP16 - same as VR4181_IRQ_INT2
asm/vr4181/irq.h:   IP18 - CompactFlash
asm/vr4181/vr4181.h:#define VR4181_MISCREG0		__preg16(KSEG1 + 0x0B000330)	/* Misc. R/W Battery Backed Registers for Non-Volatile Storage (R/W) */
asm/vr4181/vr4181.h:#define VR4181_MISCREG1		__preg16(KSEG1 + 0x0B000332)	/* Misc. R/W Battery Backed Registers for Non-Volatile Storage (R/W) */
asm/vr4181/vr4181.h:#define VR4181_MISCREG2		__preg16(KSEG1 + 0x0B000334)	/* Misc. R/W Battery Backed Registers for Non-Volatile Storage (R/W) */
asm/vr4181/vr4181.h:#define VR4181_MISCREG3		__preg16(KSEG1 + 0x0B000336)	/* Misc. R/W Battery Backed Registers for Non-Volatile Storage (R/W) */
asm/vr4181/vr4181.h:#define VR4181_MISCREG4		__preg16(KSEG1 + 0x0B000338)	/* Misc. R/W Battery Backed Registers for Non-Volatile Storage (R/W) */
asm/vr4181/vr4181.h:#define VR4181_MISCREG5		__preg16(KSEG1 + 0x0B00033A)	/* Misc. R/W Battery Backed Registers for Non-Volatile Storage (R/W) */
asm/vr4181/vr4181.h:#define VR4181_MISCREG6		__preg16(KSEG1 + 0x0B00033C)	/* Misc. R/W Battery Backed Registers for Non-Volatile Storage (R/W) */
asm/vr4181/vr4181.h:#define VR4181_MISCREG7		__preg16(KSEG1 + 0x0B00033D)	/* Misc. R/W Battery Backed Registers for Non-Volatile Storage (R/W) */
asm/vr4181/vr4181.h:#define VR4181_MISCREG8		__preg16(KSEG1 + 0x0B000340)	/* Misc. R/W Battery Backed Registers for Non-Volatile Storage (R/W) */
asm/vr4181/vr4181.h:#define VR4181_MISCREG9		__preg16(KSEG1 + 0x0B000342)	/* Misc. R/W Battery Backed Registers for Non-Volatile Storage (R/W) */
asm/vr4181/vr4181.h:#define VR4181_MISCREG10	__preg16(KSEG1 + 0x0B000344)	/* Misc. R/W Battery Backed Registers for Non-Volatile Storage (R/W) */
asm/vr4181/vr4181.h:#define VR4181_MISCREG11	__preg16(KSEG1 + 0x0B000346)	/* Misc. R/W Battery Backed Registers for Non-Volatile Storage (R/W) */
asm/vr4181/vr4181.h:#define VR4181_MISCREG12	__preg16(KSEG1 + 0x0B000348)	/* Misc. R/W Battery Backed Registers for Non-Volatile Storage (R/W) */
asm/vr4181/vr4181.h:#define VR4181_MISCREG13	__preg16(KSEG1 + 0x0B00034A)	/* Misc. R/W Battery Backed Registers for Non-Volatile Storage (R/W) */
asm/vr4181/vr4181.h:#define VR4181_MISCREG14	__preg16(KSEG1 + 0x0B00034C)	/* Misc. R/W Battery Backed Registers for Non-Volatile Storage (R/W) */
asm/vr4181/vr4181.h:#define VR4181_MISCREG15	__preg16(KSEG1 + 0x0B00034E)	/* Misc. R/W Battery Backed Registers for Non-Volatile Storage (R/W) */
asm/vr4181/vr4181.h:#define VR4181_SIUCSEL_2	__preg8(KSEG1 + 0x0C00000A)	/* IrDA Echo-back Control (R/W) */
asm/vr41xx/e55.h: *	include/asm-mips/vr41xx/e55.h
asm/vr41xx/e55.h: *	Include file for CASIO CASSIOPEIA E-10/15/55/65.
asm/vr41xx/eagle.h: *	include/asm-mips/vr41xx/eagle.h
asm/vr41xx/eagle.h: * Copyright 2001-2003 MontaVista Software Inc.
asm/vr41xx/eagle.h: * General-Purpose I/O Pin Number
asm/vr41xx/capcella.h: *	include/asm-mips/vr41xx/capcella.h
asm/vr41xx/capcella.h: * General-Purpose I/O Pin Number
asm/vr41xx/workpad.h: *	include/asm-mips/vr41xx/workpad.h
asm/vr41xx/mpc30x.h: *	include/asm-mips/vr41xx/mpc30x.h
asm/vr41xx/mpc30x.h: *	Include file for Victor MP-C303/304.
asm/vr41xx/mpc30x.h: * General-Purpose I/O Pin Number
asm/vr41xx/vr41xx.h: * include/asm-mips/vr41xx/vr41xx.h
asm/vr41xx/vr41xx.h:/* VR4122 0x00000c70-0x00000c72 */
asm/vr41xx/vr41xx.h:/* VR4181A 0x00000c73-0x00000c7f */
asm/vr41xx/vr41xx.h:/* VR4131 0x00000c80-0x00000c83 */
asm/vr41xx/vr41xx.h:/* VR4133 0x00000c84- */
asm/vr41xx/vr41xx.h:#define GIU_IRQ(x)		(GIU_IRQ_BASE + (x))	/* IRQ 40-71 */
asm/vr41xx/vr41xx.h:#define GIU_IRQ_TO_PIN(x)	((x) - GIU_IRQ_BASE)	/* Pin 0-31 */
asm/vr41xx/vr41xx.h: * General-Purpose I/O Unit
asm/vr41xx/vrc4171.h: *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
asm/vr41xx/vrc4173.h: *	include/asm-mips/vr41xx/vrc4173.h
asm/vr41xx/vrc4173.h: * Copyright 2001-2003 Montavista Software Inc.
asm/vr41xx/vrc4173.h: * General-Purpose I/O Unit
asm/vr41xx/tb0226.h: *	include/asm-mips/vr41xx/tb0226.h
asm/vr41xx/tb0226.h: * General-Purpose I/O Pin Number
asm/vr41xx/tb0229.h: *	include/asm-mips/vr41xx/tb0229.h
asm/vr41xx/tb0229.h: * General-Purpose I/O Pin Number
asm/statfs.h:	long		f_frsize;	/* Fragment size - unsupported */
asm/serial.h:#include <asm/mips-boards/atlas.h>
asm/serial.h:#include <asm/mips-boards/atlasint.h>
asm/serial.h:#include <asm/mips-boards/sead.h>
asm/serial.h:#include <asm/mips-boards/seadint.h>
asm/serial.h:#include <asm/galileo-boards/ev96100int.h>
asm/serial.h: * Also look in ip27-pci.c:pci_fixuop_ioc3() for some comments on working
asm/pgtable.h:	test_bit(PG_dcache_dirty, &(page)->flags)
asm/pgtable.h:	set_bit(PG_dcache_dirty, &(page)->flags)
asm/pgtable.h:	clear_bit(PG_dcache_dirty, &(page)->flags)
asm/pgtable.h: * - add_wired_entry() add a fixed TLB entry, and move wired register
asm/pgtable.h: * - add_temporary_entry() add a temporary TLB entry. We use TLB entries
asm/pgtable.h:/* Basically we have the same two-level (which is the logical three level
asm/pgtable.h:/* PMD_SHIFT determines the size of the area a second-level page table can map */
asm/pgtable.h:#define PMD_MASK	(~(PMD_SIZE-1))
asm/pgtable.h:/* PGDIR_SHIFT determines what a third-level page table entry can map */
asm/pgtable.h:#define PGDIR_MASK	(~(PGDIR_SIZE-1))
asm/pgtable.h:# define VMALLOC_END	(PKMAP_BASE-2*PAGE_SIZE)
asm/pgtable.h:# define VMALLOC_END	(FIXADDR_START-2*PAGE_SIZE)
asm/pgtable.h:#include <asm/pgtable-bits.h>
asm/pgtable.h:#include <asm/pgtable-64.h>
asm/pgtable.h:#include <asm/pgtable-32.h>
asm/pgtable.h: * The "pgd_xxx()" functions here are trivial for a folded two-level
asm/pgtable.h:	(((address) >> PMD_SHIFT) & (PTRS_PER_PMD-1))
asm/pgtable.h:/* to find an entry in a kernel page-table-directory */
asm/pgtable.h:/* to find an entry in a page-table-directory */
asm/pgtable.h:	return mm->pgd + pgd_index(address);
asm/pgtable.h:/* Find an entry in the second-level page table.. */
asm/pgtable.h:/* Find an entry in the third-level page table.. */
asm/pgtable.h:	       ((address >> PAGE_SHIFT) & (PTRS_PER_PTE - 1));
asm/pgtable.h:#include <asm-generic/pgtable.h>
asm/unaligned.h: * get_unaligned - get value from possibly mis-aligned location
asm/unaligned.h: * e.g. retrieving a u16 value from a location not u16-aligned.
asm/unaligned.h: * put_unaligned - put value to a possibly mis-aligned location
asm/unaligned.h: * e.g. writing a u16 value to a location not u16-aligned.
asm/unaligned.h:	return ptr->x;
asm/unaligned.h:	return ptr->x;
asm/unaligned.h:	return ptr->x;
asm/unaligned.h:	ptr->x = r5;
asm/unaligned.h:	ptr->x = r5;
asm/unaligned.h:	ptr->x = r5;
asm/cacheflush.h: *  - flush_cache_all() flushes entire cache
asm/cacheflush.h: *  - flush_cache_mm(mm) flushes the specified mm context's cache lines
asm/cacheflush.h: *  - flush_cache_page(mm, vmaddr) flushes a single page
asm/cacheflush.h: *  - flush_cache_range(mm, start, end) flushes a range of pages
asm/cacheflush.h: *  - flush_page_to_ram(page) write back kernel page to ram
asm/cacheflush.h: *  - flush_icache_range(start, end) flush a range of instructions
asm/cacheflush.h: *  - flush_cache_sigtramp() flush signal trampoline
asm/cacheflush.h: *  - flush_icache_all() flush the entire instruction cache
asm/cacheflush.h: *  - flush_data_cache_page() flushes a page from the data cache
asm/ddb5074.h: *  include/asm-mips/ddb5074.h -- NEC DDB Vrc-5074 definitions
asm/param.h:    * Ye olde division-by-multiplication trick.
asm/param.h:#  define QUOTIENT ((1UL << (32 - LOG_2_HZ)) * 100)
asm/param.h:   unless you know what you're doing - changing breaks binary compatibility.  */
asm/param.h:#define NOGROUP		(-1)
asm/ds1286.h: * mc146818rtc.h - register definitions for the Real-Time-Clock / CMOS RAM
asm/ds1286.h: * Copyright Torsten Duwe <duwe@informatik.uni-erlangen.de> 1993
asm/mipsregs.h:#define FPU_CSR_RD      0x3     /* towards -Infinity */
asm/mipsregs.h: * physical address space running the 32-bit kernel.  That's none atm :-)
asm/bootinfo.h:#define MACH_GROUP_TITAN       22 /* PMC-Sierra Titan 			    */
asm/bootinfo.h:#define MACH_ACER_PICA_61	0	/* Acer PICA-61 (PICA1)		*/
asm/bootinfo.h:#define MACH_OLIVETTI_M700      2	/* Olivetti M700-10 (-15 ??)    */
asm/bootinfo.h:#define MACH_NEC_DDB5074	0	/* NEC DDB Vrc-5074 */
asm/bootinfo.h:#define MACH_NEC_DDB5476	1	/* NEC DDB Vrc-5476 */
asm/bootinfo.h:#define MACH_NEC_DDB5477	2	/* NEC DDB Vrc-5477 */
asm/bootinfo.h:#define MACH_BAGET201		0	/* BT23-201 */
asm/bootinfo.h:#define MACH_BAGET202		1	/* BT23-202 */
asm/bootinfo.h:#define MACH_TOSHIBA_JMR3927	3	/* JMR-TX3927 CPU/IO board */
asm/bootinfo.h:#define MACH_PB1000		0	/* Au1000-based eval board */
asm/bootinfo.h:#define MACH_PB1100		1	/* Au1100-based eval board */
asm/bootinfo.h:#define MACH_PB1500		2	/* Au1500-based eval board */
asm/bootinfo.h:#define MACH_DB1000		3       /* Au1000-based eval board */
asm/bootinfo.h:#define MACH_DB1100		4       /* Au1100-based eval board */
asm/bootinfo.h:#define MACH_DB1500		5       /* Au1500-based eval board */
asm/bootinfo.h:#define MACH_XXS1500		6       /* Au1500-based eval board */
asm/bootinfo.h:#define MACH_MTX1		7	/* 4G MTX-1 Au1500-based board */
asm/bootinfo.h:#define MACH_PB1550     	9       /* Au1550-based eval board */
asm/bootinfo.h:#define MACH_PB1200     	10      /* Au1200-based eval board */
asm/bootinfo.h:#define MACH_DB1550     	11      /* Au1550-based eval board */
asm/bootinfo.h:#define MACH_DB1200     	12      /* Au1200-based eval board */
asm/bootinfo.h:#define MACH_VICTOR_MPC30X	3	/* Victor MP-C303/304 */
asm/bootinfo.h:#define MACH_CASIO_E55		5	/* CASIO CASSIOPEIA E-10/15/55/65 */
asm/bootinfo.h:#define	MACH_TITAN_YOSEMITE	1 	/* PMC-Sierra Yosemite */
asm/mips-boards/msc01_pci.h:#define MSC01_PCI_HEAD11_OFS		0x2058  /* SubSystem ID, -VendorID */
asm/mips-boards/msc01_pci.h: * FIXME - are these macros specific to Malta and co or to the MSC?  If the
asm/mips-boards/atlasint.h: *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm/mips-boards/atlasint.h: * Atlas registers are memory mapped on 64-bit aligned boundaries and
asm/mips-boards/malta.h: *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm/mips-boards/malta.h: * Defines of the Malta board specific address-MAP, registers, etc.
asm/mips-boards/malta.h: * Malta RTC-device indirect register access.
asm/mips-boards/saa9730_uart.h: *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm/mips-boards/generic.h: * 59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm/mips-boards/generic.h: * Defines of the MIPS boards specific address-MAP, registers, etc.
asm/mips-boards/generic.h:#include <asm/mips-boards/bonito64.h>
asm/mips-boards/seadint.h: *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm/mips-boards/prom.h: *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm/mips-boards/sead.h: *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm/mips-boards/sead.h: * Defines of the SEAD board specific address-MAP, registers, etc.
asm/mips-boards/maltaint.h: *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm/mips-boards/bonito64.h:#define BONITO_BOOT_TOP 		(BONITO_BOOT_BASE+BONITO_BOOT_SIZE-1)
asm/mips-boards/bonito64.h:#define BONITO_FLASH_TOP		(BONITO_FLASH_BASE+BONITO_FLASH_SIZE-1)
asm/mips-boards/bonito64.h:#define BONITO_SOCKET_TOP		(BONITO_SOCKET_BASE+BONITO_SOCKET_SIZE-1)
asm/mips-boards/bonito64.h:#define BONITO_REG_TOP			(BONITO_REG_BASE+BONITO_REG_SIZE-1)
asm/mips-boards/bonito64.h:#define BONITO_DEV_TOP			(BONITO_DEV_BASE+BONITO_DEV_SIZE-1)
asm/mips-boards/bonito64.h:#define BONITO_PCILO_TOP		(BONITO_PCILO_BASE+BONITO_PCILO_SIZE-1)
asm/mips-boards/bonito64.h:#define BONITO_PCIHI_TOP		(BONITO_PCIHI_BASE+BONITO_PCIHI_SIZE-1)
asm/mips-boards/bonito64.h:#define BONITO_PCIIO_TOP		(BONITO_PCIIO_BASE+BONITO_PCIIO_SIZE-1)
asm/mips-boards/bonito64.h:#define BONITO_PCICFG_TOP		(BONITO_PCICFG_BASE+BONITO_PCICFG_SIZE-1)
asm/mips-boards/bonito64.h:/* Added by RPF 11-9-00 */
asm/mips-boards/bonito64.h:/* --- */
asm/mips-boards/bonito64.h:/* GPIO Regs - r/w */
asm/mips-boards/bonito64.h:/* ICU Configuration Regs - r/w */
asm/mips-boards/bonito64.h:/* ICU Enable Regs - IntEn & IntISR are r/o. */
asm/mips-boards/bonito64.h:/* DRAM - sdCfg */
asm/mips-boards/bonito64.h:/* Changed by RPF 11-9-00 */
asm/mips-boards/bonito64.h:/* --- */
asm/mips-boards/bonito64.h:/* Added by RPF 11-9-00 */
asm/mips-boards/bonito64.h:/* --- */
asm/mips-boards/bonito64.h:/* PCI Cache - pciCacheCtrl */
asm/mips-boards/bonito64.h:/* Added by RPF 11-9-00 */
asm/mips-boards/bonito64.h:/* --- */
asm/mips-boards/bonito64.h:#define BONITO_PCIMAP_WINOFFSET(ADDR)	((ADDR) & (BONITO_PCIMAP_WINSIZE - 1))
asm/mips-boards/bonito64.h:#define BONITO_PCIMEMBASECFGSIZE(WIN,SIZE)	(((~((SIZE)-1))>>(BONITO_PCIMEMBASECFG_ASHIFT-BONITO_PCIMEMBASECFG_MEMBASE##WIN##_MASK_SHIFT)) & BONITO_PCIMEMBASECFG_MEMBASE##WIN##_MASK)
asm/mips-boards/bonito64.h:#define BONITO_PCIMEMBASECFGBASE(WIN,BASE)	(((BASE)>>(BONITO_PCIMEMBASECFG_ASHIFT-BONITO_PCIMEMBASECFG_MEMBASE##WIN##_TRANS_SHIFT)) & BONITO_PCIMEMBASECFG_MEMBASE##WIN##_TRANS)
asm/mips-boards/bonito64.h:#define BONITO_PCIMEMBASECFG_SIZE(WIN,CFG)  (((((~(CFG)) & BONITO_PCIMEMBASECFG_MEMBASE##WIN##_MASK)) << (BONITO_PCIMEMBASECFG_ASHIFT - BONITO_PCIMEMBASECFG_MEMBASE##WIN##_MASK_SHIFT)) | BONITO_PCIMEMBASECFG_AMASK)
asm/mips-boards/atlas.h: *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm/mips-boards/atlas.h: * Defines of the Atlas board specific address-MAP, registers, etc.
asm/mips-boards/atlas.h: * Atlas RTC-device indirect register access.
asm/mips-boards/piix4.h: *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm/csb250.h: *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm/gdb-stub.h: * Derived from the stack layout described in asm-mips/stackframe.h
asm/gdb-stub.h:#define GDB_FR_SIZE		((((GDB_FR_CP0_PRID) + 4) + (PTRSIZE-1)) & ~(PTRSIZE-1))
asm/gdb-stub.h: * This is the same as above, but for the high-level
asm/sgialib.h:/* A 32-bit ARC PROM pass arguments and environment as 32-bit pointer.
asm/sgialib.h:/* Simple char-by-char console I/O. */
asm/sgialib.h:/* Running stand-along programs. */
asm/jazzdma.h: * Helpfile for jazzdma.c -- Mips Jazz R4030 DMA controller support
asm/jazzdma.h:#define VDMA_OFFSET(a)          ((unsigned int)(a) & (VDMA_PAGESIZE-1))
asm/sgiarcs.h:#define ROMVECTOR ((struct linux_romvec *) (long)(PROMBLOCK)->romvec)
asm/sgiarcs.h:#define SGIPROM_ROFILE    0x01  /* read-only file */
asm/sgiarcs.h: * Macros for calling a 32-bit ARC implementation from 64-bit code
asm/sgiarcs.h:	long __vec = (long) romvec->dest;				\
asm/sgiarcs.h:	long __vec = (long) romvec->dest;				\
asm/sgiarcs.h:	long __vec = (long) romvec->dest;				\
asm/sgiarcs.h:	long __vec = (long) romvec->dest;				\
asm/sgiarcs.h:	long __vec = (long) romvec->dest;				\
asm/sgiarcs.h:	long __vec = (long) romvec->dest;				\
asm/sgiarcs.h:	long (*__vec)(void) = (void *) romvec->dest;			\
asm/sgiarcs.h:	long (*__vec)(long) = (void *) romvec->dest;			\
asm/sgiarcs.h:	long (*__vec)(long, long) = (void *) romvec->dest;		\
asm/sgiarcs.h:	long (*__vec)(long, long, long)	= (void *) romvec->dest;	\
asm/sgiarcs.h:	long (*__vec)(long, long, long, long) = (void *) romvec->dest;	\
asm/sgiarcs.h:	__vec = (void *) romvec->dest;					\
asm/sgiarcs.h:#endif /* both kernel and ARC either 32-bit or 64-bit */
asm/siginfo.h:#define SI_PAD_SIZE	((SI_MAX_SIZE/sizeof(int)) - 3)
asm/siginfo.h:#define SI_PAD_SIZE	((SI_MAX_SIZE/sizeof(int)) - 4)
asm/siginfo.h:	int __pad0[SI_MAX_SIZE / sizeof(int) - SI_PAD_SIZE - 3];
asm/siginfo.h:#define SI_QUEUE	-1	/* sent by sigqueue */
asm/siginfo.h:#define SI_ASYNCIO	-2	/* sent by AIO completion */
asm/siginfo.h:#define SI_TIMER __SI_CODE(__SI_TIMER,-3) /* sent by timer expiration */
asm/siginfo.h:#define SI_MESGQ	-4	/* sent by real time mesq state change */
asm/siginfo.h:#define SI_SIGIO	-5	/* sent by queued SIGIO */
asm/siginfo.h:#define SI_TKILL	-6	/* sent by tkill system call */
asm/siginfo.h:#define SI_FROMUSER(siptr)	((siptr)->si_code <= 0)
asm/siginfo.h:#define SI_FROMKERNEL(siptr)	((siptr)->si_code > 0)
asm/siginfo.h:#define BUS_ADRERR	(__SI_FAULT|2)	/* non-existant physical address */
asm/siginfo.h:#define SIGEV_PAD_SIZE	((SIGEV_MAX_SIZE-SIGEV_HEAD_SIZE) / sizeof(int))
asm/siginfo.h:	if (from->si_code < 0)
asm/siginfo.h:		memcpy(to, from, 3*sizeof(int) + sizeof(from->_sifields._sigchld));
asm/floppy.h: * Copyright (C) 1995 - 2000 Ralf Baechle
asm/floppy.h:#define fd_inb(port)		fd_ops->fd_inb(port)
asm/floppy.h:#define fd_outb(value,port)	fd_ops->fd_outb(value,port)
asm/floppy.h:#define fd_enable_dma()		fd_ops->fd_enable_dma(FLOPPY_DMA)
asm/floppy.h:#define fd_disable_dma()	fd_ops->fd_disable_dma(FLOPPY_DMA)
asm/floppy.h:#define fd_request_dma()	fd_ops->fd_request_dma(FLOPPY_DMA)
asm/floppy.h:#define fd_free_dma()		fd_ops->fd_free_dma(FLOPPY_DMA)
asm/floppy.h:#define fd_clear_dma_ff()	fd_ops->fd_clear_dma_ff(FLOPPY_DMA)
asm/floppy.h:#define fd_set_dma_mode(mode)	fd_ops->fd_set_dma_mode(FLOPPY_DMA, mode)
asm/floppy.h:#define fd_set_dma_addr(addr)	fd_ops->fd_set_dma_addr(FLOPPY_DMA, \
asm/floppy.h:#define fd_set_dma_count(count)	fd_ops->fd_set_dma_count(FLOPPY_DMA,count)
asm/floppy.h:#define fd_get_dma_residue()	fd_ops->fd_get_dma_residue(FLOPPY_DMA)
asm/floppy.h:#define fd_enable_irq()		fd_ops->fd_enable_irq(FLOPPY_IRQ)
asm/floppy.h:#define fd_disable_irq()	fd_ops->fd_disable_irq(FLOPPY_IRQ)
asm/floppy.h:#define fd_dma_mem_alloc(size)	fd_ops->fd_dma_mem_alloc(size)
asm/floppy.h:#define fd_dma_mem_free(mem,size) fd_ops->fd_dma_mem_free(mem,size)
asm/floppy.h:#define fd_drive_type(n)	fd_ops->fd_drive_type(n)
asm/floppy.h:#define FDC1			fd_ops->fd_getfdaddr1();
asm/floppy.h:#define CROSS_64KB(a,s) ((unsigned long)(a)/K_64 != ((unsigned long)(a) + (s) - 1) / K_64)
asm/irq_cpu.h: *	include/asm-mips/irq_cpu.h
asm/sockios.h: * Socket-level I/O control calls.
asm/sockios.h:/* Socket-level I/O control calls. */
asm/sockios.h:#define SIOCGSTAMP	0x8906			/* Get stamp - linux-specific */
asm/keyboard.h: * Copyright (C) 1994 - 1999 Ralf Baechle
asm/keyboard.h:#define kbd_request_region() kbd_ops->kbd_request_region()
asm/keyboard.h:#define kbd_request_irq(handler) kbd_ops->kbd_request_irq(handler)
asm/keyboard.h:#define aux_request_irq(hand, dev_id) kbd_ops->aux_request_irq(hand)
asm/keyboard.h:#define aux_free_irq(dev_id) kbd_ops->aux_free_irq()
asm/keyboard.h:#define kbd_read_input() kbd_ops->kbd_read_input()
asm/keyboard.h:#define kbd_write_output(val) kbd_ops->kbd_write_output(val)
asm/keyboard.h:#define kbd_write_command(val) kbd_ops->kbd_write_command(val)
asm/keyboard.h:#define kbd_read_status() kbd_ops->kbd_read_status()
asm/ioctl.h:#define _IOC_NRMASK	((1 << _IOC_NRBITS)-1)
asm/ioctl.h:#define _IOC_TYPEMASK	((1 << _IOC_TYPEBITS)-1)
asm/ioctl.h:#define _IOC_SIZEMASK	((1 << _IOC_SIZEBITS)-1)
asm/ioctl.h:#define _IOC_DIRMASK	((1 << _IOC_DIRBITS)-1)
asm/au1100_mmc.h: * From "AMD Alchemy Solutions Au1100 Processor Data Book - Preliminary"
asm/au1100_mmc.h:/* support routines required on a platform-specific basis */
asm/string.h:		"lbu\t$1,-1(%0)\n\t"
asm/break.h: * non-Linux/MIPS object files or make use of them in the future.
asm/break.h:#define BRK_BD_TAKEN	3	/* For bd slot emulation - not implemented */
asm/break.h:#define BRK_BD_NOTTAKEN	4	/* For bd slot emulation - not implemented */
asm/break.h:#define BRK_NORLD	10	/* No rld found - not used by Linux/MIPS */
asm/ioctls.h:						/* 127-124 compat */
asm/ioctls.h:#define TIOCGPTN	_IOR('T',0x30, unsigned int) /* Get Pty Number (of pty-mux device) */
asm/msgbuf.h: * - extension of time_t to 64-bit on 32-bitsystem to solve the y2038 problem
asm/msgbuf.h: * - 2 miscellaneous unsigned long values
asm/pci_channel.h: * Each pci channel is a top-level PCI bus seem by CPU.  A machine  with
asm/bcache.h:/* Some R4000 / R4400 / R4600 / R5000 machines may have a non-dma-coherent,
asm/bcache.h:	bcops->bc_enable();
asm/bcache.h:	bcops->bc_disable();
asm/bcache.h:	bcops->bc_wback_inv(page, size);
asm/bcache.h:	bcops->bc_inv(page, size);
asm/regdef.h: * include/asm-mips/regdefs.h
asm/regdef.h:#define AT      $1      /* assembler temp  - uppercase because of ".set at" */
asm/socket.h:#define SO_OOBINLINE 0x0100	/* Receive out-of-band data in-band.  */
asm/socket.h:#define SO_SNDLOWAT	0x1003	/* send low-water mark */
asm/socket.h:#define SO_RCVLOWAT	0x1004	/* receive low-water mark */
asm/socket.h:/* linux-specific, might as well be the same as on i386 */
asm/socket.h:/* Security levels - as per NRL IPv6 - don't actually do anything */
asm/socket.h:/* Nast libc5 fixup - bletch */
asm/socket.h:#define SOCK_RDM	4		/* reliably-delivered message	*/
asm-alpha/io.h: * Virtual -> physical identity mapping starts at this offset
asm-alpha/io.h: * register not being up-to-date with respect to the hardware
asm-alpha/io.h:	/* Re-read to make sure it was written.  */
asm-alpha/io.h:	return (unsigned long)address - IDENT_ADDR;
asm-alpha/io.h:	/* Sign-extend from bit 41.  */
asm-alpha/io.h:	phys <<= (64 - 41);
asm-alpha/io.h:	phys = (long)phys >> (64 - 41);
asm-alpha/io.h:        phys &= (1ul << hwrpb->pa_bits) - 1;
asm-alpha/io.h:        return (void *)(IDENT_ADDR + (address & ((1ul << 41) - 1)));
asm-alpha/io.h:	address -= __direct_map_base;
asm-alpha/io.h: * Define actual functions in private name-space so it's easier to
asm-alpha/io.h: * discontiguous set of I/O pages. This set of pages is scatter-gather
asm-alpha/io.h: * XXX - We don't have csum_partial_copy_fromio() yet, so we cheat here and 
asm-alpha/io.h:  memcpy_fromio((skb)->data,(src),(len))
asm-alpha/io.h:  isa_memcpy_fromio((skb)->data,(src),(len))
asm-alpha/io.h:		length--;
asm-alpha/io.h: * ISA space is mapped to some machine-specific location on Alpha.
asm-alpha/io.h:		length--;
asm-alpha/atomic.h:#define atomic_read(v)		((v)->counter)
asm-alpha/atomic.h:#define atomic_set(v,i)		((v)->counter = (i))
asm-alpha/atomic.h:	:"=&r" (temp), "=m" (v->counter)
asm-alpha/atomic.h:	:"Ir" (i), "m" (v->counter));
asm-alpha/atomic.h:	:"=&r" (temp), "=m" (v->counter)
asm-alpha/atomic.h:	:"Ir" (i), "m" (v->counter));
asm-alpha/atomic.h:	:"=&r" (temp), "=m" (v->counter), "=&r" (result)
asm-alpha/atomic.h:	:"Ir" (i), "m" (v->counter) : "memory");
asm-alpha/atomic.h:	:"=&r" (temp), "=m" (v->counter), "=&r" (result)
asm-alpha/atomic.h:	:"Ir" (i), "m" (v->counter) : "memory");
asm-alpha/ipcbuf.h: * - 32-bit seq
asm-alpha/ipcbuf.h: * - 2 miscellaneous 64-bit values
asm-alpha/core_irongate.h: * IRONGATE is the internal name for the AMD-751 K7 core logic chipset
asm-alpha/core_irongate.h: * which provides memory controller and PCI access for NAUTILUS-based
asm-alpha/core_irongate.h: * The 21264 supports, and internally recognizes, a 44-bit physical
asm-alpha/core_irongate.h: * through the routines given is 32-bit.
asm-alpha/core_irongate.h:	igcsr32 dev_vendor;		/* 0x00 - device ID, vendor ID */
asm-alpha/core_irongate.h:	igcsr32 stat_cmd;		/* 0x04 - status, command */
asm-alpha/core_irongate.h:	igcsr32 class;			/* 0x08 - class code, rev ID */
asm-alpha/core_irongate.h:	igcsr32 latency;		/* 0x0C - header type, PCI latency */
asm-alpha/core_irongate.h:	igcsr32 bar0;			/* 0x10 - BAR0 - AGP */
asm-alpha/core_irongate.h:	igcsr32 bar1;			/* 0x14 - BAR1 - GART */
asm-alpha/core_irongate.h:	igcsr32 bar2;			/* 0x18 - Power Management reg block */
asm-alpha/core_irongate.h:	igcsr32 rsrvd0[6];		/* 0x1C-0x33 reserved */
asm-alpha/core_irongate.h:	igcsr32 capptr;			/* 0x34 - Capabilities pointer */
asm-alpha/core_irongate.h:	igcsr32 rsrvd1[2];		/* 0x38-0x3F reserved */
asm-alpha/core_irongate.h:	igcsr32 bacsr10;		/* 0x40 - base address chip selects */
asm-alpha/core_irongate.h:	igcsr32 bacsr32;		/* 0x44 - base address chip selects */
asm-alpha/core_irongate.h:	igcsr32 bacsr54_eccms761;	/* 0x48 - 751: base addr. chip selects
asm-alpha/core_irongate.h:	igcsr32 rsrvd2[1];		/* 0x4C-0x4F reserved */
asm-alpha/core_irongate.h:	igcsr32 drammap;		/* 0x50 - address mapping control */
asm-alpha/core_irongate.h:	igcsr32 dramtm;			/* 0x54 - timing, driver strength */
asm-alpha/core_irongate.h:	igcsr32 dramms;			/* 0x58 - DRAM mode/status */
asm-alpha/core_irongate.h:	igcsr32 rsrvd3[1];		/* 0x5C-0x5F reserved */
asm-alpha/core_irongate.h:	igcsr32 biu0;			/* 0x60 - bus interface unit */
asm-alpha/core_irongate.h:	igcsr32 biusip;			/* 0x64 - Serial initialisation pkt */
asm-alpha/core_irongate.h:	igcsr32 rsrvd4[2];		/* 0x68-0x6F reserved */
asm-alpha/core_irongate.h:	igcsr32 mro;			/* 0x70 - memory request optimiser */
asm-alpha/core_irongate.h:	igcsr32 rsrvd5[3];		/* 0x74-0x7F reserved */
asm-alpha/core_irongate.h:	igcsr32 whami;			/* 0x80 - who am I */
asm-alpha/core_irongate.h:	igcsr32 pciarb;			/* 0x84 - PCI arbitration control */
asm-alpha/core_irongate.h:	igcsr32 pcicfg;			/* 0x88 - PCI config status */
asm-alpha/core_irongate.h:	igcsr32 rsrvd6[4];		/* 0x8C-0x9B reserved */
asm-alpha/core_irongate.h:	igcsr32 pci_mem;		/* 0x9C - PCI top of memory,
asm-alpha/core_irongate.h:	igcsr32 agpcap;			/* 0xA0 - AGP Capability Identifier */
asm-alpha/core_irongate.h:	igcsr32 agpstat;		/* 0xA4 - AGP status register */
asm-alpha/core_irongate.h:	igcsr32 agpcmd;			/* 0xA8 - AGP control register */
asm-alpha/core_irongate.h:	igcsr32 agpva;			/* 0xAC - AGP Virtual Address Space */
asm-alpha/core_irongate.h:	igcsr32 agpmode;		/* 0xB0 - AGP/GART mode control */
asm-alpha/core_irongate.h:	igcsr32 dev_vendor;		/* 0x00 - Device and Vendor IDs */
asm-alpha/core_irongate.h:	igcsr32 stat_cmd;		/* 0x04 - Status and Command regs */
asm-alpha/core_irongate.h:	igcsr32 class;			/* 0x08 - subclass, baseclass etc */
asm-alpha/core_irongate.h:	igcsr32 htype;			/* 0x0C - header type (at 0x0E) */
asm-alpha/core_irongate.h:	igcsr32 rsrvd0[2];		/* 0x10-0x17 reserved */
asm-alpha/core_irongate.h:	igcsr32 busnos;			/* 0x18 - Primary, secondary bus nos */
asm-alpha/core_irongate.h:	igcsr32 io_baselim_regs;	/* 0x1C - IO base, IO lim, AGP status */
asm-alpha/core_irongate.h:	igcsr32	mem_baselim;		/* 0x20 - memory base, memory lim */
asm-alpha/core_irongate.h:	igcsr32 pfmem_baselim;		/* 0x24 - prefetchable base, lim */
asm-alpha/core_irongate.h:	igcsr32 rsrvd1[2];		/* 0x28-0x2F reserved */
asm-alpha/core_irongate.h:	igcsr32 io_baselim;		/* 0x30 - IO base, IO limit */
asm-alpha/core_irongate.h:	igcsr32 rsrvd2[2];		/* 0x34-0x3B - reserved */
asm-alpha/core_irongate.h:	igcsr32 interrupt;		/* 0x3C - interrupt, PCI bridge ctrl */
asm-alpha/core_irongate.h: *                  ---bus numer---   -device-- -fun-   ---register----
asm-alpha/core_irongate.h:	__u32 CpuOffset;                 /* Offset to CPU-specific into */
asm-alpha/core_irongate.h:	__u32 SystemOffset;              /* Offset to system-specific info */
asm-alpha/core_irongate.h: * IRONGATE (AMD-751) PCI/memory support chip for the EV6 (21264) and
asm-alpha/parport.h: * parport.h: platform-specific PC-style parport initialisation
asm-alpha/shmbuf.h: * - 2 miscellaneous 64-bit values
asm-alpha/sfp-machine.h:/* Machine-dependent software floating-point definitions.
asm-alpha/sfp-machine.h:   59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
asm-alpha/bitops.h: * These have to be done with inline assembly: that way the bit-setting
asm-alpha/bitops.h:	x = ~x & -~x;		/* set first 0 bit, clear others */
asm-alpha/bitops.h:	return 63 - bit;
asm-alpha/bitops.h:	for (bit = -1; word ; bit++)
asm-alpha/bitops.h: * of bits set) of a N-bit word
asm-alpha/bitops.h:	size -= result;
asm-alpha/bitops.h:		tmp |= ~0UL >> (64-offset);
asm-alpha/bitops.h:		size -= 64;
asm-alpha/bitops.h:		size -= 64;
asm-alpha/div64.h: * Hey, we're already 64-bit, no
asm-alpha/resource.h:#define RLIMIT_MEMLOCK	9		/* max locked-in-memory address space */
asm-alpha/ptrace.h: *  - floating point regs: the kernel doesn't change those
asm-alpha/ptrace.h: *  - r9-15: saved by the C compiler
asm-alpha/ptrace.h:/* JRP - These are the values provided to a0-a2 by PALcode */
asm-alpha/ptrace.h:/* These are saved by PAL-code: */
asm-alpha/ptrace.h:#define user_mode(regs) (((regs)->ps & 8) != 0)
asm-alpha/ptrace.h:#define instruction_pointer(regs) ((regs)->pc)
asm-alpha/ptrace.h:  ((struct pt_regs *)((long)(task) + 2*PAGE_SIZE) - 1)
asm-alpha/ptrace.h:#define force_successful_syscall_return() (alpha_task_regs(current)->r0 = 0)
asm-alpha/pgalloc.h:/* Caches aren't brain-dead on the Alpha. */
asm-alpha/pgalloc.h:	long * mmc = &mm->context[smp_processor_id()];
asm-alpha/pgalloc.h:	if (vma->vm_flags & VM_EXEC) {
asm-alpha/pgalloc.h:		struct mm_struct *mm = vma->vm_mm;
asm-alpha/pgalloc.h:		if (current->active_mm == mm)
asm-alpha/pgalloc.h:			mm->context[smp_processor_id()] = 0;
asm-alpha/pgalloc.h:	if (vma->vm_flags & VM_EXEC) {
asm-alpha/pgalloc.h:	if (vma->vm_flags & VM_EXEC)
asm-alpha/pgalloc.h:	flush_tlb_current(current->active_mm);
asm-alpha/pgalloc.h:	if (mm == current->active_mm)
asm-alpha/pgalloc.h: * Page-granular tlb flush.
asm-alpha/pgalloc.h:	struct mm_struct * mm = vma->vm_mm;
asm-alpha/pgalloc.h:	if (mm == current->active_mm)
asm-alpha/pgalloc.h: * used to allocate a kernel page table - this turns on ASN bits
asm-alpha/pgalloc.h:		pgtable_cache_size--;
asm-alpha/pgalloc.h:		pgtable_cache_size--;
asm-alpha/pgalloc.h:		pgtable_cache_size--;
asm-alpha/unistd.h: * Linux-specific system calls begin at 300
asm-alpha/unistd.h:	return (_sc_err ? errno = _sc_ret, _sc_ret = -1L : 0), (type) _sc_ret
asm-alpha/unistd.h:	return waitpid(-1,wait_stat,0);
asm-alpha/dma.h: * include/asm-alpha/dma.h
asm-alpha/dma.h: * use ISA-compatible dma.  The only extension is support for high-page
asm-alpha/dma.h: * registers that allow to set the top 8 bits of a 32-bit DMA address.
asm-alpha/dma.h: *  controller 1: channels 0-3, byte operations, ports 00-1F
asm-alpha/dma.h: *  controller 2: channels 4-7, word operations, ports C0-DF
asm-alpha/dma.h: *  - ALL registers are 8 bits only, regardless of transfer size
asm-alpha/dma.h: *  - channel 4 is not used - cascades 1 into 2.
asm-alpha/dma.h: *  - channels 0-3 are byte - addresses/counts are for physical bytes
asm-alpha/dma.h: *  - channels 5-7 are word - addresses/counts are for physical words
asm-alpha/dma.h: *  - transfers must not cross physical 64K (0-3) or 128K (5-7) boundaries
asm-alpha/dma.h: *  - transfer count loaded to registers is 1 less than actual count
asm-alpha/dma.h: *  - controller 2 offsets are all even (2x offsets for controller 1)
asm-alpha/dma.h: *  - page registers for 5-7 don't use data bit 0, represent 128K pages
asm-alpha/dma.h: *  - page registers for 0-3 use bit 0, represent 64K pages
asm-alpha/dma.h: *  Address mapping for channels 0-3:
asm-alpha/dma.h: *  Address mapping for channels 5-7:
asm-alpha/dma.h: * Again, channels 5-7 transfer _physical_ words (16 bits), so addresses
asm-alpha/dma.h: * and counts _must_ be word-aligned (the lowest address bit is _ignored_ at
asm-alpha/dma.h: * the hardware level, so odd-byte transfers aren't possible).
asm-alpha/dma.h: * count - 1 : 64K => 0xFFFF, 1 => 0x0000.  Thus, count is always 1 or more,
asm-alpha/dma.h: * and up to 128K bytes may be transferred on channels 5-7 in one operation. 
asm-alpha/dma.h:  These may be due to SIO (PCI<->ISA bridge) chipset limitation, or
asm-alpha/dma.h:  Maximum address for all the others is the complete 32-bit bus
asm-alpha/dma.h:#define DMA1_MASK_REG		0x0A	/* single-channel mask (w) */
asm-alpha/dma.h:#define DMA1_CLEAR_FF_REG	0x0C	/* clear pointer flip-flop (w) */
asm-alpha/dma.h:#define DMA1_MASK_ALL_REG       0x0F    /* all-channels mask (w) */
asm-alpha/dma.h:#define DMA2_MASK_REG		0xD4	/* single-channel mask (w) */
asm-alpha/dma.h:#define DMA2_CLEAR_FF_REG	0xD8	/* clear pointer flip-flop (w) */
asm-alpha/dma.h:#define DMA2_MASK_ALL_REG       0xDE    /* all-channels mask (w) */
asm-alpha/dma.h:#define DMA_MODE_CASCADE 0xC0   /* pass thru DREQ->HRQ, DACK<-HLDA only */
asm-alpha/dma.h: * After that, keep track of it. :-)
asm-alpha/dma.h: * --- In order to do that, the DMA routines below should ---
asm-alpha/dma.h: * --- only be used while interrupts are disabled! ---
asm-alpha/dma.h:	set_dma_page(dmanr, a>>16);	/* set hipage last to enable 32-bit mode */
asm-alpha/dma.h: * Assumes dma flip-flop is clear.
asm-alpha/dma.h: * NOTE 2: "count" represents _bytes_ and must be even for channels 5-7.
asm-alpha/dma.h:        count--;
asm-alpha/dma.h: * Assumes DMA flip-flop is clear.
asm-alpha/dma.h:	/* using short to get 16-bit wrap around */
asm-alpha/elf.h:#define elf_check_arch(x) ((x)->e_machine == EM_ALPHA)
asm-alpha/elf.h:#define ELF_PLAT_INIT(_r, load_addr)	_r->r0 = 0
asm-alpha/elf.h:   convenience.  Re-order them for the linear elf_gregset_t.  */
asm-alpha/elf.h:#define ELF_HWCAP  (~amask(-1))
asm-alpha/gct.h:					 hwrpb->frut_offset + 		\
asm-alpha/fpu.h: * Alpha floating-point control register defines:
asm-alpha/fpu.h:#define FPCR_DYN_MINUS	 (0x1UL << FPCR_DYN_SHIFT)	/* towards -INF */
asm-alpha/fpu.h: * IEEE trap enables are implemented in software.  These per-thread
asm-alpha/fpu.h: * floating-point enable bit (which is architected).  On top of that,
asm-alpha/fpu.h: * receive my thanks for making all the not-implemented fpcr bits
asm-alpha/ide.h: *  linux/include/asm-alpha/ide.h
asm-alpha/ide.h: *  Copyright (C) 1994-1996  Linus Torvalds & authors
asm-alpha/ide.h:		hw->io_ports[i] = reg;
asm-alpha/ide.h:		hw->io_ports[IDE_CONTROL_OFFSET] = ctrl_port;
asm-alpha/ide.h:		hw->io_ports[IDE_CONTROL_OFFSET] = hw->io_ports[IDE_DATA_OFFSET] + 0x206;
asm-alpha/ide.h:	hw->io_ports[IDE_IRQ_OFFSET] = 0;
asm-alpha/ide.h:#include <asm-generic/ide_iops.h>
asm-alpha/irq.h:#  define NR_IRQS	(32768 + 16)	/* marvel - 32 pids */
asm-alpha/irq.h:# define NR_IRQS	(32768 + 16)	/* marvel - 32 pids */
asm-alpha/pal.h: * Common PAL-code
asm-alpha/pal.h: * VMS specific PAL-code
asm-alpha/pal.h: * OSF specific PAL-code
asm-alpha/pci.h:	   that if we report a BWX-capable dense memory, we do not report
asm-alpha/pci.h:/* Override the logic in pci_scan_bus for skipping already-configured
asm-alpha/pci.h:   device.  Returns non-NULL cpu-view pointer to the buffer if
asm-alpha/pci.h:   mode.  The 32-bit PCI bus mastering address to use is returned.
asm-alpha/pci.h:	((PTR)->ADDR_NAME)
asm-alpha/pci.h:	(((PTR)->ADDR_NAME) = (VAL))
asm-alpha/pci.h:	((PTR)->LEN_NAME)
asm-alpha/pci.h:	(((PTR)->LEN_NAME) = (VAL))
asm-alpha/pci.h:   PCI DMA.  This is the scather-gather version of the above
asm-alpha/pci.h:   for a scatter-gather list, same rules and usage.  */
asm-alpha/pci.h:   only drive the low 24-bits during PCI bus mastering, then
asm-alpha/reg.h:#define HWEF_SIZE	(6*8)		/* size of PAL frame (PS-A2) */
asm-alpha/reg.h:#define EF_SSIZE	(EF_SIZE - HWEF_SIZE)
asm-alpha/smp.h:/* HACK: Cabrio WHAMI return value is bogus if more than 8 bits used.. :-( */
asm-alpha/smp.h:   not be idempotent when cpus failed to come on-line.  */
asm-alpha/smp.h:#define smp_processor_id()	(current->processor)
asm-alpha/smp.h:#define NO_PROC_ID	(-1)
asm-alpha/tlb.h:#include <asm-generic/tlb.h>
asm-alpha/xor.h: * include/asm-alpha/xor.h
asm-alpha/xor.h: * Optimized RAID-5 checksumming functions for alpha EV5 and EV6
asm-alpha/xor.h:#include <asm-generic/xor.h>
asm-alpha/signal.h:#define SIGRTMAX	(_NSIG-1)
asm-alpha/signal.h: * SA_INTERRUPT is a no-op, but left due to historical reasons. Use the
asm-alpha/signal.h:#define SA_INTERRUPT	0x20000000 /* dummy -- ignored */
asm-alpha/signal.h:#define SIG_ERR	((__sighandler_t)-1)	/* error return from signal */
asm-alpha/core_wildfire.h: ((wildfire_qsd *)(WILDFIRE_QBB_IO(q)|WILDFIRE_QSD_ENTITY_SLOW|(((1UL<<13)-1)<<23)))
asm-alpha/core_wildfire.h: ((wildfire_fast_qsd *)(WILDFIRE_QBB_IO(0)|WILDFIRE_QSD_ENTITY_FAST|(((1UL<<13)-1)<<23)))
asm-alpha/core_wildfire.h: ((wildfire_qsa *)(WILDFIRE_QBB_IO(q)|WILDFIRE_QSA_ENTITY|(((1UL<<13)-1)<<23)))
asm-alpha/core_wildfire.h: ((wildfire_iop *)(WILDFIRE_QBB_IO(q)|WILDFIRE_IOP_ENTITY|(((1UL<<13)-1)<<23)))
asm-alpha/core_wildfire.h: ((wildfire_gp *)(WILDFIRE_QBB_IO(q)|WILDFIRE_GP_ENTITY|(((1UL<<13)-1)<<23)))
asm-alpha/core_wildfire.h: ((wildfire_pca *)(WILDFIRE_QBB_IO(q)|WILDFIRE_PCA_ENTITY(pca)|(((1UL<<13)-1)<<23)))
asm-alpha/core_wildfire.h: ((wildfire_ne *)(WILDFIRE_QBB_IO(q)|WILDFIRE_PCA_ENTITY(pca)|(((1UL<<13)-1)<<23)|(1UL<<16)))
asm-alpha/core_wildfire.h: ((wildfire_fe *)(WILDFIRE_QBB_IO(q)|WILDFIRE_PCA_ENTITY(pca)|(((1UL<<13)-1)<<23)|(3UL<<15)))
asm-alpha/core_wildfire.h: ((wildfire_pci *)(WILDFIRE_QBB_IO(q)|WILDFIRE_PCA_ENTITY(((h)&6)>>1)|((((h)&1)|2)<<16)|(((1UL<<13)-1)<<23)))
asm-alpha/core_mcpcia.h: * 16-May-96
asm-alpha/core_mcpcia.h:/*------------------------------------------------------------------------**
asm-alpha/core_mcpcia.h:**------------------------------------------------------------------------*/
asm-alpha/core_mcpcia.h: *  ---- ---- ---- ---- ---- ---- ---- ---- ---- ----
asm-alpha/core_mcpcia.h: *  ---- ---- ---- ---- ---- ---- ---- ---- ---- ----
asm-alpha/core_mcpcia.h: *  |                               Byte Enable --+ |
asm-alpha/core_mcpcia.h: *  |                             Transfer Length --+
asm-alpha/core_mcpcia.h: *  +-- IO space, not cached
asm-alpha/core_mcpcia.h: *   ---------------------------------------------
asm-alpha/core_mcpcia.h: * The canonical non-remaped I/O and MEM addresses have these values
asm-alpha/core_mcpcia.h: * scheme, or the so-called byte-word PCI address space, to get at PCI memory
asm-alpha/core_mcpcia.h: * Memory functions.  64-bit and 32-bit accesses are done through
asm-alpha/core_mcpcia.h: * See p 6-17 of the specification but it looks something like this:
asm-alpha/core_mcpcia.h:	hose = hose - MCPCIA_DENSE(4) + MCPCIA_SPARSE(4);
asm-alpha/core_mcpcia.h:	hose = hose - MCPCIA_DENSE(4) + MCPCIA_SPARSE(4);
asm-alpha/core_mcpcia.h:	hose = hose - MCPCIA_DENSE(4) + MCPCIA_SPARSE(4);
asm-alpha/core_mcpcia.h:	hose = hose - MCPCIA_DENSE(4) + MCPCIA_SPARSE(4);
asm-alpha/jensen.h: * not needed for cases like a frame buffer that is essentially memory-like.
asm-alpha/jensen.h: * Handling interrupts that need to do mb's to synchronize to non-interrupts
asm-alpha/jensen.h: * EISA "Host Address Extension" address (bits 25-31 of the EISA address)
asm-alpha/sysinfo.h: * include/asm-alpha/sysinfo.h
asm-alpha/sysinfo.h:   per-thread flags.  */
asm-alpha/hardirq.h:#define irq_exit(cpu, irq)	(local_irq_count(cpu)--)
asm-alpha/hardirq.h:        --local_irq_count(cpu);
asm-alpha/processor.h: * include/asm-alpha/processor.h
asm-alpha/processor.h: * We have a 42-bit user address space: 4TB user VM...
asm-alpha/processor.h:  ((current->personality & ADDR_LIMIT_32BIT) ? 0x40000000 : TASK_SIZE / 2)
asm-alpha/processor.h:	 * The fields below are Linux-specific:
asm-alpha/processor.h: * all.  -- r~
asm-alpha/processor.h:	unsigned long fp, sp = t->ksp, base = (unsigned long)t;
asm-alpha/processor.h:#define PT_REG(reg)	(PAGE_SIZE*2 - sizeof(struct pt_regs)		\
asm-alpha/processor.h:			 + (long)&((struct pt_regs *)0)->reg)
asm-alpha/processor.h:#define SW_REG(reg)	(PAGE_SIZE*2 - sizeof(struct pt_regs)		\
asm-alpha/processor.h:			 - sizeof(struct switch_stack)			\
asm-alpha/processor.h:			 + (long)&((struct switch_stack *)0)->reg)
asm-alpha/processor.h:#define KSTK_ESP(tsk)	((tsk) == current ? rdusp() : (tsk)->thread.usp)
asm-alpha/processor.h:#define get_task_struct(tsk)      atomic_inc(&virt_to_page(tsk)->count)
asm-alpha/compiler.h: * we could test during compilation -- too bad, so sad.
asm-alpha/linux_logo.h: * include/asm-alpha/linux_logo.h: This is a linux logo
asm-alpha/mmu_context.h: * but the PAL-code doesn't actually use this information.  On the
asm-alpha/mmu_context.h: * On the EV4, the ASNs are more-or-less useless anyway, as they are
asm-alpha/mmu_context.h: * work correctly and can thus not be used (explaining the lack of PAL-code
asm-alpha/mmu_context.h: * +-------------+----------------+--------------+
asm-alpha/mmu_context.h: * +-------------+----------------+--------------+
asm-alpha/mmu_context.h:#define HARDWARE_ASN_MASK ((1UL << WIDTH_HARDWARE_ASN) - 1)
asm-alpha/mmu_context.h: * the "mm->context") are the ASN _version_ code. A version of 0 is
asm-alpha/mmu_context.h: * need to do "p->mm->context = 0".
asm-alpha/mmu_context.h:	mmc = next_mm->context[cpu];
asm-alpha/mmu_context.h:		next_mm->context[cpu] = mmc;
asm-alpha/mmu_context.h:	   a new mm->context (via flush_tlb_mm) without the ASN serial
asm-alpha/mmu_context.h:	next->thread.asn = mmc & HARDWARE_ASN_MASK;
asm-alpha/mmu_context.h:	   optimize for switching between threads -- if the mm is
asm-alpha/mmu_context.h:	   I'm going to leave this here anyway, just to Be Sure.  -- r~  */
asm-alpha/mmu_context.h:		struct mm_struct * mm = current->active_mm;	\
asm-alpha/mmu_context.h:		if (!mm->context[cpu])			\
asm-alpha/mmu_context.h:		mm->context[cpu_logical_map(i)] = 0;
asm-alpha/mmu_context.h:        tsk->thread.ptbr = ((unsigned long)mm->pgd - IDENT_ADDR) >> PAGE_SHIFT;
asm-alpha/mmu_context.h:	tsk->thread.ptbr = ((unsigned long)mm->pgd - IDENT_ADDR) >> PAGE_SHIFT;
asm-alpha/semaphore.h: * SMP- and interrupt-safe semaphores..
asm-alpha/semaphore.h:	atomic_t waking;		/* biased by -1 */
asm-alpha/semaphore.h:	{ ATOMIC_INIT(count), ATOMIC_INIT(-1),		\
asm-alpha/semaphore.h:	atomic_set(&sem->count, val);
asm-alpha/semaphore.h:	atomic_set(&sem->waking, -1);
asm-alpha/semaphore.h:	init_waitqueue_head(&sem->wait);
asm-alpha/semaphore.h:	sem->__magic = (long)&sem->__magic;
asm-alpha/semaphore.h:	return atomic_read(&sem->count);
asm-alpha/semaphore.h:	long count = atomic_dec_return(&sem->count);
asm-alpha/semaphore.h:	long count = atomic_dec_return(&sem->count);
asm-alpha/semaphore.h: * Do this by using ll/sc on the pair of 32-bit words.
asm-alpha/semaphore.h:		tmp -= sub;
asm-alpha/fcntl.h:/* open/fcntl - O_SYNC is only implemented on blocks devices and on files
asm-alpha/fcntl.h:#define O_DIRECT	02000000 /* direct disk access - should check with OSF/1 */
asm-alpha/fcntl.h:#define F_GETFL		3	/* get file->f_flags */
asm-alpha/fcntl.h:#define F_SETFL		4       /* set file->f_flags */
asm-alpha/core_polaris.h: * 22-Jan-98
asm-alpha/core_polaris.h: * so-called byte-word PCI address space, to get at PCI memory and I/O.
asm-alpha/mmzone.h:	(PLAT_NODE_DATA(n)->gendata.node_start_mapnr)
asm-alpha/mmzone.h:#define PLAT_NODE_DATA_SIZE(n)		(PLAT_NODE_DATA(n)->gendata.node_size)
asm-alpha/mmzone.h:	(((p) - PLAT_NODE_DATA(n)->gendata.node_start_paddr) >> PAGE_SHIFT)
asm-alpha/mmzone.h:	temp = p - PLAT_NODE_DATA(n)->gendata.node_start_paddr;
asm-alpha/mmzone.h:#define NODE_DATA(n)	(&((PLAT_NODE_DATA(n))->gendata))
asm-alpha/mmzone.h:#define NODE_MEM_MAP(nid)	(NODE_DATA(nid)->node_mem_map)
asm-alpha/mmzone.h:#define LOCAL_BASE_ADDR(kaddr)	((unsigned long)__va(NODE_DATA(KVADDR_TO_NID(kaddr))->node_start_paddr))
asm-alpha/mmzone.h:	(((unsigned long)(kvaddr)-LOCAL_BASE_ADDR(kvaddr)) >> PAGE_SHIFT)
asm-alpha/mmzone.h:					 NODE_DATA(KVADDR_TO_NID(kaddr))->valid_addr_bitmap)
asm-alpha/mmzone.h:#define VALID_PAGE(page)	(((page) - mem_map) < max_mapnr)
asm-alpha/mmzone.h:#define NODE_SCHEDULE_DATA(nid)	(&((PLAT_NODE_DATA(nid))->schedule_data))
asm-alpha/module.h:        if (!mod_bound(mod->gp - 0x8000, 0, mod)) {
asm-alpha/module.h:                printk(KERN_ERR "module_arch_init: mod->gp out of bounds.\n");
asm-alpha/module.h:	__asm__("stq $29,%0" : "=m" (mod->gp));
asm-alpha/rwsem.h: * Based on asm-alpha/semaphore.h and asm-i386/rwsem.h
asm-alpha/rwsem.h:#define RWSEM_WAITING_BIAS		(-0x0000000100000000L)
asm-alpha/rwsem.h:	sem->count = RWSEM_UNLOCKED_VALUE;
asm-alpha/rwsem.h:	spin_lock_init(&sem->wait_lock);
asm-alpha/rwsem.h:	INIT_LIST_HEAD(&sem->wait_list);
asm-alpha/rwsem.h:	sem->debug = 0;
asm-alpha/rwsem.h:	oldcount = sem->count;
asm-alpha/rwsem.h:	sem->count += RWSEM_ACTIVE_READ_BIAS;
asm-alpha/rwsem.h:	:"=&r" (oldcount), "=m" (sem->count), "=&r" (temp)
asm-alpha/rwsem.h:	:"Ir" (RWSEM_ACTIVE_READ_BIAS), "m" (sem->count) : "memory");
asm-alpha/rwsem.h: * trylock for reading -- returns 1 if successful, 0 if contention
asm-alpha/rwsem.h:	res = sem->count;
asm-alpha/rwsem.h:		res = cmpxchg(&sem->count, old, new);
asm-alpha/rwsem.h:	oldcount = sem->count;
asm-alpha/rwsem.h:	sem->count += RWSEM_ACTIVE_WRITE_BIAS;
asm-alpha/rwsem.h:	:"=&r" (oldcount), "=m" (sem->count), "=&r" (temp)
asm-alpha/rwsem.h:	:"Ir" (RWSEM_ACTIVE_WRITE_BIAS), "m" (sem->count) : "memory");
asm-alpha/rwsem.h: * trylock for writing -- returns 1 if successful, 0 if contention
asm-alpha/rwsem.h:	long ret = cmpxchg(&sem->count, RWSEM_UNLOCKED_VALUE,
asm-alpha/rwsem.h:	oldcount = sem->count;
asm-alpha/rwsem.h:	sem->count -= RWSEM_ACTIVE_READ_BIAS;
asm-alpha/rwsem.h:	:"=&r" (oldcount), "=m" (sem->count), "=&r" (temp)
asm-alpha/rwsem.h:	:"Ir" (RWSEM_ACTIVE_READ_BIAS), "m" (sem->count) : "memory");
asm-alpha/rwsem.h:		if ((int)oldcount - RWSEM_ACTIVE_READ_BIAS == 0)
asm-alpha/rwsem.h:	sem->count -= RWSEM_ACTIVE_WRITE_BIAS;
asm-alpha/rwsem.h:	count = sem->count;
asm-alpha/rwsem.h:	:"=&r" (count), "=m" (sem->count), "=&r" (temp)
asm-alpha/rwsem.h:	:"Ir" (RWSEM_ACTIVE_WRITE_BIAS), "m" (sem->count) : "memory");
asm-alpha/rwsem.h:	sem->count += val;
asm-alpha/rwsem.h:	:"=&r" (temp), "=m" (sem->count)
asm-alpha/rwsem.h:	:"Ir" (val), "m" (sem->count));
asm-alpha/rwsem.h:	sem->count += val;
asm-alpha/rwsem.h:	return sem->count;
asm-alpha/rwsem.h:	:"=&r" (ret), "=m" (sem->count), "=&r" (temp)
asm-alpha/rwsem.h:	:"Ir" (val), "m" (sem->count));
asm-alpha/spinlock.h:#define SPIN_LOCK_UNLOCKED (spinlock_t) {0, -1, 0, 0, 0, 0}
asm-alpha/spinlock.h:	((x)->lock = 0, (x)->on_cpu = -1, (x)->previous = 0, (x)->task = 0)
asm-alpha/spinlock.h:#define spin_lock_init(x)	((x)->lock = 0)
asm-alpha/spinlock.h:#define spin_is_locked(x)	((x)->lock != 0)
asm-alpha/spinlock.h:#define spin_unlock_wait(x)	({ do { barrier(); } while ((x)->lock); })
asm-alpha/spinlock.h:	if (!((LOCK)->lock && (LOCK)->on_cpu == smp_processor_id()))	\
asm-alpha/spinlock.h:		       (LOCK)->lock ? "taken" : "freed", (LOCK)->on_cpu); \
asm-alpha/spinlock.h:	lock->lock = 0;
asm-alpha/spinlock.h:	/* Use sub-sections to put the actual loop at the end
asm-alpha/spinlock.h:	: "=&r" (tmp), "=m" (lock->lock)
asm-alpha/spinlock.h:	: "m"(lock->lock) : "memory");
asm-alpha/errno.h:#define	EXDEV		18	/* Cross-device link */
asm-alpha/errno.h:#define	EROFS		30	/* Read-only file system */
asm-alpha/errno.h:#define	ENOTSOCK	38	/* Socket operation on non-socket */
asm-alpha/softirq.h:	local_bh_count(cpu)--;
asm-alpha/softirq.h:	if (!--local_bh_count(cpu) && softirq_pending(cpu))	\
asm-alpha/timex.h: * linux/include/asm-alpha/timex.h
asm-alpha/bugs.h: *  include/asm-alpha/bugs.h
asm-alpha/bugs.h: * This is included by init/main.c to check for architecture-dependent bugs.
asm-alpha/namei.h: * linux/include/asm-alpha/namei.h
asm-alpha/namei.h: * Look at asm-sparc/namei.h for details.
asm-alpha/core_titan.h: * TITAN PA-chip Window Space Base Address register.
asm-alpha/core_titan.h: * (WSBA[0-2])
asm-alpha/core_titan.h: * TITAN PA-chip Control Register
asm-alpha/core_titan.h: * This definition covers both the G-Port GPCTL and the A-PORT APCTL.
asm-alpha/core_titan.h: *		0 - pachip 0 / G Port
asm-alpha/core_titan.h: *		1 - pachip 1 / G Port
asm-alpha/core_titan.h: * 		2 - pachip 0 / A Port
asm-alpha/core_titan.h: *      	3 - pachip 1 / A Port
asm-alpha/core_titan.h: * The canonical non-remaped I/O and MEM addresses have these values
asm-alpha/core_titan.h:#define TITAN_IO_SPACE		(TITAN_CONF(0) - TITAN_IO(0))
asm-alpha/init.h:#error "<asm/init.h> should never be used - use <linux/init.h> instead"
asm-alpha/uaccess.h:#define USER_DS		((mm_segment_t) { -0x40000000000UL })
asm-alpha/uaccess.h:#define get_fs()  (current->thread.fs)
asm-alpha/uaccess.h:#define set_fs(x) (current->thread.fs = (x))
asm-alpha/uaccess.h: *  - "addr" doesn't have any high-bits set
asm-alpha/uaccess.h: *  - AND "size" doesn't have any high-bits set
asm-alpha/uaccess.h: *  - AND "addr+size" doesn't have any high-bits set
asm-alpha/uaccess.h: *  - OR we are in kernel mode.
asm-alpha/uaccess.h:	return access_ok(type,addr,size) ? 0 : -EFAULT;
asm-alpha/uaccess.h: * These are the main single-value transfer routines.  They automatically
asm-alpha/uaccess.h: * (a) re-use the arguments for side effects (sizeof/typeof is ok)
asm-alpha/uaccess.h: * The "lda %1, 2b-1b(%0)" bits are magic to get the assembler to
asm-alpha/uaccess.h:	long __gu_err = -EFAULT, __gu_val = 0;			\
asm-alpha/uaccess.h:	"	lda %0, 2b-1b(%1)\n"			\
asm-alpha/uaccess.h:	"	lda %0, 2b-1b(%1)\n"			\
asm-alpha/uaccess.h:	"	lda %0, 2b-1b(%1)\n"			\
asm-alpha/uaccess.h:	"	lda %0, 2b-1b(%1)\n"			\
asm-alpha/uaccess.h:/* Unfortunately, we can't get an unaligned access trap for the sub-word
asm-alpha/uaccess.h:	"	lda %0, 3b-1b(%2)\n"					\
asm-alpha/uaccess.h:	"	lda %0, 2b-1b(%2)\n"					\
asm-alpha/uaccess.h:	"	lda %0, 2b-1b(%1)\n"					\
asm-alpha/uaccess.h:	long __pu_err = -EFAULT;				\
asm-alpha/uaccess.h:	"	lda $31,2b-1b(%0)\n"				\
asm-alpha/uaccess.h:	"	lda $31,2b-1b(%0)\n"				\
asm-alpha/uaccess.h:	"	lda $31,2b-1b(%0)\n"				\
asm-alpha/uaccess.h:	"	lda $31,2b-1b(%0)\n"				\
asm-alpha/uaccess.h:/* Unfortunately, we can't get an unaligned access trap for the sub-word
asm-alpha/uaccess.h:	"	lda $31, 5b-1b(%0)\n"				\
asm-alpha/uaccess.h:	"	lda $31, 5b-2b(%0)\n"				\
asm-alpha/uaccess.h:	"	lda $31, 5b-3b(%0)\n"				\
asm-alpha/uaccess.h:	"	lda $31, 5b-4b(%0)\n"				\
asm-alpha/uaccess.h:	"	lda $31, 3b-1b(%0)\n"				\
asm-alpha/uaccess.h:	"	lda $31, 3b-2b(%0)\n"				\
asm-alpha/uaccess.h:/* Returns: -EFAULT if exception before terminator, N if the entire
asm-alpha/uaccess.h:	long ret = -EFAULT;
asm-alpha/uaccess.h: * - insn is a 32-bit offset off of the kernel's or module's gp.
asm-alpha/uaccess.h: * - nextinsn is a 16-bit offset off of the faulting instruction
asm-alpha/uaccess.h: * - errreg is the register in which to place -EFAULT.
asm-alpha/uaccess.h: * - valreg is the final target register for the load sequence
asm-alpha/uaccess.h:		map_reg(__fie_fixup.bits.errreg) = -EFAULT;	\
asm-alpha/core_tsunami.h: * Preliminary, Chapters 2-5
asm-alpha/core_tsunami.h: * The canonical non-remaped I/O and MEM addresses have these values
asm-alpha/core_tsunami.h:#define TSUNAMI_IO_SPACE	(TSUNAMI_CONF(0) - TSUNAMI_IO(0))
asm-alpha/mman.h:/* These are linux-specific */
asm-alpha/mman.h:#define MAP_GROWSDOWN	0x1000		/* stack-like segment */
asm-alpha/posix_types.h: * This file is generally used by user-level software, so you need to
asm-alpha/posix_types.h:#define	__FD_SET(d, set)	((set)->fds_bits[__FDELT(d)] |= __FDMASK(d))
asm-alpha/posix_types.h:#define	__FD_CLR(d, set)	((set)->fds_bits[__FDELT(d)] &= ~__FDMASK(d))
asm-alpha/posix_types.h:#define	__FD_ISSET(d, set)	(((set)->fds_bits[__FDELT(d)] & __FDMASK(d)) != 0)
asm-alpha/posix_types.h:	fdsetp->fds_bits[_tmp] |= (1UL<<_rem);
asm-alpha/posix_types.h:	fdsetp->fds_bits[_tmp] &= ~(1UL<<_rem);
asm-alpha/posix_types.h:	return (p->fds_bits[_tmp] & (1UL<<_rem)) != 0;
asm-alpha/posix_types.h: * for a 256-bit fd_set)
asm-alpha/posix_types.h:	unsigned long *tmp = p->fds_bits;
asm-alpha/posix_types.h:		i--;
asm-alpha/scatterlist.h:#define sg_dma_address(sg)	((sg)->dma_address)
asm-alpha/scatterlist.h:#define sg_dma_len(sg)		((sg)->dma_length)
asm-alpha/smplock.h:	if (task->lock_depth >= 0)
asm-alpha/smplock.h: * Re-acquire the kernel lock
asm-alpha/smplock.h:	if (task->lock_depth >= 0)
asm-alpha/smplock.h:	if (!++current->lock_depth)
asm-alpha/smplock.h:	if (--current->lock_depth < 0)
asm-alpha/page.h:#define PAGE_MASK	(~(PAGE_SIZE-1))
asm-alpha/page.h: * These are used to make use of C type-checking..
asm-alpha/page.h:	size = (size-1) >> (PAGE_SHIFT-1);
asm-alpha/page.h:	order = -1;
asm-alpha/page.h:#define PAGE_ALIGN(addr)	(((addr)+PAGE_SIZE-1)&PAGE_MASK)
asm-alpha/page.h:#define __pa(x)			((unsigned long) (x) - PAGE_OFFSET)
asm-alpha/page.h:#define VALID_PAGE(page)	(((page) - mem_map) < max_mapnr)
asm-alpha/core_cia.h: * Also supported here is the 21172 (CIA-2) and 21174 (PYXIS).
asm-alpha/core_cia.h: * EC-QE18B-TE
asm-alpha/core_cia.h: *  ---- ---- ---- ---- ---- ---- ---- ---- ---- ----
asm-alpha/core_cia.h: *  ---- ---- ---- ---- ---- ---- ---- ---- ---- ----
asm-alpha/core_cia.h: *  |                               Byte Enable --+ |
asm-alpha/core_cia.h: *  |                             Transfer Length --+
asm-alpha/core_cia.h: *  +-- IO space, not cached
asm-alpha/core_cia.h: *   ---------------------------------------------
asm-alpha/core_cia.h: * 21171-CA Control and Status Registers
asm-alpha/core_cia.h: * 21171-CA Diagnostic Registers
asm-alpha/core_cia.h: * 21171-CA Performance Monitor registers
asm-alpha/core_cia.h: * 21171-CA Error registers
asm-alpha/core_cia.h: * 21171-CA System configuration registers
asm-alpha/core_cia.h: * 2117A-CA PCI Address and Scatter-Gather Registers.
asm-alpha/core_cia.h: * 2117A-CA Address Translation Registers.
asm-alpha/core_cia.h:/* System-specific info.  */
asm-alpha/core_cia.h: * Memory functions.  64-bit and 32-bit accesses are done through
asm-alpha/core_cia.h: * See p 6-17 of the specification but it looks something like this:
asm-alpha/hdreg.h: *  linux/include/asm-alpha/hdreg.h
asm-alpha/hdreg.h: *  Copyright (C) 1994-1996  Linus Torvalds & authors
asm-alpha/core_lca.h: *	Maynard, MA; Order Number: EC-N2681-71.
asm-alpha/core_lca.h: * memory-like.  You need to do them by hand if the operations depend
asm-alpha/core_lca.h: * non-interrupts is another fun race area.  Don't do it (because if
asm-alpha/core_lca.h:#define LCA_PMR_OCCEB   0xffff0000L             /* Override cycle counter - even bits */
asm-alpha/core_lca.h:#define LCA_PMR_OCCOB   0xffff000000000000L     /* Override cycle counter - even bits */
asm-alpha/core_lca.h:	unsigned long		esr;		/* error-status register */
asm-alpha/core_lca.h:	unsigned long		ear;		/* error-address register */
asm-alpha/core_lca.h: * I/O---everything goes over the PCI bus.
asm-alpha/core_lca.h: * data to/from the right byte-lanes.
asm-alpha/core_lca.h: * Memory functions.  64-bit and 32-bit accesses are done through
asm-alpha/core_lca.h:	addr -= LCA_DENSE_MEM;
asm-alpha/core_lca.h:		addr -= msb;
asm-alpha/core_lca.h:	addr -= LCA_DENSE_MEM;
asm-alpha/core_lca.h:		addr -= msb;
asm-alpha/core_lca.h:	addr -= LCA_DENSE_MEM;
asm-alpha/core_lca.h:		addr -= msb;
asm-alpha/core_lca.h:	addr -= LCA_DENSE_MEM;
asm-alpha/core_lca.h:		addr -= msb;
asm-alpha/types.h: * application is Linux specific so (user-) name space pollution is
asm-alpha/sembuf.h: * - 2 miscellaneous 64-bit values
asm-alpha/system.h:	unsigned int	proc_offset;	/* processor-specific offset */
asm-alpha/system.h:	unsigned int	sys_offset;	/* system-specific offset */
asm-alpha/system.h: *      --- This is used to log uncorrectable errors such as
asm-alpha/system.h: *      --- These errors are detected by both processor and systems.
asm-alpha/system.h:        unsigned long   shadow[8];        /* Shadow reg. 8-14, 25           */
asm-alpha/system.h:        unsigned long   ic_perr_stat;     /* I-CACHE Reg. <11> set Data parity
asm-alpha/system.h:        unsigned long   dc_perr_stat;     /* D-CACHE error Reg. Bits set to 1:
asm-alpha/system.h:        unsigned long   mm_stat;          /* Holds the reason for D-stream 
asm-alpha/system.h:                                             fault or D-cache parity errors */
asm-alpha/system.h:	unsigned int CpuOffset;		/* Offset to CPU-specific info */
asm-alpha/system.h:	unsigned int SystemOffset;	/* Offset to system-specific info */
asm-alpha/system.h:	pcbb = virt_to_phys(&current->thread);		\
asm-alpha/system.h:#define tbiap()		__tbi(-1, /* no second argument */)
asm-alpha/system.h:#define tbia()		__tbi(-2, /* no second argument */)
asm-alpha/checksum.h: * computes the checksum of the TCP/UDP pseudo-header
asm-alpha/checksum.h: * returns a 16-bit checksum, already complemented
asm-alpha/checksum.h: * and adds in "sum" (32-bit)
asm-alpha/checksum.h: * returns a 32-bit number suitable for feeding into itself
asm-alpha/checksum.h: * it's best to have buff aligned on a 32-bit boundary
asm-alpha/checksum.h: * here even more important to align src and dst on a 32-bit (or even
asm-alpha/checksum.h: * better 64-bit) boundary
asm-alpha/checksum.h: * this routine is used for miscellaneous IP-like checksums, mainly
asm-alpha/termios.h:#define N_IRDA		11	/* Linux IrDa - http://irda.sourceforge.net/ */
asm-alpha/termios.h:#define N_SMSBLOCK	12	/* SMS block mode - for talking to GSM data cards about SMS messages */
asm-alpha/termios.h:		*(unsigned short *)&k_termios->c_iflag = k_termio.c_iflag;	\
asm-alpha/termios.h:		*(unsigned short *)&k_termios->c_oflag = k_termio.c_oflag;	\
asm-alpha/termios.h:		*(unsigned short *)&k_termios->c_cflag = k_termio.c_cflag;	\
asm-alpha/termios.h:		*(unsigned short *)&k_termios->c_lflag = k_termio.c_lflag;	\
asm-alpha/termios.h:		k_termios->c_cc[VINTR]  = k_termio.c_cc[_VINTR];		\
asm-alpha/termios.h:		k_termios->c_cc[VQUIT]  = k_termio.c_cc[_VQUIT];		\
asm-alpha/termios.h:		k_termios->c_cc[VERASE] = k_termio.c_cc[_VERASE];		\
asm-alpha/termios.h:		k_termios->c_cc[VKILL]  = k_termio.c_cc[_VKILL];		\
asm-alpha/termios.h:		k_termios->c_cc[VEOL2]  = k_termio.c_cc[_VEOL2];		\
asm-alpha/termios.h:		k_termios->c_cc[VSWTC]  = k_termio.c_cc[_VSWTC];		\
asm-alpha/termios.h:		k_termios->c_cc[canon ? VEOF : VMIN]  = k_termio.c_cc[_VEOF];	\
asm-alpha/termios.h:		k_termios->c_cc[canon ? VEOL : VTIME] = k_termio.c_cc[_VEOL];	\
asm-alpha/termios.h:	k_termio.c_iflag = k_termios->c_iflag;				\
asm-alpha/termios.h:	k_termio.c_oflag = k_termios->c_oflag;				\
asm-alpha/termios.h:	k_termio.c_cflag = k_termios->c_cflag;				\
asm-alpha/termios.h:	canon = (k_termio.c_lflag = k_termios->c_lflag) & ICANON;	\
asm-alpha/termios.h:	k_termio.c_line = k_termios->c_line;				\
asm-alpha/termios.h:	k_termio.c_cc[_VINTR]  = k_termios->c_cc[VINTR];		\
asm-alpha/termios.h:	k_termio.c_cc[_VQUIT]  = k_termios->c_cc[VQUIT];		\
asm-alpha/termios.h:	k_termio.c_cc[_VERASE] = k_termios->c_cc[VERASE];		\
asm-alpha/termios.h:	k_termio.c_cc[_VKILL]  = k_termios->c_cc[VKILL];		\
asm-alpha/termios.h:	k_termio.c_cc[_VEOF]   = k_termios->c_cc[canon ? VEOF : VMIN];	\
asm-alpha/termios.h:	k_termio.c_cc[_VEOL]   = k_termios->c_cc[canon ? VEOL : VTIME];	\
asm-alpha/termios.h:	k_termio.c_cc[_VEOL2]  = k_termios->c_cc[VEOL2];		\
asm-alpha/termios.h:	k_termio.c_cc[_VSWTC]  = k_termios->c_cc[VSWTC];		\
asm-alpha/user.h: * linux we use the `trad-core' bfd, NOT the osf-core).  The file contents
asm-alpha/user.h: *  data: The data segment follows next.  We use current->end_text to
asm-alpha/user.h: *	current->brk to pick up all of the user variables, plus any memory
asm-alpha/user.h: *	page is demand-zero or if a page is totally unused, we just cover
asm-alpha/user.h: *	current->start_stack, so we round each of these in order to be able
asm-alpha/gentrap.h: * Definitions for gentrap causes.  They are generated by user-level
asm-alpha/gentrap.h:#define GEN_INTOVF	-1	/* integer overflow */
asm-alpha/gentrap.h:#define GEN_INTDIV	-2	/* integer division by zero */
asm-alpha/gentrap.h:#define GEN_FLTOVF	-3	/* fp overflow */
asm-alpha/gentrap.h:#define GEN_FLTDIV	-4	/* fp division by zero */
asm-alpha/gentrap.h:#define GEN_FLTUND	-5	/* fp underflow */
asm-alpha/gentrap.h:#define GEN_FLTINV	-6	/* invalid fp operand */
asm-alpha/gentrap.h:#define GEN_FLTINE	-7	/* inexact fp operand */
asm-alpha/gentrap.h:#define GEN_DECOVF	-8	/* decimal overflow (for COBOL??) */
asm-alpha/gentrap.h:#define GEN_DECDIV	-9	/* decimal division by zero */
asm-alpha/gentrap.h:#define GEN_DECINV	-10	/* invalid decimal operand */
asm-alpha/gentrap.h:#define GEN_ROPRAND	-11	/* reserved operand */
asm-alpha/gentrap.h:#define GEN_ASSERTERR	-12	/* assertion error */
asm-alpha/gentrap.h:#define GEN_NULPTRERR	-13	/* null pointer error */
asm-alpha/gentrap.h:#define GEN_STKOVF	-14	/* stack overflow */
asm-alpha/gentrap.h:#define GEN_STRLENERR	-15	/* string length error */
asm-alpha/gentrap.h:#define GEN_SUBSTRERR	-16	/* substring error */
asm-alpha/gentrap.h:#define GEN_RANGERR	-17	/* range error */
asm-alpha/gentrap.h:#define GEN_SUBRNG	-18
asm-alpha/gentrap.h:#define GEN_SUBRNG1	-19	 
asm-alpha/gentrap.h:#define GEN_SUBRNG2	-20
asm-alpha/gentrap.h:#define GEN_SUBRNG3	-21	/* these report range errors for */
asm-alpha/gentrap.h:#define GEN_SUBRNG4	-22	/* subscripting (indexing) at levels 0..7 */
asm-alpha/gentrap.h:#define GEN_SUBRNG5	-23
asm-alpha/gentrap.h:#define GEN_SUBRNG6	-24
asm-alpha/gentrap.h:#define GEN_SUBRNG7	-25
asm-alpha/gentrap.h:/* the remaining codes (-26..-1023) are reserved. */
asm-alpha/serial.h: * include/asm-alpha/serial.h
asm-alpha/pgtable.h: * This hopefully works with any standard Alpha page-size, as defined
asm-alpha/pgtable.h:/* PMD_SHIFT determines the size of the area a second-level page table can map */
asm-alpha/pgtable.h:#define PMD_SHIFT	(PAGE_SHIFT + (PAGE_SHIFT-3))
asm-alpha/pgtable.h:#define PMD_MASK	(~(PMD_SIZE-1))
asm-alpha/pgtable.h:/* PGDIR_SHIFT determines what a third-level page table entry can map */
asm-alpha/pgtable.h:#define PGDIR_SHIFT	(PAGE_SHIFT + 2*(PAGE_SHIFT-3))
asm-alpha/pgtable.h:#define PGDIR_MASK	(~(PGDIR_SIZE-1))
asm-alpha/pgtable.h: * Entries per page directory level:  the Alpha is three-level, with
asm-alpha/pgtable.h: * all levels having a one-page page table.
asm-alpha/pgtable.h:#define PTRS_PER_PTE	(1UL << (PAGE_SHIFT-3))
asm-alpha/pgtable.h:#define PTRS_PER_PMD	(1UL << (PAGE_SHIFT-3))
asm-alpha/pgtable.h:#define PTRS_PER_PGD	(1UL << (PAGE_SHIFT-3))
asm-alpha/pgtable.h:#define PTRS_PER_PAGE	(1UL << (PAGE_SHIFT-3))
asm-alpha/pgtable.h:#define VMALLOC_START		(-2*PGDIR_SIZE)
asm-alpha/pgtable.h:#define VMALLOC_END		(-PGDIR_SIZE)
asm-alpha/pgtable.h: * OSF/1 PAL-code-imposed page table bits
asm-alpha/pgtable.h:#define _PAGE_KRE	0x0100	/* xxx - see below on the "accessed" bit */
asm-alpha/pgtable.h: * the page is accessed. They are cleared only by the page-out routines
asm-alpha/pgtable.h: * The hardware can handle write-only mappings, but as the Alpha
asm-alpha/pgtable.h: * architecture does byte-wide writes with a read-modify-write
asm-alpha/pgtable.h: * sequence, it's not practical to have write-without-read privs.
asm-alpha/pgtable.h: * Thus the "-w- -> rw-" and "-wx -> rwx" mapping here (and in
asm-alpha/pgtable.h: * BAD_PAGETABLE is used when we need a bogus page-table, while
asm-alpha/pgtable.h: * for zero-mapped memory areas etc..
asm-alpha/pgtable.h:#define PTR_MASK			(~(sizeof(void*)-1))
asm-alpha/pgtable.h:/* to find an entry in a page-table */
asm-alpha/pgtable.h:  ((unsigned long)(address)>>(PAGE_SHIFT-SIZEOF_PTR_LOG2)&PTR_MASK&~PAGE_MASK)
asm-alpha/pgtable.h: * namely EV6 and above, we must re-twiddle the physaddr to restore the
asm-alpha/pgtable.h: * correct high-order bits.
asm-alpha/pgtable.h: * in this area -- memory or whathaveyou -- then this hack will have
asm-alpha/pgtable.h:#error "EV6-only feature in a generic kernel"
asm-alpha/pgtable.h:#define PAGE_TO_PA(page)	((page - mem_map) << PAGE_SHIFT)
asm-alpha/pgtable.h:		((((page)-page_zone(page)->zone_mem_map) << PAGE_SHIFT) \
asm-alpha/pgtable.h:		+ page_zone(page)->zone_start_paddr)
asm-alpha/pgtable.h:	pte_val(pte) = ((unsigned long)(page - mem_map) << 32) |	\
asm-alpha/pgtable.h:	pfn = ((unsigned long)((page)-page_zone(page)->zone_mem_map)) << 32;	\
asm-alpha/pgtable.h:	pfn += page_zone(page)->zone_start_paddr << (32-PAGE_SHIFT);		\
asm-alpha/pgtable.h:{ pte_t pte; pte_val(pte) = (PHYS_TWIDDLE(physpage) << (32-PAGE_SHIFT)) | pgprot_val(pgprot); return pte; }
asm-alpha/pgtable.h:{ pmd_val(*pmdp) = _PAGE_TABLE | ((((unsigned long) ptep) - PAGE_OFFSET) << (32-PAGE_SHIFT)); }
asm-alpha/pgtable.h:{ pgd_val(*pgdp) = _PAGE_TABLE | ((((unsigned long) pmdp) - PAGE_OFFSET) << (32-PAGE_SHIFT)); }
asm-alpha/pgtable.h:	kvirt = (unsigned long)__va(pte_val(x) >> (32-PAGE_SHIFT));	\
asm-alpha/pgtable.h:{ return PAGE_OFFSET + ((pmd_val(pmd) & _PFN_MASK) >> (32-PAGE_SHIFT)); }
asm-alpha/pgtable.h:{ return PAGE_OFFSET + ((pgd_val(pgd) & _PFN_MASK) >> (32-PAGE_SHIFT)); }
asm-alpha/pgtable.h:/* to find an entry in a kernel page-table-directory */
asm-alpha/pgtable.h:/* to find an entry in a page-table-directory. */
asm-alpha/pgtable.h:#define pgd_index(address)	((address >> PGDIR_SHIFT) & (PTRS_PER_PGD - 1))
asm-alpha/pgtable.h:#define pgd_offset(mm, address)	((mm)->pgd+pgd_index(address))
asm-alpha/pgtable.h:/* Find an entry in the second-level page table.. */
asm-alpha/pgtable.h:	return (pmd_t *) pgd_page(*dir) + ((address >> PMD_SHIFT) & (PTRS_PER_PAGE - 1));
asm-alpha/pgtable.h:/* Find an entry in the third-level page table.. */
asm-alpha/pgtable.h:	return (pte_t *) pmd_page(*dir) + ((address >> PAGE_SHIFT) & (PTRS_PER_PAGE - 1));
asm-alpha/pgtable.h: * Non-present pages:  high 24 bits are offset, next 8 bits type,
asm-alpha/pgtable.h:#include <asm-generic/pgtable.h>
asm-alpha/unaligned.h: * The main single-value unaligned transfer routines.
asm-alpha/unaligned.h:	return ptr->x;
asm-alpha/unaligned.h:	return ptr->x;
asm-alpha/unaligned.h:	return ptr->x;
asm-alpha/unaligned.h:	ptr->x = r5;
asm-alpha/unaligned.h:	ptr->x = r5;
asm-alpha/unaligned.h:	ptr->x = r5;
asm-alpha/param.h:   hardware ignores reprogramming.  We also need userland buy-in to the 
asm-alpha/param.h:#define NOGROUP		(-1)
asm-alpha/core_t2.h: * memory controller and PCI access for the SABLE-based systems.
asm-alpha/core_t2.h:/* GAMMA-SABLE is a SABLE with EV5-based CPUs */
asm-alpha/core_t2.h:/*  T2 CSRs are in the non-cachable primary IO space from 3.8000.0000 to
asm-alpha/core_t2.h: *  +--------------+ 3 8000 0000
asm-alpha/core_t2.h: *  +--------------+ 3 8100 0000
asm-alpha/core_t2.h: *  +--------------+ 3 8200 0000
asm-alpha/core_t2.h: *  +--------------+ 3 8300 0000
asm-alpha/core_t2.h: *  +--------------+ 3 8400 0000
asm-alpha/core_t2.h: *  +--------------+ 3 8700 0000
asm-alpha/core_t2.h: *  +--------------+ 3 8800 0000
asm-alpha/core_t2.h: *  +--------------+ 3 8900 0000
asm-alpha/core_t2.h: *  +--------------+ 3 8a00 0000
asm-alpha/core_t2.h: *  +--------------+ 3 8b00 0000
asm-alpha/core_t2.h: *  +--------------+ 3 8c00 0000
asm-alpha/core_t2.h: *  +--------------+ 3 8e00 0000
asm-alpha/core_t2.h: *  +--------------+ 3 8f00 0000
asm-alpha/core_t2.h: *  +--------------+ 3 9000 0000
asm-alpha/core_t2.h:  unsigned long bccea;   long fill_02[3]; /* B-Cache Corr Err Address Latch */
asm-alpha/core_t2.h:  unsigned long bcue;    long fill_03[3]; /* B-Cache Uncorrectable Error */
asm-alpha/core_t2.h:  unsigned long bcuea;   long fill_04[3]; /* B-Cache Uncorr Err Addr Latch */
asm-alpha/core_t2.h:  unsigned long ipir;    long fill_11[3]; /* Inter-Processor Int Request */
asm-alpha/core_t2.h:	/* EV4-specific fields */
asm-alpha/core_t2.h:	unsigned long	elfmc_mm_csr;	/* D-stream fault info. */
asm-alpha/core_t2.h:	unsigned long	elfmc_dc_stat;	/* D-cache status (ECC/Parity Err). */
asm-alpha/core_t2.h:	unsigned int	elfl_procoffset; /* Processor-specific offset. */
asm-alpha/core_t2.h:	unsigned int	elfl_sysoffset;	 /* Offset of system-specific. */
asm-alpha/core_t2.h: * Sable memory error frame - sable pfms section 3.42
asm-alpha/core_t2.h:	struct	el_t2_frame_header elcm_hdr;	/* ID$MEM-FERR = 0x08 */
asm-alpha/core_t2.h: * Sable other CPU error frame - sable pfms section 3.43
asm-alpha/core_t2.h: * Sable other CPU error frame - sable pfms section 3.44
asm-alpha/core_t2.h:	struct el_t2_frame_header elct_hdr;	/* ID$T2-FRAME */
asm-alpha/core_t2.h: * Sable error log data structure - sable pfms section 3.40
asm-alpha/core_t2.h:	struct el_t2_frame_header elfmc_header;	/* ID$P-FRAME_MCHECK */
asm-alpha/core_t2.h:	struct el_t2_frame_header elfcc_header;	/* ID$P-BC-COR */
asm-alpha/core_t2.h: * See p 6-17 of the specification but it looks something like this:
asm-alpha/core_t2.h: * On SABLE with T2, we must use SPARSE memory even for 32-bit access,
asm-alpha/core_t2.h: * On SABLE with T2, we must use SPARSE memory even for 32-bit access,
asm-alpha/core_apecs.h: * DECchip 21071-AA and DECchip 21072-AA Core Logic Chipsets
asm-alpha/core_apecs.h: * EC-N0648-72
asm-alpha/core_apecs.h:   that get passed through the PCI<->ISA bridge chip. So we've gotta use
asm-alpha/core_apecs.h:   If we try a window at 0 for 1GB as a work-around, we run into conflicts
asm-alpha/core_apecs.h:   We put window 1 at BUS 64Mb for 64Mb, mapping physical 0 to 64Mb-1,
asm-alpha/core_apecs.h:   and window 2 at BUS 1Gb for 1Gb, mapping physical 0 to 1Gb-1.
asm-alpha/core_apecs.h:   Yes, this does map 0 to 64Mb-1 twice, but only window 1 will actually
asm-alpha/core_apecs.h:   we can't just use that here, because of header file looping... :-(
asm-alpha/core_apecs.h:   window 2, maxing out at 1Gb of memory. I trust this is enough... :-)
asm-alpha/core_apecs.h:   wants to access memory-mapped registers in byte and short lengths.
asm-alpha/core_apecs.h: * 21071-DA Control and Status registers.
asm-alpha/core_apecs.h: * 21071-CA Control and Status registers.
asm-alpha/core_apecs.h: *  configure memory and initialise the B-Cache.
asm-alpha/core_apecs.h:	/* EV4-specific fields */
asm-alpha/core_apecs.h:	unsigned long csr;          /* D-stream fault info. */
asm-alpha/core_apecs.h:	unsigned long dc_stat;      /* D-cache status (ECC/Parity Err). */
asm-alpha/core_apecs.h: * I/O---everything goes over the PCI bus.
asm-alpha/core_apecs.h: * data to/from the right byte-lanes.
asm-alpha/core_apecs.h: * Memory functions.  64-bit and 32-bit accesses are done through
asm-alpha/core_apecs.h:	addr -= APECS_DENSE_MEM;
asm-alpha/core_apecs.h:		addr -= msb;
asm-alpha/core_apecs.h:	addr -= APECS_DENSE_MEM;
asm-alpha/core_apecs.h:		addr -= msb;
asm-alpha/core_apecs.h:	addr -= APECS_DENSE_MEM;
asm-alpha/core_apecs.h:		addr -= msb;
asm-alpha/core_apecs.h:	addr -= APECS_DENSE_MEM;
asm-alpha/core_apecs.h:		addr -= msb;
asm-alpha/cache.h: * include/asm-alpha/cache.h
asm-alpha/cache.h:/* Both EV4 and EV5 are write-through, read-allocate,
asm-alpha/cache.h:   direct-mapped, physical.
asm-alpha/cache.h:#define L1_CACHE_ALIGN(x)  (((x)+(L1_CACHE_BYTES-1))&~(L1_CACHE_BYTES-1))
asm-alpha/siginfo.h:#define SI_PAD_SIZE	((SI_MAX_SIZE/sizeof(int)) - 4)
asm-alpha/siginfo.h: * Digital reserves positive values for kernel-generated signals.
asm-alpha/siginfo.h:#define SI_QUEUE	-1		/* sent by sigqueue */
asm-alpha/siginfo.h:#define SI_TIMER __SI_CODE(__SI_TIMER,-2) /* sent by timer expiration */
asm-alpha/siginfo.h:#define SI_MESGQ	-3		/* sent by real time mesq state change */
asm-alpha/siginfo.h:#define SI_ASYNCIO	-4		/* sent by AIO completion */
asm-alpha/siginfo.h:#define SI_SIGIO	-5		/* sent by queued SIGIO */
asm-alpha/siginfo.h:#define SI_TKILL	-6		/* sent by tkill system call */
asm-alpha/siginfo.h:#define SI_FROMUSER(siptr)	((siptr)->si_code <= 0)
asm-alpha/siginfo.h:#define SI_FROMKERNEL(siptr)	((siptr)->si_code > 0)
asm-alpha/siginfo.h:#define BUS_ADRERR	(__SI_FAULT|2)	/* non-existant physical address */
asm-alpha/siginfo.h:#define SIGEV_PAD_SIZE	((SIGEV_MAX_SIZE/sizeof(int)) - 4)
asm-alpha/siginfo.h:	if (from->si_code < 0)
asm-alpha/siginfo.h:		memcpy(to, from, 4*sizeof(int) + sizeof(from->_sifields._sigchld));
asm-alpha/floppy.h:		/* different from last time -- unmap prev */
asm-alpha/floppy.h:static int FDC2 = -1;
asm-alpha/floppy.h: * scatter-gather when it never had before, and there *is* a problem
asm-alpha/floppy.h: * on that platform... ;-}
asm-alpha/floppy.h:   unsigned long __e64 = __s64 + (unsigned long)(s) - 1;	\
asm-alpha/sockios.h:/* Socket-level I/O control calls. */
asm-alpha/sockios.h:#define SIOCGSTAMP	0x8906		/* Get stamp - linux-specific */
asm-alpha/hwrpb.h:	/* virtual->physical map */
asm-alpha/hwrpb.h:        for (l = (unsigned long *) h; l < (unsigned long *) &h->chksum; ++l)
asm-alpha/hwrpb.h:        h->chksum = sum;
asm-alpha/keyboard.h: *  linux/include/asm-alpha/keyboard.h
asm-alpha/a.out.h: * 	- a file header (struct filehdr),
asm-alpha/a.out.h: *	- an a.out header (struct aouthdr),
asm-alpha/a.out.h: *	- one or more section headers (struct scnhdr). 
asm-alpha/a.out.h:   (sizeof(struct exec) + (x).fh.f_nscns*SCNHSZ + SCNROUND - 1) & ~(SCNROUND - 1))
asm-alpha/a.out.h:	set_personality (((BFPM->sh_bang || EX.ah.entry < 0x100000000 \
asm-alpha/a.out.h:  (current->personality & ADDR_LIMIT_32BIT ? 0x80000000 : 0x00120000000UL)
asm-alpha/ioctl.h:#define _IOC_NRMASK	((1 << _IOC_NRBITS)-1)
asm-alpha/ioctl.h:#define _IOC_TYPEMASK	((1 << _IOC_TYPEBITS)-1)
asm-alpha/ioctl.h:#define _IOC_SIZEMASK	((1 << _IOC_SIZEBITS)-1)
asm-alpha/ioctl.h:#define _IOC_DIRMASK	((1 << _IOC_DIRBITS)-1)
asm-alpha/string.h:/* The following routine is like memset except that it writes 16-bit
asm-alpha/ioctls.h:#define TIOCGPTN	_IOR('T',0x30, unsigned int) /* Get Pty Number (of pty-mux device) */
asm-alpha/core_marvel.h:#define MARVEL_MAX_PIDS		 32 /* as long as we rely on 43-bit superpage */
asm-alpha/core_marvel.h:#define MARVEL_IRQ_VEC_IRQ_MASK	((1 << MARVEL_IRQ_VEC_PE_SHIFT) - 1)
asm-alpha/core_marvel.h:#define EV7_MASK40(addr)        ((addr) & ((1UL << 41) - 1))
asm-alpha/core_marvel.h:#define EV7_CSR_OFFSET(name)	((unsigned long)&((ev7_csrs *)NULL)->name.csr)
asm-alpha/core_marvel.h:	/* AGP Control Registers -- port 3 only */
asm-alpha/core_marvel.h:		unsigned dac : 1;	/* <2> -- window 3 only */
asm-alpha/core_marvel.h: * For level-sensitive interrupts, int_num is encoded as:
asm-alpha/core_marvel.h:	 (&(((io7_ioport_csrs *)IO7_CSRS_KERN(0, 0))->POx_IACK_SPECIAL)))
asm-alpha/core_marvel.h:		a += pci_vga_hose->io_space->start;	\
asm-alpha/core_marvel.h:	return (addr & (1UL << 40)) != 0; /*FIXME - hardwire*/
asm-alpha/core_marvel.h:				    ("Bad IO addr %lx - reading -1\n", addr));
asm-alpha/core_marvel.h:		return (u8)-1;
asm-alpha/core_marvel.h:				    ("Bad IO addr %lx - reading -1\n", addr));
asm-alpha/core_marvel.h:				    ("Bad IO addr %lx - reading -1\n", addr));
asm-alpha/core_marvel.h:		return (u16)-1;
asm-alpha/core_marvel.h:				    ("Bad IO addr %lx - reading -1\n", addr));
asm-alpha/core_marvel.h:				    ("Bad IO addr %lx - reading -1\n", addr));
asm-alpha/core_marvel.h:		return (u32)-1;
asm-alpha/core_marvel.h:				    ("Bad IO addr %lx - reading -1\n", addr));
asm-alpha/core_marvel.h:		IOBUG(("Bad MEM addr %lx - reading -1\n", addr));
asm-alpha/core_marvel.h:		return (u8)-1;
asm-alpha/core_marvel.h:		IOBUG(("Bad MEM addr %lx - reading -1\n", addr));
asm-alpha/core_marvel.h:		return (u16)-1;
asm-alpha/core_marvel.h:		IOBUG(("Bad MEM addr %lx - reading -1\n", addr));
asm-alpha/core_marvel.h:		return (u32)-1;
asm-alpha/core_marvel.h:		IOBUG(("Bad MEM addr %lx - reading -1\n", addr));
asm-alpha/core_marvel.h:		return (u64)-1;
asm-alpha/core_marvel.h:		IOBUG(("Bad MEM addr %lx - dropping store\n", addr));
asm-alpha/core_marvel.h:		IOBUG(("Bad MEM addr %lx - dropping store\n", addr));
asm-alpha/core_marvel.h:		IOBUG(("Bad MEM addr %lx - dropping store\n", addr));
asm-alpha/core_marvel.h:		IOBUG(("Bad MEM addr %lx - dropping store\n", addr));
asm-alpha/msgbuf.h: * - 2 miscellaneous 64-bit values
asm-alpha/regdef.h:#define t0	$1	/* temporary registers (caller-saved) */
asm-alpha/regdef.h:#define	s0	$9	/* saved-registers (callee-saved registers) */
asm-alpha/regdef.h:#define	fp	s6	/* frame-pointer (s6 in frame-less procedures) */
asm-alpha/regdef.h:#define a0	$16	/* argument registers (caller-saved) */
asm-alpha/regdef.h:#define t8	$22	/* more temps (caller-saved) */
asm-alpha/regdef.h:#define pv	t12	/* procedure-variable register */
asm-alpha/socket.h:/* linux-specific, might as well be the same as on i386 */
asm-alpha/socket.h:/* Security levels - as per NRL IPv6 - don't actually do anything */
asm-alpha/socket.h:/* Nast libc5 fixup - bletch */
asm-alpha/socket.h:#define SOCK_RDM	4		/* reliably-delivered message	*/
asm-arm/io.h: *  linux/include/asm-arm/io.h
asm-arm/io.h: *  Copyright (C) 1996-2000 Russell King
asm-arm/io.h: *  16-Sep-1996	RMK	Inlined the inx/outx functions & optimised for both
asm-arm/io.h: *  04-Dec-1997	RMK	Moved a lot of this stuff to the new architecture
asm-arm/io.h: *  27-Mar-1999	PJB	Second parameter of memcpy_toio is const..
asm-arm/io.h: *  04-Apr-1999	PJB	Added check_signature.
asm-arm/io.h: *  12-Dec-1999	RMK	More cleanups
asm-arm/io.h: *  18-Jun-2000 RMK	Removed virt_to_* and friends definitions
asm-arm/io.h: * Generic virtual read/write.  Note that we don't support half-word
asm-arm/io.h: * Now, pick up the machine-defined IO definitions
asm-arm/io.h: *  -------------------------
asm-arm/io.h: *    PCI:  D0-D7   D8-D15 D16-D23 D24-D31
asm-arm/io.h: *    ARM: D24-D31 D16-D23  D8-D15  D0-D7
asm-arm/io.h: * Note that we prevent GCC re-ordering or caching values in expressions
asm-arm/io.h: * The {in,out}[bwl] macros are for emulating x86-style PCI/ISA IO space.
asm-arm/io.h: * linux/Documentation/IO-mapping.txt.  If you want a
asm-arm/io.h: * DMA-consistent mapping functions.  These allocate/free a region of
asm-arm/io.h: * uncached, unwrite-buffered mapped memory space for use with DMA
asm-arm/io.h:		length--;
asm-arm/io.h:		length--;
asm-arm/mach/serial_at91rm9200.h: *  linux/include/asm-arm/mach/serial_at91rm9200.h
asm-arm/mach/dma.h: *  linux/include/asm-arm/mach/dma.h
asm-arm/mach/dma.h: *  Copyright (C) 1998-2000 Russell King
asm-arm/mach/dma.h: *  (dma.c) and the architecture-specific DMA backends (dma-*.c)
asm-arm/mach/dma.h:	struct scatterlist *sg;		/* DMA Scatter-Gather List	*/
asm-arm/mach/dma.h: * Params   : dma - pointer to array of DMA structures
asm-arm/mach/irq.h: *  linux/include/asm-arm/mach/irq.h
asm-arm/mach/irq.h: *  Copyright (C) 1995-2000 Russell King.
asm-arm/mach/map.h: *  linux/include/asm-arm/map.h
asm-arm/mach/map.h: *  Copyright (C) 1999-2000 Russell King
asm-arm/mach/pci.h: *  linux/include/asm-arm/mach/pci.h
asm-arm/mach/serial_sa1100.h: *  linux/include/asm-arm/mach/serial_sa1100.h
asm-arm/mach/serial_sa1100.h: * Moved to include/asm-arm/mach and changed lots, Russell King
asm-arm/mach/arch.h: *  linux/include/asm-arm/mach/arch.h
asm-arm/mach/arch.h:	 * by assembler code in head-armv.S
asm-arm/mach/amba_kmi.h: *  linux/include/asm-arm/mach/amba_kmi.h
asm-arm/mach/amba_kmi.h: * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
asm-arm/atomic.h: *  linux/include/asm-arm/atomic.h
asm-arm/atomic.h: *   27-06-1996	RMK	Created
asm-arm/atomic.h: *   13-04-1997	RMK	Made functions atomic!
asm-arm/atomic.h: *   07-12-1997	RMK	Upgraded for v2.1.
asm-arm/atomic.h: *   26-08-1998	PJB	Added #ifdef __KERNEL__
asm-arm/atomic.h:#define atomic_read(v)	((v)->counter)
asm-arm/atomic.h:#define atomic_set(v,i)	(((v)->counter) = (i))
asm-arm/atomic.h:	v->counter += i;
asm-arm/atomic.h:	v->counter -= i;
asm-arm/atomic.h:	v->counter += 1;
asm-arm/atomic.h:	v->counter -= 1;
asm-arm/atomic.h:	val = v->counter;
asm-arm/atomic.h:	v->counter = val -= 1;
asm-arm/atomic.h:	val = v->counter;
asm-arm/atomic.h:	v->counter = val += i;
asm-arm/delay.h: *  linux/include/asm-arm/delay.h
asm-arm/delay.h: *  Copyright (C) 1995-2003 Russell King
asm-arm/delay.h: *  Delay routines, using a pre-computed "loops_per_second" value.
asm-arm/ipcbuf.h: * - 32-bit mode_t and seq
asm-arm/ipcbuf.h: * - 2 miscellaneous 32-bit values
asm-arm/parport.h: *  linux/include/asm-arm/parport.h: ARM-specific parport initialisation
asm-arm/hardware.h: *  linux/include/asm-arm/hardware.h
asm-arm/shmbuf.h: * - 64-bit time_t to solve y2038 problem
asm-arm/shmbuf.h: * - 2 miscellaneous 32-bit values
asm-arm/bitops.h: * Function prototypes to keep gcc -Wall happy.
asm-arm/bitops.h:	if (word & 0x0000ffff) { k -= 16; word <<= 16; }
asm-arm/bitops.h:	if (word & 0x00ff0000) { k -= 8;  word <<= 8;  }
asm-arm/bitops.h:	if (word & 0x0f000000) { k -= 4;  word <<= 4;  }
asm-arm/bitops.h:	if (word & 0x30000000) { k -= 2;  word <<= 2;  }
asm-arm/bitops.h:	if (word & 0x40000000) { k -= 1; }
asm-arm/bitops.h: * of bits set) of a N-bit word
asm-arm/assembler.h: * Do not include any C declarations in this file - it is included by
asm-arm/div64.h:/* We're not 64-bit, but... */
asm-arm/resource.h:#define RLIMIT_MEMLOCK	8		/* max locked-in-memory address space */
asm-arm/ptrace.h:	(pc_pointer((regs)->ARM_pc))
asm-arm/pgalloc.h: *  linux/include/asm-arm/pgalloc.h
asm-arm/pgalloc.h: *  Copyright (C) 2000-2001 Russell King
asm-arm/pgalloc.h:#error Pgtable caches have to be per-CPU, so that no locking is needed.
asm-arm/pgalloc.h:		pgtable_cache_size--;
asm-arm/pgalloc.h:		pgtable_cache_size--;
asm-arm/pgalloc.h: * Since we have only two-level page tables, these are trivial
asm-arm/arch-anakin/io.h: *  linux/include/asm-arm/arch-anakin/io.h
asm-arm/arch-anakin/io.h: *   10-Apr-2001 TTC	Created
asm-arm/arch-anakin/hardware.h: *  linux/include/asm-arm/arch-anakin/hardware.h
asm-arm/arch-anakin/hardware.h: *   10-Apr-2001 TTC	Created
asm-arm/arch-anakin/hardware.h: * Use SRAM for D-cache flush
asm-arm/arch-anakin/uncompress.h: *  linux/include/asm-arm/arch-anakin/uncompress.h
asm-arm/arch-anakin/uncompress.h: *   10-Apr-2001 TTC	Created
asm-arm/arch-anakin/vmalloc.h: *  linux/include/asm-arm/arch-anakin/vmalloc.h
asm-arm/arch-anakin/vmalloc.h: *   09-Apr-2001 TTC	Created
asm-arm/arch-anakin/vmalloc.h:#define VMALLOC_START		((VMALLOC_VMADDR(high_memory) + VMALLOC_ARCH_OFFSET) & ~(VMALLOC_ARCH_OFFSET - 1))
asm-arm/arch-anakin/dma.h: *  linux/include/asm-arm/arch-anakin/dma.h
asm-arm/arch-anakin/dma.h: *   09-Apr-2001 W/TTC	Created
asm-arm/arch-anakin/ide.h: * linux/include/asm-arm/arch-anakin/ide.h
asm-arm/arch-anakin/ide.h: * 08-jun-2001: Initial clone of arch-sa1100/ide.h by Jon McClintock
asm-arm/arch-anakin/ide.h:		hw->io_ports[i] = reg;
asm-arm/arch-anakin/ide.h:	hw->io_ports[IDE_CONTROL_OFFSET] = (ide_ioreg_t) ctrl_port;
asm-arm/arch-anakin/irq.h: *  linux/include/asm-arm/arch-anakin/irq.h
asm-arm/arch-anakin/irq.h: *   10-Apr-2001 TTC	Created
asm-arm/arch-anakin/timex.h: *  linux/include/asm-arm/arch-anakin/timex.h
asm-arm/arch-anakin/timex.h: *   09-Apr-2001 TTC	Created
asm-arm/arch-anakin/irqs.h: *  linux/include/asm-arm/arch-anakin/irqs.h
asm-arm/arch-anakin/irqs.h: *   10-Apr-2001 TTC	Created
asm-arm/arch-anakin/serial_reg.h: *  linux/include/asm-arm/arch-anakin/serial_reg.h
asm-arm/arch-anakin/serial_reg.h: *   09-Apr-2001 TTC	Created
asm-arm/arch-anakin/serial_reg.h:#define SETBAUD(baud)		((230400 / (baud) - 1) << 3)
asm-arm/arch-anakin/system.h: *  linux/include/asm-arm/arch-anakin/system.h
asm-arm/arch-anakin/system.h: *   11-Apr-2001 TTC	Created
asm-arm/arch-anakin/system.h: *   04-May-2001 W/PB	Removed cpu_do_idle()
asm-arm/arch-anakin/time.h: *  linux/include/asm-arm/arch-anakin/time.h
asm-arm/arch-anakin/time.h: *   10-Apr-2001 TTC	Created
asm-arm/arch-anakin/serial.h: *  linux/include/asm-arm/arch-anakin/serial.h
asm-arm/arch-anakin/serial.h: *   11-Apr-2001 TTC	Created
asm-arm/arch-anakin/param.h: *  linux/include/asm-arm/arch-anakin/param.h
asm-arm/arch-anakin/param.h: *   11-Apr-2001 TTC	Created
asm-arm/arch-anakin/keyboard.h: *  linux/include/asm-arm/arch-anakin/keyboard.h
asm-arm/arch-anakin/keyboard.h: *   11-Apr-2001 TTC	Created
asm-arm/arch-anakin/memory.h: *  linux/include/asm-arm/arch-anakin/memory.h
asm-arm/arch-anakin/memory.h: *   09-Apr-2001 TTC	Created
asm-arm/arch-anakin/memory.h:#define __virt_to_phys(a)	((a) - PAGE_OFFSET + PHYS_OFFSET)
asm-arm/arch-anakin/memory.h:#define __phys_to_virt(a)	((a) + PAGE_OFFSET - PHYS_OFFSET)
asm-arm/unistd.h: *  linux/include/asm-arm/unistd.h
asm-arm/unistd.h: *  Copyright (C) 2001-2002 Russell King
asm-arm/unistd.h:	if ((unsigned long)(res) >= (unsigned long)(-125)) {		\
asm-arm/unistd.h:		errno = -(res); 					\
asm-arm/unistd.h:		res = -1;						\
asm-arm/unistd.h:	return sys_wait4(-1, wait_stat, 0, NULL);
asm-arm/unistd.h: * The following two can't be eliminated yet - they rely on
asm-arm/elf.h:#define elf_check_arch(x) ( ((x)->e_machine == EM_ARM) && (ELF_PROC_OK((x))) )
asm-arm/elf.h:#define ELF_PLAT_INIT(_r, load_addr)	(_r)->ARM_r0 = 0
asm-arm/elf.h:   implemented optimisations that require it.  26-bit CPUs give you
asm-arm/elf.h:   supported).  32-bit CPUs give you "v3[lb]" for anything based on an
asm-arm/elf.h:   ARM6 or ARM7 core and "armv4[lb]" for anything based on a StrongARM-1
asm-arm/fiq.h: *  linux/include/asm-arm/fiq.h
asm-arm/fiq.h: * Re-written by Russell King
asm-arm/fiq.h:	 * return zero to accept, or -<errno>
asm-arm/ide.h: *  linux/include/asm-arm/ide.h
asm-arm/ide.h: *  Copyright (C) 1994-1996  Linus Torvalds & authors
asm-arm/ide.h:#include <asm-generic/ide_iops.h>
asm-arm/ipc.h: * See arch/arm/kernel/sys-arm.c for ugly details..
asm-arm/irq.h:#define NO_IRQ	((unsigned int)(-1))
asm-arm/arch-cl7500/io.h: * linux/include/asm-arm/arch-cl7500/io.h
asm-arm/arch-cl7500/io.h: *  from linux/include/asm-arm/arch-rpc/io.h
asm-arm/arch-cl7500/io.h: *  06-Dec-1997	RMK	Created.
asm-arm/arch-cl7500/io.h: * We use two different types of addressing - PC style addresses, and ARM
asm-arm/arch-cl7500/io.h: * Dynamic IO functions - let the compiler
asm-arm/arch-cl7500/io.h:	: "r" (value), "r" (port), "Ir" (PCIO_BASE - IO_BASE), "Ir" (IO_BASE)
asm-arm/arch-cl7500/io.h:	: "r" (value|value<<16), "r" (port), "Ir" (PCIO_BASE - IO_BASE), "Ir" (IO_BASE)
asm-arm/arch-cl7500/io.h:	: "r" (value), "r" (port), "Ir" (PCIO_BASE - IO_BASE), "Ir" (IO_BASE)
asm-arm/arch-cl7500/io.h:	: "r" (port), "Ir" (PCIO_BASE - IO_BASE), "Ir" (IO_BASE)		\
asm-arm/arch-cl7500/io.h: * These have to be macros for the 'J' constraint to work -
asm-arm/arch-cl7500/io.h: * +/-4096 immediate operand.
asm-arm/arch-cl7500/hardware.h: * linux/include/asm-arm/arch-cl7500/hardware.h
asm-arm/arch-cl7500/hardware.h: * Copyright (C) 1996-1999 Russell King.
asm-arm/arch-cl7500/uncompress.h: * linux/include/asm-arm/arch-cl7500/uncompress.h
asm-arm/arch-cl7500/vmalloc.h: * linux/include/asm-arm/arch-cl7500/vmalloc.h
asm-arm/arch-cl7500/vmalloc.h: * any out-of-bounds memory accesses will hopefully be caught.
asm-arm/arch-cl7500/vmalloc.h:#define VMALLOC_START	  (((unsigned long)high_memory + VMALLOC_OFFSET) & ~(VMALLOC_OFFSET-1))
asm-arm/arch-cl7500/dma.h: * linux/include/asm-arm/arch-cl7500/dma.h
asm-arm/arch-cl7500/dma.h: * There should not be more than (0xd0000000 - 0xc0000000)
asm-arm/arch-cl7500/ide.h: * linux/include/asm-arm/arch-cl7500/ide.h
asm-arm/arch-cl7500/ide.h: *  29-07-1998	RMK	Major re-work of IDE architecture specific code
asm-arm/arch-cl7500/ide.h:		hw->io_ports[i] = reg;
asm-arm/arch-cl7500/ide.h:		hw->io_ports[IDE_CONTROL_OFFSET] = ctrl_port;
asm-arm/arch-cl7500/ide.h:		hw->io_ports[IDE_CONTROL_OFFSET] = data_port + 0x206;
asm-arm/arch-cl7500/ide.h:	hw->io_ports[IDE_IRQ_OFFSET] = 0;
asm-arm/arch-cl7500/irq.h: * include/asm-arm/arch-cl7500/irq.h
asm-arm/arch-cl7500/irq.h: *   10-10-1996	RMK	Brought up to date with arch-sa110eval
asm-arm/arch-cl7500/irq.h: *   22-08-1998	RMK	Restructured IRQ routines
asm-arm/arch-cl7500/irq.h: *   11-08-1999	PJB	Created ARM7500 version, derived from RiscPC code
asm-arm/arch-cl7500/acornfb.h:	vidc->control |= VIDC20_CTRL_PIX_CK;
asm-arm/arch-cl7500/acornfb.h:	bandwidth = var->pixclock * 8 / var->bits_per_pixel;
asm-arm/arch-cl7500/acornfb.h:		vidc->control |= VIDC20_CTRL_FIFO_16;
asm-arm/arch-cl7500/acornfb.h:		vidc->control |= VIDC20_CTRL_FIFO_20;
asm-arm/arch-cl7500/acornfb.h:		vidc->control |= VIDC20_CTRL_FIFO_24;
asm-arm/arch-cl7500/acornfb.h:		vidc->control |= VIDC20_CTRL_FIFO_28;
asm-arm/arch-cl7500/acornfb.h:	vidc->pll_ctl  = 0x2020;
asm-arm/arch-cl7500/timex.h: * linux/include/asm-arm/arch-cl7500/timex.h
asm-arm/arch-cl7500/irqs.h: * linux/include/asm-arm/arch-cl7500/irqs.h
asm-arm/arch-cl7500/system.h: * linux/include/asm-arm/arch-cl7500/system.h
asm-arm/arch-cl7500/time.h: * linux/include/asm-arm/arch-cl7500/time.h
asm-arm/arch-cl7500/time.h: * Copyright (c) 1996-2000 Russell King.
asm-arm/arch-cl7500/time.h: *  24-Sep-1996	RMK	Created
asm-arm/arch-cl7500/time.h: *  10-Oct-1996	RMK	Brought up to date with arch-sa110eval
asm-arm/arch-cl7500/time.h: *  04-Dec-1997	RMK	Updated for new arch/arm/time.c
asm-arm/arch-cl7500/time.h:		if (count-- == 0) {
asm-arm/arch-cl7500/serial.h: * linux/include/asm-arm/arch-cl7500/serial.h
asm-arm/arch-cl7500/serial.h: *  15-10-1996	RMK	Created
asm-arm/arch-cl7500/serial.h: *  10-08-1999	PJB	Added COM3/COM4 for CL7500
asm-arm/arch-cl7500/param.h: * linux/include/asm-arm/arch-cl7500/param.h
asm-arm/arch-cl7500/keyboard.h: * linux/include/asm-arm/arch-cl7500/keyboard.h
asm-arm/arch-cl7500/keyboard.h: *  from linux/include/asm-arm/arch-rpc/keyboard.h
asm-arm/arch-cl7500/keyboard.h: * Copyright (C) 1998-2001 Russell King
asm-arm/arch-cl7500/memory.h: * linux/include/asm-arm/arch-cl7500/memory.h
asm-arm/arch-cl7500/memory.h: *  20-Oct-1996	RMK	Created
asm-arm/arch-cl7500/memory.h: *  31-Dec-1997	RMK	Fixed definitions to reduce warnings
asm-arm/arch-cl7500/memory.h: *  11-Jan-1998	RMK	Uninlined to reduce hits on cache
asm-arm/arch-cl7500/memory.h: *  08-Feb-1998	RMK	Added __virt_to_bus and __bus_to_virt
asm-arm/arch-cl7500/memory.h: *  21-Mar-1999	RMK	Renamed to memory.h
asm-arm/arch-cl7500/memory.h:#define __virt_to_phys(vpage) ((vpage) - PAGE_OFFSET + PHYS_OFFSET)
asm-arm/arch-cl7500/memory.h:#define __phys_to_virt(ppage) ((ppage) + PAGE_OFFSET - PHYS_OFFSET)
asm-arm/pci.h: * For SA-1111 these functions are "magic" and utilize bounce
asm-arm/pci.h: * buffers as need to workaround SA-1111 DMA bugs.  They are called in
asm-arm/pci.h: * NULL for PCI-like buses (ISA, EISA).
asm-arm/pci.h: * Returns non-NULL cpu-view pointer to the buffer if successful and
asm-arm/pci.h: * The 32-bit bus address to use is returned.
asm-arm/pci.h:	((PTR)->ADDR_NAME)
asm-arm/pci.h:	(((PTR)->ADDR_NAME) = (VAL))
asm-arm/pci.h:	((PTR)->LEN_NAME)
asm-arm/pci.h:	(((PTR)->LEN_NAME) = (VAL))
asm-arm/pci.h: * mode for DMA.  This is the scather-gather version of the
asm-arm/pci.h:		char *vaddr = sg->address;
asm-arm/pci.h:			vaddr = ((char *)page_address(sg->page)) + sg->offset;
asm-arm/pci.h:		consistent_sync(vaddr, sg->length, direction);
asm-arm/pci.h:		sg->dma_address = virt_to_bus(vaddr);
asm-arm/pci.h: * The same as pci_dma_sync_single but for a scatter-gather list,
asm-arm/pci.h:		consistent_sync(sg->address, sg->length, direction);
asm-arm/pci.h: * only drive the low 24-bits during PCI bus mastering, then
asm-arm/pci.h:/* SA-1111 needs these prototypes even when !defined(CONFIG_PCI) */
asm-arm/tlb.h:#include <asm-generic/tlb.h>
asm-arm/xor.h: *  linux/include/asm-arm/xor.h
asm-arm/xor.h:#include <asm-generic/xor.h>
asm-arm/xor.h:	} while (--lines);
asm-arm/xor.h:	} while (--lines);
asm-arm/xor.h:	} while (--lines);
asm-arm/xor.h:	} while (--lines);
asm-arm/ecard.h: * linux/include/asm-arm/ecard.h
asm-arm/ecard.h: *  11-12-1996	RMK	Further minor improvements
asm-arm/ecard.h: *  12-09-1997	RMK	Added interrupt enable/disable for card level
asm-arm/ecard.h:#define ecard_resource_start(ec,nr)	((ec)->resource[nr].start)
asm-arm/ecard.h:#define ecard_resource_end(ec,nr)	((ec)->resource[nr].end)
asm-arm/ecard.h:#define ecard_resource_len(ec,nr)	((ec)->resource[nr].end - \
asm-arm/ecard.h:					 (ec)->resource[nr].start + 1)
asm-arm/ecard.h:#define ecard_claim(ec) ((ec)->claimed = 1)
asm-arm/ecard.h:#define ecard_release(ec) ((ec)->claimed = 0)
asm-arm/ecard.h:/* Definitions internal to ecard.c - for it's use only!!
asm-arm/ecard.h:#define c_id(x)		((x)->r_id)
asm-arm/ecard.h:#define c_len(x)	((x)->r_len[0]|((x)->r_len[1]<<8)|((x)->r_len[2]<<16))
asm-arm/ecard.h:#define c_start(x)	((x)->r_start)
asm-arm/ecard.h:#define ecard_set_drvdata(ec,data)	((ec)->driver_data = (data))
asm-arm/ecard.h:#define ecard_get_drvdata(ec)		((ec)->driver_data)
asm-arm/signal.h:#define SIGRTMAX	(_NSIG-1)
asm-arm/signal.h: * SA_THIRTYTWO		delivers the signal in 32-bit mode, even if the task 
asm-arm/signal.h: *			is running in 26-bit.
asm-arm/signal.h: * SA_INTERRUPT		is a no-op, but left due to historical reasons. Use the
asm-arm/signal.h:#define SA_INTERRUPT	0x20000000 /* dummy -- ignored */
asm-arm/signal.h:#define SIG_ERR	((__sighandler_t)-1)	/* error return from signal */
asm-arm/signal.h:#define sigmask(sig)	(1UL << ((sig) - 1))
asm-arm/cpu-single.h: *  linux/include/asm-arm/cpu-single.h
asm-arm/hc_sl811-hw.h:File: include/asm-arm/hc_sl811-hw.h
asm-arm/hc_sl811-hw.h:	data = readb (hp->hcport2);
asm-arm/hc_sl811-hw.h:	writeb (offset, hp->hcport);
asm-arm/hc_sl811-hw.h:	writeb (data, hp->hcport2);
asm-arm/hc_sl811-hw.h:	writeb (offset, hp->hcport);
asm-arm/hc_sl811-hw.h:	writeb (data, hp->hcport2);
asm-arm/hc_sl811-hw.h:	if (hp->hcport > 0) {
asm-arm/hc_sl811-hw.h:		release_region (hp->hcport, SIZEOF_IO_REGION);
asm-arm/hc_sl811-hw.h:		hp->hcport = 0;
asm-arm/hc_sl811-hw.h:	if (hp->hcport2 > 0) {
asm-arm/hc_sl811-hw.h:		release_region (hp->hcport2, SIZEOF_IO_REGION);
asm-arm/hc_sl811-hw.h:		hp->hcport2 = 0;
asm-arm/hc_sl811-hw.h:		return -EBUSY;
asm-arm/hc_sl811-hw.h:	hp->hcport = addr1;
asm-arm/hc_sl811-hw.h:	if (!hp->hcport) {
asm-arm/hc_sl811-hw.h:		return -EBUSY;
asm-arm/hc_sl811-hw.h:	hp->hcport2 = addr2;
asm-arm/hc_sl811-hw.h:	if (!hp->hcport2) {
asm-arm/setup.h: *  Copyright (C) 1997-1999 Russell King
asm-arm/setup.h: *  - do not go blindly adding fields, add them at the end
asm-arm/setup.h: *  - when adding fields, don't rely on the address until
asm-arm/setup.h: *  - unused fields should be zero (for future expansion)
asm-arm/setup.h: *  - this structure is relatively short-lived - only
asm-arm/setup.h:	    char n[1024 - sizeof(unsigned long)];
asm-arm/setup.h:	u32 flags;		/* bit 0 = read-only */
asm-arm/setup.h:	u32 start;	/* starting block of floppy-based RAM disk image */
asm-arm/setup.h: * this one accidentally used virtual addresses - as such,
asm-arm/setup.h:/* initial values for vesafb-type framebuffers. see struct screen_info
asm-arm/setup.h:/* footbridge memory clock, see arch/arm/mach-footbridge/arch.c */
asm-arm/setup.h:	((unsigned long)(&((struct tag *)0L)->member + 1)	\
asm-arm/setup.h:		<= (tag)->hdr.size * 4)
asm-arm/setup.h:#define tag_next(t)	((struct tag *)((u32 *)(t) + (t)->hdr.size))
asm-arm/setup.h:	for (t = base; t->hdr.size; t = tag_next(t))
asm-arm/nwflash.h:#define FLASH_MINOR		 160	/* MAJOR is 10 - miscdevice */
asm-arm/hardirq.h:#define irq_exit(cpu,irq)	(local_irq_count(cpu)--)
asm-arm/sigcontext.h: * Signal context structure - contains all info to do with the state
asm-arm/arch-riscstation/io.h: *  linux/include/asm-arm/arch-rs/io.h
asm-arm/arch-riscstation/io.h:/* identical to the arch-rpc implementation (bjd) */
asm-arm/arch-riscstation/io.h:#include <asm/arch-rpc/io.h>
asm-arm/arch-riscstation/hardware.h: *  linux/include/asm-arm/arch-rpc/hardware.h
asm-arm/arch-riscstation/hardware.h: *  Copyright (C) 1996-1999 Russell King.
asm-arm/arch-riscstation/uncompress.h: *  linux/include/asm-arm/arch-rpc/uncompress.h
asm-arm/arch-riscstation/uncompress.h:	unsigned long unused[256/4-11];
asm-arm/arch-riscstation/uncompress.h:				y--;
asm-arm/arch-riscstation/uncompress.h:					y--;
asm-arm/arch-riscstation/vmalloc.h: *  linux/include/asm-arm/arch-rpc/vmalloc.h
asm-arm/arch-riscstation/vmalloc.h: * any out-of-bounds memory accesses will hopefully be caught.
asm-arm/arch-riscstation/vmalloc.h:#define VMALLOC_START	  (((unsigned long)high_memory + VMALLOC_OFFSET) & ~(VMALLOC_OFFSET-1))
asm-arm/arch-riscstation/dma.h: *  linux/include/asm-arm/arch-rs/dma.h
asm-arm/arch-riscstation/dma.h:/* identical to the arch-rpc implementation (bjd) */
asm-arm/arch-riscstation/dma.h:#include <asm/arch-rpc/dma.h>
asm-arm/arch-riscstation/ide.h: *  linux/include/asm-arm/arch-rs/ide.h
asm-arm/arch-riscstation/ide.h: *   29-07-1998	RMK	Major re-work of IDE architecture specific code
asm-arm/arch-riscstation/ide.h:		hw->io_ports[i] = reg;
asm-arm/arch-riscstation/ide.h:	hw->io_ports[IDE_CONTROL_OFFSET] = (ide_ioreg_t) ctrl_port;
asm-arm/arch-riscstation/irq.h: *  linux/include/asm-arm/arch-rpc/irq.h
asm-arm/arch-riscstation/irq.h: *   10-10-1996	RMK	Brought up to date with arch-sa110eval
asm-arm/arch-riscstation/irq.h: *   22-08-1998	RMK	Restructured IRQ routines
asm-arm/arch-riscstation/acornfb.h: *  linux/include/asm-arm/arch-rpc/acornfb.h
asm-arm/arch-riscstation/acornfb.h:		d = pixclk - p;
asm-arm/arch-riscstation/acornfb.h:			d = -d;
asm-arm/arch-riscstation/acornfb.h:			best_v = v - 1;
asm-arm/arch-riscstation/acornfb.h:			best_r = r - 1;
asm-arm/arch-riscstation/acornfb.h:	/* Select pixel-clock divisor to keep PLL in range */
asm-arm/arch-riscstation/acornfb.h:	div = var->pixclock / 9090; /*9921*/
asm-arm/arch-riscstation/acornfb.h:	case 1:	vidc->control |= VIDC20_CTRL_PIX_CK;  break;
asm-arm/arch-riscstation/acornfb.h:	case 2:	vidc->control |= VIDC20_CTRL_PIX_CK2; break;
asm-arm/arch-riscstation/acornfb.h:	case 3:	vidc->control |= VIDC20_CTRL_PIX_CK3; break;
asm-arm/arch-riscstation/acornfb.h:	case 4:	vidc->control |= VIDC20_CTRL_PIX_CK4; break;
asm-arm/arch-riscstation/acornfb.h:	case 5:	vidc->control |= VIDC20_CTRL_PIX_CK5; break;
asm-arm/arch-riscstation/acornfb.h:	case 6:	vidc->control |= VIDC20_CTRL_PIX_CK6; break;
asm-arm/arch-riscstation/acornfb.h:	case 7:	vidc->control |= VIDC20_CTRL_PIX_CK7; break;
asm-arm/arch-riscstation/acornfb.h:	case 8: vidc->control |= VIDC20_CTRL_PIX_CK8; break;
asm-arm/arch-riscstation/acornfb.h:	bandwidth = var->pixclock * 8 / var->bits_per_pixel;
asm-arm/arch-riscstation/acornfb.h:		vidc->control |= VIDC20_CTRL_FIFO_16;	/* < 30.0MB/s */
asm-arm/arch-riscstation/acornfb.h:		vidc->control |= VIDC20_CTRL_FIFO_20;	/* < 37.5MB/s */
asm-arm/arch-riscstation/acornfb.h:		vidc->control |= VIDC20_CTRL_FIFO_24;	/* < 45.0MB/s */
asm-arm/arch-riscstation/acornfb.h:		vidc->control |= VIDC20_CTRL_FIFO_28;	/* > 45.0MB/s */
asm-arm/arch-riscstation/acornfb.h:	vidc->pll_ctl  = acornfb_vidc20_find_pll(var->pixclock / div);
asm-arm/arch-riscstation/timex.h: *  linux/include/asm-arm/arch-rpc/timex.h
asm-arm/arch-riscstation/irqs.h: *  linux/include/asm-arm/arch-rs/irqs.h
asm-arm/arch-riscstation/irqs.h:/* identical to the arch-rpc implementation (bjd) */
asm-arm/arch-riscstation/irqs.h:#include <asm/arch-rpc/irqs.h>
asm-arm/arch-riscstation/system.h: *  linux/include/asm-arm/arch-rpc/system.h
asm-arm/arch-riscstation/system.h: *  Copyright (C) 1996-1999 Russell King.
asm-arm/arch-riscstation/time.h: *  linux/include/asm-arm/arch-rs/time.h
asm-arm/arch-riscstation/time.h: * Bits taken from linux/include/asm-arm/arch-rpc/time.h
asm-arm/arch-riscstation/time.h: * (c) 1996-2002 Russell King
asm-arm/arch-riscstation/time.h: * Bits taken from linux/include/asm-arm/arch-ebsa285/time.h
asm-arm/arch-riscstation/time.h:#include <asm/mach-types.h>
asm-arm/arch-riscstation/time.h:/* timer interrut - update things like profiling information and our
asm-arm/arch-riscstation/time.h: * from linux/include/asm-arm/arch-ebsa285/time.h
asm-arm/arch-riscstation/time.h:	 * When the Update-In-Progress (UIP) flag goes from 1 to 0, the
asm-arm/arch-riscstation/time.h: * from linux/include/asm-arm/arch-ebsa285/time.h
asm-arm/arch-riscstation/time.h:	if (((abs(real_minutes - cmos_minutes) + 15)/30) & 1)
asm-arm/arch-riscstation/time.h:	if (abs(real_minutes - cmos_minutes) < 30) {
asm-arm/arch-riscstation/time.h:		retval = -1;
asm-arm/arch-riscstation/time.h:	 * sheets anyway ...                           -- Markus Kuhn
asm-arm/arch-riscstation/serial.h: *  linux/include/asm-arm/arch-rpc/serial.h
asm-arm/arch-riscstation/serial.h: *   15-10-1996	RMK	Created
asm-arm/arch-riscstation/param.h: * linux/include/asm-arm/arch-rpc/param.h
asm-arm/arch-riscstation/keyboard.h: *  linux/include/asm-arm/arch-rpc/keyboard.h
asm-arm/arch-riscstation/keyboard.h: *  Copyright (C) 1998-2001 Russell King
asm-arm/arch-riscstation/memory.h: *  linux/include/asm-arm/arch-clps711x/mmu.h
asm-arm/arch-riscstation/memory.h: * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
asm-arm/arch-riscstation/memory.h:#define __virt_to_phys(vpage) ((vpage) - PAGE_OFFSET + PHYS_OFFSET)
asm-arm/arch-riscstation/memory.h:#define __phys_to_virt(ppage) ((ppage) + PAGE_OFFSET - PHYS_OFFSET)
asm-arm/arch-riscstation/memory.h: * Virtual view <-> DMA view memory address translations
asm-arm/arch-riscstation/memory.h:#define __virt_to_bus(x)	((x) - PAGE_OFFSET)
asm-arm/arch-riscstation/memory.h: * banks.  In 2.2, the Psion (CL-PS7110) port added custom support for
asm-arm/arch-riscstation/memory.h: * 	node 0:  0xc0000000 - 0xc7ffffff
asm-arm/arch-riscstation/memory.h: * 	node 1:  0xc8000000 - 0xcfffffff
asm-arm/arch-riscstation/memory.h: * 	node 2:  0xd0000000 - 0xd7ffffff
asm-arm/arch-riscstation/memory.h: * 	node 3:  0xd8000000 - 0xdfffffff
asm-arm/arch-riscstation/memory.h:		(((unsigned long)(addr) - PAGE_OFFSET) >> NODE_MAX_MEM_SHIFT)
asm-arm/arch-riscstation/memory.h:	(((pfn) - PHYS_PFN_OFFSET) >> (NODE_MAX_MEM_SHIFT - PAGE_SHIFT))
asm-arm/arch-riscstation/memory.h:	(((unsigned long)(addr) & (NODE_MAX_MEM_SIZE - 1)) >> PAGE_SHIFT)
asm-arm/arch-riscstation/memory.h: * The 7500 has up-to 64Mb of memory per bank
asm-arm/arch-mx1ads/io.h: *  linux/include/asm-arm/arch-mx1ads/io.h
asm-arm/arch-mx1ads/io.h: * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
asm-arm/arch-mx1ads/hardware.h: *  linux/include/asm-arm/arch-mx1ads/hardware.h
asm-arm/arch-mx1ads/hardware.h: * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
asm-arm/arch-mx1ads/uncompress.h: *  linux/include/asm-arm/arch-mx1ads/uncompress.h
asm-arm/arch-mx1ads/uncompress.h: * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
asm-arm/arch-mx1ads/vmalloc.h: *  linux/include/asm-arm/arch-mx1ads/vmalloc.h
asm-arm/arch-mx1ads/vmalloc.h: * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
asm-arm/arch-mx1ads/vmalloc.h: * any out-of-bounds memory accesses will hopefully be caught.
asm-arm/arch-mx1ads/vmalloc.h:#define VMALLOC_START	  (((unsigned long)high_memory + VMALLOC_OFFSET) & ~(VMALLOC_OFFSET-1))
asm-arm/arch-mx1ads/dma.h: *  linux/include/asm-arm/mx1ads/dma.h
asm-arm/arch-mx1ads/dma.h: * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
asm-arm/arch-mx1ads/irq.h: *  linux/include/asm-arm/arch-mx1ads/irq.h
asm-arm/arch-mx1ads/irq.h: * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
asm-arm/arch-mx1ads/platform.h: * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
asm-arm/arch-mx1ads/platform.h: * ------------------------------------------------------------------------
asm-arm/arch-mx1ads/platform.h: * ------------------------------------------------------------------------
asm-arm/arch-mx1ads/platform.h:/* ------------------------------------------------------------------------
asm-arm/arch-mx1ads/platform.h: * ------------------------------------------------------------------------
asm-arm/arch-mx1ads/timex.h: *  linux/include/asm-arm/mx1ads/timex.h
asm-arm/arch-mx1ads/timex.h: * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
asm-arm/arch-mx1ads/irqs.h: *  linux/include/asm-arm/arch-mx1ads/irqs.h
asm-arm/arch-mx1ads/irqs.h: * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
asm-arm/arch-mx1ads/system.h: *  linux/include/asm-arm/arch-mx1ads/system.h
asm-arm/arch-mx1ads/system.h: * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
asm-arm/arch-mx1ads/time.h: *  linux/include/asm-arm/arch-mx1ads/time.h
asm-arm/arch-mx1ads/time.h: * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
asm-arm/arch-mx1ads/time.h: * Note-
asm-arm/arch-mx1ads/time.h:	ticks = timer1->TimerCounter;
asm-arm/arch-mx1ads/time.h:	if (timer1->TimerClear & 1)
asm-arm/arch-mx1ads/time.h:	if (timer1->TimerClear) {
asm-arm/arch-mx1ads/time.h:		timer1->TimerClear = 0x0;
asm-arm/arch-mx1ads/time.h:	timer0->TimerControl = 0;
asm-arm/arch-mx1ads/time.h:	timer1->TimerControl = 0;
asm-arm/arch-mx1ads/time.h:	timer0->TimerPrescaler = 0;
asm-arm/arch-mx1ads/time.h:	timer1->TimerPrescaler = 0;
asm-arm/arch-mx1ads/time.h:	timer1->TimerCompare = 328;
asm-arm/arch-mx1ads/time.h:	timer1->TimerControl = (TIM_32KHZ | TIM_INTEN | TIM_ENAB);
asm-arm/arch-mx1ads/param.h: *  linux/include/asm-arm/arch-mx1ads/param.h
asm-arm/arch-mx1ads/param.h: * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
asm-arm/arch-mx1ads/keyboard.h: *  linux/include/asm-arm/arch-mx1ads/keyboard.h
asm-arm/arch-mx1ads/memory.h: *  linux/include/asm-arm/arch-mx1ads/memory.h
asm-arm/arch-mx1ads/memory.h: * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
asm-arm/arch-mx1ads/memory.h: * This should be hot-swapable with a CONFIG_MX1ADS_SDRAM
asm-arm/arch-mx1ads/memory.h:#define __virt_to_phys(vpage) ((vpage) - PAGE_OFFSET + PHYS_OFFSET)
asm-arm/arch-mx1ads/memory.h:#define __phys_to_virt(ppage) ((ppage) + PAGE_OFFSET - PHYS_OFFSET)
asm-arm/arch-mx1ads/memory.h: * Virtual view <-> DMA view memory address translations
asm-arm/arch-mx1ads/memory.h:#define __virt_to_bus(x)	(x - PAGE_OFFSET +  PHYS_OFFSET)
asm-arm/arch-mx1ads/memory.h:#define __bus_to_virt(x)	(x -  PHYS_OFFSET + PAGE_OFFSET)
asm-arm/processor.h: *  linux/include/asm-arm/processor.h
asm-arm/processor.h: *  Copyright (C) 1995-2002 Russell King
asm-arm/processor.h:	return t->save ? pc_pointer(t->save->pc) : 0;
asm-arm/processor.h:	return t->save ? t->save->fp : 0;
asm-arm/processor.h:#define get_task_struct(p)	atomic_inc(&(p)->thread.refcount)
asm-arm/processor.h:	if (atomic_dec_and_test(&(p)->thread.refcount))		\
asm-arm/linux_logo.h: *  linux/include/asm-arm/linux_logo.h
asm-arm/mmu_context.h: *  linux/include/asm-arm/mmu_context.h
asm-arm/mmu_context.h: *   27-06-1996	RMK	Created
asm-arm/mmu_context.h:#include <asm/proc-fns.h>
asm-arm/mmu_context.h: * tsk->mm will be NULL
asm-arm/mmu_context.h:		cpu_switch_mm(next->pgd, tsk);
asm-arm/sizes.h: * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
asm-arm/sizes.h:/* DO NOT EDIT!! - this file automatically generated
asm-arm/sizes.h: *                 from .s file by awk -f s2h.awk
asm-arm/semaphore.h: * linux/include/asm-arm/semaphore.h
asm-arm/semaphore.h:	atomic_set(&sem->count, val);
asm-arm/semaphore.h:	sem->sleepers = 0;
asm-arm/semaphore.h:	init_waitqueue_head(&sem->wait);
asm-arm/semaphore.h:	sem->__magic = (long)&sem->__magic;
asm-arm/semaphore.h:	CHECK_MAGIC(sem->__magic);
asm-arm/semaphore.h:	CHECK_MAGIC(sem->__magic);
asm-arm/semaphore.h:	CHECK_MAGIC(sem->__magic);
asm-arm/semaphore.h:	CHECK_MAGIC(sem->__magic);
asm-arm/semaphore.h:	return atomic_read(&sem->count);
asm-arm/fcntl.h:/* open/fcntl - O_SYNC is only implemented on blocks devices and on files
asm-arm/fcntl.h:#define O_DIRECT	0200000	/* direct disk access hint - currently ignored */
asm-arm/fcntl.h:#define F_GETFL		3	/* get file->f_flags */
asm-arm/fcntl.h:#define F_SETFL		4	/* set file->f_flags */
asm-arm/mmzone.h: *  linux/include/asm-arm/mmzone.h
asm-arm/mmzone.h: *  1999-12-29	Nicolas Pitre		Created
asm-arm/mmzone.h:#define NODE_MEM_MAP(nid)	(NODE_DATA(nid)->node_mem_map)
asm-arm/arch-epxa/exc-epxa10dbr2.h:/* megafunction wizard: %ARM-Based Excalibur%
asm-arm/arch-epxa/exc-epxa10dbr2.h:   MODULE: ARM-Based Excalibur
asm-arm/arch-epxa/exc-epxa10dbr2.h:   Megafunction Name(s): ARM-Based Excalibur
asm-arm/arch-epxa/exc-epxa10dbr2.h:   THIS IS A WIZARD-GENERATED FILE. DO NOT EDIT THIS FILE!
asm-arm/arch-epxa/exc-epxa10dbr3.h:/* megafunction wizard: %ARM-Based Excalibur%
asm-arm/arch-epxa/exc-epxa10dbr3.h:   MODULE: ARM-Based Excalibur
asm-arm/arch-epxa/exc-epxa10dbr3.h:   File Name: F:\pr_armboot\armboot-1.1.0\board\epxa10db\quartus\excalibur.h
asm-arm/arch-epxa/exc-epxa10dbr3.h:   Megafunction Name(s): ARM-Based Excalibur
asm-arm/arch-epxa/exc-epxa10dbr3.h:   THIS IS A WIZARD-GENERATED FILE. DO NOT EDIT THIS FILE!
asm-arm/arch-epxa/io.h: *  linux/include/asm-arm/arch-epxa10db/io.h
asm-arm/arch-epxa/io.h: * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
asm-arm/arch-epxa/int_ctrl00.h: * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
asm-arm/arch-epxa/mode_ctrl00.h: * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
asm-arm/arch-epxa/hardware.h: *  linux/include/asm-arm/arch-epxa10/hardware.h
asm-arm/arch-epxa/hardware.h: * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
asm-arm/arch-epxa/uncompress.h: *  linux/include/asm-arm/arch-epxa10db/uncompress.h
asm-arm/arch-epxa/uncompress.h: * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
asm-arm/arch-epxa/tdkphy.h: * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
asm-arm/arch-epxa/vmalloc.h: *  linux/include/asm-arm/arch-epxa10db/vmalloc.h
asm-arm/arch-epxa/vmalloc.h: * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
asm-arm/arch-epxa/vmalloc.h: * any out-of-bounds memory accesses will hopefully be caught.
asm-arm/arch-epxa/vmalloc.h:#define VMALLOC_START	  (((unsigned long)high_memory + VMALLOC_OFFSET) & ~(VMALLOC_OFFSET-1))
asm-arm/arch-epxa/dma.h: *  linux/include/asm-arm/arch-camelot/dma.h
asm-arm/arch-epxa/dma.h: * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
asm-arm/arch-epxa/irq.h: *  linux/include/asm-arm/arch-epxa10/irq.h
asm-arm/arch-epxa/irq.h: * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
asm-arm/arch-epxa/exc-epxa1db.h:/* megafunction wizard: %ARM-Based Excalibur%
asm-arm/arch-epxa/exc-epxa1db.h:   MODULE: ARM-Based Excalibur
asm-arm/arch-epxa/exc-epxa1db.h:   Megafunction Name(s): ARM-Based Excalibur
asm-arm/arch-epxa/exc-epxa1db.h:   THIS IS A WIZARD-GENERATED FILE. DO NOT EDIT THIS FILE!
asm-arm/arch-epxa/timer00.h: * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
asm-arm/arch-epxa/uart00.h: * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
asm-arm/arch-epxa/timex.h: *  linux/include/asm-arm/arch-epxa10db/timex.h
asm-arm/arch-epxa/timex.h: * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
asm-arm/arch-epxa/irqs.h: *  linux/include/asm-arm/arch-camelot/irqs.h
asm-arm/arch-epxa/irqs.h: * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
asm-arm/arch-epxa/excalibur.h:#include "exc-epxa10dbr2.h"
asm-arm/arch-epxa/excalibur.h:#include "exc-epxa10dbr3.h"
asm-arm/arch-epxa/excalibur.h:#include "exc-epxa1db.h"
asm-arm/arch-epxa/system.h: *  linux/include/asm-arm/arch-epxa10db/system.h
asm-arm/arch-epxa/system.h: * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
asm-arm/arch-epxa/time.h: *  linux/include/asm-arm/arch-epxa10db/time.h
asm-arm/arch-epxa/time.h: * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
asm-arm/arch-epxa/serial.h: *  linux/include/asm-arm/arch-epxa10db/serial.h
asm-arm/arch-epxa/serial.h: * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
asm-arm/arch-epxa/param.h: *  linux/include/asm-arm/arch-epxa10db/param.h
asm-arm/arch-epxa/param.h: * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
asm-arm/arch-epxa/pld_conf00.h: * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
asm-arm/arch-epxa/memory.h: *  linux/include/asm-arm/arch-epxa10/memory.h
asm-arm/arch-epxa/memory.h: * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
asm-arm/arch-epxa/memory.h:#define __virt_to_phys(vpage) ((vpage) - PAGE_OFFSET)
asm-arm/arch-epxa/memory.h: * Virtual view <-> DMA view memory address translations
asm-arm/arch-epxa/memory.h:#define __virt_to_bus(x)	(x - PAGE_OFFSET + /*SDRAM_BASE*/0)
asm-arm/arch-epxa/memory.h:#define __bus_to_virt(x)	(x - /*SDRAM_BASE*/0 + PAGE_OFFSET)
asm-arm/arch-tbox/io.h: * linux/include/asm-arm/arch-tbox/io.h
asm-arm/arch-tbox/io.h: * Copyright (C) 1996-1999 Russell King
asm-arm/arch-tbox/hardware.h: * linux/include/asm-arm/arch-tbox/hardware.h
asm-arm/arch-tbox/hardware.h: * 0xfff20000	0x00120000	  C-Cube
asm-arm/arch-tbox/hardware.h: * 0xfffe0000	0x001e0000	  C-Cube DMA throttle
asm-arm/arch-tbox/uncompress.h: * linux/include/asm-arm/arch-nexuspci/uncompress.h
asm-arm/arch-tbox/uncompress.h: *  from linux/include/asm-arm/arch-ebsa110/uncompress.h
asm-arm/arch-tbox/vmalloc.h: * linux/include/asm-arm/arch-rpc/vmalloc.h
asm-arm/arch-tbox/vmalloc.h: * any out-of-bounds memory accesses will hopefully be caught.
asm-arm/arch-tbox/vmalloc.h:#define VMALLOC_START	  (((unsigned long)high_memory + VMALLOC_OFFSET) & ~(VMALLOC_OFFSET-1))
asm-arm/arch-tbox/dma.h: * linux/include/asm-arm/arch-tbox/dma.h
asm-arm/arch-tbox/dma.h: * exception is the double-buffering which we can't really abstract
asm-arm/arch-tbox/ide.h: * linux/include/asm-arm/arch-tbox/ide.h
asm-arm/arch-tbox/irq.h: * include/asm-arm/arch-tbox/irq.h
asm-arm/arch-tbox/timex.h: * linux/include/asm-arm/arch-tbox/timex.h
asm-arm/arch-tbox/irqs.h: * linux/include/asm-arm/arch-tbox/irqs.h
asm-arm/arch-tbox/system.h: * linux/include/asm-arm/arch-tbox/system.h
asm-arm/arch-tbox/system.h: * Copyright (c) 1996-1999 Russell King.
asm-arm/arch-tbox/time.h: * linux/include/asm-arm/arch-tbox/time.h
asm-arm/arch-tbox/time.h: * Tbox has no real-time clock -- we get millisecond ticks to update
asm-arm/arch-tbox/serial.h: * linux/include/asm-arm/arch-tbox/serial.h
asm-arm/arch-tbox/serial.h: *  15-10-1996	RMK	Created
asm-arm/arch-tbox/serial.h: *  09-06-1998  PJB	tbox version
asm-arm/arch-tbox/keyboard.h: * linux/include/asm-arm/arch-tbox/keyboard.h
asm-arm/arch-tbox/keyboard.h: * Copyright (C) 1998-2001 Russell King
asm-arm/arch-tbox/memory.h: * linux/include/asm-arm/arch-tbox/memory.h
asm-arm/arch-tbox/memory.h: * Copyright (c) 1996-1999 Russell King.
asm-arm/arch-tbox/memory.h: * Copyright (c) 1998-1999 Phil Blundell
asm-arm/arch-tbox/memory.h:#define __virt_to_phys(vpage) ((vpage) - PAGE_OFFSET + PHYS_OFFSET)
asm-arm/arch-tbox/memory.h:#define __phys_to_virt(ppage) ((ppage) + PAGE_OFFSET - PHYS_OFFSET)
asm-arm/arch-sa1100/io.h: * linux/include/asm-arm/arch-sa1100/io.h
asm-arm/arch-sa1100/io.h: * Copyright (C) 1997-1999 Russell King
asm-arm/arch-sa1100/io.h: *  06-12-1997	RMK	Created.
asm-arm/arch-sa1100/io.h: *  07-04-1999	RMK	Major cleanup
asm-arm/arch-sa1100/pangolin.h: * linux/include/asm-arm/arch-sa1100/pangolin.h
asm-arm/arch-sa1100/pangolin.h: *  PSKTSEL = 0 ---> PCMCIA
asm-arm/arch-sa1100/pangolin.h: *  PSKTSEL = 1 ---> IDE port
asm-arm/arch-sa1100/pfs168.h: * linux/include/asm-arm/arch-sa1100/pfs168.h
asm-arm/arch-sa1100/pfs168.h: * This file contains the hardware specific definitions for PFS-168
asm-arm/arch-sa1100/pfs168.h: * PFS-168 definitions:
asm-arm/arch-sa1100/graphicsmaster.h: * linux/include/asm-arm/arch-sa1100/graphicsmaster.h
asm-arm/arch-sa1100/graphicsmaster.h:#define ADS_p2v( x )		((x) - ADS_CPLD_BASE + 0xf0000000)
asm-arm/arch-sa1100/graphicsmaster.h:#define ADS_v2p( x )		((x) - 0xf0000000 + ADS_CPLD_BASE)
asm-arm/arch-sa1100/graphicsmaster.h:/* On-Board Ethernet */
asm-arm/arch-sa1100/graphicsmaster.h:/* On-Board Quad UART 16C554 */
asm-arm/arch-sa1100/graphicsmaster.h:#define ADS_LED0	GPIO_GPIO20		/* on-board Green */
asm-arm/arch-sa1100/graphicsmaster.h:#define ADS_LED1	GPIO_GPIO25		/* on-board Yellow */
asm-arm/arch-sa1100/graphicsmaster.h:#define ADS_LED2	GPIO_GPIO26		/* on-board Red */
asm-arm/arch-sa1100/hardware.h: * linux/include/asm-arm/arch-sa1100/hardware.h
asm-arm/arch-sa1100/hardware.h:#include <asm/mach-types.h>
asm-arm/arch-sa1100/hardware.h:# define __REGP(x)	((__regbase *)((x)&~4095))->offset[((x)&4095)>>2]
asm-arm/arch-sa1100/hardware.h:#include "SA-1100.h"
asm-arm/arch-sa1100/hardware.h: * IRQs are generated on Falling-Edge, Rising-Edge, or both.
asm-arm/arch-sa1100/hardware.h: * Any definitions in these files should be prefixed by an identifier -
asm-arm/arch-sa1100/hardware.h:#define SA1101_p2v( x )         ((x) - SA1101_BASE + 0xf4000000)
asm-arm/arch-sa1100/hardware.h:#define SA1101_v2p( x )         ((x) - 0xf4000000  + SA1101_BASE)
asm-arm/arch-sa1100/hardware.h:#include "SA-1101.h"
asm-arm/arch-sa1100/uncompress.h: * linux/include/asm-arm/arch-brutus/uncompress.h
asm-arm/arch-sa1100/simputer.h: * linux/include/asm-arm/arch-sa1100/simputer.h
asm-arm/arch-sa1100/simputer.h: * Only include this file from SA1100-specific files.
asm-arm/arch-sa1100/vmalloc.h: * linux/include/asm-arm/arch-sa1100/vmalloc.h
asm-arm/arch-sa1100/vmalloc.h: * any out-of-bounds memory accesses will hopefully be caught.
asm-arm/arch-sa1100/vmalloc.h:#define VMALLOC_START	  (((unsigned long)high_memory + VMALLOC_OFFSET) & ~(VMALLOC_OFFSET-1))
asm-arm/arch-sa1100/SA-1100.h: *	FILE    	SA-1100.h
asm-arm/arch-sa1100/SA-1100.h: *	System  	StrongARM SA-1100
asm-arm/arch-sa1100/SA-1100.h: *	        	SA-1100 microprocessor (Advanced RISC Machine (ARM)
asm-arm/arch-sa1100/SA-1100.h: *	        	StrongARM SA-1100 data sheet version 2.2.
asm-arm/arch-sa1100/SA-1100.h:#error You must include hardware.h not SA-1100.h
asm-arm/arch-sa1100/SA-1100.h: *              	Controller (UDC) Control/Status register end-point 0
asm-arm/arch-sa1100/SA-1100.h: *              	Controller (UDC) Control/Status register end-point 1
asm-arm/arch-sa1100/SA-1100.h: *              	Controller (UDC) Control/Status register end-point 2
asm-arm/arch-sa1100/SA-1100.h: *              	Controller (UDC) Data register end-point 0
asm-arm/arch-sa1100/SA-1100.h: *              	Controller (UDC) Write Count register end-point 0
asm-arm/arch-sa1100/SA-1100.h:#define Ser0UDCCS0	__REG(0x80000010)  /* Ser. port 0 UDC Control/Status reg. end-point 0 */
asm-arm/arch-sa1100/SA-1100.h:#define Ser0UDCCS1	__REG(0x80000014)  /* Ser. port 0 UDC Control/Status reg. end-point 1 (output) */
asm-arm/arch-sa1100/SA-1100.h:#define Ser0UDCCS2	__REG(0x80000018)  /* Ser. port 0 UDC Control/Status reg. end-point 2 (input) */
asm-arm/arch-sa1100/SA-1100.h:#define Ser0UDCD0	__REG(0x8000001C)  /* Ser. port 0 UDC Data reg. end-point 0 */
asm-arm/arch-sa1100/SA-1100.h:#define Ser0UDCWC	__REG(0x80000020)  /* Ser. port 0 UDC Write Count reg. end-point 0 */
asm-arm/arch-sa1100/SA-1100.h:#define UDCCR_EIM	0x00000008	/* End-point 0 Interrupt Mask      */
asm-arm/arch-sa1100/SA-1100.h:#define UDCOMP_OUTMAXP	Fld (8, 0)	/* OUTput MAXimum Packet size - 1  */
asm-arm/arch-sa1100/SA-1100.h:                	(((Size) - 1) << FShft (UDCOMP_OUTMAXP))
asm-arm/arch-sa1100/SA-1100.h:#define UDCIMP_INMAXP	Fld (8, 0)	/* INput MAXimum Packet size - 1   */
asm-arm/arch-sa1100/SA-1100.h:                	(((Size) - 1) << FShft (UDCIMP_INMAXP))
asm-arm/arch-sa1100/SA-1100.h:#define UDCCS1_RFS	0x00000001	/* Receive FIFO 12-bytes or more   */
asm-arm/arch-sa1100/SA-1100.h:#define UDCCS2_TFS	0x00000001	/* Transmit FIFO 8-bytes or less   */
asm-arm/arch-sa1100/SA-1100.h:#define UDCCS2_TUR	0x00000008	/* Transmit FIFO Under-Run         */
asm-arm/arch-sa1100/SA-1100.h:#define UDCSR_EIR	0x00000001	/* End-point 0 Interrupt Request   */
asm-arm/arch-sa1100/SA-1100.h:#define _UTCR0(Nb)	__REG(0x80010000 + ((Nb) - 1)*0x00020000)  /* UART Control Reg. 0 [1..3] */
asm-arm/arch-sa1100/SA-1100.h:#define _UTCR1(Nb)	__REG(0x80010004 + ((Nb) - 1)*0x00020000)  /* UART Control Reg. 1 [1..3] */
asm-arm/arch-sa1100/SA-1100.h:#define _UTCR2(Nb)	__REG(0x80010008 + ((Nb) - 1)*0x00020000)  /* UART Control Reg. 2 [1..3] */
asm-arm/arch-sa1100/SA-1100.h:#define _UTCR3(Nb)	__REG(0x8001000C + ((Nb) - 1)*0x00020000)  /* UART Control Reg. 3 [1..3] */
asm-arm/arch-sa1100/SA-1100.h:#define _UTCR4(Nb)	__REG(0x80010010 + ((Nb) - 1)*0x00020000)  /* UART Control Reg. 4 [2] */
asm-arm/arch-sa1100/SA-1100.h:#define _UTDR(Nb)	__REG(0x80010014 + ((Nb) - 1)*0x00020000)  /* UART Data Reg. [1..3] */
asm-arm/arch-sa1100/SA-1100.h:#define _UTSR0(Nb)	__REG(0x8001001C + ((Nb) - 1)*0x00020000)  /* UART Status Reg. 0 [1..3] */
asm-arm/arch-sa1100/SA-1100.h:#define _UTSR1(Nb)	__REG(0x80010020 + ((Nb) - 1)*0x00020000)  /* UART Status Reg. 1 [1..3] */
asm-arm/arch-sa1100/SA-1100.h:#define UTCR0_7BitData	(UTCR0_DSS*0)	/*  7-Bit Data                     */
asm-arm/arch-sa1100/SA-1100.h:#define UTCR0_8BitData	(UTCR0_DSS*1)	/*  8-Bit Data                     */
asm-arm/arch-sa1100/SA-1100.h:#define UTCR0_RcRsEdg	(UTCR0_RCE*0)	/*  Receive clock Rising-Edge      */
asm-arm/arch-sa1100/SA-1100.h:#define UTCR0_RcFlEdg	(UTCR0_RCE*1)	/*  Receive clock Falling-Edge     */
asm-arm/arch-sa1100/SA-1100.h:#define UTCR0_TrRsEdg	(UTCR0_TCE*0)	/*  Transmit clock Rising-Edge     */
asm-arm/arch-sa1100/SA-1100.h:#define UTCR0_TrFlEdg	(UTCR0_TCE*1)	/*  Transmit clock Falling-Edge    */
asm-arm/arch-sa1100/SA-1100.h:#define UTCR1_BRD	Fld (4, 0)	/* Baud Rate Divisor/16 - 1 [11:8] */
asm-arm/arch-sa1100/SA-1100.h:#define UTCR2_BRD	Fld (8, 0)	/* Baud Rate Divisor/16 - 1  [7:0] */
asm-arm/arch-sa1100/SA-1100.h:                	(((Div) - 16)/16 >> FSize (UTCR2_BRD) << \
asm-arm/arch-sa1100/SA-1100.h:                	(((Div) - 16)/16 & FAlnMsk (UTCR2_BRD) << \
asm-arm/arch-sa1100/SA-1100.h:                	(((Div) - 1)/16 >> FSize (UTCR2_BRD) << \
asm-arm/arch-sa1100/SA-1100.h:                	(((Div) - 1)/16 & FAlnMsk (UTCR2_BRD) << \
asm-arm/arch-sa1100/SA-1100.h:#define UTCR3_RIE	0x00000008	/* Receive FIFO 1/3-to-2/3-full or */
asm-arm/arch-sa1100/SA-1100.h:#define UTCR3_TIE	0x00000010	/* Transmit FIFO 1/2-full or less  */
asm-arm/arch-sa1100/SA-1100.h:#define UTCR3_LBM	0x00000020	/* Look-Back Mode                  */
asm-arm/arch-sa1100/SA-1100.h:#define UTCR4_HSE	0x00000001	/* Hewlett-Packard Serial InfraRed */
asm-arm/arch-sa1100/SA-1100.h:                	        	/* (HP-SIR) modulation Enable      */
asm-arm/arch-sa1100/SA-1100.h:#define UTCR4_NRZ	(UTCR4_HSE*0)	/*  Non-Return to Zero modulation  */
asm-arm/arch-sa1100/SA-1100.h:#define UTCR4_HPSIR	(UTCR4_HSE*1)	/*  HP-SIR modulation              */
asm-arm/arch-sa1100/SA-1100.h:#define UTCR4_LPM	0x00000002	/* Low-Power Mode                  */
asm-arm/arch-sa1100/SA-1100.h:#define UTDR_ROR	0x00000400	/*  Receive FIFO Over-Run (read)   */
asm-arm/arch-sa1100/SA-1100.h:#define UTSR0_TFS	0x00000001	/* Transmit FIFO 1/2-full or less  */
asm-arm/arch-sa1100/SA-1100.h:#define UTSR0_RFS	0x00000002	/* Receive FIFO 1/3-to-2/3-full or */
asm-arm/arch-sa1100/SA-1100.h:#define UTSR1_ROR	0x00000020	/* Receive FIFO Over-Run (read)    */
asm-arm/arch-sa1100/SA-1100.h:#define SDCR0_LBM	0x00000004	/* Look-Back Mode                  */
asm-arm/arch-sa1100/SA-1100.h:#define SDCR0_NRZ	(SDCR0_BMS*1)	/*  Non-Return to Zero modulation  */
asm-arm/arch-sa1100/SA-1100.h:#define SDCR0_RcRsEdg	(SDCR0_RCE*0)	/*  Receive clock Rising-Edge      */
asm-arm/arch-sa1100/SA-1100.h:#define SDCR0_RcFlEdg	(SDCR0_RCE*1)	/*  Receive clock Falling-Edge     */
asm-arm/arch-sa1100/SA-1100.h:#define SDCR0_TrRsEdg	(SDCR0_TCE*0)	/*  Transmit clock Rising-Edge     */
asm-arm/arch-sa1100/SA-1100.h:#define SDCR0_TrFlEdg	(SDCR0_TCE*1)	/*  Transmit clock Falling-Edge    */
asm-arm/arch-sa1100/SA-1100.h:#define SDCR1_RIE	0x00000008	/* Receive FIFO 1/3-to-2/3-full or */
asm-arm/arch-sa1100/SA-1100.h:#define SDCR1_TIE	0x00000010	/* Transmit FIFO 1/2-full or less  */
asm-arm/arch-sa1100/SA-1100.h:#define SDCR1_TUS	0x00000040	/* Transmit FIFO Under-run Select  */
asm-arm/arch-sa1100/SA-1100.h:#define SDCR1_EFrmURn	(SDCR1_TUS*0)	/*  End Frame on Under-Run         */
asm-arm/arch-sa1100/SA-1100.h:#define SDCR1_AbortURn	(SDCR1_TUS*1)	/*  Abort on Under-Run             */
asm-arm/arch-sa1100/SA-1100.h:#define SDCR3_BRD	Fld (4, 0)	/* Baud Rate Divisor/16 - 1 [11:8] */
asm-arm/arch-sa1100/SA-1100.h:#define SDCR4_BRD	Fld (8, 0)	/* Baud Rate Divisor/16 - 1  [7:0] */
asm-arm/arch-sa1100/SA-1100.h:                	(((Div) - 16)/16 >> FSize (SDCR4_BRD) << \
asm-arm/arch-sa1100/SA-1100.h:                	(((Div) - 16)/16 & FAlnMsk (SDCR4_BRD) << \
asm-arm/arch-sa1100/SA-1100.h:                	(((Div) - 1)/16 >> FSize (SDCR4_BRD) << \
asm-arm/arch-sa1100/SA-1100.h:                	(((Div) - 1)/16 & FAlnMsk (SDCR4_BRD) << \
asm-arm/arch-sa1100/SA-1100.h:#define SDDR_EOF	0x00000100	/*  receive End-Of-Frame (read)    */
asm-arm/arch-sa1100/SA-1100.h:#define SDDR_ROR	0x00000400	/*  Receive FIFO Over-Run (read)   */
asm-arm/arch-sa1100/SA-1100.h:#define SDSR0_TUR	0x00000002	/* Transmit FIFO Under-Run         */
asm-arm/arch-sa1100/SA-1100.h:#define SDSR0_TFS	0x00000008	/* Transmit FIFO 1/2-full or less  */
asm-arm/arch-sa1100/SA-1100.h:#define SDSR0_RFS	0x00000010	/* Receive FIFO 1/3-to-2/3-full or */
asm-arm/arch-sa1100/SA-1100.h:#define SDSR1_EOF	0x00000020	/* receive End-Of-Frame (read)     */
asm-arm/arch-sa1100/SA-1100.h:#define SDSR1_ROR	0x00000080	/* Receive FIFO Over-Run (read)    */
asm-arm/arch-sa1100/SA-1100.h: * High-Speed Serial to Parallel controller (HSSP) control registers
asm-arm/arch-sa1100/SA-1100.h: *    Ser2HSCR0 	Serial port 2 High-Speed Serial to Parallel
asm-arm/arch-sa1100/SA-1100.h: *    Ser2HSCR1 	Serial port 2 High-Speed Serial to Parallel
asm-arm/arch-sa1100/SA-1100.h: *    Ser2HSDR  	Serial port 2 High-Speed Serial to Parallel
asm-arm/arch-sa1100/SA-1100.h: *    Ser2HSSR0 	Serial port 2 High-Speed Serial to Parallel
asm-arm/arch-sa1100/SA-1100.h: *    Ser2HSSR1 	Serial port 2 High-Speed Serial to Parallel
asm-arm/arch-sa1100/SA-1100.h: *    Ser2HSCR2 	Serial port 2 High-Speed Serial to Parallel
asm-arm/arch-sa1100/SA-1100.h: *              	SA-1100.]
asm-arm/arch-sa1100/SA-1100.h:#define HSCR0_LBM	0x00000002	/* Look-Back Mode                  */
asm-arm/arch-sa1100/SA-1100.h:#define HSCR0_TUS	0x00000004	/* Transmit FIFO Under-run Select  */
asm-arm/arch-sa1100/SA-1100.h:#define HSCR0_EFrmURn	(HSCR0_TUS*0)	/*  End Frame on Under-Run         */
asm-arm/arch-sa1100/SA-1100.h:#define HSCR0_AbortURn	(HSCR0_TUS*1)	/*  Abort on Under-Run             */
asm-arm/arch-sa1100/SA-1100.h:#define HSCR0_RIE	0x00000020	/* Receive FIFO 2/5-to-3/5-full or */
asm-arm/arch-sa1100/SA-1100.h:#define HSCR0_TIE	0x00000040	/* Transmit FIFO 1/2-full or less  */
asm-arm/arch-sa1100/SA-1100.h:#define HSDR_EOF	0x00000100	/*  receive End-Of-Frame (read)    */
asm-arm/arch-sa1100/SA-1100.h:#define HSDR_ROR	0x00000400	/*  Receive FIFO Over-Run (read)   */
asm-arm/arch-sa1100/SA-1100.h:#define HSSR0_TUR	0x00000002	/* Transmit FIFO Under-Run         */
asm-arm/arch-sa1100/SA-1100.h:#define HSSR0_TFS	0x00000008	/* Transmit FIFO 1/2-full or less  */
asm-arm/arch-sa1100/SA-1100.h:#define HSSR0_RFS	0x00000010	/* Receive FIFO 2/5-to-3/5-full or */
asm-arm/arch-sa1100/SA-1100.h:#define HSSR1_EOF	0x00000010	/* receive End-Of-Frame (read)     */
asm-arm/arch-sa1100/SA-1100.h:#define HSSR1_ROR	0x00000040	/* Receive FIFO Over-Run (read)    */
asm-arm/arch-sa1100/SA-1100.h:                	        	/*  (non-inverted)                 */
asm-arm/arch-sa1100/SA-1100.h:                	        	/*  (non-inverted)                 */
asm-arm/arch-sa1100/SA-1100.h: * Multi-media Communications Port (MCP) control registers
asm-arm/arch-sa1100/SA-1100.h: *    Ser4MCCR0 	Serial port 4 Multi-media Communications Port (MCP)
asm-arm/arch-sa1100/SA-1100.h: *    Ser4MCDR0 	Serial port 4 Multi-media Communications Port (MCP)
asm-arm/arch-sa1100/SA-1100.h: *    Ser4MCDR1 	Serial port 4 Multi-media Communications Port (MCP)
asm-arm/arch-sa1100/SA-1100.h: *    Ser4MCDR2 	Serial port 4 Multi-media Communications Port (MCP)
asm-arm/arch-sa1100/SA-1100.h: *    Ser4MCSR  	Serial port 4 Multi-media Communications Port (MCP)
asm-arm/arch-sa1100/SA-1100.h: *    Ser4MCCR1 	Serial port 4 Multi-media Communications Port (MCP)
asm-arm/arch-sa1100/SA-1100.h: *              	SA-1100.]
asm-arm/arch-sa1100/SA-1100.h:#define MCCR0_TTE	0x00080000	/* Telecom Transmit FIFO 1/2-full  */
asm-arm/arch-sa1100/SA-1100.h:#define MCCR0_TRE	0x00100000	/* Telecom Receive FIFO 1/2-full   */
asm-arm/arch-sa1100/SA-1100.h:#define MCCR0_ATE	0x00200000	/* Audio Transmit FIFO 1/2-full    */
asm-arm/arch-sa1100/SA-1100.h:#define MCCR0_ARE	0x00400000	/* Audio Receive FIFO 1/2-full or  */
asm-arm/arch-sa1100/SA-1100.h:#define MCCR0_LBM	0x00800000	/* Look-Back Mode                  */
asm-arm/arch-sa1100/SA-1100.h:#define MCCR0_ECP	Fld (2, 24)	/* External Clock Prescaler - 1    */
asm-arm/arch-sa1100/SA-1100.h:                	(((Div) - 1) << FShft (MCCR0_ECP))
asm-arm/arch-sa1100/SA-1100.h:#define MCSR_ATS	0x00000001	/* Audio Transmit FIFO 1/2-full    */
asm-arm/arch-sa1100/SA-1100.h:#define MCSR_ARS	0x00000002	/* Audio Receive FIFO 1/2-full or  */
asm-arm/arch-sa1100/SA-1100.h:#define MCSR_TTS	0x00000004	/* Telecom Transmit FIFO 1/2-full  */
asm-arm/arch-sa1100/SA-1100.h:#define MCSR_TRS	0x00000008	/* Telecom Receive FIFO 1/2-full   */
asm-arm/arch-sa1100/SA-1100.h:#define MCSR_ATU	0x00000010	/* Audio Transmit FIFO Under-run   */
asm-arm/arch-sa1100/SA-1100.h:#define MCSR_ARO	0x00000020	/* Audio Receive FIFO Over-run     */
asm-arm/arch-sa1100/SA-1100.h:#define MCSR_TTU	0x00000040	/* Telecom Transmit FIFO Under-run */
asm-arm/arch-sa1100/SA-1100.h:#define MCSR_TRO	0x00000080	/* Telecom Receive FIFO Over-run   */
asm-arm/arch-sa1100/SA-1100.h: *              	(rev. = 8) and higher of the StrongARM SA-1100.]
asm-arm/arch-sa1100/SA-1100.h:#define SSCR0_DSS	Fld (4, 0)	/* Data Size - 1 Select [3..15]    */
asm-arm/arch-sa1100/SA-1100.h:                	(((Size) - 1) << FShft (SSCR0_DSS))
asm-arm/arch-sa1100/SA-1100.h:#define SSCR0_SCR	Fld (8, 8)	/* Serial Clock Rate divisor/2 - 1 */
asm-arm/arch-sa1100/SA-1100.h:                	(((Div) - 2)/2 << FShft (SSCR0_SCR))
asm-arm/arch-sa1100/SA-1100.h:                	(((Div) - 1)/2 << FShft (SSCR0_SCR))
asm-arm/arch-sa1100/SA-1100.h:#define SSCR1_RIE	0x00000001	/* Receive FIFO 1/2-full or more   */
asm-arm/arch-sa1100/SA-1100.h:#define SSCR1_TIE	0x00000002	/* Transmit FIFO 1/2-full or less  */
asm-arm/arch-sa1100/SA-1100.h:#define SSCR1_LBM	0x00000004	/* Look-Back Mode                  */
asm-arm/arch-sa1100/SA-1100.h:#define SSSR_TFS	0x00000010	/* Transmit FIFO 1/2-full or less  */
asm-arm/arch-sa1100/SA-1100.h:#define SSSR_RFS	0x00000020	/* Receive FIFO 1/2-full or more   */
asm-arm/arch-sa1100/SA-1100.h:#define SSSR_ROR	0x00000040	/* Receive FIFO Over-Run           */
asm-arm/arch-sa1100/SA-1100.h: *    OWER      	Operating System (OS) timer Watch-dog Enable Register
asm-arm/arch-sa1100/SA-1100.h:#define OWER   	__REG(0x90000018	)  /* OS timer Watch-dog Enable Reg. */
asm-arm/arch-sa1100/SA-1100.h:#define OWER_WME	0x00000001	/* Watch-dog Match Enable          */
asm-arm/arch-sa1100/SA-1100.h: * Real-Time Clock (RTC) control registers
asm-arm/arch-sa1100/SA-1100.h: *    RTAR      	Real-Time Clock (RTC) Alarm Register (read/write).
asm-arm/arch-sa1100/SA-1100.h: *    RCNR      	Real-Time Clock (RTC) CouNt Register (read/write).
asm-arm/arch-sa1100/SA-1100.h: *    RTTR      	Real-Time Clock (RTC) Trim Register (read/write).
asm-arm/arch-sa1100/SA-1100.h: *    RTSR      	Real-Time Clock (RTC) Status Register (read/write).
asm-arm/arch-sa1100/SA-1100.h: *    frtx, Trtx	Frequency, period of the real-time clock crystal
asm-arm/arch-sa1100/SA-1100.h: *    frtc, Trtc	Frequency, period of the real-time clock counter
asm-arm/arch-sa1100/SA-1100.h:#define RTTR_C  	Fld (16, 0)	/* clock divider Count - 1         */
asm-arm/arch-sa1100/SA-1100.h:                	        	/* frtc = (1023*(C + 1) - D)*frtx/ */
asm-arm/arch-sa1100/SA-1100.h:                	        	/*        (1023*(C + 1) - D)       */
asm-arm/arch-sa1100/SA-1100.h: *    PSPR      	Power Manager (PM) Scratch-Pad Register (read/write).
asm-arm/arch-sa1100/SA-1100.h: *    PWER      	Power Manager (PM) Wake-up Enable Register
asm-arm/arch-sa1100/SA-1100.h: *    PPCR      	Power Manager (PM) Phase-Locked Loop (PLL)
asm-arm/arch-sa1100/SA-1100.h: *    PGSR      	Power Manager (PM) General-Purpose Input/Output (GPIO)
asm-arm/arch-sa1100/SA-1100.h:#define PSPR		__REG(0x90020008)  /* PM Scratch-Pad Reg. */
asm-arm/arch-sa1100/SA-1100.h:#define PWER		__REG(0x9002000C)  /* PM Wake-up Enable Reg. */
asm-arm/arch-sa1100/SA-1100.h:#define PWER_GPIO(Nb)	GPIO_GPIO (Nb)	/* GPIO [0..27] wake-up enable     */
asm-arm/arch-sa1100/SA-1100.h:#define PWER_GPIO0	PWER_GPIO (0)	/* GPIO  [0] wake-up enable        */
asm-arm/arch-sa1100/SA-1100.h:#define PWER_GPIO1	PWER_GPIO (1)	/* GPIO  [1] wake-up enable        */
asm-arm/arch-sa1100/SA-1100.h:#define PWER_GPIO2	PWER_GPIO (2)	/* GPIO  [2] wake-up enable        */
asm-arm/arch-sa1100/SA-1100.h:#define PWER_GPIO3	PWER_GPIO (3)	/* GPIO  [3] wake-up enable        */
asm-arm/arch-sa1100/SA-1100.h:#define PWER_GPIO4	PWER_GPIO (4)	/* GPIO  [4] wake-up enable        */
asm-arm/arch-sa1100/SA-1100.h:#define PWER_GPIO5	PWER_GPIO (5)	/* GPIO  [5] wake-up enable        */
asm-arm/arch-sa1100/SA-1100.h:#define PWER_GPIO6	PWER_GPIO (6)	/* GPIO  [6] wake-up enable        */
asm-arm/arch-sa1100/SA-1100.h:#define PWER_GPIO7	PWER_GPIO (7)	/* GPIO  [7] wake-up enable        */
asm-arm/arch-sa1100/SA-1100.h:#define PWER_GPIO8	PWER_GPIO (8)	/* GPIO  [8] wake-up enable        */
asm-arm/arch-sa1100/SA-1100.h:#define PWER_GPIO9	PWER_GPIO (9)	/* GPIO  [9] wake-up enable        */
asm-arm/arch-sa1100/SA-1100.h:#define PWER_GPIO10	PWER_GPIO (10)	/* GPIO [10] wake-up enable        */
asm-arm/arch-sa1100/SA-1100.h:#define PWER_GPIO11	PWER_GPIO (11)	/* GPIO [11] wake-up enable        */
asm-arm/arch-sa1100/SA-1100.h:#define PWER_GPIO12	PWER_GPIO (12)	/* GPIO [12] wake-up enable        */
asm-arm/arch-sa1100/SA-1100.h:#define PWER_GPIO13	PWER_GPIO (13)	/* GPIO [13] wake-up enable        */
asm-arm/arch-sa1100/SA-1100.h:#define PWER_GPIO14	PWER_GPIO (14)	/* GPIO [14] wake-up enable        */
asm-arm/arch-sa1100/SA-1100.h:#define PWER_GPIO15	PWER_GPIO (15)	/* GPIO [15] wake-up enable        */
asm-arm/arch-sa1100/SA-1100.h:#define PWER_GPIO16	PWER_GPIO (16)	/* GPIO [16] wake-up enable        */
asm-arm/arch-sa1100/SA-1100.h:#define PWER_GPIO17	PWER_GPIO (17)	/* GPIO [17] wake-up enable        */
asm-arm/arch-sa1100/SA-1100.h:#define PWER_GPIO18	PWER_GPIO (18)	/* GPIO [18] wake-up enable        */
asm-arm/arch-sa1100/SA-1100.h:#define PWER_GPIO19	PWER_GPIO (19)	/* GPIO [19] wake-up enable        */
asm-arm/arch-sa1100/SA-1100.h:#define PWER_GPIO20	PWER_GPIO (20)	/* GPIO [20] wake-up enable        */
asm-arm/arch-sa1100/SA-1100.h:#define PWER_GPIO21	PWER_GPIO (21)	/* GPIO [21] wake-up enable        */
asm-arm/arch-sa1100/SA-1100.h:#define PWER_GPIO22	PWER_GPIO (22)	/* GPIO [22] wake-up enable        */
asm-arm/arch-sa1100/SA-1100.h:#define PWER_GPIO23	PWER_GPIO (23)	/* GPIO [23] wake-up enable        */
asm-arm/arch-sa1100/SA-1100.h:#define PWER_GPIO24	PWER_GPIO (24)	/* GPIO [24] wake-up enable        */
asm-arm/arch-sa1100/SA-1100.h:#define PWER_GPIO25	PWER_GPIO (25)	/* GPIO [25] wake-up enable        */
asm-arm/arch-sa1100/SA-1100.h:#define PWER_GPIO26	PWER_GPIO (26)	/* GPIO [26] wake-up enable        */
asm-arm/arch-sa1100/SA-1100.h:#define PWER_GPIO27	PWER_GPIO (27)	/* GPIO [27] wake-up enable        */
asm-arm/arch-sa1100/SA-1100.h:#define PWER_RTC	0x80000000	/* RTC alarm wake-up enable        */
asm-arm/arch-sa1100/SA-1100.h:#define PCFR_OPDE	0x00000001	/* Oscillator Power-Down Enable    */
asm-arm/arch-sa1100/SA-1100.h:#define RCSR_WDR	0x00000004	/* Watch-Dog Reset                 */
asm-arm/arch-sa1100/SA-1100.h:#define RCSR_SMR	0x00000008	/* Sleep-Mode Reset                */
asm-arm/arch-sa1100/SA-1100.h: * General-Purpose Input/Output (GPIO) control registers
asm-arm/arch-sa1100/SA-1100.h: *    GPLR      	General-Purpose Input/Output (GPIO) Pin Level
asm-arm/arch-sa1100/SA-1100.h: *    GPDR      	General-Purpose Input/Output (GPIO) Pin Direction
asm-arm/arch-sa1100/SA-1100.h: *    GPSR      	General-Purpose Input/Output (GPIO) Pin output Set
asm-arm/arch-sa1100/SA-1100.h: *    GPCR      	General-Purpose Input/Output (GPIO) Pin output Clear
asm-arm/arch-sa1100/SA-1100.h: *    GRER      	General-Purpose Input/Output (GPIO) Rising-Edge
asm-arm/arch-sa1100/SA-1100.h: *    GFER      	General-Purpose Input/Output (GPIO) Falling-Edge
asm-arm/arch-sa1100/SA-1100.h: *    GEDR      	General-Purpose Input/Output (GPIO) Edge Detect
asm-arm/arch-sa1100/SA-1100.h: *    GAFR      	General-Purpose Input/Output (GPIO) Alternate
asm-arm/arch-sa1100/SA-1100.h:#define GRER		__REG(0x90040010)  /* GPIO Rising-Edge detect Reg.    */
asm-arm/arch-sa1100/SA-1100.h:#define GFER		__REG(0x90040014)  /* GPIO Falling-Edge detect Reg.   */
asm-arm/arch-sa1100/SA-1100.h:                	GPIO_GPIO ((Nb) - 6)
asm-arm/arch-sa1100/SA-1100.h: *              	(rev. = 8) and higher of the StrongARM SA-1100.]
asm-arm/arch-sa1100/SA-1100.h: *              	StrongARM SA-1100, it is active high (non-inverted) in
asm-arm/arch-sa1100/SA-1100.h:#define ICCR_DIM	0x00000001	/* Disable Idle-mode interrupt     */
asm-arm/arch-sa1100/SA-1100.h:#define ICCR_IdleAllInt	(ICCR_DIM*0)	/*  Idle-mode All Interrupt enable */
asm-arm/arch-sa1100/SA-1100.h:#define ICCR_IdleMskInt	(ICCR_DIM*1)	/*  Idle-mode non-Masked Interrupt */
asm-arm/arch-sa1100/SA-1100.h: *    PSDR      	Peripheral Pin Controller (PPC) Sleep-mode pin
asm-arm/arch-sa1100/SA-1100.h:#define PSDR		__REG(0x9006000C)  /* PPC Sleep-mode pin Direction Reg. */
asm-arm/arch-sa1100/SA-1100.h: * Dynamic Random-Access Memory (DRAM) control registers
asm-arm/arch-sa1100/SA-1100.h: *    MDCNFG    	Memory system: Dynamic Random-Access Memory (DRAM)
asm-arm/arch-sa1100/SA-1100.h: *    MDCAS0    	Memory system: Dynamic Random-Access Memory (DRAM)
asm-arm/arch-sa1100/SA-1100.h: *    MDCAS1    	Memory system: Dynamic Random-Access Memory (DRAM)
asm-arm/arch-sa1100/SA-1100.h: *    MDCAS2    	Memory system: Dynamic Random-Access Memory (DRAM)
asm-arm/arch-sa1100/SA-1100.h:#define MDCNFG_DRAC	Fld (2, 4)	/* DRAM Row Address Count - 9      */
asm-arm/arch-sa1100/SA-1100.h:                	(((Add) - 9) << FShft (MDCNFG_DRAC))
asm-arm/arch-sa1100/SA-1100.h:#define MDCNFG_TRP	Fld (4, 7)	/* Time RAS Pre-charge - 1 [Tmem]  */
asm-arm/arch-sa1100/SA-1100.h:#define MDCNFG_PrChrg(Tcpu)     	/*  Pre-Charge time [2..32 Tcpu]   */ \
asm-arm/arch-sa1100/SA-1100.h:                	(((Tcpu) - 2)/2 << FShft (MDCNFG_TRP))
asm-arm/arch-sa1100/SA-1100.h:                	(((Tcpu) - 1)/2 << FShft (MDCNFG_TRP))
asm-arm/arch-sa1100/SA-1100.h:#define MDCNFG_TRASR	Fld (4, 11)	/* Time RAS Refresh - 1 [Tmem]     */
asm-arm/arch-sa1100/SA-1100.h:                	(((Tcpu) - 2)/2 << FShft (MDCNFG_TRASR))
asm-arm/arch-sa1100/SA-1100.h:                	(((Tcpu) - 1)/2 << FShft (MDCNFG_TRASR))
asm-arm/arch-sa1100/SA-1100.h:#define MSC_NonBrst	        	/*  Non-Burst static memory        */ \
asm-arm/arch-sa1100/SA-1100.h:#define MSC_SRAM	        	/*  32-bit byte-writable SRAM      */ \
asm-arm/arch-sa1100/SA-1100.h:#define MSC_Brst4	        	/*  Burst-of-4 static memory       */ \
asm-arm/arch-sa1100/SA-1100.h:#define MSC_Brst8	        	/*  Burst-of-8 static memory       */ \
asm-arm/arch-sa1100/SA-1100.h:#define MSC_32BitStMem	(MSC_RBW*0)	/*  32-Bit Static Memory           */
asm-arm/arch-sa1100/SA-1100.h:#define MSC_16BitStMem	(MSC_RBW*1)	/*  16-Bit Static Memory           */
asm-arm/arch-sa1100/SA-1100.h:                	        	/* First access - 1(.5) [Tmem]     */
asm-arm/arch-sa1100/SA-1100.h:                	((((Tcpu) - 3)/2) << FShft (MSC_RDF))
asm-arm/arch-sa1100/SA-1100.h:                	((((Tcpu) - 2)/2) << FShft (MSC_RDF))
asm-arm/arch-sa1100/SA-1100.h:#define MSC_RdAcc(Tcpu)	        	/*  Read Access time (non-burst    */ \
asm-arm/arch-sa1100/SA-1100.h:                	((((Tcpu) - 2)/2) << FShft (MSC_RDF))
asm-arm/arch-sa1100/SA-1100.h:                	((((Tcpu) - 1)/2) << FShft (MSC_RDF))
asm-arm/arch-sa1100/SA-1100.h:                	        	/* Next access - 1 [Tmem]          */
asm-arm/arch-sa1100/SA-1100.h:                	((((Tcpu) - 2)/2) << FShft (MSC_RDN))
asm-arm/arch-sa1100/SA-1100.h:                	((((Tcpu) - 1)/2) << FShft (MSC_RDN))
asm-arm/arch-sa1100/SA-1100.h:#define MSC_WrAcc(Tcpu)	        	/*  Write Access time (non-burst   */ \
asm-arm/arch-sa1100/SA-1100.h:                	((((Tcpu) - 2)/2) << FShft (MSC_RDN))
asm-arm/arch-sa1100/SA-1100.h:                	((((Tcpu) - 1)/2) << FShft (MSC_RDN))
asm-arm/arch-sa1100/SA-1100.h:#define MECR_BSIO	Fld (5, 0)	/* BCLK Select I/O - 1 [Tmem]      */
asm-arm/arch-sa1100/SA-1100.h:                	((((Tcpu) - 2)/2) << FShft (MECR_BSIO))
asm-arm/arch-sa1100/SA-1100.h:                	((((Tcpu) - 1)/2) << FShft (MECR_BSIO))
asm-arm/arch-sa1100/SA-1100.h:#define MECR_BSA	Fld (5, 5)	/* BCLK Select Attribute - 1       */
asm-arm/arch-sa1100/SA-1100.h:                	((((Tcpu) - 2)/2) << FShft (MECR_BSA))
asm-arm/arch-sa1100/SA-1100.h:                	((((Tcpu) - 1)/2) << FShft (MECR_BSA))
asm-arm/arch-sa1100/SA-1100.h:#define MECR_BSM	Fld (5, 10)	/* BCLK Select Memory - 1 [Tmem]   */
asm-arm/arch-sa1100/SA-1100.h:                	((((Tcpu) - 2)/2) << FShft (MECR_BSM))
asm-arm/arch-sa1100/SA-1100.h:                	((((Tcpu) - 1)/2) << FShft (MECR_BSM))
asm-arm/arch-sa1100/SA-1100.h:                	        	/*  (memory -> device)             */
asm-arm/arch-sa1100/SA-1100.h:                	        	/*  (device -> memory)             */
asm-arm/arch-sa1100/SA-1100.h:#define DDAR_Brst4	(DDAR_BS*0)	/*  Burst-of-4 device              */
asm-arm/arch-sa1100/SA-1100.h:#define DDAR_Brst8	(DDAR_BS*1)	/*  Burst-of-8 device              */
asm-arm/arch-sa1100/SA-1100.h:#define DDAR_8BitDev	(DDAR_DW*0)	/*  8-Bit Device                   */
asm-arm/arch-sa1100/SA-1100.h:#define DDAR_16BitDev	(DDAR_DW*1)	/*  16-Bit Device                  */
asm-arm/arch-sa1100/SA-1100.h:                	 (((Add) & 0X003FFFFC) << (FShft (DDAR_DA) - 2)))
asm-arm/arch-sa1100/SA-1100.h: *              	SA-1100.]
asm-arm/arch-sa1100/SA-1100.h: *              	and 1.1 (rev. = 2) of the StrongARM SA-1100, it can be
asm-arm/arch-sa1100/SA-1100.h: *              	StrongARM SA-1100, it can be written and read in
asm-arm/arch-sa1100/SA-1100.h: *              	StrongARM SA-1100, it can be written and read in
asm-arm/arch-sa1100/SA-1100.h: *              	StrongARM SA-1100, it can be written and read in
asm-arm/arch-sa1100/SA-1100.h: *              	the StrongARM SA-1100.]
asm-arm/arch-sa1100/SA-1100.h:#define LCD_4BitPSp	        	/* LCD 4-Bit pixel Palette Space   */ \
asm-arm/arch-sa1100/SA-1100.h:#define LCD_8BitPSp	        	/* LCD 8-Bit pixel Palette Space   */ \
asm-arm/arch-sa1100/SA-1100.h:#define LCD_12_16BitPSp	        	/* LCD 12/16-Bit pixel             */ \
asm-arm/arch-sa1100/SA-1100.h:                	        	/* dummy-Palette Space [byte]      */ \
asm-arm/arch-sa1100/SA-1100.h:#define LCD_4Bit	        	/*  LCD 4-Bit pixel mode           */ \
asm-arm/arch-sa1100/SA-1100.h:#define LCD_8Bit	        	/*  LCD 8-Bit pixel mode           */ \
asm-arm/arch-sa1100/SA-1100.h:#define LCD_12_16Bit	        	/*  LCD 12/16-Bit pixel mode       */ \
asm-arm/arch-sa1100/SA-1100.h:#define LCCR0_4PixMono	(LCCR0_DPD*0)	/*  4-Pixel/clock Monochrome       */
asm-arm/arch-sa1100/SA-1100.h:#define LCCR0_8PixMono	(LCCR0_DPD*1)	/*  8-Pixel/clock Monochrome       */
asm-arm/arch-sa1100/SA-1100.h:#define LCSR_IOL	0x00000010	/* Input FIFO Over-run Lower       */
asm-arm/arch-sa1100/SA-1100.h:#define LCSR_IUL	0x00000020	/* Input FIFO Under-run Lower      */
asm-arm/arch-sa1100/SA-1100.h:#define LCSR_IOU	0x00000040	/* Input FIFO Over-run Upper       */
asm-arm/arch-sa1100/SA-1100.h:#define LCSR_IUU	0x00000080	/* Input FIFO Under-run Upper      */
asm-arm/arch-sa1100/SA-1100.h:#define LCSR_OOL	0x00000100	/* Output FIFO Over-run Lower      */
asm-arm/arch-sa1100/SA-1100.h:#define LCSR_OUL	0x00000200	/* Output FIFO Under-run Lower     */
asm-arm/arch-sa1100/SA-1100.h:#define LCSR_OOU	0x00000400	/* Output FIFO Over-run Upper      */
asm-arm/arch-sa1100/SA-1100.h:#define LCSR_OUU	0x00000800	/* Output FIFO Under-run Upper     */
asm-arm/arch-sa1100/SA-1100.h:#define LCCR1_PPL	Fld (6, 4)	/* Pixels Per Line/16 - 1          */
asm-arm/arch-sa1100/SA-1100.h:                	(((Pixel) - 16)/16 << FShft (LCCR1_PPL))
asm-arm/arch-sa1100/SA-1100.h:                	        	/* pulse Width - 1 [Tpix] (L_LCLK) */
asm-arm/arch-sa1100/SA-1100.h:                	(((Tpix) - 1) << FShft (LCCR1_HSW))
asm-arm/arch-sa1100/SA-1100.h:#define LCCR1_ELW	Fld (8, 16)	/* End-of-Line pixel clock Wait    */
asm-arm/arch-sa1100/SA-1100.h:                	        	/* count - 1 [Tpix]                */
asm-arm/arch-sa1100/SA-1100.h:#define LCCR1_EndLnDel(Tpix)    	/*  End-of-Line Delay              */ \
asm-arm/arch-sa1100/SA-1100.h:                	(((Tpix) - 1) << FShft (LCCR1_ELW))
asm-arm/arch-sa1100/SA-1100.h:#define LCCR1_BLW	Fld (8, 24)	/* Beginning-of-Line pixel clock   */
asm-arm/arch-sa1100/SA-1100.h:                	        	/* Wait count - 1 [Tpix]           */
asm-arm/arch-sa1100/SA-1100.h:#define LCCR1_BegLnDel(Tpix)    	/*  Beginning-of-Line Delay        */ \
asm-arm/arch-sa1100/SA-1100.h:                	(((Tpix) - 1) << FShft (LCCR1_BLW))
asm-arm/arch-sa1100/SA-1100.h:#define LCCR2_LPP	Fld (10, 0)	/* Line Per Panel - 1              */
asm-arm/arch-sa1100/SA-1100.h:                	(((Line) - 1) << FShft (LCCR2_LPP))
asm-arm/arch-sa1100/SA-1100.h:                	        	/* Width - 1 [Tln] (L_FCLK)        */
asm-arm/arch-sa1100/SA-1100.h:                	(((Tln) - 1) << FShft (LCCR2_VSW))
asm-arm/arch-sa1100/SA-1100.h:#define LCCR2_EFW	Fld (8, 16)	/* End-of-Frame line clock Wait    */
asm-arm/arch-sa1100/SA-1100.h:#define LCCR2_EndFrmDel(Tln)    	/*  End-of-Frame Delay             */ \
asm-arm/arch-sa1100/SA-1100.h:#define LCCR2_BFW	Fld (8, 24)	/* Beginning-of-Frame line clock   */
asm-arm/arch-sa1100/SA-1100.h:#define LCCR2_BegFrmDel(Tln)    	/*  Beginning-of-Frame Delay       */ \
asm-arm/arch-sa1100/SA-1100.h:#define LCCR3_PCD	Fld (8, 0)	/* Pixel Clock Divisor/2 - 2       */
asm-arm/arch-sa1100/SA-1100.h:                	(((Div) - 4)/2 << FShft (LCCR3_PCD))
asm-arm/arch-sa1100/SA-1100.h:                	(((Div) - 3)/2 << FShft (LCCR3_PCD))
asm-arm/arch-sa1100/SA-1100.h:#define LCCR3_ACB	Fld (8, 8)	/* AC Bias clock half period - 1   */
asm-arm/arch-sa1100/SA-1100.h:                	(((Div) - 2)/2 << FShft (LCCR3_ACB))
asm-arm/arch-sa1100/SA-1100.h:                	(((Div) - 1)/2 << FShft (LCCR3_ACB))
asm-arm/arch-sa1100/SA-1100.h:#define LCCR3_PixRsEdg	(LCCR3_PCP*0)	/*  Pixel clock Rising-Edge        */
asm-arm/arch-sa1100/SA-1100.h:#define LCCR3_PixFlEdg	(LCCR3_PCP*1)	/*  Pixel clock Falling-Edge       */
asm-arm/arch-sa1100/SA-1101.h: * SA-1101.h
asm-arm/arch-sa1100/SA-1101.h:#error You must include hardware.h not SA-1101.h
asm-arm/arch-sa1100/SA-1101.h:#error You must define SA-1101 physical base address
asm-arm/arch-sa1100/SA-1101.h: * Macro that calculates real address for registers in the SA-1101
asm-arm/arch-sa1100/SA-1101.h: *	SKCR		SA-1101 control register (read/write)
asm-arm/arch-sa1100/SA-1101.h:#define _SKCR		_SA1101( 0x00000000 ) /* SA-1101 Control Reg. */
asm-arm/arch-sa1100/SA-1101.h:#define SKCR_PLLEn	  0x0001	  /* Enable On-Chip PLL */
asm-arm/arch-sa1100/SA-1101.h:	(( (x) - 8 ) << FShft (SMCR_DCAC))
asm-arm/arch-sa1100/SA-1101.h:	(( (x) - 9 ) << FShft (SMCR_DRAC)
asm-arm/arch-sa1100/SA-1101.h:#define IEEE_Config_B	    0x08	 /* 9-bit word enable */
asm-arm/arch-sa1100/SA-1101.h: * General-Purpose I/O Interface
asm-arm/arch-sa1100/SA-1111.h:#warning using old SA-1111.h - update to <asm/hardware/sa1111.h>
asm-arm/arch-sa1100/dma.h: * linux/include/asm-arm/arch-sa1100/dma.h
asm-arm/arch-sa1100/dma.h: * The SA-1111 SAC has two DMA channels.
asm-arm/arch-sa1100/dma.h: * The SA-1111 SAC channels will reside in the same index space as
asm-arm/arch-sa1100/dma.h: * the built-in SA-1100 channels, and will take on the next available
asm-arm/arch-sa1100/dma.h:	size[1] = size[0] - sz;
asm-arm/arch-sa1100/ide.h: * linux/include/asm-arm/arch-sa1100/ide.h
asm-arm/arch-sa1100/ide.h: * 26-feb-2002: Add support for 2d3D SA-1110 Development board
asm-arm/arch-sa1100/ide.h: * 18-aug-2000: Cleanup by Erik Mouw (J.A.K.Mouw@its.tudelft.nl)
asm-arm/arch-sa1100/ide.h:#include <asm/mach-types.h>
asm-arm/arch-sa1100/ide.h:		hw->io_ports[i] = reg;
asm-arm/arch-sa1100/ide.h:	hw->io_ports[IDE_CONTROL_OFFSET] = (ide_ioreg_t) ctrl_port;
asm-arm/arch-sa1100/irq.h: * linux/include/asm-arm/arch-sa1100/irq.h
asm-arm/arch-sa1100/hackkit.h: * linux/include/asm-arm/arch-sa1100/hackkit.h
asm-arm/arch-sa1100/jornada720.h: * linux/include/asm-arm/arch-sa1100/jornada720.h
asm-arm/arch-sa1100/adsbitsy.h: * linux/include/asm-arm/arch-sa1100/adsbitsy.h
asm-arm/arch-sa1100/h3600_gpio.h: * 2001-10-??   Andrew Christian   Added support for iPAQ H3800
asm-arm/arch-sa1100/h3600_gpio.h: * This file contains machine-specific definitions
asm-arm/arch-sa1100/h3600_gpio.h:#define EGPIO_H3600_IR_FSEL		(1 << 13)  /* IR speed select: 1->fast, 0->slow */
asm-arm/arch-sa1100/h3600_gpio.h:#define EGPIO_H3600_LVDD_ON		(1 << 15)  /* enable 9V and -6.5V to LCD. */
asm-arm/arch-sa1100/h3600_gpio.h:#define _H3800_ASIC2_GPIO_InterruptFlag        0x0010    /* R,   12 bits - reads int status */
asm-arm/arch-sa1100/h3600_gpio.h:#define _H3800_ASIC2_GPIO_BattFaultOut         0x0018    /* R/W, 16 bit - sets level on batt fault */
asm-arm/arch-sa1100/h3600_gpio.h:#define _H3800_ASIC2_GPIO_Alternate            0x003c    /* R/W, 12+1 bits - set alternate functions */
asm-arm/arch-sa1100/h3600_gpio.h:#define _H3800_ASIC2_KPIO_InterruptClear       0x0010    /* W,   20 bits - 8 special */
asm-arm/arch-sa1100/h3600_gpio.h:#define _H3800_ASIC2_KPIO_InterruptFlag        0x0010    /* R,   20 bits - 8 special - reads int status */
asm-arm/arch-sa1100/h3600_gpio.h:#define _H3800_ASIC2_KPIO_BattFaultOut         0x0018    /* R/W, 16 bit - sets level on batt fault */
asm-arm/arch-sa1100/h3600_gpio.h:#define _H3800_ASIC2_KPIO_InterruptEnable      0x001c    /* R/W, 20 bits - 8 special */
asm-arm/arch-sa1100/h3600_gpio.h:#define _H3800_ASIC2_ADC_Multiplexer           0x0000    /* R/W 4 bits - low 3 bits set channel */
asm-arm/arch-sa1100/h3600_gpio.h:#define _H3800_ASIC2_OWM_ClockDivisor          0x0010    /* R/W 5 bits of divisor and pre-scale */
asm-arm/arch-sa1100/h3600_gpio.h:#define H3800_ASIC2_OWM_CMD_ONE_WIRE_RESET ( 1 << 0 )    /* Set to force reset on 1-wire bus */
asm-arm/arch-sa1100/h3600_gpio.h:#define H3800_ASIC2_OWM_CMD_DQ_OUTPUT      ( 1 << 2 )    /* Write only - forces bus low */
asm-arm/arch-sa1100/h3600_gpio.h:#define H3800_ASIC2_OWM_CMD_DQ_INPUT       ( 1 << 3 )    /* Read only - reflects state of bus */
asm-arm/arch-sa1100/h3600_gpio.h: * mapped into the 1c00 - 1f00 region
asm-arm/arch-sa1100/h3600_gpio.h:#define _H3800_ASIC1_MMC_ResFifo            0x22    /* R   8 x 16 bits - contains response FIFO */
asm-arm/arch-sa1100/h3600_gpio.h:#define GPIO_H3800_ASIC1_VGL_ON           (1 << 9)   /* Drivers VGL on the LCD (-6??) */
asm-arm/arch-sa1100/assabet.h: * linux/include/asm-arm/arch-sa1100/assabet.h
asm-arm/arch-sa1100/assabet.h: * Only include this file from SA1100-specific files.
asm-arm/arch-sa1100/assabet.h:#define ASSABET_SCR_INIT	-1
asm-arm/arch-sa1100/assabet.h:#define Nep_p2v( x )            ((x) - NEPONSET_CPLD_BASE + 0xf3000000)
asm-arm/arch-sa1100/assabet.h:#define Nep_v2p( x )            ((x) - 0xf3000000 + NEPONSET_CPLD_BASE)
asm-arm/arch-sa1100/simpad.h: * linux/include/asm-arm/arch-sa1100/simpad.h
asm-arm/arch-sa1100/simpad.h:/*---  PCMCIA  ---*/
asm-arm/arch-sa1100/huw_webpanel.h: * linux/include/asm-arm/arch-sa1100/huw_webpanel.h
asm-arm/arch-sa1100/huw_webpanel.h: * 2000/11/13 Roman Jordan <jor@hoeft-wessel.de>
asm-arm/arch-sa1100/huw_webpanel.h:#define SCR_INIT	-1
asm-arm/arch-sa1100/omnimeter.h:/* -*- Mode: c++ -*-
asm-arm/arch-sa1100/omnimeter.h:#define Socket1IOWindowOffset    (0x00010000 - Socket1IOWindowStart)
asm-arm/arch-sa1100/omnimeter.h:// Following values for run-time access
asm-arm/arch-sa1100/system3.h: * linux/include/asm-arm/arch-sa1100/system3.h
asm-arm/arch-sa1100/system3.h: * - removed neponset hack
asm-arm/arch-sa1100/system3.h: * - removed irq definitions (now in irqs.h)
asm-arm/arch-sa1100/system3.h: * - re-added from linux_2_4_8_ac12_rmk1_np1_pt1
asm-arm/arch-sa1100/system3.h: * - simplified cpld register access
asm-arm/arch-sa1100/system3.h: * - first revision
asm-arm/arch-sa1100/system3.h:#define Ptcpld_p2v( x )	((x) - PT_CPLD_BASE + 0xf3000000)
asm-arm/arch-sa1100/system3.h:#define Ptcpld_v2p( x )	((x) - 0xf3000000 + PT_CPLD_BASE)
asm-arm/arch-sa1100/adsbitsyplus.h: * linux/include/asm-arm/arch-sa1100/adsbitsy.h
asm-arm/arch-sa1100/adsbitsyplus.h:#define ADS_p2v( x )		((x) - ADS_CPLD_BASE + 0xf1000000)
asm-arm/arch-sa1100/adsbitsyplus.h:#define ADS_v2p( x )		((x) - 0xf1000000 + ADS_CPLD_BASE)
asm-arm/arch-sa1100/timex.h: * linux/include/asm-arm/arch-sa1100/timex.h
asm-arm/arch-sa1100/bitfield.h: *    field's mask is cumbersome and might break the assembler (255-character
asm-arm/arch-sa1100/bitfield.h: *    line-size limit).
asm-arm/arch-sa1100/bitfield.h:#define FMsk(Field)	(((UData (1) << FSize (Field)) - 1) << FShft (Field))
asm-arm/arch-sa1100/bitfield.h:#define FAlnMsk(Field)	((UData (1) << FSize (Field)) - 1)
asm-arm/arch-sa1100/bitfield.h: *    Value     	Bit-field value.
asm-arm/arch-sa1100/bitfield.h: *    FInsrt    	Bit-field value positioned appropriately.
asm-arm/arch-sa1100/bitfield.h: *    Data      	Data containing the bit-field to be extracted.
asm-arm/arch-sa1100/bitfield.h: *    FExtr     	Bit-field value.
asm-arm/arch-sa1100/cerf.h:// Map sa1100fb.c to sa1100_frontlight.c - Not pretty, but necessary.
asm-arm/arch-sa1100/shannon.h:#define SHANNON_GPIO_SPI_FLASH		GPIO_GPIO (0)	/* Output - Driven low, enables SPI to flash */
asm-arm/arch-sa1100/shannon.h:#define SHANNON_GPIO_SPI_DSP		GPIO_GPIO (1)	/* Output - Driven low, enables SPI to DSP */
asm-arm/arch-sa1100/shannon.h:/* lcd lower = GPIO 2-9 */
asm-arm/arch-sa1100/shannon.h:#define SHANNON_GPIO_SPI_OUTPUT		GPIO_GPIO (10)	/* Output - SPI output to DSP */
asm-arm/arch-sa1100/shannon.h:#define SHANNON_GPIO_SPI_INPUT		GPIO_GPIO (11)	/* Input  - SPI input from DSP */
asm-arm/arch-sa1100/shannon.h:#define SHANNON_GPIO_SPI_CLOCK		GPIO_GPIO (12)	/* Output - Clock for SPI */
asm-arm/arch-sa1100/shannon.h:#define SHANNON_GPIO_SPI_FRAME		GPIO_GPIO (13)	/* Output - Frame marker - not used */
asm-arm/arch-sa1100/shannon.h:#define SHANNON_GPIO_SPI_RTS		GPIO_GPIO (14)	/* Input  - SPI Ready to Send */
asm-arm/arch-sa1100/shannon.h:#define SHANNON_GPIO_SPI_CTS		GPIO_GPIO (15)	/* Output - SPI Clear to Send */
asm-arm/arch-sa1100/shannon.h:#define SHANNON_GPIO_DSP_RESET		GPIO_GPIO (17)	/* Output - Drive low to reset the DSP */
asm-arm/arch-sa1100/shannon.h:#define SHANNON_GPIO_CODEC_RESET	GPIO_GPIO (18)	/* Output - Drive low to reset the UCB1x00 */
asm-arm/arch-sa1100/frodo.h: * linux/include/asm-arm/arch-sa1100/frodo.h
asm-arm/arch-sa1100/frodo.h: * SA-1110 Development Board.
asm-arm/arch-sa1100/frodo.h: * Only include this file from SA1100-specific files.
asm-arm/arch-sa1100/frodo.h: *   2002/06/06   Added Real-Time Clock IRQ
asm-arm/arch-sa1100/frodo.h:/* Real-Time Clock */
asm-arm/arch-sa1100/graphicsclient.h: * linux/include/asm-arm/arch-sa1100/graphicsclient.h
asm-arm/arch-sa1100/graphicsclient.h:#define ADS_p2v( x )		((x) - ADS_CPLD_BASE + 0xf0000000)
asm-arm/arch-sa1100/graphicsclient.h:#define ADS_v2p( x )		((x) - 0xf0000000 + ADS_CPLD_BASE)
asm-arm/arch-sa1100/graphicsclient.h:/* On-Board Ethernet */
asm-arm/arch-sa1100/graphicsclient.h:#define ADS_LED0	GPIO_GPIO20		/* on-board D22 */
asm-arm/arch-sa1100/graphicsclient.h:#define ADS_LED1	GPIO_GPIO21		/* on-board D21 */
asm-arm/arch-sa1100/graphicsclient.h:#define ADS_LED2	GPIO_GPIO22		/* on-board D20 */
asm-arm/arch-sa1100/irqs.h: * linux/include/asm-arm/arch-sa1100/irqs.h
asm-arm/arch-sa1100/irqs.h:#define GPIO_11_27_IRQ(i)	((i) - 21)
asm-arm/arch-sa1100/irqs.h: * the kernel can only run on one machine at a time, we can re-use
asm-arm/arch-sa1100/flexanet.h: * include/asm-arm/arch-sa1100/flexanet.h
asm-arm/arch-sa1100/flexanet.h:/* Power-up value */
asm-arm/arch-sa1100/flexanet.h:#define FHH_BCR_LED_GREEN  (1<<0)  /* General-purpose green LED (1 = on) */
asm-arm/arch-sa1100/flexanet.h:#define FHH_BCR_RTS1       (1<<5)  /* RS232 RTS for UART-1 */
asm-arm/arch-sa1100/flexanet.h:#define FHH_BCR_RTS3       (1<<6)  /* RS232 RTS for UART-3 */
asm-arm/arch-sa1100/flexanet.h:/* BCR extension, only required by L3-bus in some audio codecs */
asm-arm/arch-sa1100/flexanet.h:#define FHH_BCR_L3MOD      (1<<8)  /* L3-bus MODE signal */
asm-arm/arch-sa1100/flexanet.h:#define FHH_BCR_L3DAT      (1<<9)  /* L3-bus DATA signal */
asm-arm/arch-sa1100/flexanet.h:#define FHH_BCR_L3CLK      (1<<10) /* L3-bus CLK signal */
asm-arm/arch-sa1100/flexanet.h:#define FHH_BSR_CTS1       (1<<0)  /* RS232 CTS for UART-1 */
asm-arm/arch-sa1100/flexanet.h:#define FHH_BSR_CTS3       (1<<1)  /* RS232 CTS for UART-3 */
asm-arm/arch-sa1100/flexanet.h:#define FHH_BSR_DSR1       (1<<2)  /* RS232 DSR for UART-1 */
asm-arm/arch-sa1100/flexanet.h:#define FHH_BSR_DSR3       (1<<3)  /* RS232 DSR for UART-3 */
asm-arm/arch-sa1100/flexanet.h:#define GPIO_LED_RED       GPIO_GPIO (26)  /* General-purpose red LED */
asm-arm/arch-sa1100/flexanet.h:/* On-Board Ethernet */
asm-arm/arch-sa1100/flexanet.h:#define _FHH_ETH_MMBASE		0x18800000	/* Attribute-memory base */
asm-arm/arch-sa1100/flexanet.h:#define FHH_ETH_p2v( x )	((x) - _FHH_ETH_IOBASE + FHH_ETH_VIRT)
asm-arm/arch-sa1100/flexanet.h:#define FHH_ETH_v2p( x )	((x) - FHH_ETH_VIRT + _FHH_ETH_IOBASE)
asm-arm/arch-sa1100/pleb.h: * linux/include/asm-arm/arch-sa1100/pleb.h
asm-arm/arch-sa1100/system.h: * linux/include/asm-arm/arch-sa1100/system.h
asm-arm/arch-sa1100/system.h:		/* Use on-chip reset capability */
asm-arm/arch-sa1100/time.h: * linux/include/asm-arm/arch-sa1100/time.h
asm-arm/arch-sa1100/time.h:#define RTC_DEF_DIVIDER		(32768 - 1)
asm-arm/arch-sa1100/time.h:			return -ERESTARTSYS;
asm-arm/arch-sa1100/time.h:	ticks_to_match = OSMR0 - OSCR;
asm-arm/arch-sa1100/time.h:	elapsed = LATCH - ticks_to_match;
asm-arm/arch-sa1100/time.h:	} while ((signed long)(next_match - OSCR) <= 0);
asm-arm/arch-sa1100/time.h:	OSCR = 0;		/* initialize free-running timer, force first match */
asm-arm/arch-sa1100/badge4.h: * linux/include/asm-arm/arch-sa1100/badge4.h
asm-arm/arch-sa1100/badge4.h: * Copyright (C) 2002 Hewlett-Packard Company
asm-arm/arch-sa1100/badge4.h:#define BADGE4_GPIO_INT_1111		GPIO_GPIO0   /* SA-1111 IRQ */
asm-arm/arch-sa1100/badge4.h:#define BADGE4_GPIO_SA1111_NRST		GPIO_GPIO25  /* SA-1111 nRESET */
asm-arm/arch-sa1100/badge4.h:#define BADGE4_IRQ_GPIO_SA1111		IRQ_GPIO0    /* SA-1111 interrupt */
asm-arm/arch-sa1100/serial.h: * include/asm-arm/arch-sa1100/serial.h
asm-arm/arch-sa1100/serial.h: * All this is intended to be used with a 16550-like UART on the SA1100's 
asm-arm/arch-sa1100/serial.h: * This is included by serial.c -- serial_sa1100.c makes no use of it.
asm-arm/arch-sa1100/adsagc.h: * linux/include/asm-arm/arch-sa1100/adsagc.h
asm-arm/arch-sa1100/adsagc.h:#define ADS_p2v( x )		((x) - ADS_CPLD_BASE + 0xf0000000)
asm-arm/arch-sa1100/adsagc.h:#define ADS_v2p( x )		((x) - 0xf0000000 + ADS_CPLD_BASE)
asm-arm/arch-sa1100/adsagc.h:/* On-Board Ethernet */
asm-arm/arch-sa1100/adsagc.h:#define ADS_LED0	0x10		/* on-board Green */
asm-arm/arch-sa1100/adsagc.h:#define ADS_LED1	0x20		/* on-board Yellow */
asm-arm/arch-sa1100/adsagc.h:#define ADS_LED2	0x40		/* on-board Red */
asm-arm/arch-sa1100/param.h: * linux/include/asm-arm/arch-sa1100/param.h
asm-arm/arch-sa1100/keyboard.h: *  linux/include/asm-arm/arch-sa1100/keyboard.h
asm-arm/arch-sa1100/keyboard.h:#include <asm/mach-types.h>
asm-arm/arch-sa1100/h3600.h: * 2001-10-??	Andrew Christian   Added support for iPAQ H3800
asm-arm/arch-sa1100/h3600.h:   Machine-independent GPIO definitions
asm-arm/arch-sa1100/h3600.h:   --- these are common across all current iPAQ platforms
asm-arm/arch-sa1100/h3600.h:	IPAQ_EGPIO_OPT_NVRAM_ON,  /* Non-volatile RAM on extension sleeves (SPI interface) */
asm-arm/arch-sa1100/h3600.h:	IPAQ_EGPIO_IR_FSEL,	  /* IR speed selection 1->fast, 0->slow */
asm-arm/arch-sa1100/memory.h: * linux/include/asm-arm/arch-sa1100/memory.h
asm-arm/arch-sa1100/memory.h: * Copyright (C) 1999-2000 Nicolas Pitre <nico@cam.org>
asm-arm/arch-sa1100/memory.h: * Virtual view <-> DMA view memory address translations
asm-arm/arch-sa1100/memory.h: * 	node 0:  0xc0000000 - 0xc7ffffff
asm-arm/arch-sa1100/memory.h: * 	node 1:  0xc8000000 - 0xcfffffff
asm-arm/arch-sa1100/memory.h: * 	node 2:  0xd0000000 - 0xd7ffffff
asm-arm/arch-sa1100/memory.h: * 	node 3:  0xd8000000 - 0xdfffffff
asm-arm/arch-sa1100/memory.h:#define KVADDR_TO_NID(addr) (((unsigned long)(addr) - PAGE_OFFSET) >> 27)
asm-arm/arch-sa1100/memory.h:#define PFN_TO_NID(pfn)		(((pfn) - PHYS_PFN_OFFSET) >> (27 - PAGE_SHIFT))
asm-arm/errno.h:#define	EXDEV		18	/* Cross-device link */
asm-arm/errno.h:#define	EROFS		30	/* Read-only file system */
asm-arm/errno.h:#define	ENOTSOCK	88	/* Socket operation on non-socket */
asm-arm/byteorder.h: *  linux/include/asm-arm/byteorder.h
asm-arm/byteorder.h: * ARM Endian-ness.  In little endian mode, the data bus is connected such
asm-arm/therm.h: * linux/include/asm-arm/therm.h: Definitions for Dallas Semiconductor
asm-arm/softirq.h:		do { barrier(); local_bh_count(cpu)--; } while (0)
asm-arm/softirq.h:	if (!--*ptr && ptr[-2])						\
asm-arm/timex.h: *  linux/include/asm-arm/timex.h
asm-arm/bugs.h: *  linux/include/asm-arm/bugs.h
asm-arm/bugs.h:#include <asm/proc-fns.h>
asm-arm/namei.h: * linux/include/asm-arm/namei.h
asm-arm/namei.h:	switch (current->personality) {
asm-arm/arch-integrator/io.h: *  linux/include/asm-arm/arch-integrator/io.h
asm-arm/arch-integrator/io.h: * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
asm-arm/arch-integrator/hardware.h: *  linux/include/asm-arm/arch-integrator/hardware.h
asm-arm/arch-integrator/hardware.h: * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
asm-arm/arch-integrator/uncompress.h: *  linux/include/asm-arm/arch-integrator/uncompress.h
asm-arm/arch-integrator/uncompress.h: * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
asm-arm/arch-integrator/vmalloc.h: *  linux/include/asm-arm/arch-integrator/vmalloc.h
asm-arm/arch-integrator/vmalloc.h: * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
asm-arm/arch-integrator/vmalloc.h: * any out-of-bounds memory accesses will hopefully be caught.
asm-arm/arch-integrator/vmalloc.h:#define VMALLOC_START	  (((unsigned long)high_memory + VMALLOC_OFFSET) & ~(VMALLOC_OFFSET-1))
asm-arm/arch-integrator/dma.h: *  linux/include/asm-arm/arch-integrator/dma.h
asm-arm/arch-integrator/dma.h: * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
asm-arm/arch-integrator/irq.h: *  linux/include/asm-arm/arch-integrator/irq.h
asm-arm/arch-integrator/irq.h: * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
asm-arm/arch-integrator/platform.h: * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
asm-arm/arch-integrator/platform.h:/* DO NOT EDIT!! - this file automatically generated
asm-arm/arch-integrator/platform.h: *                 from .s file by awk -f s2h.awk
asm-arm/arch-integrator/platform.h: * 	NOTE: This is a multi-hosted header file for use with uHAL and
asm-arm/arch-integrator/platform.h: * ------------------------------------------------------------------------
asm-arm/arch-integrator/platform.h: * ------------------------------------------------------------------------
asm-arm/arch-integrator/platform.h:/* ------------------------------------------------------------------------
asm-arm/arch-integrator/platform.h: * ------------------------------------------------------------------------
asm-arm/arch-integrator/platform.h:/* ------------------------------------------------------------------------
asm-arm/arch-integrator/platform.h: * ------------------------------------------------------------------------
asm-arm/arch-integrator/platform.h:/* ------------------------------------------------------------------------
asm-arm/arch-integrator/platform.h: * ------------------------------------------------------------------------
asm-arm/arch-integrator/platform.h:/* KMI definitions are now in include/asm-arm/hardware/amba_kmi.h -- rmk */
asm-arm/arch-integrator/platform.h:/* ------------------------------------------------------------------------
asm-arm/arch-integrator/platform.h: * ------------------------------------------------------------------------
asm-arm/arch-integrator/platform.h:/*  unused 256M from A0000000-AFFFFFFF might be used for I2O ???
asm-arm/arch-integrator/platform.h:/*  unused (128-16)M from B1000000-B7FFFFFF
asm-arm/arch-integrator/platform.h:/*  unused ((128-16)M - 64K) from XXX
asm-arm/arch-integrator/platform.h:/* ------------------------------------------------------------------------
asm-arm/arch-integrator/platform.h: * ------------------------------------------------------------------------
asm-arm/arch-integrator/platform.h:/* ------------------------------------------------------------------------
asm-arm/arch-integrator/platform.h: * ------------------------------------------------------------------------
asm-arm/arch-integrator/platform.h: *  INTEGRATOR_CM_INT0      - Interrupt number of first CM interrupt
asm-arm/arch-integrator/platform.h: *  INTEGRATOR_SC_VALID_INT - Mask of valid system controller interrupts
asm-arm/arch-integrator/platform.h:/* ------------------------------------------------------------------------
asm-arm/arch-integrator/platform.h: *  LED's - The header LED is not accessable via the uHAL API
asm-arm/arch-integrator/platform.h: * ------------------------------------------------------------------------
asm-arm/arch-integrator/platform.h: *  Memory definitions - run uHAL out of SSRAM.
asm-arm/arch-integrator/platform.h:#define FLASH_END                       (FLASH_BASE + FLASH_SIZE - 1)
asm-arm/arch-integrator/platform.h:#define EPROM_END                       (EPROM_BASE + EPROM_SIZE - 1)
asm-arm/arch-integrator/platform.h: *  Clean base - dummy
asm-arm/arch-integrator/bits.h: * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
asm-arm/arch-integrator/bits.h:/* DO NOT EDIT!! - this file automatically generated
asm-arm/arch-integrator/bits.h: *                 from .s file by awk -f s2h.awk
asm-arm/arch-integrator/timex.h: *  linux/include/asm-arm/arch-integrator/timex.h
asm-arm/arch-integrator/timex.h: * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
asm-arm/arch-integrator/irqs.h: *  linux/include/asm-arm/arch-integrator/irqs.h
asm-arm/arch-integrator/irqs.h: * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
asm-arm/arch-integrator/system.h: *  linux/include/asm-arm/arch-integrator/system.h
asm-arm/arch-integrator/system.h: * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
asm-arm/arch-integrator/system.h:	 * To reset, we hit the on-board reset register
asm-arm/arch-integrator/time.h: *  linux/include/asm-arm/arch-integrator/time.h
asm-arm/arch-integrator/time.h: * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
asm-arm/arch-integrator/time.h:	ticks2 = timer1->TimerValue & 0xffff;
asm-arm/arch-integrator/time.h:		ticks2 = timer1->TimerValue & 0xffff;
asm-arm/arch-integrator/time.h:	ticks1 = TIMER_RELOAD - ticks2;
asm-arm/arch-integrator/time.h:	timer1->TimerClear = 1;
asm-arm/arch-integrator/time.h:	timer0->TimerControl = 0;
asm-arm/arch-integrator/time.h:	timer1->TimerControl = 0;
asm-arm/arch-integrator/time.h:	timer2->TimerControl = 0;
asm-arm/arch-integrator/time.h:	timer1->TimerLoad    = TIMER_RELOAD;
asm-arm/arch-integrator/time.h:	timer1->TimerValue   = TIMER_RELOAD;
asm-arm/arch-integrator/time.h:	timer1->TimerControl = TIMER_CTRL | 0x40;	/* periodic */
asm-arm/arch-integrator/serial.h: *  linux/include/asm-arm/arch-integrator/serial.h
asm-arm/arch-integrator/serial.h: * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
asm-arm/arch-integrator/param.h: *  linux/include/asm-arm/arch-integrator/param.h
asm-arm/arch-integrator/param.h: * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
asm-arm/arch-integrator/keyboard.h: *  linux/include/asm-arm/arch-integrator/keyboard.h
asm-arm/arch-integrator/keyboard.h: *  Copyright (C) 2000-2001 Deep Blue Solutions Ltd.
asm-arm/arch-integrator/keyboard.h: * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
asm-arm/arch-integrator/memory.h: *  linux/include/asm-arm/arch-integrator/mmu.h
asm-arm/arch-integrator/memory.h: * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
asm-arm/arch-integrator/memory.h:#define __virt_to_phys(vpage) ((vpage) - PAGE_OFFSET)
asm-arm/arch-integrator/memory.h: * Virtual view <-> DMA view memory address translations
asm-arm/arch-integrator/memory.h:#define __virt_to_bus(x)	(x - PAGE_OFFSET + INTEGRATOR_HDR0_SDRAM_BASE)
asm-arm/arch-integrator/memory.h:#define __bus_to_virt(x)	(x - INTEGRATOR_HDR0_SDRAM_BASE + PAGE_OFFSET)
asm-arm/hardware/ep7211.h: *  linux/include/asm-arm/hardware/ep7211.h
asm-arm/hardware/ep7211.h: * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
asm-arm/hardware/ep7212.h: *  linux/include/asm-arm/hardware/ep7212.h
asm-arm/hardware/ep7212.h: * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
asm-arm/hardware/ep7312.h: *  linux/include/asm-arm/hardware/ep7312.h
asm-arm/hardware/ep7312.h: * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307  USA
asm-arm/hardware/ep7312.h:#define RANDID0	 0x2700	/* Bits 31-0 of 128-bit random ID */
asm-arm/hardware/ep7312.h:#define RANDID1	 0x2704	/* Bits 63-32 of 128-bit random ID */
asm-arm/hardware/ep7312.h:#define RANDID2	 0x2708	/* Bits 95-64 of 128-bit random ID */
asm-arm/hardware/ep7312.h:#define RANDID3	 0x270C	/* Bits 127-96 of 128-bit random ID */
asm-arm/hardware/dec21285.h: *  linux/include/asm-arm/hardware/dec21285.h
asm-arm/hardware/ioc.h: *  linux/include/asm-arm/hardware/ioc.h
asm-arm/hardware/clps7111.h: *  linux/include/asm-arm/hardware/clps7111.h
asm-arm/hardware/clps7111.h: * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
asm-arm/hardware/clps7111.h:#define UBRLCR_BAUD_MASK	((1 << 12) - 1)
asm-arm/hardware/cs89712.h: *  linux/include/asm-arm/hardware/cs89712.h
asm-arm/hardware/cs89712.h: * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
asm-arm/hardware/cs89712.h:#define PCDR			0x0002	/* Port C Data register ---------------------------- */
asm-arm/hardware/cs89712.h:#define PCDDR			0x0042	/* Port C Data Direction register ------------------ */
asm-arm/hardware/cs89712.h:#define SDCONF			0x2300  /* SDRAM Configuration register ---------------------*/
asm-arm/hardware/cs89712.h:#define SDRFPR			0x2340  /* SDRAM Refresh period register --------------------*/
asm-arm/hardware/sa1111.h: * linux/include/asm-arm/hardware/SA-1111.h
asm-arm/hardware/sa1111.h: * This file contains definitions for the SA-1111 Companion Chip.
asm-arm/hardware/sa1111.h: * (Structure and naming borrowed from SA-1101.h, by Peter Danielsson.)
asm-arm/hardware/sa1111.h: * Macro that calculates real address for registers in the SA-1111
asm-arm/hardware/sa1111.h:#define SA1111_p2v( x )         ((x) - SA1111_BASE + SA1111_VBASE)
asm-arm/hardware/sa1111.h:#define SA1111_v2p( x )         ((x) - SA1111_VBASE + SA1111_BASE)
asm-arm/hardware/sa1111.h: * 26 bits of the SA-1110 address bus are available to the SA-1111.
asm-arm/hardware/sa1111.h:#define SA1111_ADDR_MASK	((1<<SA1111_ADDR_WIDTH)-1)
asm-arm/hardware/sa1111.h: *  - The October 1999 errata (278260-007) says its bit 13, 1 to enable.
asm-arm/hardware/sa1111.h: *  - The Feb 2001 errata (278260-010) says that the previous errata
asm-arm/hardware/sa1111.h: *    (278260-009) is wrong, and its bit actually 12, fixed in spec
asm-arm/hardware/sa1111.h: *    278242-003.
asm-arm/hardware/sa1111.h: *  - The SA1111 manual (278242) says bit 12, but 0 to enable.
asm-arm/hardware/sa1111.h: *  - Reality is bit 13, 1 to enable.
asm-arm/hardware/sa1111.h: *      -- rmk
asm-arm/hardware/sa1111.h:#define _USB_EXTENT		(_USB_INTERRUPTEST - _USB_OHCI_OP_BASE + 4)
asm-arm/hardware/sa1111.h: *    SACR2             Serial Audio AC-link Control Register
asm-arm/hardware/sa1111.h: *    SASR1             Serial Audio AC-link Interface & FIFO Status Register
asm-arm/hardware/sa1111.h: *    ACCAR             AC-link Command Address Register
asm-arm/hardware/sa1111.h: *    ACCDR             AC-link Command Data Register
asm-arm/hardware/sa1111.h: *    ACSAR             AC-link Status Address Register
asm-arm/hardware/sa1111.h: *    ACSDR             AC-link Status Data Register
asm-arm/hardware/sa1111.h: *    SADR              Serial Audio Data Register (16 x 32-bit)
asm-arm/hardware/sa1111.h: * General-Purpose I/O Interface
asm-arm/hardware/sa1111.h: *    WAKE_EN0		Wake-up source enable 0
asm-arm/hardware/sa1111.h: *    WAKE_EN1		Wake-up source enable 1
asm-arm/hardware/sa1111.h: *    WAKE_POL0		Wake-up polarity selection 0
asm-arm/hardware/sa1111.h: *    WAKE_POL1		Wake-up polarity selection 1
asm-arm/hardware/pci_v3.h: *  linux/include/asm-arm/hardware/pci_v3.h
asm-arm/hardware/pci_v3.h: *  Copyright (C) 2000-2001 Deep Blue Solutions Ltd.
asm-arm/hardware/pci_v3.h: * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
asm-arm/hardware/pci_v3.h:/* -------------------------------------------------------------------------------
asm-arm/hardware/pci_v3.h: * -------------------------------------------------------------------------------
asm-arm/hardware/pci_v3.h:/*  PCI_BASE register bits (PCI -> Local Bus)
asm-arm/hardware/pci_v3.h:/*  PCI MAP register bits (PCI -> Local bus)
asm-arm/hardware/pci_v3.h: *  LB_BASE0,1 register bits (Local bus -> PCI)
asm-arm/hardware/pci_v3.h: *  LB_MAP0,1 register bits (Local bus -> PCI)
asm-arm/hardware/pci_v3.h: *  LB_BASE2 register bits (Local bus -> PCI IO)
asm-arm/hardware/pci_v3.h: *  LB_MAP2 register bits (Local bus -> PCI IO)
asm-arm/hardware/iomd.h: *  linux/include/asm-arm/hardware/iomd.h
asm-arm/hardware/iomd.h:	outl (SCREEN_START + end - VDMA_XFERSIZE, VDMA_END);	\
asm-arm/hardware/iomd.h:	if (offset >= end - VDMA_XFERSIZE)			\
asm-arm/hardware/serial_omaha.h: *  linux/include/asm-arm/hardware/serial_omaha.h
asm-arm/hardware/serial_omaha.h: * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
asm-arm/hardware/memc.h: *  linux/include/asm-arm/hardware/memc.h
asm-arm/hardware/memc.h:	memc_write (VDMA_END, (end - VDMA_XFERSIZE) >> 2);	\
asm-arm/hardware/amba_kmi.h: *  linux/include/asm-arm/hardware/amba_kmi.h
asm-arm/hardware/amba_kmi.h: * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
asm-arm/hardware/amba_kmi.h: * ---------------------------------------------------------------------------
asm-arm/hardware/amba_kmi.h: *  Reference Manual - ARM DDI 0143B - see http://www.arm.com/
asm-arm/hardware/amba_kmi.h: * ---------------------------------------------------------------------------
asm-arm/hardware/amba_kmi.h: *  div = (ref / 8MHz) - 1; 0 <= div <= 15
asm-arm/hardware/serial_amba.h: *  linux/include/asm-arm/hardware/serial_amba.h
asm-arm/hardware/serial_amba.h: * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
asm-arm/hardware/serial_amba.h:/* -------------------------------------------------------------------------------
asm-arm/hardware/serial_amba.h: *  From AMBA UART (PL010) Block Specification (ARM-0001-CUST-DSPC-A03)
asm-arm/hardware/serial_amba.h: * -------------------------------------------------------------------------------
asm-arm/uaccess.h:#define get_fs()	(current->addr_limit)
asm-arm/uaccess.h:	return access_ok(type, addr, size) ? 0 : -EFAULT;
asm-arm/uaccess.h: * Single-value transfer routines.  They automatically use the right
asm-arm/uaccess.h: * address space - it must have been done previously with a separate
asm-arm/uaccess.h:	else /* security hole - plug it */
asm-arm/uaccess.h:	long res = -EFAULT;
asm-arm/uaccess.h:	long __gu_err = -EFAULT, __gu_val = 0;				\
asm-arm/uaccess.h:	long __pu_err = -EFAULT;					\
asm-arm/leds.h: *  linux/include/asm-arm/leds.h
asm-arm/leds.h: *  Event-driven interface for LEDs on machines
asm-arm/leds.h: *  Added led_start and led_stop- Alex Holden, 28th Dec 1998.
asm-arm/arch-arc/io.h: *  linux/include/asm-arm/arch-arc/io.h
asm-arm/arch-arc/io.h: *   06-Dec-1997 RMK	Created.
asm-arm/arch-arc/io.h: * We use two different types of addressing - PC style addresses, and ARM
asm-arm/arch-arc/io.h: * Dynamic IO functions - let the compiler
asm-arm/arch-arc/io.h:	: "r" (value), "r" (port), "Ir" (PCIO_BASE - IO_BASE), "Ir" (IO_BASE)
asm-arm/arch-arc/io.h:	: "r" (value|value<<16), "r" (port), "Ir" (PCIO_BASE - IO_BASE), "Ir" (IO_BASE)
asm-arm/arch-arc/io.h:	: "r" (value), "r" (port), "Ir" (PCIO_BASE - IO_BASE), "Ir" (IO_BASE)
asm-arm/arch-arc/io.h:	: "r" (port), "Ir" (PCIO_BASE - IO_BASE), "Ir" (IO_BASE)		\
asm-arm/arch-arc/io.h: * These have to be macros for the 'J' constraint to work -
asm-arm/arch-arc/io.h: * +/-4096 immediate operand.
asm-arm/arch-arc/hardware.h: *  linux/include/asm-arm/arch-arc/hardware.h
asm-arm/arch-arc/hardware.h: *  Copyright (C) 1996-1999 Russell King.
asm-arm/arch-arc/hardware.h: *   04-04-1998	PJB/RMK	Merged arc and a5k versions
asm-arm/arch-arc/hardware.h: * What hardware must be present - these can be tested by the kernel
asm-arm/arch-arc/uncompress.h: *  linux/include/asm-arm/arch-arc/uncompress.h
asm-arm/arch-arc/uncompress.h:	unsigned long unused[256/4-11];
asm-arm/arch-arc/uncompress.h:	x = params->video_x;
asm-arm/arch-arc/uncompress.h:	y = params->video_y;
asm-arm/arch-arc/uncompress.h:				y--;
asm-arm/arch-arc/uncompress.h:			ptr = VIDMEM + ((y*video_num_columns*params->bytes_per_char_v+x)*bytes_per_char_h);
asm-arm/arch-arc/uncompress.h:					y--;
asm-arm/arch-arc/uncompress.h:	params->video_x = x;
asm-arm/arch-arc/uncompress.h:	params->video_y = y;
asm-arm/arch-arc/uncompress.h:	video_num_lines = params->video_num_rows;
asm-arm/arch-arc/uncompress.h:	video_num_columns = params->video_num_cols;
asm-arm/arch-arc/uncompress.h:	bytes_per_char_h = params->bytes_per_char_h;
asm-arm/arch-arc/uncompress.h:	if (params->nr_pages * params->page_size < 4096*1024) error("<4M of mem\n");
asm-arm/arch-arc/dma.h: *  linux/include/asm-arm/arch-arc/dma.h
asm-arm/arch-arc/dma.h: *  Copyright (C) 1996-1998 Russell King
asm-arm/arch-arc/dma.h: *   04-04-1998	RMK	Merged arc and a5k versions
asm-arm/arch-arc/ide.h: *  linux/include/asm-arm/arch-arc/ide.h
asm-arm/arch-arc/ide.h: *   04-04-1998	PJB	Merged `arc' and `a5k' versions
asm-arm/arch-arc/ide.h: *   01-07-1998	RMK	Added new ide_ioregspec_t
asm-arm/arch-arc/ide.h: *   29-07-1998	RMK	Major re-work of IDE architecture specific code
asm-arm/arch-arc/ide.h:#include <asm/mach-types.h>
asm-arm/arch-arc/ide.h:		hw->io_ports[i] = reg;
asm-arm/arch-arc/ide.h:	hw->io_ports[IDE_CONTROL_OFFSET] = (ide_ioreg_t) ctrl_port;
asm-arm/arch-arc/irq.h: *  linux/include/asm-arm/arch-arc/irq.h
asm-arm/arch-arc/irq.h: *   24-09-1996	RMK	Created
asm-arm/arch-arc/irq.h: *   10-10-1996	RMK	Brought up to date with arch-sa110eval
asm-arm/arch-arc/irq.h: *   22-10-1996	RMK	Changed interrupt numbers & uses new inb/outb macros
asm-arm/arch-arc/irq.h: *   11-01-1998	RMK	Added mask_and_ack_irq
asm-arm/arch-arc/irq.h: *   22-08-1998	RMK	Restructured IRQ routines
asm-arm/arch-arc/oldlatches.h: *  linux/include/asm-arm/arch-arc/oldlatches.h
asm-arm/arch-arc/oldlatches.h: *   04-04-1998	PJB/RMK	Merged arc and a5k versions
asm-arm/arch-arc/timex.h: *  linux/include/asm-arm/arch-arc/timex.h
asm-arm/arch-arc/irqs.h: *  linux/include/asm-arm/arch-arc/irqs.h
asm-arm/arch-arc/irqs.h: *   04-04-1998	PJB	Merged arc and a5k versions
asm-arm/arch-arc/system.h: *  linux/include/asm-arm/arch-arc/system.h
asm-arm/arch-arc/system.h: *  Copyright (C) 1996-1999 Russell King and Dave Gilbert
asm-arm/arch-arc/time.h: *  linux/include/asm-arm/arch-arc/time.h
asm-arm/arch-arc/time.h: *  Copyright (C) 1996-2000 Russell King.
asm-arm/arch-arc/time.h: *   24-Sep-1996 RMK	Created
asm-arm/arch-arc/time.h: *   10-Oct-1996 RMK	Brought up to date with arch-sa110eval
asm-arm/arch-arc/time.h: *   04-Dec-1997 RMK	Updated for new arch/arm/time.c
asm-arm/arch-arc/serial.h: *  linux/include/asm-arm/arch-arc/serial.h
asm-arm/arch-arc/serial.h: *   15-10-1996	RMK	Created
asm-arm/arch-arc/serial.h: *   04-04-1998	PJB	Merged `arc' and `a5k' architectures
asm-arm/arch-arc/param.h: * linux/include/asm-arm/arch-arc/param.h
asm-arm/arch-arc/keyboard.h: *  linux/include/asm-arm/arch-arc/keyboard.h
asm-arm/arch-arc/keyboard.h: *  Copyright (C) 1998-2001 Russell King
asm-arm/arch-arc/memory.h: *  linux/include/asm-arm/arch-arc/memory.h
asm-arm/arch-arc/memory.h: *  Copyright (C) 1996-1999 Russell King.
asm-arm/arch-arc/memory.h: *  22-Nov-1996	RMK	Created
asm-arm/arch-arc/memory.h: *  21-Mar-1999	RMK	Renamed to memory.h
asm-arm/arch-arc/memory.h: * Virtual view <-> DMA view memory address translations
asm-arm/arch-rpc/io.h: *  linux/include/asm-arm/arch-rpc/io.h
asm-arm/arch-rpc/io.h: *  06-Dec-1997	RMK	Created.
asm-arm/arch-rpc/io.h: * We use two different types of addressing - PC style addresses, and ARM
asm-arm/arch-rpc/io.h:	: "r" (value), "r" (port), "Ir" (PCIO_BASE - IO_BASE), "Ir" (IO_BASE)
asm-arm/arch-rpc/io.h:	: "r" (value|value<<16), "r" (port), "Ir" (PCIO_BASE - IO_BASE), "Ir" (IO_BASE)
asm-arm/arch-rpc/io.h:	: "r" (value), "r" (port), "Ir" (PCIO_BASE - IO_BASE), "Ir" (IO_BASE)
asm-arm/arch-rpc/io.h:	: "r" (port), "Ir" (PCIO_BASE - IO_BASE), "Ir" (IO_BASE)		\
asm-arm/arch-rpc/io.h: * These have to be macros for the 'J' constraint to work -
asm-arm/arch-rpc/io.h: * +/-4096 immediate operand.
asm-arm/arch-rpc/hardware.h: *  linux/include/asm-arm/arch-rpc/hardware.h
asm-arm/arch-rpc/hardware.h: *  Copyright (C) 1996-1999 Russell King.
asm-arm/arch-rpc/uncompress.h: *  linux/include/asm-arm/arch-rpc/uncompress.h
asm-arm/arch-rpc/uncompress.h:	unsigned long unused[256/4-11];
asm-arm/arch-rpc/uncompress.h:	x = params->video_x;
asm-arm/arch-rpc/uncompress.h:	y = params->video_y;
asm-arm/arch-rpc/uncompress.h:				y--;
asm-arm/arch-rpc/uncompress.h:			ptr = VIDMEM + ((y*video_num_columns*params->bytes_per_char_v+x)*bytes_per_char_h);
asm-arm/arch-rpc/uncompress.h:					y--;
asm-arm/arch-rpc/uncompress.h:	params->video_x = x;
asm-arm/arch-rpc/uncompress.h:	params->video_y = y;
asm-arm/arch-rpc/uncompress.h:	video_num_lines = params->video_num_rows;
asm-arm/arch-rpc/uncompress.h:	video_num_columns = params->video_num_cols;
asm-arm/arch-rpc/uncompress.h:	bytes_per_char_h = params->bytes_per_char_h;
asm-arm/arch-rpc/uncompress.h:	if (params->nr_pages * params->page_size < 4096*1024) error("<4M of mem\n");
asm-arm/arch-rpc/vmalloc.h: *  linux/include/asm-arm/arch-rpc/vmalloc.h
asm-arm/arch-rpc/vmalloc.h: * any out-of-bounds memory accesses will hopefully be caught.
asm-arm/arch-rpc/vmalloc.h:#define VMALLOC_START	  (((unsigned long)high_memory + VMALLOC_OFFSET) & ~(VMALLOC_OFFSET-1))
asm-arm/arch-rpc/dma.h: *  linux/include/asm-arm/arch-rpc/dma.h
asm-arm/arch-rpc/dma.h: * There should not be more than (0xd0000000 - 0xc0000000)
asm-arm/arch-rpc/ide.h: *  linux/include/asm-arm/arch-rpc/ide.h
asm-arm/arch-rpc/ide.h: *   29-07-1998	RMK	Major re-work of IDE architecture specific code
asm-arm/arch-rpc/ide.h:		hw->io_ports[i] = reg;
asm-arm/arch-rpc/ide.h:	hw->io_ports[IDE_CONTROL_OFFSET] = (ide_ioreg_t) ctrl_port;
asm-arm/arch-rpc/irq.h: *  linux/include/asm-arm/arch-rpc/irq.h
asm-arm/arch-rpc/irq.h: *   10-10-1996	RMK	Brought up to date with arch-sa110eval
asm-arm/arch-rpc/irq.h: *   22-08-1998	RMK	Restructured IRQ routines
asm-arm/arch-rpc/acornfb.h: *  linux/include/asm-arm/arch-rpc/acornfb.h
asm-arm/arch-rpc/acornfb.h:		d = pixclk - p;
asm-arm/arch-rpc/acornfb.h:			d = -d;
asm-arm/arch-rpc/acornfb.h:			best_v = v - 1;
asm-arm/arch-rpc/acornfb.h:			best_r = r - 1;
asm-arm/arch-rpc/acornfb.h:	/* Select pixel-clock divisor to keep PLL in range */
asm-arm/arch-rpc/acornfb.h:	div = var->pixclock / 9090; /*9921*/
asm-arm/arch-rpc/acornfb.h:	case 1:	vidc->control |= VIDC20_CTRL_PIX_CK;  break;
asm-arm/arch-rpc/acornfb.h:	case 2:	vidc->control |= VIDC20_CTRL_PIX_CK2; break;
asm-arm/arch-rpc/acornfb.h:	case 3:	vidc->control |= VIDC20_CTRL_PIX_CK3; break;
asm-arm/arch-rpc/acornfb.h:	case 4:	vidc->control |= VIDC20_CTRL_PIX_CK4; break;
asm-arm/arch-rpc/acornfb.h:	case 5:	vidc->control |= VIDC20_CTRL_PIX_CK5; break;
asm-arm/arch-rpc/acornfb.h:	case 6:	vidc->control |= VIDC20_CTRL_PIX_CK6; break;
asm-arm/arch-rpc/acornfb.h:	case 7:	vidc->control |= VIDC20_CTRL_PIX_CK7; break;
asm-arm/arch-rpc/acornfb.h:	case 8: vidc->control |= VIDC20_CTRL_PIX_CK8; break;
asm-arm/arch-rpc/acornfb.h:	bandwidth = var->pixclock * 8 / var->bits_per_pixel;
asm-arm/arch-rpc/acornfb.h:		vidc->control |= VIDC20_CTRL_FIFO_16;	/* < 30.0MB/s */
asm-arm/arch-rpc/acornfb.h:		vidc->control |= VIDC20_CTRL_FIFO_20;	/* < 37.5MB/s */
asm-arm/arch-rpc/acornfb.h:		vidc->control |= VIDC20_CTRL_FIFO_24;	/* < 45.0MB/s */
asm-arm/arch-rpc/acornfb.h:		vidc->control |= VIDC20_CTRL_FIFO_28;	/* > 45.0MB/s */
asm-arm/arch-rpc/acornfb.h:	vidc->pll_ctl  = acornfb_vidc20_find_pll(var->pixclock / div);
asm-arm/arch-rpc/timex.h: *  linux/include/asm-arm/arch-rpc/timex.h
asm-arm/arch-rpc/irqs.h: *  linux/include/asm-arm/arch-rpc/irqs.h
asm-arm/arch-rpc/system.h: *  linux/include/asm-arm/arch-rpc/system.h
asm-arm/arch-rpc/system.h: *  Copyright (C) 1996-1999 Russell King.
asm-arm/arch-rpc/time.h: *  linux/include/asm-arm/arch-rpc/time.h
asm-arm/arch-rpc/time.h: *  Copyright (C) 1996-2000 Russell King.
asm-arm/arch-rpc/time.h: *   24-Sep-1996 RMK	Created
asm-arm/arch-rpc/time.h: *   10-Oct-1996 RMK	Brought up to date with arch-sa110eval
asm-arm/arch-rpc/time.h: *   04-Dec-1997 RMK	Updated for new arch/arm/time.c
asm-arm/arch-rpc/serial.h: *  linux/include/asm-arm/arch-rpc/serial.h
asm-arm/arch-rpc/serial.h: *   15-10-1996	RMK	Created
asm-arm/arch-rpc/param.h: * linux/include/asm-arm/arch-rpc/param.h
asm-arm/arch-rpc/keyboard.h: *  linux/include/asm-arm/arch-rpc/keyboard.h
asm-arm/arch-rpc/keyboard.h: *  Copyright (C) 1998-2001 Russell King
asm-arm/arch-rpc/memory.h: *  linux/include/asm-arm/arch-rpc/memory.h
asm-arm/arch-rpc/memory.h: *   20-Oct-1996 RMK	Created
asm-arm/arch-rpc/memory.h: *   31-Dec-1997 RMK	Fixed definitions to reduce warnings
asm-arm/arch-rpc/memory.h: *   11-Jan-1998 RMK	Uninlined to reduce hits on cache
asm-arm/arch-rpc/memory.h: *   08-Feb-1998 RMK	Added __virt_to_bus and __bus_to_virt
asm-arm/arch-rpc/memory.h: *   21-Mar-1999 RMK	Renamed to memory.h
asm-arm/arch-rpc/memory.h:#define __virt_to_phys(vpage) ((vpage) - PAGE_OFFSET + PHYS_OFFSET)
asm-arm/arch-rpc/memory.h:#define __phys_to_virt(ppage) ((ppage) + PAGE_OFFSET - PHYS_OFFSET)
asm-arm/semaphore-helper.h:	if (atomic_read(&sem->count) <= 0)
asm-arm/semaphore-helper.h:		sem->waking++;
asm-arm/semaphore-helper.h:	if (sem->waking > 0) {
asm-arm/semaphore-helper.h:		sem->waking--;
asm-arm/semaphore-helper.h: *	-EINTR	interrupted
asm-arm/semaphore-helper.h: * We must undo the sem->count down_interruptible() increment while we are
asm-arm/semaphore-helper.h: * atomic_read() in wake_one_more(), otherwise we can race. -arca
asm-arm/semaphore-helper.h:	if (sem->waking > 0) {
asm-arm/semaphore-helper.h:		sem->waking--;
asm-arm/semaphore-helper.h:		atomic_inc(&sem->count);
asm-arm/semaphore-helper.h:		ret = -EINTR;
asm-arm/semaphore-helper.h: * We must undo the sem->count down_interruptible() increment while we are
asm-arm/semaphore-helper.h: * atomic_read() in wake_one_more(), otherwise we can race. -arca
asm-arm/semaphore-helper.h:	if (sem->waking <= 0)
asm-arm/semaphore-helper.h:		atomic_inc(&sem->count);
asm-arm/semaphore-helper.h:		sem->waking--;
asm-arm/mman.h:#define MAP_GROWSDOWN	0x0100		/* stack-like segment */
asm-arm/mman.h:#define MADV_NORMAL	0x0		/* default page-in behavior */
asm-arm/mman.h:#define MADV_RANDOM	0x1		/* page-in minimum required */
asm-arm/mman.h:#define MADV_SEQUENTIAL	0x2		/* read-ahead aggressively */
asm-arm/mman.h:#define MADV_WILLNEED	0x3		/* pre-fault pages */
asm-arm/posix_types.h: *  linux/include/asm-arm/posix_types.h
asm-arm/posix_types.h: *  Copyright (C) 1996-1998 Russell King.
asm-arm/posix_types.h: *   27-06-1996	RMK	Created
asm-arm/posix_types.h: * This file is generally used by user-level software, so you need to
asm-arm/posix_types.h:		(((fd_set *)fdsetp)->fds_bits[fd >> 5] |= (1<<(fd & 31)))
asm-arm/posix_types.h:		(((fd_set *)fdsetp)->fds_bits[fd >> 5] &= ~(1<<(fd & 31)))
asm-arm/posix_types.h:		((((fd_set *)fdsetp)->fds_bits[fd >> 5] & (1<<(fd & 31))) != 0)
asm-arm/scatterlist.h:#define sg_dma_address(sg)      ((sg)->dma_address)
asm-arm/scatterlist.h:#define sg_dma_len(sg)          ((sg)->length)
asm-arm/smplock.h:	if (task->lock_depth >= 0) \
asm-arm/smplock.h: * Re-acquire the kernel lock
asm-arm/smplock.h:	if (task->lock_depth >= 0) \
asm-arm/smplock.h:	if (!++current->lock_depth)
asm-arm/smplock.h:	if (--current->lock_depth < 0)
asm-arm/arch-nexuspci/io.h: * linux/include/asm-arm/arch-nexuspci/io.h
asm-arm/arch-nexuspci/io.h: * Copyright (C) 1997-1999 Russell King
asm-arm/arch-nexuspci/io.h: * ioremap support - validate a PCI memory address,
asm-arm/arch-nexuspci/hardware.h: * linux/include/asm-arm/arch-nexuspci/hardware.h
asm-arm/arch-nexuspci/uncompress.h: * linux/include/asm-arm/arch-nexuspci/uncompress.h
asm-arm/arch-nexuspci/vmalloc.h: * linux/include/asm-arm/arch-nexuspci/vmalloc.h
asm-arm/arch-nexuspci/vmalloc.h: * any out-of-bounds memory accesses will hopefully be caught.
asm-arm/arch-nexuspci/vmalloc.h:#define VMALLOC_START	  (((unsigned long)high_memory + VMALLOC_OFFSET) & ~(VMALLOC_OFFSET-1))
asm-arm/arch-nexuspci/dma.h: * linux/include/asm-arm/arch-nexuspci/dma.h
asm-arm/arch-nexuspci/ide.h: * linux/include/asm-arm/arch-nexuspci/ide.h
asm-arm/arch-nexuspci/ide.h: *  29-07-1998	RMK	Major re-work of IDE architecture specific code
asm-arm/arch-nexuspci/ide.h:		hw->io_ports[i] = reg;
asm-arm/arch-nexuspci/ide.h:	hw->io_ports[IDE_CONTROL_OFFSET] = (ide_ioreg_t) ctrl_port;
asm-arm/arch-nexuspci/irq.h: * include/asm-arm/arch-nexuspci/irq.h
asm-arm/arch-nexuspci/timex.h: * linux/include/asm-arm/arch-nexuspci/timex.h
asm-arm/arch-nexuspci/irqs.h: * linux/include/asm-arm/arch-nexuspci/irqs.h
asm-arm/arch-nexuspci/system.h: * linux/include/asm-arm/arch-nexuspci/system.h
asm-arm/arch-nexuspci/time.h: * linux/include/asm-arm/arch-nexuspci/time.h
asm-arm/arch-nexuspci/time.h: * The FTV PCI card has no real-time clock.  We get timer ticks from the
asm-arm/arch-nexuspci/time.h:	if (--count == 0) {
asm-arm/arch-nexuspci/param.h: * linux/include/asm-arm/arch-nexuspci/param.h
asm-arm/arch-nexuspci/keyboard.h: * linux/include/asm-arm/arch-nexuspci/keyboard.h
asm-arm/arch-nexuspci/keyboard.h: * Copyright (C) 1998-2001 Russell King
asm-arm/arch-nexuspci/memory.h: * linux/include/asm-arm/arch-nexuspci/memory.h
asm-arm/arch-nexuspci/memory.h:#define __virt_to_phys(vpage) ((unsigned long)(vpage) - PAGE_OFFSET + PHYS_OFFSET)
asm-arm/arch-nexuspci/memory.h:#define __phys_to_virt(ppage) ((unsigned long)(ppage) + PAGE_OFFSET - PHYS_OFFSET)
asm-arm/arch-nexuspci/memory.h:#define __virt_to_bus(x) ((unsigned long)(x) - PAGE_OFFSET + BUS_OFFSET)
asm-arm/arch-nexuspci/memory.h:#define __bus_to_virt(x) ((unsigned long)(x) + PAGE_OFFSET - BUS_OFFSET)
asm-arm/page.h:#define PAGE_MASK       (~(PAGE_SIZE-1))
asm-arm/page.h: * These are used to make use of C type-checking..
asm-arm/page.h:#define PAGE_ALIGN(addr)	(((addr)+PAGE_SIZE-1)&PAGE_MASK)
asm-arm/page.h:	size = (size-1) >> (PAGE_SHIFT-1);
asm-arm/page.h:	order = -1;
asm-arm/proc-armo/assembler.h: *  linux/asm-arm/proc-armo/assembler.h
asm-arm/proc-armo/assembler.h: * ** Actually do nothing on Arc - hope that the caller uses a MOVS PC soon
asm-arm/proc-armo/assembler.h: * These two are used to save LR/restore PC over a user-based access.
asm-arm/proc-armo/assembler.h: * The old 26-bit architecture requires that we do.  On 32-bit
asm-arm/proc-armo/assembler.h:	str	lr, [sp, #-4]!
asm-arm/proc-armo/ptrace.h: *  linux/include/asm-arm/proc-armo/ptrace.h
asm-arm/proc-armo/ptrace.h: *  Copyright (C) 1996-2001 Russell King
asm-arm/proc-armo/ptrace.h:	((regs)->ARM_pc & MODE_MASK)
asm-arm/proc-armo/ptrace.h:	(!((regs)->ARM_pc & I_BIT))
asm-arm/proc-armo/ptrace.h:	(!((regs)->ARM_pc & F_BIT))
asm-arm/proc-armo/ptrace.h:	((regs)->ARM_pc & (CC_V_BIT|CC_C_BIT|CC_Z_BIT|CC_N_BIT))
asm-arm/proc-armo/ptrace.h:	    (regs->ARM_pc & (F_BIT | I_BIT)) == 0)
asm-arm/proc-armo/ptrace.h:	regs->ARM_pc &= ~(MODE_MASK | F_BIT | I_BIT);
asm-arm/proc-armo/pgalloc.h: *  linux/include/asm-arm/proc-armo/pgalloc.h
asm-arm/proc-armo/pgalloc.h: * Page table allocation/freeing primitives for 26-bit ARM processors.
asm-arm/proc-armo/pgalloc.h: * from the Linux copy.  The processor copies are offset by -PTRS_PER_PTE
asm-arm/proc-armo/elf.h: * ELF definitions for 26-bit CPUs
asm-arm/proc-armo/elf.h:/* We can only execute 26-bit code. */
asm-arm/proc-armo/elf.h:	((x)->e_flags & EF_ARM_APCS26)
asm-arm/proc-armo/shmparam.h: *  linux/include/asm-arm/proc-armo/shmparam.h
asm-arm/proc-armo/processor.h: *  linux/include/asm-arm/proc-armo/processor.h
asm-arm/proc-armo/processor.h: *   27-06-1996	RMK	Created
asm-arm/proc-armo/processor.h: *   10-10-1996	RMK	Brought up to date with SA110
asm-arm/proc-armo/processor.h: *   26-09-1996	RMK	Added 'EXTRA_THREAD_STRUCT*'
asm-arm/proc-armo/processor.h: *   28-09-1996	RMK	Moved start_thread into the processor dependencies
asm-arm/proc-armo/processor.h: *   11-01-1998	RMK	Added new uaccess_t
asm-arm/proc-armo/processor.h: *   09-09-1998	PJB	Delete redundant `wp_works_ok'
asm-arm/proc-armo/processor.h: *   30-05-1999	PJB	Save sl across context switches
asm-arm/proc-armo/processor.h:	memzero(regs->uregs, sizeof (regs->uregs));			\
asm-arm/proc-armo/processor.h:	regs->ARM_pc = pc;		/* pc */			\
asm-arm/proc-armo/processor.h:	regs->ARM_sp = sp;		/* sp */			\
asm-arm/proc-armo/processor.h:	regs->ARM_r2 = stack[2];	/* r2 (envp) */			\
asm-arm/proc-armo/processor.h:	regs->ARM_r1 = stack[1];	/* r1 (argv) */			\
asm-arm/proc-armo/processor.h:	regs->ARM_r0 = stack[0];	/* r0 (argc) */			\
asm-arm/proc-armo/locks.h: *  linux/include/asm-arm/proc-armo/locks.h
asm-arm/proc-armo/locks.h:"	orrle	ip, ip, #0x80000000	@ set N - should this be mi ??? DAG ! \n" \
asm-arm/proc-armo/uaccess.h: *  linux/include/asm-arm/proc-armo/segment.h
asm-arm/proc-armo/uaccess.h:	current->addr_limit = fs;
asm-arm/proc-armo/uaccess.h:	current->thread.uaccess = fs == USER_DS ? &uaccess_user : &uaccess_kernel;
asm-arm/proc-armo/uaccess.h:		: "r" (addr), "Ir" (size), "0" (current->addr_limit)	\
asm-arm/proc-armo/uaccess.h:		: "0" (current->addr_limit), "r" (addr)			\
asm-arm/proc-armo/uaccess.h:	: "r" (x), "r" (addr), "r" (current->thread.uaccess->put_byte),	\
asm-arm/proc-armo/uaccess.h:	: "r" (x), "r" (addr), "r" (current->thread.uaccess->put_half),	\
asm-arm/proc-armo/uaccess.h:	: "r" (x), "r" (addr), "r" (current->thread.uaccess->put_word),	\
asm-arm/proc-armo/uaccess.h:	: "r" (addr), "r" (current->thread.uaccess->get_byte), "0" (err)	\
asm-arm/proc-armo/uaccess.h:	: "r" (addr), "r" (current->thread.uaccess->get_half), "0" (err)	\
asm-arm/proc-armo/uaccess.h:	: "r" (addr), "r" (current->thread.uaccess->get_word), "0" (err)	\
asm-arm/proc-armo/uaccess.h:	(n) = current->thread.uaccess->copy_from_user((to),(from),(n))
asm-arm/proc-armo/uaccess.h:	(n) = current->thread.uaccess->copy_to_user((to),(from),(n))
asm-arm/proc-armo/uaccess.h:	(sz) = current->thread.uaccess->clear_user((addr),(sz))
asm-arm/proc-armo/uaccess.h:	(res) = current->thread.uaccess->strncpy_from_user(dst,src,count)
asm-arm/proc-armo/uaccess.h:	(res) = current->thread.uaccess->strnlen_user(s,n)
asm-arm/proc-armo/page.h: *  linux/include/asm-arm/proc-armo/page.h
asm-arm/proc-armo/system.h: *  linux/include/asm-arm/proc-armo/system.h
asm-arm/proc-armo/system.h:#include <asm/proc-fns.h>
asm-arm/proc-armo/system.h: * We need to turn the caches off before calling the reset vector - RiscOS
asm-arm/proc-armo/pgtable.h: *  linux/include/asm-arm/proc-armo/pgtable.h
asm-arm/proc-armo/pgtable.h: *  Copyright (C) 1995-2001 Russell King
asm-arm/proc-armo/pgtable.h: *  18-Oct-1997	RMK	Now two-level (32x32)
asm-arm/proc-armo/pgtable.h: * entries per page directory level: they are two-level, so
asm-arm/proc-armo/pgtable.h:/*                               -- present --   -- !dirty --  --- !write ---   ---- !user --- */
asm-arm/proc-armo/cache.h: *  linux/include/asm-arm/proc-armo/cache.h
asm-arm/proc-armo/cache.h: *  Copyright (C) 1999-2001 Russell King
asm-arm/proc-armo/cache.h: *  Cache handling for 26-bit ARM processors.
asm-arm/proc-armo/cache.h: *  - flush_tlb_all() flushes all processes TLBs
asm-arm/proc-armo/cache.h: *  - flush_tlb_mm(mm) flushes the specified mm context TLB's
asm-arm/proc-armo/cache.h: *  - flush_tlb_page(vma, vmaddr) flushes one page
asm-arm/proc-armo/cache.h: *  - flush_tlb_range(mm, start, end) flushes a range of pages
asm-arm/proc-armo/cache.h:		if (!p->mm)
asm-arm/proc-armo/cache.h:		cpu_memc_update_all(p->mm->pgd);
asm-arm/proc-armo/cache.h:	processor._set_pgd(current->active_mm->pgd);
asm-arm/proc-armo/cache.h:	cpu_memc_update_all(mm->pgd);
asm-arm/proc-armo/cache.h:	if (mm == current->active_mm)
asm-arm/proc-armo/cache.h:		processor._set_pgd(mm->pgd);
asm-arm/proc-armo/cache.h:	cpu_memc_update_entry(mm->pgd, (unsigned long) page_address(page), 0);
asm-arm/proc-armo/cache.h:	if (mm == current->active_mm)
asm-arm/proc-armo/cache.h:		processor._set_pgd(mm->pgd);
asm-arm/proc-armo/cache.h:	cpu_memc_update_entry(mm->pgd, pte_val(pte), vaddr);
asm-arm/proc-armo/cache.h:	if (mm == current->active_mm)
asm-arm/proc-armo/cache.h:		processor._set_pgd(mm->pgd);
asm-arm/proc-armo/cache.h:	struct mm_struct *mm = vma->vm_mm;
asm-arm/proc-armv/domain.h: *  linux/include/asm-arm/proc-armv/domain.h
asm-arm/proc-armv/domain.h: *  DOMAIN_IO     - domain 2 includes all IO only
asm-arm/proc-armv/domain.h: *  DOMAIN_KERNEL - domain 1 includes all kernel memory only
asm-arm/proc-armv/domain.h: *  DOMAIN_USER   - domain 0 includes all user memory only
asm-arm/proc-armv/domain.h:	unsigned int domain = current->thread.domain;	\
asm-arm/proc-armv/domain.h:	current->thread.domain = domain;		\
asm-arm/proc-armv/domain.h:	set_domain(current->thread.domain);		\
asm-arm/proc-armv/assembler.h: *  linux/asm-arm/proc-armv/assembler.h
asm-arm/proc-armv/assembler.h: *  Copyright (C) 1996-2000 Russell King
asm-arm/proc-armv/assembler.h: * LOADREGS - ldm with PC in register list (eg, ldmfd sp!, {pc})
asm-arm/proc-armv/assembler.h: * These two are used to save LR/restore PC over a user-based access.
asm-arm/proc-armv/assembler.h: * The old 26-bit architecture requires that we do.  On 32-bit
asm-arm/proc-armv/ptrace.h: *  linux/include/asm-arm/proc-armv/ptrace.h
asm-arm/proc-armv/ptrace.h: *  Copyright (C) 1996-1999 Russell King
asm-arm/proc-armv/ptrace.h:	(((regs)->ARM_cpsr & 0xf) == 0)
asm-arm/proc-armv/ptrace.h:	(((regs)->ARM_cpsr & T_BIT))
asm-arm/proc-armv/ptrace.h:	((regs)->ARM_cpsr & MODE_MASK)
asm-arm/proc-armv/ptrace.h:	(!((regs)->ARM_cpsr & I_BIT))
asm-arm/proc-armv/ptrace.h:	(!((regs)->ARM_cpsr & F_BIT))
asm-arm/proc-armv/ptrace.h:	((regs)->ARM_cpsr & (CC_V_BIT|CC_C_BIT|CC_Z_BIT|CC_N_BIT))
asm-arm/proc-armv/ptrace.h:	if ((regs->ARM_cpsr & 0xf) == 0 &&
asm-arm/proc-armv/ptrace.h:	    (regs->ARM_cpsr & (F_BIT|I_BIT)) == 0)
asm-arm/proc-armv/ptrace.h:	regs->ARM_cpsr &= (CC_V_BIT|CC_C_BIT|CC_Z_BIT|CC_N_BIT|0x10);
asm-arm/proc-armv/pgalloc.h: *  linux/include/asm-arm/proc-armv/pgalloc.h
asm-arm/proc-armv/pgalloc.h: * Page table allocation/freeing primitives for 32-bit ARM processors.
asm-arm/proc-armv/pgalloc.h: * from the Linux copy.  The processor copies are offset by -PTRS_PER_PTE
asm-arm/proc-armv/pgalloc.h:		pte -= PTRS_PER_PTE;
asm-arm/proc-armv/elf.h: * ELF definitions for 32-bit CPUs
asm-arm/proc-armv/elf.h: * 32-bit code is always OK.  Some cpus can do 26-bit, some can't.
asm-arm/proc-armv/elf.h:	(( (elf_hwcap & HWCAP_THUMB) && ((x)->e_entry & 1) == 1)      || \
asm-arm/proc-armv/elf.h:	 (!(elf_hwcap & HWCAP_THUMB) && ((x)->e_entry & 3) == 0)      || \
asm-arm/proc-armv/elf.h:	 ( (elf_hwcap & HWCAP_26BIT) && (x)->e_flags & EF_ARM_APCS26) || \
asm-arm/proc-armv/elf.h:	 ((x)->e_flags & EF_ARM_APCS26) == 0)
asm-arm/proc-armv/shmparam.h: *  linux/include/asm-arm/proc-armv/shmparam.h
asm-arm/proc-armv/processor.h: *  linux/include/asm-arm/proc-armv/processor.h
asm-arm/proc-armv/processor.h: *  Copyright (C) 1996-1999 Russell King.
asm-arm/proc-armv/processor.h: *   20-09-1996	RMK	Created
asm-arm/proc-armv/processor.h: *   26-09-1996	RMK	Added 'EXTRA_THREAD_STRUCT*'
asm-arm/proc-armv/processor.h: *   28-09-1996	RMK	Moved start_thread into the processor dependencies
asm-arm/proc-armv/processor.h: *   09-09-1998	PJB	Delete redundant `wp_works_ok'
asm-arm/proc-armv/processor.h: *   30-05-1999	PJB	Save sl across context switches
asm-arm/proc-armv/processor.h: *   31-07-1999	RMK	Added 'domain' stuff
asm-arm/proc-armv/processor.h:	memzero(regs->uregs, sizeof(regs->uregs));			\
asm-arm/proc-armv/processor.h:	if (current->personality & ADDR_LIMIT_32BIT)			\
asm-arm/proc-armv/processor.h:		regs->ARM_cpsr = USR_MODE;				\
asm-arm/proc-armv/processor.h:		regs->ARM_cpsr = USR26_MODE;				\
asm-arm/proc-armv/processor.h:	regs->ARM_pc = pc;		/* pc */			\
asm-arm/proc-armv/processor.h:	regs->ARM_sp = sp;		/* sp */			\
asm-arm/proc-armv/processor.h:	regs->ARM_r2 = stack[2];	/* r2 (envp) */			\
asm-arm/proc-armv/processor.h:	regs->ARM_r1 = stack[1];	/* r1 (argv) */			\
asm-arm/proc-armv/processor.h:	regs->ARM_r0 = stack[0];	/* r0 (argc) */			\
asm-arm/proc-armv/locks.h: *  linux/include/asm-arm/proc-armv/locks.h
asm-arm/proc-armv/uaccess.h: *  linux/include/asm-arm/proc-armv/uaccess.h
asm-arm/proc-armv/uaccess.h:	current->addr_limit = fs;
asm-arm/proc-armv/uaccess.h:/* We use 33-bit arithmetic here... */
asm-arm/proc-armv/uaccess.h:		: "r" (addr), "Ir" (size), "0" (current->addr_limit) \
asm-arm/proc-armv/uaccess.h:		: "0" (current->addr_limit), "r" (addr) \
asm-arm/proc-armv/uaccess.h:	: "r" (x), "r" (addr), "i" (-EFAULT), "0" (err))
asm-arm/proc-armv/uaccess.h:	: "r" (x), "r" (addr), "i" (-EFAULT), "0" (err))
asm-arm/proc-armv/uaccess.h:	: "r" (addr), "i" (-EFAULT), "0" (err))
asm-arm/proc-armv/uaccess.h:	: "r" (addr), "i" (-EFAULT), "0" (err))
asm-arm/proc-armv/page.h: *  linux/include/asm-arm/proc-armv/page.h
asm-arm/proc-armv/system.h: *  linux/include/asm-arm/proc-armv/system.h
asm-arm/proc-armv/system.h:#define CR_P	(1 << 4)	/* 32-bit exception handler		*/
asm-arm/proc-armv/system.h:#define CR_D	(1 << 5)	/* 32-bit data address range		*/
asm-arm/proc-armv/system.h:extern unsigned long cr_no_alignment;	/* defined in entry-armv.S */
asm-arm/proc-armv/system.h:extern unsigned long cr_alignment;	/* defined in entry-armv.S */
asm-arm/proc-armv/system.h: * more disasterous effects.  There are two work-arounds:
asm-arm/proc-armv/pgtable.h: *  linux/include/asm-arm/proc-armv/pgtable.h
asm-arm/proc-armv/pgtable.h: *  Copyright (C) 1995-2001 Russell King
asm-arm/proc-armv/pgtable.h: *  12-Jan-1997	RMK	Altered flushing routines to use function pointers
asm-arm/proc-armv/pgtable.h: *  17-Apr-1999	RMK	Now pass an area size to clean_cache_area and
asm-arm/proc-armv/pgtable.h: * entries per page directory level: they are two-level, so
asm-arm/proc-armv/pgtable.h:	pte_ptr -= PTRS_PER_PTE * sizeof(void *);
asm-arm/proc-armv/pgtable.h:	ptr = pmd_val(pmd) & ~(PTRS_PER_PTE * sizeof(void *) - 1);
asm-arm/proc-armv/pgtable.h:/* We now keep two sets of ptes - the physical and the linux version.
asm-arm/proc-armv/pgtable.h: *   2    bufferable	- matches physical pte
asm-arm/proc-armv/pgtable.h: *   3    cacheable	- matches physical pte
asm-arm/proc-armv/pgtable.h: *  8-11  unused
asm-arm/proc-armv/pgtable.h: *  12-31 virtual page address
asm-arm/proc-armv/pgtable.h: * These are stored at the pte pointer; the physical PTE is at -1024bytes
asm-arm/proc-armv/cache.h: *  linux/include/asm-arm/proc-armv/cache.h
asm-arm/proc-armv/cache.h: *  Copyright (C) 1999-2001 Russell King
asm-arm/proc-armv/cache.h: * Cache handling for 32-bit ARM processors.
asm-arm/proc-armv/cache.h:/* This is always called for current->mm */
asm-arm/proc-armv/cache.h:		if ((_mm) == current->active_mm)			\
asm-arm/proc-armv/cache.h:		if ((_mm) == current->active_mm)			\
asm-arm/proc-armv/cache.h:		if ((_vma)->vm_mm == current->active_mm) {		\
asm-arm/proc-armv/cache.h:				((_vma)->vm_flags & VM_EXEC));		\
asm-arm/proc-armv/cache.h: *    [via do_no_page - ok]
asm-arm/proc-armv/cache.h: *    [zero page, never written by kernel - ok]
asm-arm/proc-armv/cache.h: *    [via do_no_page - ok]
asm-arm/proc-armv/cache.h: *     kernel virtual addresses from the dcache - ok]
asm-arm/proc-armv/cache.h: * cache page at virtual address page->virtual.
asm-arm/proc-armv/cache.h: * If this page isn't mapped (ie, page->mapping = NULL), or it has
asm-arm/proc-armv/cache.h: * userspace mappings (page->mapping->i_mmap or page->mapping->i_mmap_shared)
asm-arm/proc-armv/cache.h:#define mapping_mapped(map)	((map)->i_mmap || (map)->i_mmap_shared)
asm-arm/proc-armv/cache.h:	if (page->mapping && !mapping_mapped(page->mapping))
asm-arm/proc-armv/cache.h:		set_bit(PG_dcache_dirty, &page->flags);
asm-arm/proc-armv/cache.h: *  - flush_tlb_all()			flushes all processes TLBs
asm-arm/proc-armv/cache.h: *  - flush_tlb_mm(mm)			flushes the specified mm context TLB's
asm-arm/proc-armv/cache.h: *  - flush_tlb_page(vma, vmaddr)	flushes TLB for specified page
asm-arm/proc-armv/cache.h: *  - flush_tlb_range(mm, start, end)	flushes TLB for specified range of pages
asm-arm/proc-armv/cache.h: *  current->active_mm is the currently active memory description.
asm-arm/proc-armv/cache.h: *  current->mm == NULL iff we are lazy.
asm-arm/proc-armv/cache.h: * Currently, this is always called for current->mm, which should be
asm-arm/proc-armv/cache.h: * the same as current->active_mm.  This is currently not be called for
asm-arm/proc-armv/cache.h:		if ((_mm) == current->active_mm)			\
asm-arm/proc-armv/cache.h: * _mm may not be current->active_mm, but may not be NULL.
asm-arm/proc-armv/cache.h:		if ((_mm) == current->active_mm)			\
asm-arm/proc-armv/cache.h:		if ((_vma)->vm_mm == current->active_mm)		\
asm-arm/proc-armv/cache.h:				 ((_vma)->vm_flags & VM_EXEC));		\
asm-arm/proc-armv/cache.h: * we have on the older 26-bit machines.  We don't have a MEMC chip, so...
asm-arm/hdreg.h: *  linux/include/asm-arm/hdreg.h
asm-arm/hdreg.h: *  Copyright (C) 1994-1996  Linus Torvalds & authors
asm-arm/poll.h:/* The rest seem to be more-or-less nonstandard. Check them! */
asm-arm/arch-l7200/io.h: * linux/include/asm-arm/arch-l7200/io.h
asm-arm/arch-l7200/io.h: *  03-21-2000	SJH	Created from linux/include/asm-arm/arch-nexuspci/io.h
asm-arm/arch-l7200/io.h: *  08-31-2000	SJH	Added in IO functions necessary for new drivers
asm-arm/arch-l7200/io.h: * FIXME - These are to allow for linking. On all the other
asm-arm/arch-l7200/pmpcon.h: *  linux/include/asm-arm/arch-l7200/pmpcon.h
asm-arm/arch-l7200/pmpcon.h: *   Registers and  helper functions for the L7200 Link-Up Systems
asm-arm/arch-l7200/hardware.h: * linux/include/asm-arm/arch-l7200/hardware.h
asm-arm/arch-l7200/hardware.h: *   02-01-2000	 RS	Created L7200 version, derived from rpc code
asm-arm/arch-l7200/hardware.h: *   03-21-2000	SJH	Cleaned up file
asm-arm/arch-l7200/hardware.h: *   04-21-2000	 RS 	Changed mapping of I/O in virtual space
asm-arm/arch-l7200/hardware.h: *   04-25-2000	SJH	Removed unused symbols and such
asm-arm/arch-l7200/hardware.h: *   05-05-2000	SJH	Complete rewrite
asm-arm/arch-l7200/hardware.h: *   07-31-2000	SJH	Added undocumented debug auxillary port to
asm-arm/arch-l7200/uncompress.h: * linux/include/asm-arm/arch-l7200/uncompress.h
asm-arm/arch-l7200/uncompress.h: *  05-01-2000	SJH	Created
asm-arm/arch-l7200/uncompress.h: *  05-13-2000	SJH	Filled in function bodies
asm-arm/arch-l7200/uncompress.h: *  07-26-2000	SJH	Removed hard coded buad rate
asm-arm/arch-l7200/vmalloc.h: * linux/include/asm-arm/arch-l7200/vmalloc.h
asm-arm/arch-l7200/vmalloc.h: * any out-of-bounds memory accesses will hopefully be caught.
asm-arm/arch-l7200/vmalloc.h:#define VMALLOC_START	  (((unsigned long)high_memory + VMALLOC_OFFSET) & ~(VMALLOC_OFFSET-1))
asm-arm/arch-l7200/dma.h: * linux/include/asm-arm/arch-l7200/dma.h
asm-arm/arch-l7200/dma.h: *  08-29-2000	SJH	Created
asm-arm/arch-l7200/dma.h: * There should not be more than (0xd0000000 - 0xc0000000)
asm-arm/arch-l7200/ide.h: * linux/include/asm-arm/arch-l7200/ide.h
asm-arm/arch-l7200/ide.h: *  03-29-2000	SJH	Created file placeholder
asm-arm/arch-l7200/irq.h: * include/asm-arm/arch-l7200/irq.h
asm-arm/arch-l7200/irq.h: *   01-02-2000	RS	Created l7200 version, derived from ebsa110 code
asm-arm/arch-l7200/irq.h: *   04-15-2000 RS      Made dependent on hardware.h
asm-arm/arch-l7200/irq.h: *   05-05-2000 SJH     Complete rewrite
asm-arm/arch-l7200/aux_reg.h: * linux/include/asm-arm/arch-l7200/aux_reg.h
asm-arm/arch-l7200/aux_reg.h: *   08-02-2000	SJH	Created file
asm-arm/arch-l7200/pmu.h: *  linux/include/asm-arm/arch-l7200/pmu.h
asm-arm/arch-l7200/pmu.h: *   Registers and  helper functions for the L7200 Link-Up Systems
asm-arm/arch-l7200/pmu.h:#define GET_TRANSOP(reg)  ((reg >> 25) & 0x03) /* Bits 26-25 */
asm-arm/arch-l7200/pmu.h:#define GET_PLLMUL(reg)   ((reg >>  9) & 0x3f) /* Bits 14-9 */
asm-arm/arch-l7200/pmu.h:#define GET_BCLK_DIV(reg) ((reg >>  3) & 0x03) /* Bits 4-3 */
asm-arm/arch-l7200/pmu.h:#define CFG_NEXT_CLOCKRECOVERY ((PMU->NEXT >> 18) & 0x7f)   /* Bits 24-18 */
asm-arm/arch-l7200/pmu.h:#define CFG_NEXT_INTRET        ((PMU->NEXT >> 17) & 0x01)
asm-arm/arch-l7200/pmu.h:#define CFG_NEXT_SDR_STOP      ((PMU->NEXT >>  6) & 0x01)
asm-arm/arch-l7200/pmu.h:#define CFG_NEXT_SYSCLKEN      ((PMU->NEXT >>  5) & 0x01)
asm-arm/arch-l7200/pmu.h:#define SDRREFACK        1<<1  /* Read-only */
asm-arm/arch-l7200/pmu.h:#define SDRSTOPACK       1<<3  /* Read-only */
asm-arm/arch-l7200/pmu.h:#define PICEN            1<<4  /* Enable Co-procesor */
asm-arm/arch-l7200/pmu.h:#define GET_SDRREFFQ    ((PMU->SDRAM >> 0) & 0x01)
asm-arm/arch-l7200/pmu.h:#define GET_SDRREFACK   ((PMU->SDRAM >> 1) & 0x01) /* Read-only */
asm-arm/arch-l7200/pmu.h:#define GET_SDRSTOPRQ   ((PMU->SDRAM >> 2) & 0x01)
asm-arm/arch-l7200/pmu.h:#define GET_SDRSTOPACK  ((PMU->SDRAM >> 3) & 0x01) /* Read-only */
asm-arm/arch-l7200/pmu.h:#define GET_PICEN       ((PMU->SDRAM >> 4) & 0x01)
asm-arm/arch-l7200/pmu.h:#define GET_PICTEST     ((PMU->SDRAM >> 5) & 0x01)
asm-arm/arch-l7200/sib.h: *  linux/include/asm-arm/arch-l7200/sib.h
asm-arm/arch-l7200/sib.h:#define GET_ASD ((SIB->MCCR >>  0) & 0x3f) /* Audio Sample Rate Div. */
asm-arm/arch-l7200/sib.h:#define GET_TSD ((SIB->MCCR >>  8) & 0x3f) /* Telcom Sample Rate Div. */
asm-arm/arch-l7200/sib.h:#define GET_MCE ((SIB->MCCR >> 16) & 0x01) /* SIB Enable */
asm-arm/arch-l7200/sib.h:#define GET_ECS ((SIB->MCCR >> 17) & 0x01) /* External Clock Select */
asm-arm/arch-l7200/sib.h:#define GET_ADM ((SIB->MCCR >> 18) & 0x01) /* A/D Data Sampling Mode */
asm-arm/arch-l7200/sib.h:#define GET_TTM ((SIB->MCCR >> 19) & 0x01) /* Telco Trans. FIFO I mask */ 
asm-arm/arch-l7200/sib.h:#define GET_TRM ((SIB->MCCR >> 20) & 0x01) /* Telco Recv. FIFO I mask */
asm-arm/arch-l7200/sib.h:#define GET_ATM ((SIB->MCCR >> 21) & 0x01) /* Audio Trans. FIFO I mask */ 
asm-arm/arch-l7200/sib.h:#define GET_ARM ((SIB->MCCR >> 22) & 0x01) /* Audio Recv. FIFO I mask */
asm-arm/arch-l7200/sib.h:#define GET_LBM ((SIB->MCCR >> 23) & 0x01) /* Loop Back Mode */
asm-arm/arch-l7200/sib.h:#define GET_ECP ((SIB->MCCR >> 24) & 0x03) /* Extern. Clck Prescale sel */
asm-arm/arch-l7200/sib.h:#define GET_PMC ((SIB->MCCR >> 26) & 0x01) /* PIN Multiplexer Control */
asm-arm/arch-l7200/sib.h:#define GET_ERI ((SIB->MCCR >> 27) & 0x01) /* External Read Interrupt */
asm-arm/arch-l7200/sib.h:#define GET_EWI ((SIB->MCCR >> 28) & 0x01) /* External Write Interrupt */
asm-arm/arch-l7200/sib.h:#define AUDIO_RECV     ((SIB->MCDR0 >> 4) & 0xfff)
asm-arm/arch-l7200/sib.h:#define AUDIO_WRITE(v) ((SIB->MCDR0 = (v & 0xfff) << 4))
asm-arm/arch-l7200/sib.h:#define TELECOM_RECV     ((SIB->MCDR1 >> 2) & 032fff)
asm-arm/arch-l7200/sib.h:#define TELECOM_WRITE(v) ((SIB->MCDR1 = (v & 0x3fff) << 2))
asm-arm/arch-l7200/sib.h:#define GET_ATS ((SIB->MCSR >>  0) & 0x01) /* Audio Transmit FIFO Service Req*/
asm-arm/arch-l7200/sib.h:#define GET_ARS ((SIB->MCSR >>  1) & 0x01) /* Audio Recv FIFO Service Request*/
asm-arm/arch-l7200/sib.h:#define GET_TTS ((SIB->MCSR >>  2) & 0x01) /* TELECOM Transmit FIFO  Flag */
asm-arm/arch-l7200/sib.h:#define GET_TRS ((SIB->MCSR >>  3) & 0x01) /* TELECOM Recv FIFO Service Req. */
asm-arm/arch-l7200/sib.h:#define GET_ATU ((SIB->MCSR >>  4) & 0x01) /* Audio Transmit FIFO Underrun */
asm-arm/arch-l7200/sib.h:#define GET_ARO ((SIB->MCSR >>  5) & 0x01) /* Audio Receive  FIFO Underrun */
asm-arm/arch-l7200/sib.h:#define GET_TTU ((SIB->MCSR >>  6) & 0x01) /* TELECOM Transmit FIFO Underrun */
asm-arm/arch-l7200/sib.h:#define GET_TRO ((SIB->MCSR >>  7) & 0x01) /* TELECOM Receive  FIFO Underrun */
asm-arm/arch-l7200/sib.h:#define GET_ANF ((SIB->MCSR >>  8) & 0x01) /* Audio Transmit FIFO not full */
asm-arm/arch-l7200/sib.h:#define GET_ANE ((SIB->MCSR >>  9) & 0x01) /* Audio Receive FIFO not empty */
asm-arm/arch-l7200/sib.h:#define GET_TNF ((SIB->MCSR >> 10) & 0x01) /* Telecom Transmit FIFO not full */
asm-arm/arch-l7200/sib.h:#define GET_TNE ((SIB->MCSR >> 11) & 0x01) /* Telecom Receive FIFO not empty */
asm-arm/arch-l7200/sib.h:#define GET_CWC ((SIB->MCSR >> 12) & 0x01) /* Codec Write Complete */
asm-arm/arch-l7200/sib.h:#define GET_CRC ((SIB->MCSR >> 13) & 0x01) /* Codec Read Complete */
asm-arm/arch-l7200/sib.h:#define GET_ACE ((SIB->MCSR >> 14) & 0x01) /* Audio Codec Enabled */
asm-arm/arch-l7200/sib.h:#define GET_TCE ((SIB->MCSR >> 15) & 0x01) /* Telecom Codec Enabled */
asm-arm/arch-l7200/sib.h:#define WRITE_MCDR2(reg, data) (SIB->MCDR2 =((reg<<17)|MCDR2_rW|(data&0xffff)))
asm-arm/arch-l7200/sib.h:#define INITIATE_MCDR2_READ(reg) (SIB->MCDR2 = (reg << 17))
asm-arm/arch-l7200/sib.h:#define MCDR2_READ               (SIB->MCDR2 & 0xffff)
asm-arm/arch-l7200/serial_l7200.h: * linux/include/asm-arm/arch-l7200/serial_l7200.h
asm-arm/arch-l7200/serial_l7200.h: *  05-09-2000	SJH	Created
asm-arm/arch-l7200/timex.h: * linux/include/asm-arm/arch-l7200/timex.h
asm-arm/arch-l7200/timex.h: * 04-21-2000  RS Created file
asm-arm/arch-l7200/timex.h: * 05-03-2000 SJH Tick rate was wrong
asm-arm/arch-l7200/gpio.h: *      linux/include/asm-arm/arch-l7200/gpio.h
asm-arm/arch-l7200/gpio.h: *      Registers and  helper functions for the L7200 Link-Up Systems
asm-arm/arch-l7200/irqs.h: * include/asm-arm/arch-l7200/irqs.h
asm-arm/arch-l7200/irqs.h: *   01-02-2000 RS	Create l7200 version
asm-arm/arch-l7200/irqs.h: *   03-28-2000 SJH	Removed unused interrupt
asm-arm/arch-l7200/irqs.h: *   07-28-2000 SJH	Added pseudo-keyboard interrupt
asm-arm/arch-l7200/sys-clock.h: *  linux/include/asm-arm/arch-l7200/sys-clock.h
asm-arm/arch-l7200/sys-clock.h: *   Registers and  helper functions for the L7200 Link-Up Systems
asm-arm/arch-l7200/sys-clock.h:/* SYS_CLOCK -> ENABLE */
asm-arm/arch-l7200/sys-clock.h:/* SYS_CLOCK -> SELECT */
asm-arm/arch-l7200/system.h: * linux/include/asm-arm/arch-l7200/system.h
asm-arm/arch-l7200/system.h: *  03-21-2000  SJH	Created
asm-arm/arch-l7200/system.h: *  04-26-2000  SJH	Fixed functions
asm-arm/arch-l7200/system.h: *  05-03-2000  SJH	Removed usage of obsolete 'iomd.h'
asm-arm/arch-l7200/system.h: *  05-31-2000  SJH	Properly implemented 'arch_idle'
asm-arm/arch-l7200/time.h: * linux/include/asm-arm/arch-l7200/time.h
asm-arm/arch-l7200/time.h: *   01-02-2000	RS	Created l7200 version, derived from rpc code
asm-arm/arch-l7200/time.h: *   05-03-2000	SJH	Complete rewrite
asm-arm/arch-l7200/serial.h: * linux/include/asm-arm/arch-l7200/serial.h
asm-arm/arch-l7200/serial.h: *  03-20-2000  SJH     Created
asm-arm/arch-l7200/serial.h: *  03-26-2000  SJH     Added flags for serial ports
asm-arm/arch-l7200/serial.h: *  03-27-2000  SJH     Corrected BASE_BAUD value
asm-arm/arch-l7200/serial.h: *  04-14-2000  RS      Made register addr dependent on IO_BASE
asm-arm/arch-l7200/serial.h: *  05-03-2000  SJH     Complete rewrite
asm-arm/arch-l7200/serial.h: *  05-09-2000	SJH	Stripped out architecture specific serial stuff
asm-arm/arch-l7200/serial.h: *  07-28-2000	SJH	Moved base baud rate variable
asm-arm/arch-l7200/param.h: * linux/include/asm-arm/arch-l7200/param.h
asm-arm/arch-l7200/param.h: *   04-21-2000 RS      Created L7200 version
asm-arm/arch-l7200/param.h: *   04-25-2000 SJH     Cleaned up file
asm-arm/arch-l7200/param.h: *   05-03-2000 SJH     Change comments and rate
asm-arm/arch-l7200/param.h: * (see include/asm-arm/param.h)
asm-arm/arch-l7200/gp_timers.h: * linux/include/asm-arm/arch-l7200/gp_timers.h
asm-arm/arch-l7200/gp_timers.h: *   07-28-2000	SJH	Created file
asm-arm/arch-l7200/gp_timers.h: *   08-02-2000	SJH	Used structure for registers
asm-arm/arch-l7200/keyboard.h: *  linux/include/asm-arm/arch-l7200/keyboard.h
asm-arm/arch-l7200/keyboard.h: *   07-18-2000	SAM	Created file
asm-arm/arch-l7200/keyboard.h: *   07-28-2000	SJH	Complete rewrite
asm-arm/arch-l7200/keyboard.h:#error This needs fixing --rmk
asm-arm/arch-l7200/keyboard.h:#define kbd_setkeycode(sc,kc)		(-EINVAL)
asm-arm/arch-l7200/keyboard.h:#define kbd_getkeycode(sc)		(-EINVAL)
asm-arm/arch-l7200/memory.h: * linux/include/asm-arm/arch-l7200/memory.h
asm-arm/arch-l7200/memory.h: *  03-13-2000	SJH	Created
asm-arm/arch-l7200/memory.h: *  04-13-2000  RS      Changed bus macros for new addr
asm-arm/arch-l7200/memory.h: *  05-03-2000  SJH     Removed bus macros and fixed virt_to_phys macro
asm-arm/arch-l7200/memory.h:#define __virt_to_phys(vpage) ((vpage) - PAGE_OFFSET + PHYS_OFFSET)
asm-arm/arch-l7200/memory.h:#define __phys_to_virt(ppage) ((ppage) + PAGE_OFFSET - PHYS_OFFSET)
asm-arm/types.h:/* Dma addresses are 32-bits wide.  */
asm-arm/sembuf.h: * - 64-bit time_t to solve y2038 problem
asm-arm/sembuf.h: * - 2 miscellaneous 32-bit values
asm-arm/arch-omaha/io.h: *  linux/include/asm-arm/arch-omaha/io.h
asm-arm/arch-omaha/io.h: *  Copyright (C) 1999-2002 ARM Limited
asm-arm/arch-omaha/io.h: * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
asm-arm/arch-omaha/hardware.h: *  linux/include/asm-arm/arch-omaha/hardware.h
asm-arm/arch-omaha/hardware.h: *  Copyright (C) 1999-2002 ARM Limited.
asm-arm/arch-omaha/hardware.h: * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
asm-arm/arch-omaha/uncompress.h: *  linux/include/asm-arm/arch-omaha/uncompress.h
asm-arm/arch-omaha/uncompress.h: *  Copyright (C) 1999-2002 ARM Limited
asm-arm/arch-omaha/uncompress.h: * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
asm-arm/arch-omaha/vmalloc.h: *  linux/include/asm-arm/arch-omaha/vmalloc.h
asm-arm/arch-omaha/vmalloc.h: * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
asm-arm/arch-omaha/vmalloc.h: * any out-of-bounds memory accesses will hopefully be caught.
asm-arm/arch-omaha/vmalloc.h:#define VMALLOC_START	  (((unsigned long)high_memory + VMALLOC_OFFSET) & ~(VMALLOC_OFFSET-1))
asm-arm/arch-omaha/dma.h: *  linux/include/asm-arm/arch-omaha/dma.h
asm-arm/arch-omaha/dma.h: * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
asm-arm/arch-omaha/ide.h: * linux/include/asm-arm/arch-omaha/ide.h
asm-arm/arch-omaha/ide.h: *  03-29-2000	SJH	Created file placeholder
asm-arm/arch-omaha/ide.h:		hw->io_ports[i] = reg;
asm-arm/arch-omaha/ide.h:		 * we need to be able to do 16-bit r/w.
asm-arm/arch-omaha/ide.h:			hw->io_ports[i] = reg + 0x04000000;
asm-arm/arch-omaha/ide.h:	hw->io_ports[IDE_CONTROL_OFFSET] = (ide_ioreg_t) ctrl_port;
asm-arm/arch-omaha/irq.h: *  linux/include/asm-arm/arch-omaha/irq.h
asm-arm/arch-omaha/irq.h: *  Copyright (C) 1999-2002 ARM Limited
asm-arm/arch-omaha/irq.h: * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
asm-arm/arch-omaha/platform.h:/* DO NOT EDIT!! - this file automatically generated
asm-arm/arch-omaha/platform.h: *                 from .s file by awk -f s2h.awk
asm-arm/arch-omaha/platform.h: *    Copyright ARM Limited 1998 - 2001.  All rights reserved.
asm-arm/arch-omaha/platform.h: * 	NOTE: This is a multi-hosted header file for use with uHAL and
asm-arm/arch-omaha/platform.h: * 	different (physical vs virtual) memory maps - just change the
asm-arm/arch-omaha/platform.h: *  definitions. These can be over-ridden by the makefile/ARM project file
asm-arm/arch-omaha/platform.h:/* -----------------------------------------------------------------------
asm-arm/arch-omaha/platform.h: *  1-1 physical to virtual. 
asm-arm/arch-omaha/platform.h: * -----------------------------------------------------------------------
asm-arm/arch-omaha/platform.h: * -----------------------------------------------------------------------
asm-arm/arch-omaha/platform.h: *  3		FPGA / sub-chip-selects
asm-arm/arch-omaha/platform.h: *  Two banks of 32-bit SDRAM, each 32Mbytes in size.
asm-arm/arch-omaha/platform.h:#define PLAT_USER_SDRAM_SIZE            PLAT_SDRAM_SIZE - SZ_1M
asm-arm/arch-omaha/platform.h: *  One bank of 8-bit Flash on nGCS0 (SST39VF040-90-4C-NH)
asm-arm/arch-omaha/platform.h: *  However, we need 8-bit access to the Command
asm-arm/arch-omaha/platform.h: *  Registers, and 16-bit access to the Data-Register.
asm-arm/arch-omaha/platform.h: *  0x01C00000 - 0x01C00007 	- Command Registers (8-bit r/w)
asm-arm/arch-omaha/platform.h: *  0x01E00006 - 0x01E00006	- Control Register (8-bit r/w)
asm-arm/arch-omaha/platform.h: *  0x05C00000 - 0x05C00001	- Data Register (16-bit r/w)
asm-arm/arch-omaha/platform.h:/*  CF 16-bit access in nCS2
asm-arm/arch-omaha/platform.h:/*  CF 8-bit access in nCS0
asm-arm/arch-omaha/platform.h: *  from a uHAL program into an OS using high-vectors,
asm-arm/arch-omaha/platform.h:/*  Remaining chip-select regions
asm-arm/arch-omaha/platform.h: *  Leave these un-mapped for the moment
asm-arm/arch-omaha/platform.h:/*  ----------------------------------------------------------------------
asm-arm/arch-omaha/platform.h: * -----------------------------------------------------------------------
asm-arm/arch-omaha/platform.h:#define OMAHA_PBUP                      0x1600010	 /*  Port B pull-up control */
asm-arm/arch-omaha/platform.h:#define OMAHA_PCUP                      0x160001C	 /*  Port C pull-up */
asm-arm/arch-omaha/platform.h:#define OMAHA_PDUP                      0x1600028	 /*  Port D pull-up */
asm-arm/arch-omaha/platform.h:#define OMAHA_PEUP                      0x1600034	 /*  Port E pull-up */
asm-arm/arch-omaha/platform.h:#define OMAHA_PFUP                      0x1600040	 /*  Port F pull-up */
asm-arm/arch-omaha/platform.h:#define OMAHA_PGUP                      0x160004C	 /*  Port G pull-up */
asm-arm/arch-omaha/platform.h:/*  nGCS0: 8-bit r/o, no-wait. boot flash
asm-arm/arch-omaha/platform.h: *  nGCS1: 32-bit, r/w, no-wait. PLD (inc. ethernet)
asm-arm/arch-omaha/platform.h: *  nGCS2: 16-bit, r/w, wait. CompactFlash+USB2
asm-arm/arch-omaha/platform.h: *  nGCS3: 32-bit, r/w, no-wait. FPGA
asm-arm/arch-omaha/platform.h: *  nGCS4: 32-bit, r/w, no-wait. Expansion Bus
asm-arm/arch-omaha/platform.h: *  nGCS5: 32-bit, r/w, no-wait. Expansion Bus
asm-arm/arch-omaha/platform.h: *  nGCS6: 32-bit, r/w, no-wait. SDRAM bank 0
asm-arm/arch-omaha/platform.h: *  nGCS7: 32-bit, r/w, no-wait. SDRAM bank 1
asm-arm/arch-omaha/platform.h:#define OMAHA_BWSCON_DEF                0x222221A0	 /*  All 32-bit, r/w, no-wait */
asm-arm/arch-omaha/platform.h: *  CS0	- Flash bank 0
asm-arm/arch-omaha/platform.h: *  CS1	- PLD
asm-arm/arch-omaha/platform.h: *  CS2	- FPGA
asm-arm/arch-omaha/platform.h: *  CS3	- FPGA
asm-arm/arch-omaha/platform.h: *  CS4	- PCMCIA0 (Unused)
asm-arm/arch-omaha/platform.h: *  CS5	- PCMCIA1 (Unused)
asm-arm/arch-omaha/platform.h:#define OMAHA_BANKCON6_DEF              0x00018001	 /*  9-bit, 2clks */
asm-arm/arch-omaha/platform.h:#define OMAHA_BANKCON7_DEF              0x00018001	 /*  9-bit, 2clks */
asm-arm/arch-omaha/platform.h:/* -----------------------------------------------------------------------
asm-arm/arch-omaha/platform.h: * -----------------------------------------------------------------------
asm-arm/arch-omaha/platform.h: *  FCLK - CPU clock
asm-arm/arch-omaha/platform.h: *  HCLK - AHB clock
asm-arm/arch-omaha/platform.h: *  PCLK - APB clock
asm-arm/arch-omaha/platform.h:/* -----------------------------------------------------------------------
asm-arm/arch-omaha/platform.h: *  From PrimeCell UART (PL010) Block Specification (ARM-DDI-0139B)
asm-arm/arch-omaha/platform.h: * -----------------------------------------------------------------------
asm-arm/arch-omaha/platform.h:/* -----------------------------------------------------------------------
asm-arm/arch-omaha/platform.h: * -----------------------------------------------------------------------
asm-arm/arch-omaha/platform.h:/* -----------------------------------------------------------------------
asm-arm/arch-omaha/platform.h: * -----------------------------------------------------------------------
asm-arm/arch-omaha/platform.h:#define PLD_FPGA_ID                     0x00	 /*  8-bit FPGA ID number (ro) */
asm-arm/arch-omaha/platform.h:#define PLD_TEST                        0x18	 /*  8-bit test register (rw) */
asm-arm/arch-omaha/platform.h:/*  INT_CTRL bit-defs
asm-arm/arch-omaha/platform.h:/*  INT_STATUS bit-defs
asm-arm/arch-omaha/platform.h:#define PLD_INT_STATUS_CF_IDE           BIT0	 /*  CF True-IDE mode (r/w) */
asm-arm/arch-omaha/platform.h:/*  WAIT_STATUS bit-defs
asm-arm/arch-omaha/platform.h:#define PLD_BUS_ADDR                    0x0F	 /*  4-bit expansion bus address */
asm-arm/arch-omaha/platform.h:/*  TEST		; 8-bit r/w any value.
asm-arm/arch-omaha/platform.h:/* -----------------------------------------------------------------------
asm-arm/arch-omaha/platform.h: *  LEDs - One available
asm-arm/arch-omaha/platform.h: * -----------------------------------------------------------------------
asm-arm/arch-omaha/platform.h:/* -----------------------------------------------------------------------
asm-arm/arch-omaha/platform.h: *  Memory definitions - run uHAL out of SDRAM.  Reserve top 64K for MMU.
asm-arm/arch-omaha/platform.h:#define FLASH_END                       (FLASH_BASE + FLASH_SIZE - 1)
asm-arm/arch-omaha/platform.h:#define EPROM_END                       (EPROM_BASE + EPROM_SIZE - 1)
asm-arm/arch-omaha/platform.h:/*  Clean base - an area of memory (usually fast access) which can be read
asm-arm/arch-omaha/platform.h:/* -----------------------------------------------------------------------
asm-arm/arch-omaha/platform.h:/* -----------------------------------------------------------------------
asm-arm/arch-omaha/platform.h: *  There are 5 16-bit countdown timers on-chip.
asm-arm/arch-omaha/platform.h:/* -----------------------------------------------------------------------
asm-arm/arch-omaha/platform.h: *  Each entry contains 256 32-bit descriptors
asm-arm/arch-omaha/platform.h:#define uHAL_HEAP_SIZE                  (SZ_16M - SZ_1M - SZ_1M - 4)
asm-arm/arch-omaha/platform.h:#define uHAL_HEAP_BASE                  (PLAT_SDRAM_BASE + PLAT_SDRAM_SIZE - SZ_64K)
asm-arm/arch-omaha/bits.h: * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
asm-arm/arch-omaha/bits.h:/* DO NOT EDIT!! - this file automatically generated
asm-arm/arch-omaha/bits.h: *                 from .s file by awk -f s2h.awk
asm-arm/arch-omaha/timex.h: *  linux/include/asm-arm/arch-omaha/timex.h
asm-arm/arch-omaha/timex.h: *  Copyright (C) 1999-2002 ARM Limited
asm-arm/arch-omaha/timex.h: * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
asm-arm/arch-omaha/irqs.h: *  linux/include/asm-arm/arch-omaha/irqs.h
asm-arm/arch-omaha/irqs.h: *  Copyright (C) 1999-2002 ARM Limited
asm-arm/arch-omaha/irqs.h: * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
asm-arm/arch-omaha/system.h: *  linux/include/asm-arm/arch-omaha/system.h
asm-arm/arch-omaha/system.h: *  Copyright (C) 1999-2002 ARM Limited
asm-arm/arch-omaha/system.h: * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
asm-arm/arch-omaha/time.h: *  linux/include/asm-arm/arch-omaha/time.h
asm-arm/arch-omaha/time.h: * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
asm-arm/arch-omaha/time.h:	// Its only 16-bits
asm-arm/arch-omaha/time.h:	ticks1 = TIMER_INTERVAL - ticks2;
asm-arm/arch-omaha/serial.h: *  linux/include/asm-arm/arch-omaha/serial.h
asm-arm/arch-omaha/serial.h: *  Copyright (C) 1999-2002 ARM Limited
asm-arm/arch-omaha/serial.h: * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
asm-arm/arch-omaha/param.h: *  linux/include/asm-arm/arch-omaha/param.h
asm-arm/arch-omaha/param.h: *  Copyright (C) 1999-2002 ARM Limited
asm-arm/arch-omaha/param.h: * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
asm-arm/arch-omaha/memory.h: *  linux/include/asm-arm/arch-omaha/mmu.h
asm-arm/arch-omaha/memory.h: *  Copyright (C) 1999-2002 ARM Limited
asm-arm/arch-omaha/memory.h: * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
asm-arm/arch-omaha/memory.h:#define __virt_to_phys(vpage) ((vpage) - PAGE_OFFSET + PHYS_OFFSET)
asm-arm/arch-omaha/memory.h:#define __phys_to_virt(ppage) ((ppage) + PAGE_OFFSET - PHYS_OFFSET)
asm-arm/arch-omaha/memory.h: * Virtual view <-> DMA view memory address translations
asm-arm/arch-omaha/memory.h:#define __virt_to_bus(x)	(x - PAGE_OFFSET + PLAT_SDRAM_PHYS0)
asm-arm/arch-omaha/memory.h:#define __bus_to_virt(x)	(x - PLAT_SDRAM_PHYS0 + PAGE_OFFSET)
asm-arm/arch-shark/io.h: * linux/include/asm-arm/arch-shark/io.h
asm-arm/arch-shark/io.h: * linux/include/asm-arm/arch-ebsa110/io.h
asm-arm/arch-shark/io.h: * We use two different types of addressing - PC style addresses, and ARM
asm-arm/arch-shark/io.h: * Dynamic IO functions - let the compiler
asm-arm/arch-shark/io.h:	: "r" (value), "r" (port), "Ir" (PCIO_BASE - IO_BASE), "Ir" (IO_BASE)	\
asm-arm/arch-shark/io.h:	: "r" (port), "Ir" (PCIO_BASE - IO_BASE), "Ir" (IO_BASE)		\
asm-arm/arch-shark/io.h: * These have to be macros for the 'J' constraint to work -
asm-arm/arch-shark/io.h: * +/-4096 immediate operand.
asm-arm/arch-shark/hardware.h: * linux/include/asm-arm/arch-shark/hardware.h
asm-arm/arch-shark/hardware.h: * linux/include/asm-arm/arch-ebsa110/hardware.h
asm-arm/arch-shark/hardware.h: * Copyright (C) 1996-1999 Russell King.
asm-arm/arch-shark/uncompress.h: * linux/include/asm-arm/arch-shark/uncompress.h
asm-arm/arch-shark/uncompress.h: * linux/include/asm-arm/arch-ebsa285/uncompress.h
asm-arm/arch-shark/uncompress.h:	while (t--);
asm-arm/arch-shark/uncompress.h:		x='0'+((z>>((7-i)*4))&0xf);
asm-arm/arch-shark/uncompress.h:		if (x>'9') x=x-'0'+'A'-10;
asm-arm/arch-shark/vmalloc.h: * linux/include/asm-arm/arch-rpc/vmalloc.h
asm-arm/arch-shark/vmalloc.h: * any out-of-bounds memory accesses will hopefully be caught.
asm-arm/arch-shark/vmalloc.h:#define VMALLOC_START	  (((unsigned long)high_memory + VMALLOC_OFFSET) & ~(VMALLOC_OFFSET-1))
asm-arm/arch-shark/dma.h: * linux/include/asm-arm/arch-shark/dma.h
asm-arm/arch-shark/dma.h:  zone_size[1] = zone_size[0] - 1024;
asm-arm/arch-shark/ide.h: * linux/include/asm-arm/arch-shark/ide.h
asm-arm/arch-shark/ide.h: * linux/include/asm-arm/arch-ebsa285/ide.h
asm-arm/arch-shark/ide.h:		hw->io_ports[i] = reg;
asm-arm/arch-shark/ide.h:	hw->io_ports[IDE_CONTROL_OFFSET] = (ide_ioreg_t) ctrl_port;
asm-arm/arch-shark/irq.h: * linux/include/asm-arm/arch-shark/irq.h
asm-arm/arch-shark/irq.h: * include/asm-arm/arch-ebsa110/irq.h
asm-arm/arch-shark/irq.h: * Copyright (C) 1996-1998 Russell King
asm-arm/arch-shark/irq.h: * Let through the cascade-interrupt no. 2 (ff-(1<<2)==fb)
asm-arm/arch-shark/irq.h:	  mask = 1 << (irq-8);
asm-arm/arch-shark/irq.h:	  mask = ~(1 << (irq-8));
asm-arm/arch-shark/irq.h:                cached_irq_mask[1] |= 1 << (irq-8);
asm-arm/arch-shark/timex.h: * linux/include/asm-arm/arch-shark/timex.h
asm-arm/arch-shark/irqs.h: * linux/include/asm-arm/arch-shark/irqs.h
asm-arm/arch-shark/system.h: * linux/include/asm-arm/arch-shark/system.h
asm-arm/arch-shark/time.h: * linux/include/asm-arm/arch-shark/time.h
asm-arm/arch-shark/time.h: * linux/include/asm-arm/arch-ebsa110/time.h
asm-arm/arch-shark/time.h:		if (divisor-- == 0) {
asm-arm/arch-shark/time.h:			divisor = DIVISOR - 1;
asm-arm/arch-shark/time.h:	val |= (16 - tmp);
asm-arm/arch-shark/serial.h: * linux/include/asm-arm/arch-ebsa110/serial.h
asm-arm/arch-shark/serial.h: *  15-10-1996	RMK	Created
asm-arm/arch-shark/param.h: * linux/include/asm-arm/arch-shark/param.h
asm-arm/arch-shark/keyboard.h: * linux/include/asm-arm/arch-shark/keyboard.h
asm-arm/arch-shark/keyboard.h: * Derived from linux/include/asm-arm/arch-ebsa285/keyboard.h
asm-arm/arch-shark/memory.h: * linux/include/asm-arm/arch-shark/memory.h
asm-arm/arch-shark/memory.h: * linux/include/asm-arm/arch-ebsa110/memory.h
asm-arm/arch-shark/memory.h: * Copyright (c) 1996-1999 Russell King.
asm-arm/arch-shark/memory.h:#define __virt_to_phys(vpage) (vpage - PAGE_OFFSET + PHYS_OFFSET)
asm-arm/arch-shark/memory.h:#define __phys_to_virt(ppage) (ppage - PHYS_OFFSET + PAGE_OFFSET)
asm-arm/system.h:#include <asm/proc-fns.h>
asm-arm/stat.h:	unsigned long	st_blocks;	/* Number 512-byte blocks allocated. */
asm-arm/checksum.h: *  linux/include/asm-arm/checksum.h
asm-arm/checksum.h: * Copyright (C) Original authors of ../asm-i386/checksum.h
asm-arm/checksum.h: * Copyright (C) 1996-1999 Russell King
asm-arm/checksum.h: * and adds in "sum" (32-bit)
asm-arm/checksum.h: * returns a 32-bit number suitable for feeding into itself
asm-arm/checksum.h: * it's best to have buff aligned on a 32-bit boundary
asm-arm/checksum.h: * checksums, and handles user-space pointer exceptions correctly, when needed.
asm-arm/checksum.h: * here even more important to align src and dst on a 32-bit (or even
asm-arm/checksum.h: * better 64-bit) boundary
asm-arm/checksum.h: * computes the checksum of the TCP/UDP pseudo-header
asm-arm/checksum.h: * returns a 16-bit checksum, already complemented
asm-arm/checksum.h: * this routine is used for miscellaneous IP-like checksums, mainly
asm-arm/termios.h:#define N_IRDA		11	/* Linux IrDa - http://irda.sourceforge.net/ */
asm-arm/termios.h:#define N_SMSBLOCK	12	/* SMS block mode - for talking to GSM data cards about SMS messages */
asm-arm/termios.h:	get_user(__tmp,&(termio)->x);				\
asm-arm/termios.h:	*(unsigned short *) &(termios)->x = __tmp;		\
asm-arm/termios.h:	copy_from_user((termios)->c_cc, (termio)->c_cc, NCC); \
asm-arm/termios.h:	put_user((termios)->c_iflag, &(termio)->c_iflag); \
asm-arm/termios.h:	put_user((termios)->c_oflag, &(termio)->c_oflag); \
asm-arm/termios.h:	put_user((termios)->c_cflag, &(termio)->c_cflag); \
asm-arm/termios.h:	put_user((termios)->c_lflag, &(termio)->c_lflag); \
asm-arm/termios.h:	put_user((termios)->c_line,  &(termio)->c_line); \
asm-arm/termios.h:	copy_to_user((termio)->c_cc, (termios)->c_cc, NCC); \
asm-arm/user.h:   linux we use the 'trad-core' bfd).  There are quite a number of
asm-arm/user.h:   DATA: The data area is stored.  We use current->end_text to
asm-arm/user.h:   current->brk to pick up all of the user variables, plus any memory
asm-arm/user.h:   is demand-zero or if a page is totally unused, we just cover the entire
asm-arm/user.h:   current->start_stack, so we round each of these off in order to be able
asm-arm/user.h:/* When the kernel dumps core, it starts by dumping the user struct -
asm-arm/user.h:  int u_fpvalid;		/* True if math co-processor being used. */
asm-arm/sl811-hw.h:File: include/asm-arm/sl811-hw.h
asm-arm/sl811-hw.h:Splitt hardware depens into file sl811-x86.h and sl811-arm.h.
asm-arm/sl811-hw.h:Move Hardware depend header sl811-arm.h into include/asm-arm/sl811-hw.h.
asm-arm/sl811-hw.h:Low level only for port io into hardware-include.
asm-arm/sl811-hw.h:	data = readb(hc->data_io);
asm-arm/sl811-hw.h:	writeb(index, hc->addr_io);
asm-arm/sl811-hw.h:	writeb(data, hc->data_io);
asm-arm/sl811-hw.h:	writeb(index, hc->addr_io);
asm-arm/sl811-hw.h:	writeb(data, hc->data_io);
asm-arm/sl811-hw.h:	if (hc->addr_io)
asm-arm/sl811-hw.h:		release_region(hc->addr_io, SIZEOF_IO_REGION);
asm-arm/sl811-hw.h:	hc->addr_io = 0;
asm-arm/sl811-hw.h:	if (hc->data_io)
asm-arm/sl811-hw.h:		release_region(hc->data_io, SIZEOF_IO_REGION);
asm-arm/sl811-hw.h:	hc->data_io = 0;
asm-arm/sl811-hw.h:		return -EBUSY;
asm-arm/sl811-hw.h:	hc->addr_io =	addr_io;
asm-arm/sl811-hw.h:		/* release_region(hc->addr_io, SIZEOF_IO_REGION); */
asm-arm/sl811-hw.h:		return -EBUSY;
asm-arm/sl811-hw.h:	hc->data_io =	data_io;
asm-arm/procinfo.h: *  linux/include/asm-arm/procinfo.h
asm-arm/procinfo.h: *  Copyright (C) 1996-2002 Russell King
asm-arm/procinfo.h:#include <asm/proc-fns.h>
asm-arm/procinfo.h: *  arch/arm/mm/proc-*.S and arch/arm/kernel/head-armv.S
asm-arm/procinfo.h:	unsigned long		__cpu_mmu_flags;	/* used by head-armv.S */
asm-arm/procinfo.h:	unsigned long		__cpu_flush;		/* used by head-armv.S */
asm-arm/serial.h: *  linux/include/asm-arm/serial.h
asm-arm/serial.h: *   15-10-1996	RMK	Created
asm-arm/pgtable.h: *  linux/include/asm-arm/pgtable.h
asm-arm/pgtable.h: *  Copyright (C) 2000-2002 Russell King
asm-arm/pgtable.h:#include <asm/proc-fns.h>
asm-arm/pgtable.h: * PMD_SHIFT determines the size of the area a second-level page table can map
asm-arm/pgtable.h: * PGDIR_SHIFT determines what a third-level page table entry can map
asm-arm/pgtable.h:#define PMD_MASK		(~(PMD_SIZE-1))
asm-arm/pgtable.h:#define PGDIR_MASK		(~(PGDIR_SIZE-1))
asm-arm/pgtable.h:#define USER_PTRS_PER_PGD	((TASK_SIZE/PGDIR_SIZE) - FIRST_USER_PGD_NR)
asm-arm/pgtable.h: * for zero-mapped memory areas etc..
asm-arm/pgtable.h:#define pages_to_mb(x)		((x) >> (20 - PAGE_SHIFT))
asm-arm/pgtable.h: * The "pgd_xxx()" functions here are trivial for a folded two-level
asm-arm/pgtable.h:/* to find an entry in a page-table-directory */
asm-arm/pgtable.h:#define pgd_offset(mm, addr)	((mm)->pgd+pgd_index(addr))
asm-arm/pgtable.h:/* to find an entry in a kernel page-table-directory */
asm-arm/pgtable.h:/* Find an entry in the second-level page table.. */
asm-arm/pgtable.h:/* Find an entry in the third-level page table.. */
asm-arm/pgtable.h:#define __pte_offset(addr)	(((addr) >> PAGE_SHIFT) & (PTRS_PER_PTE - 1))
asm-arm/pgtable.h:#include <asm-generic/pgtable.h>
asm-arm/unaligned.h:	 * case - go for the extra register.
asm-arm/param.h: *  linux/include/asm-arm/param.h
asm-arm/param.h: *  Copyright (C) 1995-1999 Russell King
asm-arm/param.h:#define NOGROUP         (-1)
asm-arm/arch-ebsa110/io.h: *  linux/include/asm-arm/arch-ebsa110/io.h
asm-arm/arch-ebsa110/io.h: *  06-Dec-1997	RMK	Created.
asm-arm/arch-ebsa110/hardware.h: *  linux/include/asm-arm/arch-ebsa110/hardware.h
asm-arm/arch-ebsa110/hardware.h: *  Copyright (C) 1996-2000 Russell King.
asm-arm/arch-ebsa110/hardware.h: * This file contains the hardware definitions of the EBSA-110.
asm-arm/arch-ebsa110/hardware.h: * --------------------------------------------------------
asm-arm/arch-ebsa110/hardware.h: * f0000fe0 - f0000ffc	3f8 - 3ff  ttyS0
asm-arm/arch-ebsa110/hardware.h: * f0000e60 - f0000e64	398 - 399
asm-arm/arch-ebsa110/hardware.h: * f0000de0 - f0000dfc	378 - 37f  lp0
asm-arm/arch-ebsa110/hardware.h: * f0000be0 - f0000bfc	2f8 - 2ff  ttyS1
asm-arm/arch-ebsa110/hardware.h: * --------------------------------------------------------
asm-arm/arch-ebsa110/hardware.h: * f00007c0 - f00007c1	3e0 - 3e1  pcmcia
asm-arm/arch-ebsa110/hardware.h: * f0000440 - f000046c  220 - 236  eth0
asm-arm/arch-ebsa110/uncompress.h: *  linux/include/asm-arm/arch-ebsa110/uncompress.h
asm-arm/arch-ebsa110/vmalloc.h: *  linux/include/asm-arm/arch-ebsa110/vmalloc.h
asm-arm/arch-ebsa110/vmalloc.h: * any out-of-bounds memory accesses will hopefully be caught.
asm-arm/arch-ebsa110/vmalloc.h:#define VMALLOC_START	  (((unsigned long)high_memory + VMALLOC_OFFSET) & ~(VMALLOC_OFFSET-1))
asm-arm/arch-ebsa110/dma.h: *  linux/include/asm-arm/arch-ebsa110/dma.h
asm-arm/arch-ebsa110/irq.h: *  linux/include/asm-arm/arch-ebsa110/irq.h
asm-arm/arch-ebsa110/irq.h: *  Copyright (C) 1996-1998 Russell King
asm-arm/arch-ebsa110/irq.h: *   22-08-1998	RMK	Restructured IRQ routines
asm-arm/arch-ebsa110/timex.h: *  linux/include/asm-arm/arch-ebsa110/timex.h
asm-arm/arch-ebsa110/irqs.h: *  linux/include/asm-arm/arch-ebsa110/irqs.h
asm-arm/arch-ebsa110/system.h: *  linux/include/asm-arm/arch-ebsa110/system.h
asm-arm/arch-ebsa110/system.h: *  Copyright (C) 1996-2000 Russell King.
asm-arm/arch-ebsa110/time.h: *  linux/include/asm-arm/arch-ebsa110/time.h
asm-arm/arch-ebsa110/time.h: *  10-Oct-1996	RMK	Created
asm-arm/arch-ebsa110/time.h: *  04-Dec-1997	RMK	Updated for new arch/arm/kernel/time.c
asm-arm/arch-ebsa110/time.h: *  07-Aug-1998	RMK	Updated for arch/arm/kernel/leds.c
asm-arm/arch-ebsa110/time.h: *  28-Dec-1998	APH	Made leds code optional
asm-arm/arch-ebsa110/serial.h: *  linux/include/asm-arm/arch-ebsa110/serial.h
asm-arm/arch-ebsa110/serial.h: *   15-10-1996	RMK	Created
asm-arm/arch-ebsa110/param.h: * linux/include/asm-arm/arch-ebsa110/param.h
asm-arm/arch-ebsa110/memory.h: *  linux/include/asm-arm/arch-ebsa110/memory.h
asm-arm/arch-ebsa110/memory.h: *  Copyright (C) 1996-1999 Russell King.
asm-arm/arch-ebsa110/memory.h: *   20-Oct-1996 RMK	Created
asm-arm/arch-ebsa110/memory.h: *   31-Dec-1997 RMK	Fixed definitions to reduce warnings
asm-arm/arch-ebsa110/memory.h: *   21-Mar-1999 RMK	Renamed to memory.h
asm-arm/arch-ebsa110/memory.h:#define __virt_to_phys(vpage)	((vpage) - PAGE_OFFSET)
asm-arm/arch-ebsa285/io.h: *  linux/include/asm-arm/arch-ebsa285/io.h
asm-arm/arch-ebsa285/io.h: *  Copyright (C) 1997-1999 Russell King
asm-arm/arch-ebsa285/io.h: *   06-12-1997	RMK	Created.
asm-arm/arch-ebsa285/io.h: *   07-04-1999	RMK	Major cleanup
asm-arm/arch-ebsa285/hardware.h: *  linux/include/asm-arm/arch-ebsa285/hardware.h
asm-arm/arch-ebsa285/hardware.h: *  Copyright (C) 1998-1999 Russell King.
asm-arm/arch-ebsa285/hardware.h: *  This file contains the hardware definitions of the EBSA-285.
asm-arm/arch-ebsa285/hardware.h: * 0xff800000	0x40000000	1MB	X-Bus
asm-arm/arch-ebsa285/hardware.h: * This is the COEBSA285 cut-down mapping
asm-arm/arch-ebsa285/uncompress.h: *  linux/include/asm-arm/arch-ebsa285/uncompress.h
asm-arm/arch-ebsa285/uncompress.h: *  Copyright (C) 1996-1999 Russell King
asm-arm/arch-ebsa285/uncompress.h:#include <asm/mach-types.h>
asm-arm/arch-ebsa285/vmalloc.h: *  linux/include/asm-arm/arch-ebsa285/vmalloc.h
asm-arm/arch-ebsa285/vmalloc.h: * any out-of-bounds memory accesses will hopefully be caught.
asm-arm/arch-ebsa285/vmalloc.h:#define VMALLOC_START	  (((unsigned long)high_memory + VMALLOC_OFFSET) & ~(VMALLOC_OFFSET-1))
asm-arm/arch-ebsa285/dma.h: *  linux/include/asm-arm/arch-ebsa285/dma.h
asm-arm/arch-ebsa285/ide.h: *  linux/include/asm-arm/arch-ebsa285/ide.h
asm-arm/arch-ebsa285/ide.h: *   29-07-1998	RMK	Major re-work of IDE architecture specific code
asm-arm/arch-ebsa285/ide.h:		hw->io_ports[i] = reg;
asm-arm/arch-ebsa285/ide.h:	hw->io_ports[IDE_CONTROL_OFFSET] = (ide_ioreg_t) ctrl_port;
asm-arm/arch-ebsa285/irq.h: *  linux/include/asm-arm/arch-ebsa285/irq.h
asm-arm/arch-ebsa285/irq.h: *  Copyright (C) 1996-1998 Russell King
asm-arm/arch-ebsa285/irq.h: *   22-Aug-1998 RMK	Restructured IRQ routines
asm-arm/arch-ebsa285/irq.h: *   03-Sep-1998 PJB	Merged CATS support
asm-arm/arch-ebsa285/irq.h: *   20-Jan-1998 RMK	Started merge of EBSA286, CATS and NetWinder
asm-arm/arch-ebsa285/irq.h: *   26-Jan-1999 PJB	Don't use IACK on CATS
asm-arm/arch-ebsa285/irq.h: *   16-Mar-1999 RMK	Added autodetect of ISA PICs
asm-arm/arch-ebsa285/irq.h:#include <asm/mach-types.h>
asm-arm/arch-ebsa285/irq.h:int isa_irq = -1;
asm-arm/arch-ebsa285/timex.h: *  linux/include/asm-arm/arch-ebsa285/timex.h
asm-arm/arch-ebsa285/timex.h: * divided by a 4-bit prescaler.  Other boards use an
asm-arm/arch-ebsa285/irqs.h: * linux/include/asm-arm/arch-ebsa285/irqs.h
asm-arm/arch-ebsa285/irqs.h: *  20-Jan-1998	RMK	Started merge of EBSA286, CATS and NetWinder
asm-arm/arch-ebsa285/irqs.h: *  01-Feb-1999	PJB	ISA IRQs start at 0 not 16
asm-arm/arch-ebsa285/irqs.h:#include <asm/mach-types.h>
asm-arm/arch-ebsa285/irqs.h:#define _ISA_INR(x)		((x) - 0)
asm-arm/arch-ebsa285/irqs.h:#define _DC21285_INR(x)		((x) - 16)
asm-arm/arch-ebsa285/system.h: *  linux/include/asm-arm/arch-ebsa285/system.h
asm-arm/arch-ebsa285/system.h: *  Copyright (C) 1996-1999 Russell King.
asm-arm/arch-ebsa285/system.h:#include <asm/mach-types.h>
asm-arm/arch-ebsa285/system.h:			/* set GP16 for WD-TIMER output
asm-arm/arch-ebsa285/time.h: *  linux/include/asm-arm/arch-ebsa285/time.h
asm-arm/arch-ebsa285/time.h: * CATS has a real-time clock, though the evaluation board doesn't.
asm-arm/arch-ebsa285/time.h: *  21-Mar-1998	RMK	Created
asm-arm/arch-ebsa285/time.h: *  27-Aug-1998	PJB	CATS support
asm-arm/arch-ebsa285/time.h: *  28-Dec-1998	APH	Made leds optional
asm-arm/arch-ebsa285/time.h: *  20-Jan-1999	RMK	Started merge of EBSA285, CATS and NetWinder
asm-arm/arch-ebsa285/time.h: *  16-Mar-1999	RMK	More support for EBSA285-like machines with RTCs in
asm-arm/arch-ebsa285/time.h:#include <asm/mach-types.h>
asm-arm/arch-ebsa285/time.h:		count -= (mSEC_10_from_14/6);
asm-arm/arch-ebsa285/time.h:	count = (((mSEC_10_from_14/6)-1) - count) * tick;
asm-arm/arch-ebsa285/time.h:	 * When the Update-In-Progress (UIP) flag goes from 1 to 0, the
asm-arm/arch-ebsa285/time.h:	if (((abs(real_minutes - cmos_minutes) + 15)/30) & 1)
asm-arm/arch-ebsa285/time.h:	if (abs(real_minutes - cmos_minutes) < 30) {
asm-arm/arch-ebsa285/time.h:		retval = -1;
asm-arm/arch-ebsa285/time.h:	 * sheets anyway ...                           -- Markus Kuhn
asm-arm/arch-ebsa285/time.h:	unsigned long value = LATCH - *CSR_TIMER1_VALUE;
asm-arm/arch-ebsa285/time.h:		 * Add-in 21285s shouldn't access the RTC
asm-arm/arch-ebsa285/serial.h: *  linux/include/asm-arm/arch-ebsa285/serial.h
asm-arm/arch-ebsa285/serial.h: *   15-10-1996	RMK	Created
asm-arm/arch-ebsa285/serial.h: *   25-05-1998	PJB	CATS support
asm-arm/arch-ebsa285/param.h: * linux/include/asm-arm/arch-ebsa285/param.h
asm-arm/arch-ebsa285/keyboard.h: * linux/include/asm-arm/arch-ebsa285/keyboard.h
asm-arm/arch-ebsa285/keyboard.h: * Copyright (C) 1998-2001 Russell King
asm-arm/arch-ebsa285/memory.h: *  linux/include/asm-arm/arch-ebsa285/memory.h
asm-arm/arch-ebsa285/memory.h: *  Copyright (C) 1996-1999 Russell King.
asm-arm/arch-ebsa285/memory.h: *   20-Oct-1996 RMK	Created
asm-arm/arch-ebsa285/memory.h: *   31-Dec-1997 RMK	Fixed definitions to reduce warnings.
asm-arm/arch-ebsa285/memory.h: *   17-May-1998 DAG	Added __virt_to_bus and __bus_to_virt functions.
asm-arm/arch-ebsa285/memory.h: *   21-Nov-1998 RMK	Changed __virt_to_bus and __bus_to_virt to macros.
asm-arm/arch-ebsa285/memory.h: *   21-Mar-1999 RMK	Added PAGE_OFFSET for co285 architecture.
asm-arm/arch-ebsa285/memory.h: * If we may be using add-in footbridge mode, then we must
asm-arm/arch-ebsa285/memory.h: * use the out-of-line translation that makes use of the
asm-arm/arch-ebsa285/memory.h:#define __virt_to_bus(x)	((x) - 0xe0000000)
asm-arm/arch-ebsa285/memory.h:#define __virt_to_phys(vpage) ((unsigned long)(vpage) - PAGE_OFFSET)
asm-arm/cache.h: *  linux/include/asm-arm/cache.h
asm-arm/cache.h:#define        L1_CACHE_ALIGN(x)       (((x)+(L1_CACHE_BYTES-1))&~(L1_CACHE_BYTES-1))
asm-arm/siginfo.h:#define SI_PAD_SIZE	((SI_MAX_SIZE/sizeof(int)) - 3)
asm-arm/siginfo.h: * Digital reserves positive values for kernel-generated signals.
asm-arm/siginfo.h:#define SI_QUEUE	-1		/* sent by sigqueue */
asm-arm/siginfo.h:#define SI_TIMER __SI_CODE(__SI_TIMER,-2) /* sent by timer expiration */
asm-arm/siginfo.h:#define SI_MESGQ	-3		/* sent by real time mesq state change */
asm-arm/siginfo.h:#define SI_ASYNCIO	-4		/* sent by AIO completion */
asm-arm/siginfo.h:#define SI_SIGIO	-5		/* sent by queued SIGIO */
asm-arm/siginfo.h:#define SI_TKILL        -6              /* sent by tkill system call */
asm-arm/siginfo.h:#define SI_FROMUSER(siptr)	((siptr)->si_code <= 0)
asm-arm/siginfo.h:#define SI_FROMKERNEL(siptr)	((siptr)->si_code > 0)
asm-arm/siginfo.h:#define BUS_ADRERR	(__SI_FAULT|2)	/* non-existant physical address */
asm-arm/siginfo.h:#define SIGEV_PAD_SIZE	((SIGEV_MAX_SIZE/sizeof(int)) - 3)
asm-arm/siginfo.h:	if (from->si_code < 0)
asm-arm/siginfo.h:		memcpy(to, from, 3*sizeof(int) + sizeof(from->_sifields._sigchld));
asm-arm/floppy.h: *  linux/include/asm-arm/floppy.h
asm-arm/floppy.h: *  Copyright (C) 1996-2000 Russell King
asm-arm/floppy.h: * to a non-zero track, and then restoring it to track 0.  If an error occurs,
asm-arm/floppy.h:	raw_cmd->flags = FD_RAW_SPIN | FD_RAW_NEED_SEEK;
asm-arm/floppy.h:	raw_cmd->track = 0;
asm-arm/floppy.h:	raw_cmd->rate = ?;
asm-arm/floppy.h:			for (i = drive_count; i < 3; i--)
asm-arm/floppy.h:			floppy -= 1;
asm-arm/sockios.h:/* Socket-level I/O control calls. */
asm-arm/keyboard.h: *  linux/include/asm-arm/keyboard.h
asm-arm/keyboard.h:	int ret = -EINVAL;
asm-arm/keyboard.h:	int ret = -EINVAL;
asm-arm/a.out.h:#define STACK_TOP	((current->personality == PER_LINUX_32BIT) ? \
asm-arm/arch-at91rm9200/io.h: * linux/include/asm-arm/arch-at91rm9200/io.h
asm-arm/arch-at91rm9200/io.h: * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
asm-arm/arch-at91rm9200/hardware.h: * linux/include/asm-arm/arch-at91rm9200/hardware.h
asm-arm/arch-at91rm9200/hardware.h:  * The following variable is defined in arch/arm/mach-at91rm9200/core.c
asm-arm/arch-at91rm9200/hardware.h:#define AT91C_IO_SIZE		(0xFFFFFFFF - AT91C_IO_PHYS_BASE + 1)
asm-arm/arch-at91rm9200/hardware.h:#define AT91C_IO_VIRT_BASE	(0xFF000000 - AT91C_IO_SIZE)
asm-arm/arch-at91rm9200/hardware.h:#define AT91_IO_P2V(x)	((x) - AT91C_IO_PHYS_BASE + AT91C_IO_VIRT_BASE)
asm-arm/arch-at91rm9200/uncompress.h: * linux/include/asm-arm/arch-at91rm9200/uncompress.h
asm-arm/arch-at91rm9200/uncompress.h: * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
asm-arm/arch-at91rm9200/uncompress.h:		while (!(pSYS->DBGU_CSR & AT91C_DBGU_TXRDY)) { barrier(); }
asm-arm/arch-at91rm9200/uncompress.h:		pSYS->DBGU_THR = *s;
asm-arm/arch-at91rm9200/uncompress.h:			while (!(pSYS->DBGU_CSR & AT91C_DBGU_TXRDY)) { barrier(); }
asm-arm/arch-at91rm9200/uncompress.h:			pSYS->DBGU_THR = '\r';
asm-arm/arch-at91rm9200/uncompress.h:	while (!(pSYS->DBGU_CSR & AT91C_DBGU_TXEMPTY)) { barrier(); }
asm-arm/arch-at91rm9200/vmalloc.h: * linux/include/asm-arm/arch-at91rm9200/vmalloc.h
asm-arm/arch-at91rm9200/vmalloc.h: * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
asm-arm/arch-at91rm9200/vmalloc.h: * any out-of-bounds memory accesses will hopefully be caught.
asm-arm/arch-at91rm9200/vmalloc.h:#define VMALLOC_START		(((unsigned long)high_memory + VMALLOC_OFFSET) & ~(VMALLOC_OFFSET-1))
asm-arm/arch-at91rm9200/vmalloc.h:#define VMALLOC_END		(AT91C_IO_VIRT_BASE-1)
asm-arm/arch-at91rm9200/dma.h: * linux/include/asm-arm/arch-at91rm9200/dma.h
asm-arm/arch-at91rm9200/dma.h: * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
asm-arm/arch-at91rm9200/irq.h: * linux/include/asm-arm/arch-at91rm9200/irq.h
asm-arm/arch-at91rm9200/irq.h: * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
asm-arm/arch-at91rm9200/irq.h:#define irq_finish(irq) do { AT91_SYS->AIC_EOICR = 0; } while (0)
asm-arm/arch-at91rm9200/pio.h: * linux/include/asm-arm/arch-at91rm9200/pio.h
asm-arm/arch-at91rm9200/pio.h:	AT91_SYS->PIOA_PDR = AT91C_PA17_TXD0 | AT91C_PA18_RXD0
asm-arm/arch-at91rm9200/pio.h:	AT91_SYS->PIOB_PDR = AT91C_PB18_RI1 | AT91C_PB19_DTR1
asm-arm/arch-at91rm9200/pio.h:	AT91_SYS->PIOA_PDR = AT91C_PA22_RXD2 | AT91C_PA23_TXD2;
asm-arm/arch-at91rm9200/pio.h:	AT91_SYS->PIOA_PDR = AT91C_PA5_TXD3 | AT91C_PA6_RXD3;
asm-arm/arch-at91rm9200/pio.h:	AT91_SYS->PIOA_BSR = AT91C_PA5_TXD3 | AT91C_PA6_RXD3;
asm-arm/arch-at91rm9200/pio.h:	AT91_SYS->PIOA_PDR = AT91C_PA31_DTXD | AT91C_PA30_DRXD;
asm-arm/arch-at91rm9200/pio.h:	AT91_SYS->PIOA_PDR = AT91C_PA16_EMDIO | AT91C_PA15_EMDC | AT91C_PA14_ERXER | AT91C_PA13_ERX1
asm-arm/arch-at91rm9200/pio.h:	AT91_SYS->PIOB_PDR = AT91C_PB25_EF100 | AT91C_PB19_ERXCK;
asm-arm/arch-at91rm9200/pio.h:	AT91_SYS->PIOB_BSR = AT91C_PB25_EF100 | AT91C_PB19_ERXCK;
asm-arm/arch-at91rm9200/pio.h:	AT91_SYS->PIOA_PDR = AT91C_PA16_EMDIO | AT91C_PA15_EMDC | AT91C_PA14_ERXER | AT91C_PA13_ERX1
asm-arm/arch-at91rm9200/pio.h:	AT91_SYS->PIOB_PDR = AT91C_PB25_EF100 | AT91C_PB19_ERXCK | AT91C_PB18_ECOL | AT91C_PB17_ERXDV
asm-arm/arch-at91rm9200/pio.h:	AT91_SYS->PIOB_BSR = AT91C_PB25_EF100 | AT91C_PB19_ERXCK | AT91C_PB18_ECOL | AT91C_PB17_ERXDV
asm-arm/arch-at91rm9200/pio.h: * Enable the Two-Wire interface.
asm-arm/arch-at91rm9200/pio.h:	AT91_SYS->PIOA_PDR = AT91C_PA25_TWD | AT91C_PA26_TWCK;
asm-arm/arch-at91rm9200/pio.h:	AT91_SYS->PIOA_ASR = AT91C_PA25_TWD | AT91C_PA26_TWCK;
asm-arm/arch-at91rm9200/pio.h:	AT91_SYS->PIOA_PDR = AT91C_PA0_MISO | AT91C_PA1_MOSI | AT91C_PA2_SPCK;
asm-arm/arch-at91rm9200/pio.h:	AT91_SYS->PIOA_PDR = AT91C_PA3_NPCS0;
asm-arm/arch-at91rm9200/pio.h:	AT91_SYS->PIOA_PDR = AT91C_PA4_NPCS1;
asm-arm/arch-at91rm9200/pio.h:	AT91_SYS->PIOA_PDR = AT91C_PA5_NPCS2;
asm-arm/arch-at91rm9200/pio.h:	AT91_SYS->PIOA_PDR = AT91C_PA6_NPCS3;
asm-arm/arch-at91rm9200/pio.h:	AT91_SYS->PIOB_PER = AT91C_PIO_PB7;
asm-arm/arch-at91rm9200/pio.h:	AT91_SYS->PIOB_OER = AT91C_PIO_PB7;
asm-arm/arch-at91rm9200/pio.h:	AT91_SYS->PIOB_CODR = AT91C_PIO_PB7;
asm-arm/arch-at91rm9200/pio.h:	AT91_SYS->PIOC_ASR = AT91C_PC0_BFCK | AT91C_PC1_BFRDY_SMOE | AT91C_PC3_BFBAA_SMWE;
asm-arm/arch-at91rm9200/pio.h:	AT91_SYS->PIOC_PDR = AT91C_PC0_BFCK | AT91C_PC1_BFRDY_SMOE | AT91C_PC3_BFBAA_SMWE;
asm-arm/arch-at91rm9200/pio.h:	AT91_SYS->PIOC_PER = AT91C_PC2_BFAVD;	/* enable direct output enable */
asm-arm/arch-at91rm9200/pio.h:	AT91_SYS->PIOC_ODR = AT91C_PC2_BFAVD;	/* disable output */
asm-arm/arch-at91rm9200/pio.h:	AT91_SYS->PIOB_PER = AT91C_PIO_PB1;	/* enable direct output enable */
asm-arm/arch-at91rm9200/pio.h:	AT91_SYS->PIOB_ODR = AT91C_PIO_PB1;	/* disable output */
asm-arm/arch-at91rm9200/pio.h:	return (AT91_SYS->PIOC_PDSR & AT91C_PIO_PC2) ? 1 : 0;
asm-arm/arch-at91rm9200/pio.h:	return (AT91_SYS->PIOB_PDSR & AT91C_PIO_PB1) ? 1 : 0;
asm-arm/arch-at91rm9200/at91rm9200dk.h: * linux/include/asm-arm/arch-at91rm9200/at91rm9200dk.h
asm-arm/arch-at91rm9200/at91rm9200dk.h:/* Multi-Master Memory controller */
asm-arm/arch-at91rm9200/at91rm9200dk.h:#define AT91_SMR_TWI	(AT91C_AIC_PRIOR_LOWEST  | AT91C_AIC_SRCTYPE_INT_LEVEL_SENSITIVE)	// Two-Wire Interface
asm-arm/arch-at91rm9200/at91rm9200dk.h:#define AT91C_UART_MAP		{ 4, 1, -1, -1, -1 }	/* ttyS0, ..., ttyS4 */
asm-arm/arch-at91rm9200/AT91RM9200_EMAC.h:// ----------------------------------------------------------------------------
asm-arm/arch-at91rm9200/AT91RM9200_EMAC.h://          ATMEL Microcontroller Software Support  -  ROUSSET  -
asm-arm/arch-at91rm9200/AT91RM9200_EMAC.h:// ----------------------------------------------------------------------------
asm-arm/arch-at91rm9200/AT91RM9200_EMAC.h:// ----------------------------------------------------------------------------
asm-arm/arch-at91rm9200/AT91RM9200_EMAC.h:// ----------------------------------------------------------------------------
asm-arm/arch-at91rm9200/AT91RM9200_EMAC.h:// -------- EMAC_CTL : (EMAC Offset: 0x0)  --------
asm-arm/arch-at91rm9200/AT91RM9200_EMAC.h:// -------- EMAC_CFG : (EMAC Offset: 0x4) Network Configuration Register --------
asm-arm/arch-at91rm9200/AT91RM9200_EMAC.h:// -------- EMAC_SR : (EMAC Offset: 0x8) Network Status Register --------
asm-arm/arch-at91rm9200/AT91RM9200_EMAC.h:// -------- EMAC_TCR : (EMAC Offset: 0x10) Transmit Control Register --------
asm-arm/arch-at91rm9200/AT91RM9200_EMAC.h:// -------- EMAC_TSR : (EMAC Offset: 0x14) Transmit Control Register --------
asm-arm/arch-at91rm9200/AT91RM9200_EMAC.h:// -------- EMAC_RSR : (EMAC Offset: 0x20) Receive Status Register --------
asm-arm/arch-at91rm9200/AT91RM9200_EMAC.h:// -------- EMAC_ISR : (EMAC Offset: 0x24) Interrupt Status Register --------
asm-arm/arch-at91rm9200/AT91RM9200_EMAC.h:// -------- EMAC_IER : (EMAC Offset: 0x28) Interrupt Enable Register --------
asm-arm/arch-at91rm9200/AT91RM9200_EMAC.h:// -------- EMAC_IDR : (EMAC Offset: 0x2c) Interrupt Disable Register --------
asm-arm/arch-at91rm9200/AT91RM9200_EMAC.h:// -------- EMAC_IMR : (EMAC Offset: 0x30) Interrupt Mask Register --------
asm-arm/arch-at91rm9200/AT91RM9200_EMAC.h:// -------- EMAC_MAN : (EMAC Offset: 0x34) PHY Maintenance Register --------
asm-arm/arch-at91rm9200/timex.h: * linux/include/asm-arm/arch-at91rm9200/timex.h
asm-arm/arch-at91rm9200/timex.h: * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
asm-arm/arch-at91rm9200/AT91RM9200.h:// ----------------------------------------------------------------------------
asm-arm/arch-at91rm9200/AT91RM9200.h://          ATMEL Microcontroller Software Support  -  ROUSSET  -
asm-arm/arch-at91rm9200/AT91RM9200.h:// ----------------------------------------------------------------------------
asm-arm/arch-at91rm9200/AT91RM9200.h:// ----------------------------------------------------------------------------
asm-arm/arch-at91rm9200/AT91RM9200.h:// ----------------------------------------------------------------------------
asm-arm/arch-at91rm9200/AT91RM9200.h:#define AT91C_ID_TWI    (12) // Two-Wire Interface
asm-arm/arch-at91rm9200/AT91RM9200.h:#define AT91C_PA25_TWD		(AT91C_PIO_PA25) //  TWI Two-wire Serial Data
asm-arm/arch-at91rm9200/AT91RM9200.h:#define AT91C_PA26_TWCK		(AT91C_PIO_PA26) //  TWI Two-wire Serial Clock
asm-arm/arch-at91rm9200/AT91RM9200_SPI.h:// ----------------------------------------------------------------------------
asm-arm/arch-at91rm9200/AT91RM9200_SPI.h://          ATMEL Microcontroller Software Support  -  ROUSSET  -
asm-arm/arch-at91rm9200/AT91RM9200_SPI.h:// ----------------------------------------------------------------------------
asm-arm/arch-at91rm9200/AT91RM9200_SPI.h:// ----------------------------------------------------------------------------
asm-arm/arch-at91rm9200/AT91RM9200_SPI.h:// ----------------------------------------------------------------------------
asm-arm/arch-at91rm9200/AT91RM9200_SPI.h:// -------- SPI_CR : (SPI Offset: 0x0) SPI Control Register --------
asm-arm/arch-at91rm9200/AT91RM9200_SPI.h:// -------- SPI_MR : (SPI Offset: 0x4) SPI Mode Register --------
asm-arm/arch-at91rm9200/AT91RM9200_SPI.h:// -------- SPI_RDR : (SPI Offset: 0x8) Receive Data Register --------
asm-arm/arch-at91rm9200/AT91RM9200_SPI.h:// -------- SPI_TDR : (SPI Offset: 0xc) Transmit Data Register --------
asm-arm/arch-at91rm9200/AT91RM9200_SPI.h:// -------- SPI_SR : (SPI Offset: 0x10) Status Register --------
asm-arm/arch-at91rm9200/AT91RM9200_SPI.h:// -------- SPI_IER : (SPI Offset: 0x14) Interrupt Enable Register --------
asm-arm/arch-at91rm9200/AT91RM9200_SPI.h:// -------- SPI_IDR : (SPI Offset: 0x18) Interrupt Disable Register --------
asm-arm/arch-at91rm9200/AT91RM9200_SPI.h:// -------- SPI_IMR : (SPI Offset: 0x1c) Interrupt Mask Register --------
asm-arm/arch-at91rm9200/AT91RM9200_SPI.h:// -------- SPI_CSR : (SPI Offset: 0x30) Chip Select Register --------
asm-arm/arch-at91rm9200/AT91RM9200_SYS.h:// ----------------------------------------------------------------------------
asm-arm/arch-at91rm9200/AT91RM9200_SYS.h://          ATMEL Microcontroller Software Support  -  ROUSSET  -
asm-arm/arch-at91rm9200/AT91RM9200_SYS.h:// ----------------------------------------------------------------------------
asm-arm/arch-at91rm9200/AT91RM9200_SYS.h:// ----------------------------------------------------------------------------
asm-arm/arch-at91rm9200/AT91RM9200_SYS.h:// ----------------------------------------------------------------------------
asm-arm/arch-at91rm9200/AT91RM9200_SYS.h:	AT91_REG	 PIOA_MDER; 	// Multi-driver Enable Register
asm-arm/arch-at91rm9200/AT91RM9200_SYS.h:	AT91_REG	 PIOA_MDDR; 	// Multi-driver Disable Register
asm-arm/arch-at91rm9200/AT91RM9200_SYS.h:	AT91_REG	 PIOA_MDSR; 	// Multi-driver Status Register
asm-arm/arch-at91rm9200/AT91RM9200_SYS.h:	AT91_REG	 PIOA_PPUDR; 	// Pull-up Disable Register
asm-arm/arch-at91rm9200/AT91RM9200_SYS.h:	AT91_REG	 PIOA_PPUER; 	// Pull-up Enable Register
asm-arm/arch-at91rm9200/AT91RM9200_SYS.h:	AT91_REG	 PIOA_PPUSR; 	// Pad Pull-up Status Register
asm-arm/arch-at91rm9200/AT91RM9200_SYS.h:	AT91_REG	 PIOB_MDER; 	// Multi-driver Enable Register
asm-arm/arch-at91rm9200/AT91RM9200_SYS.h:	AT91_REG	 PIOB_MDDR; 	// Multi-driver Disable Register
asm-arm/arch-at91rm9200/AT91RM9200_SYS.h:	AT91_REG	 PIOB_MDSR; 	// Multi-driver Status Register
asm-arm/arch-at91rm9200/AT91RM9200_SYS.h:	AT91_REG	 PIOB_PPUDR; 	// Pull-up Disable Register
asm-arm/arch-at91rm9200/AT91RM9200_SYS.h:	AT91_REG	 PIOB_PPUER; 	// Pull-up Enable Register
asm-arm/arch-at91rm9200/AT91RM9200_SYS.h:	AT91_REG	 PIOB_PPUSR; 	// Pad Pull-up Status Register
asm-arm/arch-at91rm9200/AT91RM9200_SYS.h:	AT91_REG	 PIOC_MDER; 	// Multi-driver Enable Register
asm-arm/arch-at91rm9200/AT91RM9200_SYS.h:	AT91_REG	 PIOC_MDDR; 	// Multi-driver Disable Register
asm-arm/arch-at91rm9200/AT91RM9200_SYS.h:	AT91_REG	 PIOC_MDSR; 	// Multi-driver Status Register
asm-arm/arch-at91rm9200/AT91RM9200_SYS.h:	AT91_REG	 PIOC_PPUDR; 	// Pull-up Disable Register
asm-arm/arch-at91rm9200/AT91RM9200_SYS.h:	AT91_REG	 PIOC_PPUER; 	// Pull-up Enable Register
asm-arm/arch-at91rm9200/AT91RM9200_SYS.h:	AT91_REG	 PIOC_PPUSR; 	// Pad Pull-up Status Register
asm-arm/arch-at91rm9200/AT91RM9200_SYS.h:	AT91_REG	 PIOD_MDER; 	// Multi-driver Enable Register
asm-arm/arch-at91rm9200/AT91RM9200_SYS.h:	AT91_REG	 PIOD_MDDR; 	// Multi-driver Disable Register
asm-arm/arch-at91rm9200/AT91RM9200_SYS.h:	AT91_REG	 PIOD_MDSR; 	// Multi-driver Status Register
asm-arm/arch-at91rm9200/AT91RM9200_SYS.h:	AT91_REG	 PIOD_PPUDR; 	// Pull-up Disable Register
asm-arm/arch-at91rm9200/AT91RM9200_SYS.h:	AT91_REG	 PIOD_PPUER; 	// Pull-up Enable Register
asm-arm/arch-at91rm9200/AT91RM9200_SYS.h:	AT91_REG	 PIOD_PPUSR; 	// Pad Pull-up Status Register
asm-arm/arch-at91rm9200/AT91RM9200_SYS.h:	AT91_REG	 ST_RTMR; 	// Real-time Mode Register
asm-arm/arch-at91rm9200/AT91RM9200_SYS.h:	AT91_REG	 ST_RTAR; 	// Real-time Alarm Register
asm-arm/arch-at91rm9200/AT91RM9200_SYS.h:	AT91_REG	 ST_CRTR; 	// Current Real-time Register
asm-arm/arch-at91rm9200/AT91RM9200_SYS.h:// -------- MC_RCR : (MC Offset: 0x0) MC Remap Control Register --------
asm-arm/arch-at91rm9200/AT91RM9200_SYS.h:// -------- MC_ASR : (MC Offset: 0x4) MC Abort Status Register --------
asm-arm/arch-at91rm9200/AT91RM9200_SYS.h:#define 	AT91C_MC_ABTSZ_HWORD                (0x1 <<  8) // (MC) Half-word
asm-arm/arch-at91rm9200/AT91RM9200_SYS.h:// -------- MC_PUIA : (MC Offset: 0x10) MC Protection Unit Area --------
asm-arm/arch-at91rm9200/AT91RM9200_SYS.h:// -------- MC_PUP : (MC Offset: 0x50) MC Protection Unit Peripheral --------
asm-arm/arch-at91rm9200/AT91RM9200_SYS.h:// -------- MC_PUER : (MC Offset: 0x54) MC Protection Unit Area --------
asm-arm/arch-at91rm9200/AT91RM9200_SYS.h://              SOFTWARE API DEFINITION  FOR Real-time Clock Alarm and Parallel Load Interface
asm-arm/arch-at91rm9200/AT91RM9200_SYS.h:// -------- RTC_CR : (RTC Offset: 0x0) RTC Control Register --------
asm-arm/arch-at91rm9200/AT91RM9200_SYS.h:// -------- RTC_MR : (RTC Offset: 0x4) RTC Mode Register --------
asm-arm/arch-at91rm9200/AT91RM9200_SYS.h:#define AT91C_RTC_HRMOD       (0x1 <<  0) // (RTC) 12-24 hour Mode
asm-arm/arch-at91rm9200/AT91RM9200_SYS.h:// -------- RTC_TIMR : (RTC Offset: 0x8) RTC Time Register --------
asm-arm/arch-at91rm9200/AT91RM9200_SYS.h:// -------- RTC_CALR : (RTC Offset: 0xc) RTC Calendar Register --------
asm-arm/arch-at91rm9200/AT91RM9200_SYS.h:// -------- RTC_TIMALR : (RTC Offset: 0x10) RTC Time Alarm Register --------
asm-arm/arch-at91rm9200/AT91RM9200_SYS.h:// -------- RTC_CALALR : (RTC Offset: 0x14) RTC Calendar Alarm Register --------
asm-arm/arch-at91rm9200/AT91RM9200_SYS.h:// -------- RTC_SR : (RTC Offset: 0x18) RTC Status Register --------
asm-arm/arch-at91rm9200/AT91RM9200_SYS.h:// -------- RTC_SCCR : (RTC Offset: 0x1c) RTC Status Clear Command Register --------
asm-arm/arch-at91rm9200/AT91RM9200_SYS.h:// -------- RTC_IER : (RTC Offset: 0x20) RTC Interrupt Enable Register --------
asm-arm/arch-at91rm9200/AT91RM9200_SYS.h:// -------- RTC_IDR : (RTC Offset: 0x24) RTC Interrupt Disable Register --------
asm-arm/arch-at91rm9200/AT91RM9200_SYS.h:// -------- RTC_IMR : (RTC Offset: 0x28) RTC Interrupt Mask Register --------
asm-arm/arch-at91rm9200/AT91RM9200_SYS.h:// -------- RTC_VER : (RTC Offset: 0x2c) RTC Valid Entry Register --------
asm-arm/arch-at91rm9200/AT91RM9200_SYS.h:// -------- ST_CR : (ST Offset: 0x0) System Timer Control Register --------
asm-arm/arch-at91rm9200/AT91RM9200_SYS.h:// -------- ST_PIMR : (ST Offset: 0x4) System Timer Period Interval Mode Register --------
asm-arm/arch-at91rm9200/AT91RM9200_SYS.h:// -------- ST_WDMR : (ST Offset: 0x8) System Timer Watchdog Mode Register --------
asm-arm/arch-at91rm9200/AT91RM9200_SYS.h:// -------- ST_RTMR : (ST Offset: 0xc) System Timer Real-time Mode Register --------
asm-arm/arch-at91rm9200/AT91RM9200_SYS.h:#define AT91C_ST_RTPRES       (0xFFFF <<  0) // (ST) Real-time Timer Prescaler Value
asm-arm/arch-at91rm9200/AT91RM9200_SYS.h:// -------- ST_SR : (ST Offset: 0x10) System Timer Status Register --------
asm-arm/arch-at91rm9200/AT91RM9200_SYS.h:#define AT91C_ST_RTTINC       (0x1 <<  2) // (ST) Real-time Timer Increment
asm-arm/arch-at91rm9200/AT91RM9200_SYS.h:// -------- ST_IER : (ST Offset: 0x14) System Timer Interrupt Enable Register --------
asm-arm/arch-at91rm9200/AT91RM9200_SYS.h:// -------- ST_IDR : (ST Offset: 0x18) System Timer Interrupt Disable Register --------
asm-arm/arch-at91rm9200/AT91RM9200_SYS.h:// -------- ST_IMR : (ST Offset: 0x1c) System Timer Interrupt Mask Register --------
asm-arm/arch-at91rm9200/AT91RM9200_SYS.h:// -------- ST_RTAR : (ST Offset: 0x20) System Timer Real-time Alarm Register --------
asm-arm/arch-at91rm9200/AT91RM9200_SYS.h:// -------- ST_CRTR : (ST Offset: 0x24) System Timer Current Real-time Register --------
asm-arm/arch-at91rm9200/AT91RM9200_SYS.h:#define AT91C_ST_CRTV         (0xFFFFF <<  0) // (ST) Current Real-time Value
asm-arm/arch-at91rm9200/AT91RM9200_SYS.h:// -------- PMC_SCER : (PMC Offset: 0x0) System Clock Enable Register --------
asm-arm/arch-at91rm9200/AT91RM9200_SYS.h:// -------- PMC_SCDR : (PMC Offset: 0x4) System Clock Disable Register --------
asm-arm/arch-at91rm9200/AT91RM9200_SYS.h:// -------- PMC_SCSR : (PMC Offset: 0x8) System Clock Status Register --------
asm-arm/arch-at91rm9200/AT91RM9200_SYS.h:// -------- PMC_MCKR : (PMC Offset: 0x30) Master Clock Register --------
asm-arm/arch-at91rm9200/AT91RM9200_SYS.h:// -------- PMC_PCKR : (PMC Offset: 0x40) Programmable Clock Register --------
asm-arm/arch-at91rm9200/AT91RM9200_SYS.h:// -------- PMC_IER : (PMC Offset: 0x60) PMC Interrupt Enable Register --------
asm-arm/arch-at91rm9200/AT91RM9200_SYS.h:// -------- PMC_IDR : (PMC Offset: 0x64) PMC Interrupt Disable Register --------
asm-arm/arch-at91rm9200/AT91RM9200_SYS.h:// -------- PMC_SR : (PMC Offset: 0x68) PMC Status Register --------
asm-arm/arch-at91rm9200/AT91RM9200_SYS.h:// -------- PMC_IMR : (PMC Offset: 0x6c) PMC Interrupt Mask Register --------
asm-arm/arch-at91rm9200/AT91RM9200_SYS.h:// -------- CKGR_MOR : (CKGR Offset: 0x0) Main Oscillator Register --------
asm-arm/arch-at91rm9200/AT91RM9200_SYS.h:#define AT91C_CKGR_OSCOUNT    (0xFF <<  8) // (CKGR) Main Oscillator Start-up Time
asm-arm/arch-at91rm9200/AT91RM9200_SYS.h:// -------- CKGR_MCFR : (CKGR Offset: 0x4) Main Clock Frequency Register --------
asm-arm/arch-at91rm9200/AT91RM9200_SYS.h:// -------- CKGR_PLLAR : (CKGR Offset: 0x8) PLL A Register --------
asm-arm/arch-at91rm9200/AT91RM9200_SYS.h:// -------- CKGR_PLLBR : (CKGR Offset: 0xc) PLL B Register --------
asm-arm/arch-at91rm9200/AT91RM9200_SYS.h:// -------- DBGU_CR : (DBGU Offset: 0x0) Debug Unit Control Register --------
asm-arm/arch-at91rm9200/AT91RM9200_SYS.h:// -------- DBGU_MR : (DBGU Offset: 0x4) Debug Unit Mode Register --------
asm-arm/arch-at91rm9200/AT91RM9200_SYS.h:// -------- DBGU_IER : (DBGU Offset: 0x8) Debug Unit Interrupt Enable Register --------
asm-arm/arch-at91rm9200/AT91RM9200_SYS.h:// -------- DBGU_IDR : (DBGU Offset: 0xc) Debug Unit Interrupt Disable Register --------
asm-arm/arch-at91rm9200/AT91RM9200_SYS.h:// -------- DBGU_IMR : (DBGU Offset: 0x10) Debug Unit Interrupt Mask Register --------
asm-arm/arch-at91rm9200/AT91RM9200_SYS.h:// -------- DBGU_CSR : (DBGU Offset: 0x14) Debug Unit Channel Status Register --------
asm-arm/arch-at91rm9200/AT91RM9200_SYS.h:// -------- DBGU_FNTR : (DBGU Offset: 0x48) Debug Unit FORCE_NTRST Register --------
asm-arm/arch-at91rm9200/AT91RM9200_SYS.h:// -------- PDC_PTCR : (PDC Offset: 0x20) PDC Transfer Control Register --------
asm-arm/arch-at91rm9200/AT91RM9200_SYS.h:// -------- PDC_PTSR : (PDC Offset: 0x24) PDC Transfer Status Register --------
asm-arm/arch-at91rm9200/AT91RM9200_SYS.h:// -------- AIC_SMR : (AIC Offset: 0x0) Control Register --------
asm-arm/arch-at91rm9200/AT91RM9200_SYS.h:#define 	AT91C_AIC_SRCTYPE_EXT_HIGH_LEVEL       (0x2 <<  5) // (AIC) External Sources Code Label High-level Sensitive
asm-arm/arch-at91rm9200/AT91RM9200_SYS.h:// -------- AIC_CISR : (AIC Offset: 0x114) AIC Core Interrupt Status Register --------
asm-arm/arch-at91rm9200/AT91RM9200_SYS.h:// -------- AIC_DCR : (AIC Offset: 0x138) AIC Debug Control Register (Protect) --------
asm-arm/arch-at91rm9200/AT91RM9200_SYS.h:// -------- EBI_CSA : (EBI Offset: 0x0) Chip Select Assignment Register --------
asm-arm/arch-at91rm9200/AT91RM9200_SYS.h:// -------- EBI_CFGR : (EBI Offset: 0x4) Configuration Register --------
asm-arm/arch-at91rm9200/AT91RM9200_SYS.h:#define AT91C_EBI_DBPUC       (0x1 <<  0) // (EBI) Data Bus Pull-Up Configuration
asm-arm/arch-at91rm9200/AT91RM9200_SYS.h:// -------- SMC2_CSR : (SMC2 Offset: 0x0) SMC2 Chip Select Register --------
asm-arm/arch-at91rm9200/AT91RM9200_SYS.h:#define 	AT91C_SMC2_DBW_16                   (0x1 << 13) // (SMC2) 16-bit.
asm-arm/arch-at91rm9200/AT91RM9200_SYS.h:#define 	AT91C_SMC2_DBW_8                    (0x2 << 13) // (SMC2) 8-bit.
asm-arm/arch-at91rm9200/AT91RM9200_SYS.h:// -------- SDRC_MR : (SDRC Offset: 0x0) SDRAM Controller Mode Register --------
asm-arm/arch-at91rm9200/AT91RM9200_SYS.h:// -------- SDRC_TR : (SDRC Offset: 0x4) SDRC Refresh Timer Register --------
asm-arm/arch-at91rm9200/AT91RM9200_SYS.h:// -------- SDRC_CR : (SDRC Offset: 0x8) SDRAM Configuration Register --------
asm-arm/arch-at91rm9200/AT91RM9200_SYS.h:// -------- SDRC_SRR : (SDRC Offset: 0xc) SDRAM Controller Self-refresh Register --------
asm-arm/arch-at91rm9200/AT91RM9200_SYS.h:#define AT91C_SDRC_SRCB       (0x1 <<  0) // (SDRC) Self-refresh Command Bit
asm-arm/arch-at91rm9200/AT91RM9200_SYS.h:// -------- SDRC_LPR : (SDRC Offset: 0x10) SDRAM Controller Low-power Register --------
asm-arm/arch-at91rm9200/AT91RM9200_SYS.h:#define AT91C_SDRC_LPCB       (0x1 <<  0) // (SDRC) Low-power Command Bit
asm-arm/arch-at91rm9200/AT91RM9200_SYS.h:// -------- SDRC_IER : (SDRC Offset: 0x14) SDRAM Controller Interrupt Enable Register --------
asm-arm/arch-at91rm9200/AT91RM9200_SYS.h:// -------- SDRC_IDR : (SDRC Offset: 0x18) SDRAM Controller Interrupt Disable Register --------
asm-arm/arch-at91rm9200/AT91RM9200_SYS.h:// -------- SDRC_IMR : (SDRC Offset: 0x1c) SDRAM Controller Interrupt Mask Register --------
asm-arm/arch-at91rm9200/AT91RM9200_SYS.h:// -------- SDRC_ISR : (SDRC Offset: 0x20) SDRAM Controller Interrupt Status Register --------
asm-arm/arch-at91rm9200/AT91RM9200_SYS.h:// -------- BFC_MR : (BFC Offset: 0x0) BFC Mode Register --------
asm-arm/arch-at91rm9200/AT91RM9200_UDP.h:// ----------------------------------------------------------------------------
asm-arm/arch-at91rm9200/AT91RM9200_UDP.h://          ATMEL Microcontroller Software Support  -  ROUSSET  -
asm-arm/arch-at91rm9200/AT91RM9200_UDP.h:// ----------------------------------------------------------------------------
asm-arm/arch-at91rm9200/AT91RM9200_UDP.h:// ----------------------------------------------------------------------------
asm-arm/arch-at91rm9200/AT91RM9200_UDP.h:// ----------------------------------------------------------------------------
asm-arm/arch-at91rm9200/AT91RM9200_UDP.h:// -------- UDP_FRM_NUM : (UDP Offset: 0x0) USB Frame Number Register --------
asm-arm/arch-at91rm9200/AT91RM9200_UDP.h:// -------- UDP_GLB_STATE : (UDP Offset: 0x4) USB Global State Register --------
asm-arm/arch-at91rm9200/AT91RM9200_UDP.h:// -------- UDP_FADDR : (UDP Offset: 0x8) USB Function Address Register --------
asm-arm/arch-at91rm9200/AT91RM9200_UDP.h:// -------- UDP_IER : (UDP Offset: 0x10) USB Interrupt Enable Register --------
asm-arm/arch-at91rm9200/AT91RM9200_UDP.h:// -------- UDP_IDR : (UDP Offset: 0x14) USB Interrupt Disable Register --------
asm-arm/arch-at91rm9200/AT91RM9200_UDP.h:// -------- UDP_IMR : (UDP Offset: 0x18) USB Interrupt Mask Register --------
asm-arm/arch-at91rm9200/AT91RM9200_UDP.h:// -------- UDP_ISR : (UDP Offset: 0x1c) USB Interrupt Status Register --------
asm-arm/arch-at91rm9200/AT91RM9200_UDP.h:// -------- UDP_ICR : (UDP Offset: 0x20) USB Interrupt Clear Register --------
asm-arm/arch-at91rm9200/AT91RM9200_UDP.h:// -------- UDP_RST_EP : (UDP Offset: 0x28) USB Reset Endpoint Register --------
asm-arm/arch-at91rm9200/AT91RM9200_UDP.h:// -------- UDP_CSR : (UDP Offset: 0x30) USB Endpoint Control and Status Register --------
asm-arm/arch-at91rm9200/AT91RM9200_UDP.h:#define AT91C_UDP_RX_DATA_BK1 ( 0x1 <<  6) // (UDP) Receive Data Bank 1 (only used by endpoints with ping-pong attributes).
asm-arm/arch-at91rm9200/AT91RM9200_UHP.h:// ----------------------------------------------------------------------------
asm-arm/arch-at91rm9200/AT91RM9200_UHP.h://          ATMEL Microcontroller Software Support  -  ROUSSET  -
asm-arm/arch-at91rm9200/AT91RM9200_UHP.h:// ----------------------------------------------------------------------------
asm-arm/arch-at91rm9200/AT91RM9200_UHP.h:// ----------------------------------------------------------------------------
asm-arm/arch-at91rm9200/AT91RM9200_UHP.h:// ----------------------------------------------------------------------------
asm-arm/arch-at91rm9200/AT91RM9200_TWI.h:// ----------------------------------------------------------------------------
asm-arm/arch-at91rm9200/AT91RM9200_TWI.h://          ATMEL Microcontroller Software Support  -  ROUSSET  -
asm-arm/arch-at91rm9200/AT91RM9200_TWI.h:// ----------------------------------------------------------------------------
asm-arm/arch-at91rm9200/AT91RM9200_TWI.h:// ----------------------------------------------------------------------------
asm-arm/arch-at91rm9200/AT91RM9200_TWI.h:// ----------------------------------------------------------------------------
asm-arm/arch-at91rm9200/AT91RM9200_TWI.h://              SOFTWARE API DEFINITION  FOR Two-wire Interface
asm-arm/arch-at91rm9200/AT91RM9200_TWI.h:// -------- TWI_CR : (TWI Offset: 0x0) TWI Control Register --------
asm-arm/arch-at91rm9200/AT91RM9200_TWI.h:// -------- TWI_MMR : (TWI Offset: 0x4) TWI Master Mode Register --------
asm-arm/arch-at91rm9200/AT91RM9200_TWI.h:#define 	AT91C_TWI_IADRSZ_1_BYTE               ( 0x1 <<  8) // (TWI) One-byte internal device address
asm-arm/arch-at91rm9200/AT91RM9200_TWI.h:#define 	AT91C_TWI_IADRSZ_2_BYTE               ( 0x2 <<  8) // (TWI) Two-byte internal device address
asm-arm/arch-at91rm9200/AT91RM9200_TWI.h:#define 	AT91C_TWI_IADRSZ_3_BYTE               ( 0x3 <<  8) // (TWI) Three-byte internal device address
asm-arm/arch-at91rm9200/AT91RM9200_TWI.h:// -------- TWI_SMR : (TWI Offset: 0x8) TWI Slave Mode Register --------
asm-arm/arch-at91rm9200/AT91RM9200_TWI.h:// -------- TWI_CWGR : (TWI Offset: 0x10) TWI Clock Waveform Generator Register --------
asm-arm/arch-at91rm9200/AT91RM9200_TWI.h:// -------- TWI_SR : (TWI Offset: 0x20) TWI Status Register --------
asm-arm/arch-at91rm9200/AT91RM9200_TWI.h:// -------- TWI_IER : (TWI Offset: 0x24) TWI Interrupt Enable Register --------
asm-arm/arch-at91rm9200/AT91RM9200_TWI.h:// -------- TWI_IDR : (TWI Offset: 0x28) TWI Interrupt Disable Register --------
asm-arm/arch-at91rm9200/AT91RM9200_TWI.h:// -------- TWI_IMR : (TWI Offset: 0x2c) TWI Interrupt Mask Register --------
asm-arm/arch-at91rm9200/irqs.h: * linux/include/asm-arm/arch-at91rm9200/irqs.h
asm-arm/arch-at91rm9200/irqs.h: * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
asm-arm/arch-at91rm9200/system.h: * linux/include/asm-arm/arch-at91rm9200/system.h
asm-arm/arch-at91rm9200/system.h: * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
asm-arm/arch-at91rm9200/system.h:	 * re-enabled by an interrupt or by a reset.
asm-arm/arch-at91rm9200/system.h://	AT91_SYS->PMC_SCDR = AT91C_PMC_PCK;
asm-arm/arch-at91rm9200/system.h:	AT91_SYS->ST_WDMR = AT91C_ST_RSTEN | AT91C_ST_EXTEN | 1 ;
asm-arm/arch-at91rm9200/system.h:	AT91_SYS->ST_CR = AT91C_ST_WDRST;
asm-arm/arch-at91rm9200/time.h: * linux/include/asm-arm/arch-at91rm9200/time.h
asm-arm/arch-at91rm9200/time.h: * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
asm-arm/arch-at91rm9200/time.h:	elapsed = (AT91_SYS->ST_CRTR - AT91_SYS->ST_RTAR) & AT91C_ST_ALMV;
asm-arm/arch-at91rm9200/time.h:	if (AT91_SYS->ST_SR & AT91C_ST_PITS) {	/* This is a shared interrupt */
asm-arm/arch-at91rm9200/time.h:			AT91_SYS->ST_RTAR = (AT91_SYS->ST_RTAR + LATCH) & AT91C_ST_ALMV;
asm-arm/arch-at91rm9200/time.h:		} while (((AT91_SYS->ST_CRTR - AT91_SYS->ST_RTAR) & AT91C_ST_ALMV) >= LATCH);
asm-arm/arch-at91rm9200/time.h:	AT91_SYS->ST_IDR = AT91C_ST_PITS | AT91C_ST_WDOVF | AT91C_ST_RTTINC | AT91C_ST_ALMS;
asm-arm/arch-at91rm9200/time.h:	(void) AT91_SYS->ST_SR;		/* Clear any pending interrupts */
asm-arm/arch-at91rm9200/time.h:	AT91_SYS->ST_RTAR = 0;
asm-arm/arch-at91rm9200/time.h:	AT91_SYS->ST_RTMR = 1;
asm-arm/arch-at91rm9200/time.h:	AT91_SYS->ST_PIMR = LATCH;
asm-arm/arch-at91rm9200/time.h:	AT91_SYS->ST_IER = AT91C_ST_PITS;
asm-arm/arch-at91rm9200/param.h: * linux/include/asm-arm/arch-at91rm9200/param.h
asm-arm/arch-at91rm9200/param.h: * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
asm-arm/arch-at91rm9200/AT91RM9200_USART.h:// ----------------------------------------------------------------------------
asm-arm/arch-at91rm9200/AT91RM9200_USART.h://          ATMEL Microcontroller Software Support  -  ROUSSET  -
asm-arm/arch-at91rm9200/AT91RM9200_USART.h:// ----------------------------------------------------------------------------
asm-arm/arch-at91rm9200/AT91RM9200_USART.h:// ----------------------------------------------------------------------------
asm-arm/arch-at91rm9200/AT91RM9200_USART.h:// ----------------------------------------------------------------------------
asm-arm/arch-at91rm9200/AT91RM9200_USART.h:	AT91_REG	 US_RTOR; 	// Receiver Time-out Register
asm-arm/arch-at91rm9200/AT91RM9200_USART.h:	AT91_REG	 US_TTGR; 	// Transmitter Time-guard Register
asm-arm/arch-at91rm9200/AT91RM9200_USART.h:// -------- US_CR : (USART Offset: 0x0) Debug Unit Control Register --------
asm-arm/arch-at91rm9200/AT91RM9200_USART.h:#define AT91C_US_STTTO        ( 0x1 << 11) // (USART) Start Time-out
asm-arm/arch-at91rm9200/AT91RM9200_USART.h:#define AT91C_US_RETTO        ( 0x1 << 15) // (USART) Rearm Time-out
asm-arm/arch-at91rm9200/AT91RM9200_USART.h:// -------- US_MR : (USART Offset: 0x4) Debug Unit Mode Register --------
asm-arm/arch-at91rm9200/AT91RM9200_USART.h:#define		AT91C_US_PAR_MULTI_DROP           ( 0x6 <<  9) // (USART) Multi-drop mode
asm-arm/arch-at91rm9200/AT91RM9200_USART.h:#define AT91C_US_MODE9        ( 0x1 << 17) // (USART) 9-bit Character length
asm-arm/arch-at91rm9200/AT91RM9200_USART.h:// -------- US_IER : (USART Offset: 0x8) Debug Unit Interrupt Enable Register --------
asm-arm/arch-at91rm9200/AT91RM9200_USART.h:#define AT91C_US_TIMEOUT      ( 0x1 <<  8) // (USART) Receiver Time-out
asm-arm/arch-at91rm9200/AT91RM9200_USART.h:// -------- US_IDR : (USART Offset: 0xc) Debug Unit Interrupt Disable Register --------
asm-arm/arch-at91rm9200/AT91RM9200_USART.h:// -------- US_IMR : (USART Offset: 0x10) Debug Unit Interrupt Mask Register --------
asm-arm/arch-at91rm9200/AT91RM9200_USART.h:// -------- US_CSR : (USART Offset: 0x14) Debug Unit Channel Status Register --------
asm-arm/arch-at91rm9200/memory.h: * linux/include/asm-arm/arch-at91rm9200/memory.h
asm-arm/arch-at91rm9200/memory.h: * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
asm-arm/arch-at91rm9200/memory.h:#define __virt_to_phys(vpage) ((vpage) - PAGE_OFFSET + PHYS_OFFSET)
asm-arm/arch-at91rm9200/memory.h:#define __phys_to_virt(ppage) ((ppage) + PAGE_OFFSET - PHYS_OFFSET)
asm-arm/arch-at91rm9200/memory.h: * Virtual view <-> DMA view memory address translations
asm-arm/ioctl.h: * NOTE: This limits the max parameter size to 16kB -1 !
asm-arm/ioctl.h:#define _IOC_NRMASK	((1 << _IOC_NRBITS)-1)
asm-arm/ioctl.h:#define _IOC_TYPEMASK	((1 << _IOC_TYPEBITS)-1)
asm-arm/ioctl.h:#define _IOC_SIZEMASK	((1 << _IOC_SIZEBITS)-1)
asm-arm/ioctl.h:#define _IOC_DIRMASK	((1 << _IOC_DIRBITS)-1)
asm-arm/proc-fns.h: *  linux/include/asm-arm/proc-fns.h
asm-arm/proc-fns.h: *  Copyright (C) 1997-1999 Russell King
asm-arm/proc-fns.h:# define CPU_INCLUDE_NAME "asm/cpu-multi26.h"
asm-arm/proc-fns.h:# define CPU_INCLUDE_NAME "asm/cpu-multi32.h"
asm-arm/proc-fns.h:#define CPU_INCLUDE_NAME "asm/cpu-single.h"
asm-arm/proc-fns.h: * file does indeed depend on the cpu-*.h files.
asm-arm/proc-fns.h:#include <asm/cpu-single.h>
asm-arm/proc-fns.h:#include <asm/cpu-multi26.h>
asm-arm/proc-fns.h:#include <asm/cpu-multi32.h>
asm-arm/ioctls.h:#define TIOCGPTN	_IOR('T',0x30, unsigned int) /* Get Pty Number (of pty-mux device) */
asm-arm/msgbuf.h: * - 64-bit time_t to solve y2038 problem
asm-arm/msgbuf.h: * - 2 miscellaneous 32-bit values
asm-arm/arch-clps711x/io.h: *  linux/include/asm-arm/arch-clps711x/io.h
asm-arm/arch-clps711x/io.h: * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
asm-arm/arch-clps711x/io.h: * ioremap support - validate a PCI memory address, and convert it
asm-arm/arch-clps711x/hardware.h: *  linux/include/asm-arm/arch-clps711x/hardware.h
asm-arm/arch-clps711x/hardware.h: * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
asm-arm/arch-clps711x/uncompress.h: *  linux/include/asm-arm/arch-clps711x/uncompress.h
asm-arm/arch-clps711x/uncompress.h: * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
asm-arm/arch-clps711x/vmalloc.h: *  linux/include/asm-arm/arch-clps711x/vmalloc.h
asm-arm/arch-clps711x/vmalloc.h: * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
asm-arm/arch-clps711x/vmalloc.h: * any out-of-bounds memory accesses will hopefully be caught.
asm-arm/arch-clps711x/vmalloc.h:#define VMALLOC_START	  (((unsigned long)high_memory + VMALLOC_OFFSET) & ~(VMALLOC_OFFSET-1))
asm-arm/arch-clps711x/dma.h: *  linux/include/asm-arm/arch-clps711x/dma.h
asm-arm/arch-clps711x/dma.h: * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
asm-arm/arch-clps711x/irq.h: *  linux/include/asm-arm/arch-clps711x/irq.h
asm-arm/arch-clps711x/irq.h: * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
asm-arm/arch-clps711x/timex.h: *  linux/include/asm-arm/arch-clps711x/timex.h
asm-arm/arch-clps711x/timex.h: * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
asm-arm/arch-clps711x/irqs.h: *  linux/include/asm-arm/arch-clps711x/irqs.h
asm-arm/arch-clps711x/irqs.h: * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
asm-arm/arch-clps711x/syspld.h: *  linux/include/asm-arm/arch-clps711x/syspld.h
asm-arm/arch-clps711x/syspld.h: * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
asm-arm/arch-clps711x/system.h: *  linux/include/asm-arm/arch-clps711x/system.h
asm-arm/arch-clps711x/system.h: * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
asm-arm/arch-clps711x/time.h: *  linux/include/asm-arm/arch-clps711x/time.h
asm-arm/arch-clps711x/time.h: * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
asm-arm/arch-clps711x/param.h: *  linux/include/asm-arm/arch-clps711x/param.h
asm-arm/arch-clps711x/param.h: * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
asm-arm/arch-clps711x/autcpu12.h: * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
asm-arm/arch-clps711x/keyboard.h: * linux/include/asm-arm/arch-clps711x/keyboard.h
asm-arm/arch-clps711x/keyboard.h: * Copyright (C) 1998-2001 Russell King
asm-arm/arch-clps711x/keyboard.h:#include <asm/mach-types.h>
asm-arm/arch-clps711x/memory.h: *  linux/include/asm-arm/arch-clps711x/mmu.h
asm-arm/arch-clps711x/memory.h: * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
asm-arm/arch-clps711x/memory.h:#define __virt_to_phys(vpage) ((vpage) - PAGE_OFFSET + PHYS_OFFSET)
asm-arm/arch-clps711x/memory.h:#define __phys_to_virt(ppage) ((ppage) + PAGE_OFFSET - PHYS_OFFSET)
asm-arm/arch-clps711x/memory.h: * Virtual view <-> DMA view memory address translations
asm-arm/arch-clps711x/memory.h:#define __virt_to_bus(x)	((x) - PAGE_OFFSET)
asm-arm/arch-clps711x/memory.h: * banks.  In 2.2, the Psion (CL-PS7110) port added custom support for
asm-arm/arch-clps711x/memory.h: * 	node 0:  0xc0000000 - 0xc7ffffff
asm-arm/arch-clps711x/memory.h: * 	node 1:  0xc8000000 - 0xcfffffff
asm-arm/arch-clps711x/memory.h: * 	node 2:  0xd0000000 - 0xd7ffffff
asm-arm/arch-clps711x/memory.h: * 	node 3:  0xd8000000 - 0xdfffffff
asm-arm/arch-clps711x/memory.h:		(((unsigned long)(addr) - PAGE_OFFSET) >> NODE_MAX_MEM_SHIFT)
asm-arm/arch-clps711x/memory.h:	(((pfn) - PHYS_PFN_OFFSET) >> (NODE_MAX_MEM_SHIFT - PAGE_SHIFT))
asm-arm/arch-clps711x/memory.h:	(((unsigned long)(addr) & (NODE_MAX_MEM_SIZE - 1)) >> PAGE_SHIFT)
asm-arm/cpu-multi26.h: *  linux/include/asm-arm/cpu-multi26.h
asm-arm/cpu-multi26.h:/* forward-declare task_struct */
asm-arm/cpu-multi26.h: * Don't change this structure - ASM code
asm-arm/cpu-multi32.h: *  linux/include/asm-arm/cpu-multi32.h
asm-arm/cpu-multi32.h:/* forward-declare task_struct */
asm-arm/cpu-multi32.h: * Don't change this structure - ASM code
asm-arm/cpu-multi32.h:	struct {	/* D-cache */
asm-arm/cpu-multi32.h:		 * D-cache without flushing the cache.
asm-arm/cpu-multi32.h:	struct {	/* I-cache */
asm-arm/cpu-multi32.h:		 * invalidate the I-cache for the specified range
asm-arm/cpu-multi32.h:		 * invalidate the I-cache for the specified virtual page
asm-arm/socket.h:/* Security levels - as per NRL IPv6 - don't actually do anything */
asm-arm/socket.h:/* Nast libc5 fixup - bletch */
asm-arm/socket.h:#define SOCK_RDM	4		/* reliably-delivered message	*/
asm-arm/memory.h: *  linux/include/asm-arm/memory.h
asm-arm/memory.h: *  Copyright (C) 2000-2002 Russell King
asm-arm/memory.h: *  Note: this file should not be included by non-asm/.h files
asm-arm/memory.h: * direct-mapped view.  We assume this is the first page
asm-arm/memory.h: * Virtual <-> DMA view memory address translations
asm-arm/memory.h:#define page_to_pfn(page)	(((page) - mem_map) + PHYS_PFN_OFFSET)
asm-arm/memory.h:#define pfn_to_page(pfn)	((mem_map + (pfn)) - PHYS_PFN_OFFSET)
asm-arm/memory.h:#define VALID_PAGE(page)	((page - mem_map) < max_mapnr)
asm-arm/memory.h:	(((page) - page_zone(page)->zone_mem_map)		\
asm-arm/memory.h:	  + (page_zone(page)->zone_start_paddr >> PAGE_SHIFT))
asm-arm/memory.h:	 ((pfn - (nd->node_start_paddr >> PAGE_SHIFT)) < nd->node_size));\
asm-arm/memory.h: * VALID_PAGE returns a non-zero value if given page pointer is valid.
asm-arm/memory.h:     ((unsigned)((page) - NODE_MEM_MAP(node)) < NODE_DATA(node)->node_size)); \
asm-arm/memory.h: * We should really eliminate virt_to_bus() here - it's depreciated.
asm-cris/io.h:       "jump -6809	\n"						\
asm-cris/io.h:/* Etrax shadow registers - which live in arch/cris/kernel/shadows.c */
asm-cris/io.h:/* macro for setting regs through a shadow - 
asm-cris/io.h:/* The LED's on various Etrax-based products are set differently. */
asm-cris/io.h:/* The following is junk needed for the arch-independant code but which
asm-cris/etraxgpio.h: *       g1-g7 and g25-g31 is both input and outputs but on different pins
asm-cris/atomic.h:#define atomic_read(v) ((v)->counter)
asm-cris/atomic.h:#define atomic_set(v,i) (((v)->counter) = (i))
asm-cris/atomic.h:	v->counter += i;
asm-cris/atomic.h:	v->counter -= i;
asm-cris/atomic.h:	retval = (v->counter += i);
asm-cris/atomic.h:	retval = (v->counter -= i);
asm-cris/atomic.h:	retval = (v->counter -= i) == 0;
asm-cris/atomic.h:	(v->counter)++;
asm-cris/atomic.h:	(v->counter)--;
asm-cris/atomic.h:	retval = (v->counter)++;
asm-cris/atomic.h:	retval = (v->counter)--;
asm-cris/atomic.h:	retval = --(v->counter) == 0;
asm-cris/atomic.h:	retval = ++(v->counter) == 0;
asm-cris/delay.h: * Delay routines, using a pre-computed "loops_per_second" value.
asm-cris/ipcbuf.h: * - 32-bit mode_t and seq
asm-cris/ipcbuf.h: * - 2 miscellaneous 32-bit values
asm-cris/shmbuf.h: * - 64-bit time_t to solve y2038 problem
asm-cris/shmbuf.h: * - 2 miscellaneous 32-bit values
asm-cris/bitops.h: *       kernel-doc things (**) for macros are disabled
asm-cris/bitops.h: * Some hacks to defeat gcc over-optimizations..
asm-cris/bitops.h: * set_bit - Atomically set a bit in memory
asm-cris/bitops.h: * restricted to acting on a single-word quantity.
asm-cris/bitops.h: * clear_bit - Clears a bit in memory
asm-cris/bitops.h: * change_bit - Toggle a bit in memory
asm-cris/bitops.h: * restricted to acting on a single-word quantity.
asm-cris/bitops.h: * __change_bit - Toggle a bit in memory
asm-cris/bitops.h: * Unlike change_bit(), this function is non-atomic and may be reordered.
asm-cris/bitops.h: * test_and_set_bit - Set a bit and return its old value
asm-cris/bitops.h: * test_and_clear_bit - Clear a bit and return its old value
asm-cris/bitops.h: * __test_and_clear_bit - Clear a bit and return its old value
asm-cris/bitops.h: * This operation is non-atomic and can be reordered.  
asm-cris/bitops.h: * test_and_change_bit - Change a bit and return its new value
asm-cris/bitops.h: * test_bit - Determine whether a bit is set
asm-cris/bitops.h: * Find-bit routines..
asm-cris/bitops.h: * zeroes of a bits-in-byte and byte-in-word and word-in-dword-swapped
asm-cris/bitops.h:	   confuses gcc (sched.c, gcc from cris-dist-1.14).  */
asm-cris/bitops.h:		? (~w ? (unsigned long) generic_ffs ((int) ~w) - 1 : 32)
asm-cris/bitops.h: * ffz we return the first one-bit *plus one*.
asm-cris/bitops.h: * Since we define it "external", it collides with the built-in
asm-cris/bitops.h: * use -fno-builtin, so just hide the name ffs.
asm-cris/bitops.h: * find_next_zero_bit - find the first zero bit in a memory region
asm-cris/bitops.h:	size -= result;
asm-cris/bitops.h:		tmp |= ~0UL >> (32-offset);
asm-cris/bitops.h:		size -= 32;
asm-cris/bitops.h:		size -= 32;
asm-cris/bitops.h: * find_first_zero_bit - find the first zero bit in a memory region
asm-cris/bitops.h: * Returns the bit-number of the first zero bit, not the number of the byte
asm-cris/bitops.h: * hweightN - returns the hamming weight of a N-bit word
asm-cris/svinto.h:	unsigned short sw_len;                /* 0-1 */
asm-cris/svinto.h:	unsigned short ctrl;                  /* 2-3 */
asm-cris/svinto.h:	unsigned long  next;                  /* 4-7 */
asm-cris/svinto.h:	unsigned long  buf;                   /* 8-11 */
asm-cris/svinto.h:	unsigned short hw_len;                /* 12-13 */
asm-cris/div64.h:/* copy from asm-arm */
asm-cris/div64.h:/* We're not 64-bit, but... */
asm-cris/resource.h:#define RLIMIT_MEMLOCK	8		/* max locked-in-memory address space */
asm-cris/ptrace.h:#define PT_CSRINSTR  20    /* CPU Status record remnants -
asm-cris/ptrace.h:#define PT_USP       23    /* special case - USP is not in the pt_regs */
asm-cris/ptrace.h:/* pt_regs not only specifices the format in the user-struct during
asm-cris/ptrace.h: * when doing a context-switch. it is used (apart from in resume) when a new
asm-cris/ptrace.h:/* bit 8 is user-mode flag */
asm-cris/ptrace.h:#define user_mode(regs) (((regs)->dccr & 0x100) != 0)
asm-cris/ptrace.h:#define instruction_pointer(regs) ((regs)->irp)
asm-cris/pgalloc.h:		       (PTRS_PER_PGD - USER_PTRS_PER_PGD) * sizeof(pgd_t));
asm-cris/pgalloc.h:                pgtable_cache_size--;
asm-cris/pgalloc.h:                pgtable_cache_size--;
asm-cris/unistd.h:/* XXX - _foo needs to be __foo, while __NR_bar could be _NR_bar. */
asm-cris/unistd.h: * any hard-to-spot gcc register allocation bugs.
asm-cris/unistd.h:  errno = -__a; \
asm-cris/unistd.h:  return (type) -1; \
asm-cris/unistd.h:  errno = -__a; \
asm-cris/unistd.h:  return (type) -1; \
asm-cris/unistd.h:  errno = -__a; \
asm-cris/unistd.h:  return (type) -1; \
asm-cris/unistd.h:  errno = -__a; \
asm-cris/unistd.h:  return (type) -1; \
asm-cris/unistd.h:  errno = -__a; \
asm-cris/unistd.h:  return (type) -1; \
asm-cris/unistd.h:  errno = -__a; \
asm-cris/unistd.h:  return (type) -1; \
asm-cris/unistd.h:  errno = -__a; \
asm-cris/unistd.h:  return (type) -1; \
asm-cris/unistd.h: * we need this inline - forking from kernel space will result
asm-cris/unistd.h: * calls - which means inline code for fork too, as otherwise we
asm-cris/unistd.h: * Since we define it "external", it collides with the built-in
asm-cris/unistd.h: * complaints.  We don't want to use -fno-builtin, so just use a
asm-cris/unistd.h:	return waitpid(-1,wait_stat,0);
asm-cris/dma.h:/* TODO: check nbr of channels on Etrax-100LX */
asm-cris/elf.h:   thus exposed to user-space. */
asm-cris/elf.h:#define elf_check_arch(x) ( (x)->e_machine == EM_CRIS )
asm-cris/elf.h:	/* SVR4/i386 ABI (pages 3-31, 3-32) says that when the program
asm-cris/elf.h:	(_r)->r13 = 0; (_r)->r12 = 0; (_r)->r11 = 0; (_r)->r10 = 0; \
asm-cris/elf.h:	(_r)->r9 = 0;  (_r)->r8 = 0;  (_r)->r7 = 0;  (_r)->r6 = 0;  \
asm-cris/elf.h:	(_r)->r5 = 0;  (_r)->r4 = 0;  (_r)->r3 = 0;  (_r)->r2 = 0;  \
asm-cris/elf.h:	(_r)->r1 = 0;  (_r)->r0 = 0;  (_r)->mof = 0; (_r)->srp = 0; \
asm-cris/elf.h:	pr_reg[0] = regs->r0;                              \
asm-cris/elf.h:	pr_reg[1] = regs->r1;                              \
asm-cris/elf.h:	pr_reg[2] = regs->r2;                              \
asm-cris/elf.h:	pr_reg[3] = regs->r3;                              \
asm-cris/elf.h:	pr_reg[4] = regs->r4;                              \
asm-cris/elf.h:	pr_reg[5] = regs->r5;                              \
asm-cris/elf.h:	pr_reg[6] = regs->r6;                              \
asm-cris/elf.h:	pr_reg[7] = regs->r7;                              \
asm-cris/elf.h:	pr_reg[8] = regs->r8;                              \
asm-cris/elf.h:	pr_reg[9] = regs->r9;                              \
asm-cris/elf.h:	pr_reg[10] = regs->r10;                            \
asm-cris/elf.h:	pr_reg[11] = regs->r11;                            \
asm-cris/elf.h:	pr_reg[12] = regs->r12;                            \
asm-cris/elf.h:	pr_reg[13] = regs->r13;                            \
asm-cris/elf.h:	pr_reg[15] = regs->irp;             /* pc */       \
asm-cris/elf.h:	pr_reg[21] = (regs->dccr & 0xffff); /* ccr */      \
asm-cris/elf.h:	pr_reg[23] = regs->mof;             /* mof */      \
asm-cris/elf.h:	pr_reg[27] = regs->srp;             /* srp */      \
asm-cris/elf.h:	pr_reg[29] = regs->dccr;            /* dccr */     \
asm-cris/ide.h: *  linux/include/asm-cris/ide.h
asm-cris/ide.h:#include <asm-generic/ide_iops.h>
asm-cris/ide.h:	 * this has the side-effect that ide-probe.c will cluster our 4 interfaces
asm-cris/ide.h:		hw->io_ports[i] = data_port | 
asm-cris/ide.h:	hw->io_ports[IDE_CONTROL_OFFSET] = data_port |
asm-cris/ide.h:	hw->io_ports[IDE_IRQ_OFFSET] = 0;
asm-cris/irq.h: *	linux/include/asm-cris/irq.h
asm-cris/irq.h:/* dma0-9 is irq 16..25 */
asm-cris/irq.h:  "move $irp,[$sp=$sp-16]\n\t" /* push instruction pointer and fake SBFS struct */ \
asm-cris/irq.h:  "subq 14*4,$sp\n\t"   /* make room for r0-r13 */ \
asm-cris/irq.h:  "movem $r13,[$sp]\n\t" /* push the r0-r13 registers */ \
asm-cris/irq.h:  "clear.d [$sp=$sp-4]\n\t"  /* frametype - this is a normal stackframe */
asm-cris/irq.h: * The non-blocking here is based on the knowledge that the timer interrupt is
asm-cris/mmu.h: *   Bit:  31-13 12-------4    3        2       1       0  
asm-cris/mmu.h:/* Real HW-based PTE bits. We use some synonym names so that
asm-cris/mmu.h: * things become less confusing in combination with the SW-based
asm-cris/mmu.h:#define _PAGE_WE	   (1<<0) /* page is write-enabled */
asm-cris/mmu.h:#define _PAGE_GLOBAL       (1<<3) /* global page - context is ignored */
asm-cris/mmu.h:#define _PAGE_READ      (1<<7)  /* read-enabled */
asm-cris/mmu.h:#define _PAGE_WRITE     (1<<8)  /* write-enabled */
asm-cris/rtc.h:#  define RTC_INIT() (-1)
asm-cris/rtc.h: * source is self contained, allowing cross-compiles, etc. etc.
asm-cris/tlb.h:#include <asm-generic/tlb.h>
asm-cris/signal.h:#define SIGRTMAX        (_NSIG-1)
asm-cris/signal.h: * SA_INTERRUPT is a no-op, but left due to historical reasons. Use the
asm-cris/signal.h:#define SA_INTERRUPT	0x20000000 /* dummy -- ignored */
asm-cris/signal.h:#define SIG_ERR	((__sighandler_t)-1)	/* error return from signal */
asm-cris/signal.h:/* here we could define asm-optimized sigaddset, sigdelset etc. operations. 
asm-cris/rs485.h:/* RS-485 structures */
asm-cris/rs485.h:/* RS-485 support */
asm-cris/setup.h:** asm/setup.h -- Definition of the Linux/m68k boot information structure
asm-cris/setup.h: * Define several Hardware-Chips for indication so that for the ATARI we do
asm-cris/setup.h:		ATARIHW_DECLARE(STND_SHIFTER);	/* ST-Shifter - no base low ! */
asm-cris/setup.h:		ATARIHW_DECLARE(EXTD_SHIFTER);	/* STe-Shifter - 24 bit address */
asm-cris/setup.h:		ATARIHW_DECLARE(TT_SHIFTER);	/* TT-Shifter */
asm-cris/setup.h:		ATARIHW_DECLARE(VIDEL_SHIFTER);	/* Falcon-Shifter */
asm-cris/setup.h:		ATARIHW_DECLARE(PCM_8BIT);	/* PCM-Sound in STe-ATARI */
asm-cris/setup.h:		ATARIHW_DECLARE(ST_SCSI);	/* NCR5380 via ST-DMA (Falcon) */
asm-cris/setup.h:		ATARIHW_DECLARE(ST_MFP);	/* The ST-MFP (there should
asm-cris/setup.h:		ATARIHW_DECLARE(STND_DMA);	/* 24 Bit limited ST-DMA */
asm-cris/setup.h:		ATARIHW_DECLARE(EXTD_DMA);	/* 32 Bit ST-DMA */
asm-cris/setup.h: * avoid user confusion if kernel and bootstrap don't work together :-)
asm-cris/setup.h: * appropriate machine. If a change is backward-compatible, the minor should
asm-cris/setup.h: * be stepped. "Backwards-compatible" means that booting will work, but
asm-cris/hardirq.h:/* only non-SMP supported */
asm-cris/hardirq.h:#define irq_exit(cpu)       (local_irq_count(cpu)--)
asm-cris/shmparam.h:/* same as asm-i386/ version.. */
asm-cris/processor.h: * include/asm-cris/processor.h
asm-cris/processor.h: * CRIS does not do any hardware task-switching, but it's here for legacy reasons.
asm-cris/processor.h: * The thread_struct here is used when task-switching using _resume defined in entry.S.
asm-cris/processor.h: * The offsets here are hardcoded into _resume - if you change this struct, you need to
asm-cris/processor.h: * At user->kernel entry, the pt_regs struct is stacked on the top of the kernel-stack.
asm-cris/processor.h: * we're in the kernel, won't affect this - only the first user->kernel transition
asm-cris/processor.h:#define user_regs(task) (((struct pt_regs *)((unsigned long)(task) + THREAD_SIZE)) - 1)
asm-cris/processor.h: * set user-mode (The 'U' flag (User mode flag) is CCR/DCCR bit 8) 
asm-cris/processor.h: * switch user-stackpointer
asm-cris/processor.h:	regs->irp = ip;       \
asm-cris/processor.h:	regs->dccr |= 1 << U_DCCR_BITNR; \
asm-cris/processor.h:              eip = ((struct pt_regs *)regs)->irp; \
asm-cris/processor.h:#define KSTK_ESP(tsk)   ((tsk) == current ? rdusp() : (tsk)->thread.usp)
asm-cris/processor.h:	return (unsigned long)user_regs(t)->irp;
asm-cris/processor.h:#define get_task_struct(tsk) atomic_inc(&virt_to_page(tsk)->count)
asm-cris/mmu_context.h:/* current active pgd - this is similar to other processors pgd 
asm-cris/semaphore.h: * CRIS semaphores, implemented in C-only so far.
asm-cris/semaphore.h:/* notice - we probably can do cli/sti here instead of saving */
asm-cris/semaphore.h:	CHECK_MAGIC(sem->__magic);
asm-cris/semaphore.h:	failed = --(sem->count) < 0;
asm-cris/semaphore.h:	CHECK_MAGIC(sem->__magic);
asm-cris/semaphore.h:	failed = --(sem->count) < 0;
asm-cris/semaphore.h:	CHECK_MAGIC(sem->__magic);
asm-cris/semaphore.h:	failed = --(sem->count) < 0;
asm-cris/semaphore.h:	CHECK_MAGIC(sem->__magic);
asm-cris/semaphore.h:	wakeup = ++(sem->count) <= 0;
asm-cris/semaphore.h:	return sem->count;
asm-cris/fcntl.h:/* open/fcntl - O_SYNC is only implemented on blocks devices and on files
asm-cris/fcntl.h:#define O_DIRECT	 040000	/* direct disk access hint - currently ignored */
asm-cris/sync_serial.h: * Copyright (c) 2001-2003 Axis Communications AB
asm-cris/sync_serial.h:#define GET_WORD_RATE(x) (((x & 0x0fff0000) >> 16) - 1)
asm-cris/sync_serial.h:#define GET_FRAME_RATE(x) (((x & 0xf0000000) >> 28) - 1)
asm-cris/locks.h:	while(lock_set_bit(0,&sp->lock))
asm-cris/locks.h:		if(sp->cpu==processor)
asm-cris/locks.h:			sp->users++;
asm-cris/locks.h:		while(sp->lock)
asm-cris/locks.h:			sp->spins++;
asm-cris/locks.h:	sp->users++;sp->cpu=processor;
asm-cris/locks.h:	if(!--sp->users)
asm-cris/locks.h:		lock_clear_bit(0,&sp->lock);sp->cpu= NO_PROC_ID;
asm-cris/locks.h:	if(lock_set_bit(0,&sp->lock))
asm-cris/locks.h:	sp->users++;
asm-cris/locks.h:	if(sp->priority<current->lock_order)
asm-cris/locks.h:		panic("lock order violation: %s (%d)\n", sp->name, current->lock_order);
asm-cris/locks.h:		sp->oldpri=current->lock_order;
asm-cris/locks.h:		current->lock_order=sp->priority;
asm-cris/locks.h:	if(current->lock_order!=sp->priority)
asm-cris/locks.h:		panic("lock release order violation %s (%d)\n", sp->name, current->lock_order);
asm-cris/locks.h:		current->lock_order=sp->oldpri;
asm-cris/errno.h:/* verbatim copy of asm-i386/errno.h */
asm-cris/errno.h:#define	EXDEV		18	/* Cross-device link */
asm-cris/errno.h:#define	EROFS		30	/* Read-only file system */
asm-cris/errno.h:#define	ENOTSOCK	88	/* Socket operation on non-socket */
asm-cris/byteorder.h: * asm instruction in CRIS) and the arch-independent files will put
asm-cris/fasttimer.h: * linux/include/asm-cris/fasttimer.h
asm-cris/fasttimer.h:  return (t->next != NULL) || (t->prev != NULL) || (t == fast_timer_list);
asm-cris/softirq.h:        local_bh_count(smp_processor_id())--;   \
asm-cris/softirq.h:        if (!--local_bh_count(smp_processor_id())       \
asm-cris/timex.h: * linux/include/asm-cris/timex.h
asm-cris/timex.h: * 2002-03-04    Johan Adolfsson
asm-cris/timex.h:  ( (TIMER0_DIV - *R_TIMER0_DATA) * (1000000/HZ)/TIMER0_DIV )
asm-cris/timex.h: * We don't have a cycle-counter.. but we do not support SMP anyway where this is
asm-cris/bugs.h: *  include/asm-cris/bugs.h
asm-cris/bugs.h: * This is included by init/main.c to check for architecture-dependent bugs.
asm-cris/namei.h: * linux/include/asm-cris/namei.h
asm-cris/namei.h:/* used to find file-system prefixes for doing emulations
asm-cris/namei.h: * see for example asm-sparc/namei.h
asm-cris/sv_addr_ag.h:/*------------------------------------------------------------
asm-cris/sv_addr_ag.h:!*-----------------------------------------------------------*/
asm-cris/sv_addr_ag.h:    ( ( ( 1 << reg_##_##field_##_WIDTH ) - 1 ) << reg_##_##field_##_BITNR )
asm-cris/sv_addr_ag.h:     - 1 ) << reg_##_##field_##_BITNR ) & (val)) >> reg_##_##field_##_BITNR )
asm-cris/sv_addr_ag.h:/*--- Obsolete. Kept for backw compatibility. ---*/
asm-cris/sv_addr_ag.h:/*------------------------------------------------------------
asm-cris/sv_addr_ag.h:!*-----------------------------------------------------------*/
asm-cris/sv_addr_ag.h:/*------------------------------------------------------------
asm-cris/sv_addr_ag.h:!*-----------------------------------------------------------*/
asm-cris/sv_addr_ag.h:/*------------------------------------------------------------*/
asm-cris/uaccess.h: *	       Hans-Peter Nilsson (hp@axis.com)
asm-cris/uaccess.h: * Remove unused copy-pasted register clobber from __asm_clear
asm-cris/uaccess.h: * Add support for 64-bit put_user/get_user
asm-cris/uaccess.h: * - Provide implementation for everything else but get_user and put_user;
asm-cris/uaccess.h: * - Constraints for destination addr in get_user cannot be memory, only reg.
asm-cris/uaccess.h: * - Correct labels for PC at expected fault points.
asm-cris/uaccess.h: * - Nits with assembly code.
asm-cris/uaccess.h: * - Don't use statement expressions without value; use "do {} while (0)".
asm-cris/uaccess.h: * - Return correct values from __generic_... functions.
asm-cris/uaccess.h: * New user-access functions
asm-cris/uaccess.h:   Register $r9 is chosen for temporaries, being a call-clobbered register
asm-cris/uaccess.h:#define get_fs()	(current->addr_limit)
asm-cris/uaccess.h:#define set_fs(x)	(current->addr_limit = (x))
asm-cris/uaccess.h:#define __user_ok(addr,size) (((size) <= TASK_SIZE)&&((addr) <= TASK_SIZE-(size)))
asm-cris/uaccess.h:	return access_ok(type,addr,size) ? 0 : -EFAULT;
asm-cris/uaccess.h: * These are the main single-value transfer routines.  They automatically
asm-cris/uaccess.h:	long __pu_err = -EFAULT;				\
asm-cris/uaccess.h:		: "r" (x), "r" (addr), "g" (-EFAULT), "0" (err))
asm-cris/uaccess.h:		: "r" (x), "r" (addr), "g" (-EFAULT), "0" (err))
asm-cris/uaccess.h:	long __gu_err = -EFAULT, __gu_val = 0;				\
asm-cris/uaccess.h:		: "r" (addr), "g" (-EFAULT), "0" (err))
asm-cris/uaccess.h:		: "r" (addr), "g" (-EFAULT), "0" (err))
asm-cris/uaccess.h: * -EFAULT		for an exception
asm-cris/uaccess.h:	 * Currently, in 2.4.0-test9, most ports use a simple byte-copy loop.
asm-cris/uaccess.h:	 *	       && --tmp1)
asm-cris/uaccess.h:	 *	res = count - tmp1;
asm-cris/uaccess.h:		   being a delay-slot filler.  However, the branch-target
asm-cris/uaccess.h:		: "3" (count), "1" (dst), "2" (src), "g" (-EFAULT)
asm-cris/uaccess.h:	long res = -EFAULT;
asm-cris/uaccess.h:   Note again, a post-increment is performed regardless of whether a bus
asm-cris/uaccess.h:/* And now, the to-user ones.  */
asm-cris/uaccess.h:/* This frame-asm is like the __asm_copy_user_cont one, but has one less
asm-cris/uaccess.h:	 *	while (tmp1-- > 0 && *s++)
asm-cris/uaccess.h:	 *	res = n - tmp1;
asm-cris/uaccess.h:		   being a delay-slot filler.  However, the branch-target
asm-cris/eshlibld.h:*!---------------------------------------------------------------------------
asm-cris/eshlibld.h:*! (C) Copyright 1998-2003 Axis Communications AB, LUND, SWEDEN
asm-cris/eshlibld.h:   Try to avoid breaking its double use (only works on a little-endian
asm-cris/eshlibld.h:   32-bit machine such as the i386 anyway).
asm-cris/eshlibld.h:   Use __CRIS__ when you're about to do (really) CRIS-specific code.
asm-cris/eshlibld.h:				 position-independent code. */
asm-cris/eshlibld.h:/* Task-specific debug stuff. */
asm-cris/semaphore-helper.h: * SMP- and interrupt-safe semaphores helper functions. Generic versions, no
asm-cris/semaphore-helper.h:#define read(a) ((a)->counter)
asm-cris/semaphore-helper.h:#define inc(a) (((a)->counter)++)
asm-cris/semaphore-helper.h:#define dec(a) (((a)->counter)--)
asm-cris/semaphore-helper.h:	atomic_inc(&sem->waking);
asm-cris/semaphore-helper.h:	if (read(&sem->waking) > 0) {
asm-cris/semaphore-helper.h:		dec(&sem->waking);
asm-cris/semaphore-helper.h:	if (read(&sem->waking) > 0) {
asm-cris/semaphore-helper.h:		dec(&sem->waking);
asm-cris/semaphore-helper.h:		count_inc(&sem->count);
asm-cris/semaphore-helper.h:		ret = -EINTR;
asm-cris/semaphore-helper.h:	if (read(&sem->waking) <= 0)
asm-cris/semaphore-helper.h:		count_inc(&sem->count);
asm-cris/semaphore-helper.h:		dec(&sem->waking);
asm-cris/mman.h:/* verbatim copy of asm-i386/ version */
asm-cris/mman.h:#define MAP_GROWSDOWN	0x0100		/* stack-like segment */
asm-cris/mman.h:#define MADV_NORMAL	0x0		/* default page-in behavior */
asm-cris/mman.h:#define MADV_RANDOM	0x1		/* page-in minimum required */
asm-cris/mman.h:#define MADV_SEQUENTIAL	0x2		/* read-ahead aggressively */
asm-cris/mman.h:#define MADV_WILLNEED	0x3		/* pre-fault pages */
asm-cris/posix_types.h:/* We cheat a bit and use our C-coded bitops functions from asm/bitops.h */
asm-cris/posix_types.h: * This file is generally used by user-level software, so you need to
asm-cris/scatterlist.h:	/* The following is i386 highmem junk - not used by us */
asm-cris/page.h:#define PAGE_MASK	(~(PAGE_SIZE-1))
asm-cris/page.h: * These are used to make use of C type-checking..
asm-cris/page.h:#define PAGE_ALIGN(addr)	(((addr)+PAGE_SIZE-1)&PAGE_MASK)
asm-cris/page.h:	size = (size-1) >> (PAGE_SHIFT-1);
asm-cris/page.h:	order = -1;
asm-cris/page.h: * we start our mem_map there - in other ports they map mem_map physically and
asm-cris/page.h:#define virt_to_page(kaddr)    (mem_map + (((unsigned long)kaddr - PAGE_OFFSET) >> PAGE_SHIFT))
asm-cris/page.h:#define VALID_PAGE(page)       ((page - mem_map) < max_mapnr)
asm-cris/hdreg.h: *  linux/include/asm-cris/hdreg.h
asm-cris/poll.h:/* taken from asm-alpha */
asm-cris/types.h:/* Dma addresses are 32-bits wide, just like our other addresses.  */
asm-cris/sembuf.h: * - 64-bit time_t to solve y2038 problem
asm-cris/sembuf.h: * - 2 miscellaneous 32-bit values
asm-cris/smp_lock.h:	if(! --kernel_counter) 
asm-cris/system.h:					 (int)&((struct task_struct *)0)->thread)
asm-cris/system.h:/* read/write the user-mode stackpointer */
asm-cris/system.h:/* If you only want to log changes - change to 1 to a 0 below */
asm-cris/stat.h:/* Keep this a verbatim copy of i386 version; tweak CRIS-specific bits in
asm-cris/stat.h:	unsigned long	st_blocks;	/* Number 512-byte blocks allocated. */
asm-cris/checksum.h: * and adds in "sum" (32-bit)
asm-cris/checksum.h: * returns a 32-bit number suitable for feeding into itself
asm-cris/checksum.h: * it's best to have buff aligned on a 32-bit boundary
asm-cris/checksum.h: * here even more important to align src and dst on a 32-bit (or even
asm-cris/checksum.h: * better 64-bit) boundary
asm-cris/checksum.h:		sum = (sum & 0xffff) + (sum >> 16); /* add in end-around carry */
asm-cris/checksum.h: * The gain by doing this in asm is that C will not generate carry-additions
asm-cris/checksum.h: * for the 32-bit components of the checksum, so otherwise we would have had
asm-cris/checksum.h: * to split all of those into 16-bit components, then add.
asm-cris/checksum.h: * computes the checksum of the TCP/UDP pseudo-header
asm-cris/checksum.h: * returns a 16-bit checksum, already complemented
asm-cris/checksum.h: * this routine is used for miscellaneous IP-like checksums, mainly
asm-cris/termios.h:#define N_IRDA		11	/* Linux IR - http://irda.sourceforge.net/ */
asm-cris/termios.h:#define N_SMSBLOCK	12	/* SMS block mode - for talking to GSM data cards about SMS messages */
asm-cris/termios.h:	get_user(__tmp,&(termio)->x); \
asm-cris/termios.h:	*(unsigned short *) &(termios)->x = __tmp; \
asm-cris/termios.h:	copy_from_user((termios)->c_cc, (termio)->c_cc, NCC); \
asm-cris/termios.h:	put_user((termios)->c_iflag, &(termio)->c_iflag); \
asm-cris/termios.h:	put_user((termios)->c_oflag, &(termio)->c_oflag); \
asm-cris/termios.h:	put_user((termios)->c_cflag, &(termio)->c_cflag); \
asm-cris/termios.h:	put_user((termios)->c_lflag, &(termio)->c_lflag); \
asm-cris/termios.h:	put_user((termios)->c_line,  &(termio)->c_line); \
asm-cris/termios.h:	copy_to_user((termio)->c_cc, (termios)->c_cc, NCC); \
asm-cris/user.h: * linux we use the `trad-core' bfd).  The file contents are as follows:
asm-cris/user.h: *  data: The data segment follows next.  We use current->end_text to
asm-cris/user.h: *	current->brk to pick up all of the user variables, plus any memory
asm-cris/user.h: *	page is demand-zero or if a page is totally unused, we just cover
asm-cris/user.h: *	current->start_stack, so we round each of these in order to be able
asm-cris/user.h:        unsigned long usp;      /* User-mode stack pointer. Same as sp when 
asm-cris/pgtable.h:/* CRIS pgtable.h - macros and functions to manipulate page tables
asm-cris/pgtable.h: * * extern inline -> static inline
asm-cris/pgtable.h: * * include asm-generic/pgtable.h
asm-cris/pgtable.h: * 2.4.0-test6 modifications:
asm-cris/pgtable.h: * Plus some comments and type-clarifications.
asm-cris/pgtable.h: * pmd_bad should recognize both kernel and user page-tables
asm-cris/pgtable.h: *   Hence we need to strip bit 31 so 0xcXXXXXXX -> 0x4XXXXXXX.
asm-cris/pgtable.h: * PAGE_DIRTY -> PAGE_SILENT_WRITE, removed PAGE_COW from PAGE_COPY.
asm-cris/pgtable.h: * Copied from include/asm-etrax100. For the new CRIS architecture.
asm-cris/pgtable.h: * The Linux memory management assumes a three-level page table setup. On
asm-cris/pgtable.h: * CRIS, we use that, but "fold" the mid level into the top-level page
asm-cris/pgtable.h: * supports any page table structure, so we could have used a three-level
asm-cris/pgtable.h: * setup, but for the amounts of memory we normally use, a two-level is
asm-cris/pgtable.h: *  - flush_tlb() flushes the current mm struct TLBs
asm-cris/pgtable.h: *  - flush_tlb_all() flushes all processes TLBs
asm-cris/pgtable.h: *  - flush_tlb_mm(mm) flushes the specified mm context TLB's
asm-cris/pgtable.h: *  - flush_tlb_page(vma, vmaddr) flushes one page
asm-cris/pgtable.h: *  - flush_tlb_range(mm, start, end) flushes a range of pages
asm-cris/pgtable.h:	flush_tlb_mm(current->mm);
asm-cris/pgtable.h:/* PMD_SHIFT determines the size of the area a second-level page table can
asm-cris/pgtable.h: * a PMD page. A PTE is 4-bytes in CRIS. Hence the following number.
asm-cris/pgtable.h:#define PMD_SHIFT	(PAGE_SHIFT + (PAGE_SHIFT-2))
asm-cris/pgtable.h:#define PMD_MASK	(~(PMD_SIZE-1))
asm-cris/pgtable.h:/* PGDIR_SHIFT determines what a third-level page table entry can map.
asm-cris/pgtable.h: * Since we fold into a two-level structure, this is the same as PMD_SHIFT.
asm-cris/pgtable.h:#define PGDIR_MASK	(~(PGDIR_SIZE-1))
asm-cris/pgtable.h: * entries per page directory level: we use a two-level, so
asm-cris/pgtable.h:#define PTRS_PER_PTE	(1UL << (PAGE_SHIFT-2))
asm-cris/pgtable.h:#define PTRS_PER_PGD	(1UL << (PAGE_SHIFT-2))
asm-cris/pgtable.h:/* calculate how many PGD entries a user-level program can use
asm-cris/pgtable.h: * defined in asm-cris/mmu.h, and these are just combinations of those.
asm-cris/pgtable.h:#define PTR_MASK			(~(sizeof(void*)-1))
asm-cris/pgtable.h:/* 64-bit machines, beware!  SRB. */
asm-cris/pgtable.h:/* to find an entry in a page-table */
asm-cris/pgtable.h:((unsigned long)(address)>>(PAGE_SHIFT-SIZEOF_PTR_LOG2)&PTR_MASK&~PAGE_MASK)
asm-cris/pgtable.h:/* to set the page-dir */
asm-cris/pgtable.h: * The "pgd_xxx()" functions here are trivial for a folded two-level
asm-cris/pgtable.h: * pte_pagenr refers to the page-number counted starting from the virtual DRAM start
asm-cris/pgtable.h:#define pte_pagenr(pte)         ((__pte_page(pte) - PAGE_OFFSET) >> PAGE_SHIFT)
asm-cris/pgtable.h:#define __page_address(page)    (PAGE_OFFSET + (((page) - mem_map) << PAGE_SHIFT))
asm-cris/pgtable.h:/* to find an entry in a page-table-directory. */
asm-cris/pgtable.h:#define pgd_index(address) ((address >> PGDIR_SHIFT) & (PTRS_PER_PGD-1))
asm-cris/pgtable.h:/* to find an entry in a page-table-directory */
asm-cris/pgtable.h:	return mm->pgd + pgd_index(address);
asm-cris/pgtable.h:/* to find an entry in a kernel page-table-directory */
asm-cris/pgtable.h:/* Find an entry in the second-level page table.. */
asm-cris/pgtable.h:/* Find an entry in the third-level page table.. */ 
asm-cris/pgtable.h:	return (pte_t *) pmd_page(*dir) + ((address >> PAGE_SHIFT) & (PTRS_PER_PTE - 1));
asm-cris/pgtable.h:/* Encode and de-code a swap entry (must be !pte_none(e) && !pte_present(e)) */
asm-cris/pgtable.h:#include <asm-generic/pgtable.h>
asm-cris/param.h:#define NOGROUP		(-1)
asm-cris/cache.h:/* Etrax 100LX have 32-byte cache-lines. When we add support for future chips
asm-cris/siginfo.h:/* This is copied from asm-m68k/siginfo.h.  */
asm-cris/siginfo.h:#define SI_PAD_SIZE	((SI_MAX_SIZE/sizeof(int)) - 3)
asm-cris/siginfo.h: * Digital reserves positive values for kernel-generated signals.
asm-cris/siginfo.h:#define SI_QUEUE	-1		/* sent by sigqueue */
asm-cris/siginfo.h:#define SI_TIMER __SI_CODE(__SI_TIMER,-2) /* sent by timer expiration */
asm-cris/siginfo.h:#define SI_MESGQ	-3		/* sent by real time mesq state change */
asm-cris/siginfo.h:#define SI_ASYNCIO	-4		/* sent by AIO completion */
asm-cris/siginfo.h:#define SI_SIGIO	-5		/* sent by queued SIGIO */
asm-cris/siginfo.h:#define SI_TKILL	-6		/* sent by tkill system call */
asm-cris/siginfo.h:#define SI_FROMUSER(siptr)	((siptr)->si_code <= 0)
asm-cris/siginfo.h:#define SI_FROMKERNEL(siptr)	((siptr)->si_code > 0)
asm-cris/siginfo.h:#define BUS_ADRERR	(__SI_FAULT|2)	/* non-existant physical address */
asm-cris/siginfo.h:#define SIGEV_PAD_SIZE	((SIGEV_MAX_SIZE/sizeof(int)) - 3)
asm-cris/siginfo.h:	if (from->si_code < 0)
asm-cris/siginfo.h:		memcpy(to, from, 3*sizeof(int) + sizeof(from->_sifields._sigchld));
asm-cris/sockios.h:/* Socket-level I/O control calls. */
asm-cris/axisflashmap.h:   instruction and delay-slot is modified elsewhere (for example the
asm-cris/axisflashmap.h:   mkptable script); don't change this to fill the delay-slot.  */
asm-cris/ioctl.h: * NOTE: This limits the max parameter size to 16kB -1 !
asm-cris/ioctl.h:#define _IOC_NRMASK	((1 << _IOC_NRBITS)-1)
asm-cris/ioctl.h:#define _IOC_TYPEMASK	((1 << _IOC_TYPEBITS)-1)
asm-cris/ioctl.h:#define _IOC_SIZEMASK	((1 << _IOC_SIZEBITS)-1)
asm-cris/ioctl.h:#define _IOC_DIRMASK	((1 << _IOC_DIRBITS)-1)
asm-cris/ioctls.h:/* verbatim copy of asm-i386/ioctls.h */
asm-cris/ioctls.h:#define TIOCGPTN	_IOR('T',0x30, unsigned int) /* Get Pty Number (of pty-mux device) */
asm-cris/ioctls.h:#define TIOCSERSETRS485 0x5460  /* enable rs-485 */
asm-cris/ioctls.h:#define TIOCSERWRRS485  0x5461  /* write rs-485 */
asm-cris/msgbuf.h:/* verbatim copy of asm-i386 version */
asm-cris/msgbuf.h: * - 64-bit time_t to solve y2038 problem
asm-cris/msgbuf.h: * - 2 miscellaneous 32-bit values
asm-cris/socket.h:/* almost the same as asm-i386/socket.h */
asm-cris/socket.h:/* Security levels - as per NRL IPv6 - don't actually do anything */
asm-cris/socket.h:#define SOCK_RDM        4               /* reliably-delivered message   */
asm-generic/bitops.h: * architecture, here are some C-language equivalents.  You should
asm-generic/bitops.h: * Alpha architecture or to a Cray.  :-)
asm-generic/bitops.h: * of bits set) of a N-bit word
asm-generic/tlb.h:/* asm-generic/tlb.h
asm-generic/tlb.h: * be per-CPU or per-MM as the page table lock is held for the duration of TLB
asm-generic/tlb.h:	tlb->mm = mm;
asm-generic/tlb.h:	tlb->nr = (atomic_read(&(mm)->mm_users) == 1) ? ~0UL : 0UL;
asm-generic/tlb.h:		if ((ctxp)->nr == ~0UL) {\
asm-generic/tlb.h:		if (!(ctxp)->nr) \
asm-generic/tlb.h:			(ctxp)->start_addr = (addr);\
asm-generic/tlb.h:		(ctxp)->ptes[(ctxp)->nr++] = ptep_get_and_clear(pte);\
asm-generic/tlb.h:		(ctxp)->end_addr = (addr) + PAGE_SIZE;\
asm-generic/tlb.h:		if ((ctxp)->nr >= FREE_PTE_NR)\
asm-generic/tlb.h:	if (ctx->nr == ~0UL) {
asm-generic/tlb.h:		flush_tlb_range(ctx->mm, start, end);
asm-generic/tlb.h:	nr = ctx->nr;
asm-generic/tlb.h:	ctx->nr = 0;
asm-generic/tlb.h:		flush_tlb_range(ctx->mm, ctx->start_addr, ctx->end_addr);
asm-generic/tlb.h:		pte_t pte = ctx->ptes[i];
asm-generic/xor.h: * include/asm-generic/xor.h
asm-generic/xor.h: * Generic optimized RAID-5 checksumming functions.
asm-generic/xor.h:	} while (--lines > 0);
asm-generic/xor.h:	} while (--lines > 0);
asm-generic/xor.h:	} while (--lines > 0);
asm-generic/xor.h:	} while (--lines > 0);
asm-generic/xor.h:	} while (--lines > 0);
asm-generic/xor.h:	} while (--lines > 0);
asm-generic/xor.h:	} while (--lines > 0);
asm-generic/xor.h:	} while (--lines > 0);
asm-generic/ide_iops.h:	while (count--) {
asm-generic/ide_iops.h:	while (count--) {
asm-generic/ide_iops.h:	while (count--) {
asm-generic/ide_iops.h:	while (count--) {
asm-generic/smplock.h:	if (task->lock_depth >= 0) \
asm-generic/smplock.h: * Re-acquire the kernel lock
asm-generic/smplock.h:	if (task->lock_depth >= 0) \
asm-generic/smplock.h:	if (!++current->lock_depth)
asm-generic/smplock.h:	if (--current->lock_depth < 0)
asm-generic/unaligned.h: * architecture, here are some C-language equivalents. 
asm-i386/apicdef.h: * tested, but we might eventually use this one in the future - the
asm-i386/apicdef.h: * errata which cannot take 8-bit reads and writes, only 32-bit ones ...
asm-i386/apicdef.h:/*320*/	struct { /* LVT - Timer */
asm-i386/apicdef.h:/*340*/	struct { /* LVT - Performance Counter */
asm-i386/apicdef.h:/*350*/	struct { /* LVT - LINT0 */
asm-i386/apicdef.h:/*360*/	struct { /* LVT - LINT1 */
asm-i386/apicdef.h:/*370*/	struct { /* LVT - Error */
asm-i386/io.h: * versions of the single-IO instructions (inb_p/inw_p/..).
asm-i386/io.h: * Thanks to James van Artsdalen for a better timing-fix than
asm-i386/io.h: * On the other hand, I'd like to be sure of a non-existent port:
asm-i386/io.h:  *  - Arnaldo Carvalho de Melo <acme@conectiva.com.br>
asm-i386/io.h: *	virt_to_phys	-	map virtual addresses to physical
asm-i386/io.h: *	phys_to_virt	-	map physical address to virtual
asm-i386/io.h:#define page_to_phys(page)	((u64)(page - mem_map) << PAGE_SHIFT)
asm-i386/io.h:#define page_to_phys(page)	((page - mem_map) << PAGE_SHIFT)
asm-i386/io.h: *	ioremap		-	map bus memory into CPU space
asm-i386/io.h: *	ioremap_nocache		-	map bus memory into CPU space
asm-i386/io.h: * bt_ioremap() and bt_iounmap() are for temporary early boot-time
asm-i386/io.h: * A boot-time mapping is currently limited to at most 16 pages.
asm-i386/io.h: * to PAGE_OFFSET is pure coincidence - it does not mean ISA values
asm-i386/io.h: * used as the IO-area pointer (it can be iounmapped as well, so the
asm-i386/io.h: *	check_signature		-	find BIOS signatures
asm-i386/io.h:		length--;
asm-i386/io.h: *	isa_check_signature		-	find BIOS signatures
asm-i386/io.h:		length--;
asm-i386/atomic.h: * atomic_read - read atomic variable
asm-i386/atomic.h:#define atomic_read(v)		((v)->counter)
asm-i386/atomic.h: * atomic_set - set atomic variable
asm-i386/atomic.h:#define atomic_set(v,i)		(((v)->counter) = (i))
asm-i386/atomic.h: * atomic_add - add integer to atomic variable
asm-i386/atomic.h:		:"=m" (v->counter)
asm-i386/atomic.h:		:"ir" (i), "m" (v->counter));
asm-i386/atomic.h: * atomic_sub - subtract the atomic variable
asm-i386/atomic.h:		:"=m" (v->counter)
asm-i386/atomic.h:		:"ir" (i), "m" (v->counter));
asm-i386/atomic.h: * atomic_sub_and_test - subtract value from variable and test result
asm-i386/atomic.h:		:"=m" (v->counter), "=qm" (c)
asm-i386/atomic.h:		:"ir" (i), "m" (v->counter) : "memory");
asm-i386/atomic.h: * atomic_inc - increment atomic variable
asm-i386/atomic.h:		:"=m" (v->counter)
asm-i386/atomic.h:		:"m" (v->counter));
asm-i386/atomic.h: * atomic_dec - decrement atomic variable
asm-i386/atomic.h:		:"=m" (v->counter)
asm-i386/atomic.h:		:"m" (v->counter));
asm-i386/atomic.h: * atomic_dec_and_test - decrement and test
asm-i386/atomic.h:		:"=m" (v->counter), "=qm" (c)
asm-i386/atomic.h:		:"m" (v->counter) : "memory");
asm-i386/atomic.h: * atomic_inc_and_test - increment and test 
asm-i386/atomic.h:		:"=m" (v->counter), "=qm" (c)
asm-i386/atomic.h:		:"m" (v->counter) : "memory");
asm-i386/atomic.h: * atomic_add_negative - add and test if negative
asm-i386/atomic.h:		:"=m" (v->counter), "=qm" (c)
asm-i386/atomic.h:		:"ir" (i), "m" (v->counter) : "memory");
asm-i386/atomic.h:/* These are x86-specific, used by some header files */
asm-i386/ipcbuf.h: * - 32-bit mode_t and seq
asm-i386/ipcbuf.h: * - 2 miscellaneous 32-bit values
asm-i386/parport.h: * parport.h: ia32-specific parport initialisation
asm-i386/shmbuf.h: * - 64-bit time_t to solve y2038 problem
asm-i386/shmbuf.h: * - 2 miscellaneous 32-bit values
asm-i386/bitops.h: * These have to be done with inline assembly: that way the bit-setting
asm-i386/bitops.h: * set_bit - Atomically set a bit in memory
asm-i386/bitops.h: * restricted to acting on a single-word quantity.
asm-i386/bitops.h: * __set_bit - Set a bit in memory
asm-i386/bitops.h: * Unlike set_bit(), this function is non-atomic and may be reordered.
asm-i386/bitops.h: * clear_bit - Clears a bit in memory
asm-i386/bitops.h: * __change_bit - Toggle a bit in memory
asm-i386/bitops.h: * Unlike change_bit(), this function is non-atomic and may be reordered.
asm-i386/bitops.h: * change_bit - Toggle a bit in memory
asm-i386/bitops.h: * restricted to acting on a single-word quantity.
asm-i386/bitops.h: * test_and_set_bit - Set a bit and return its old value
asm-i386/bitops.h: * __test_and_set_bit - Set a bit and return its old value
asm-i386/bitops.h: * This operation is non-atomic and can be reordered.  
asm-i386/bitops.h: * test_and_clear_bit - Clear a bit and return its old value
asm-i386/bitops.h: * __test_and_clear_bit - Clear a bit and return its old value
asm-i386/bitops.h: * This operation is non-atomic and can be reordered.  
asm-i386/bitops.h: * test_and_change_bit - Change a bit and return its new value
asm-i386/bitops.h:#if 0 /* Fool kernel-doc since it doesn't do macros yet */
asm-i386/bitops.h: * test_bit - Determine whether a bit is set
asm-i386/bitops.h: * find_first_zero_bit - find the first zero bit in a memory region
asm-i386/bitops.h: * Returns the bit-number of the first zero bit, not the number of the byte
asm-i386/bitops.h:		"movl $-1,%%eax\n\t"
asm-i386/bitops.h:		"xorl -4(%%edi),%%eax\n\t"
asm-i386/bitops.h: * find_next_zero_bit - find the first zero bit in a memory region
asm-i386/bitops.h:		if (set < (32 - bit))
asm-i386/bitops.h:		set = 32 - bit;
asm-i386/bitops.h:	res = find_first_zero_bit (p, size - 32 * (p - (unsigned long *) addr));
asm-i386/bitops.h: * ffz - find first zero in word.
asm-i386/bitops.h: * ffs - find first bit set
asm-i386/bitops.h:		"movl $-1,%0\n"
asm-i386/bitops.h: * hweightN - returns the hamming weight of a N-bit word
asm-i386/resource.h:#define RLIMIT_MEMLOCK	8		/* max locked-in-memory address space */
asm-i386/ptrace.h:#define user_mode(regs) ((VM_MASK & (regs)->eflags) || (3 & (regs)->xcs))
asm-i386/ptrace.h:#define instruction_pointer(regs) ((regs)->eip)
asm-i386/pgalloc.h:			(PTRS_PER_PGD - USER_PTRS_PER_PGD) * sizeof(pgd_t));
asm-i386/pgalloc.h:	for (i--; i >= 0; i--)
asm-i386/pgalloc.h:		free_page((unsigned long)__va(pgd_val(pgd[i])-1));
asm-i386/pgalloc.h:			(PTRS_PER_PGD - USER_PTRS_PER_PGD) * sizeof(pgd_t));
asm-i386/pgalloc.h:		pgtable_cache_size--;
asm-i386/pgalloc.h:		free_page((unsigned long)__va(pgd_val(pgd[i])-1));
asm-i386/pgalloc.h:		pgtable_cache_size--;
asm-i386/pgalloc.h: * allocating and freeing a pmd is trivial: the 1-entry pmd is
asm-i386/pgalloc.h: *  - flush_tlb() flushes the current mm struct TLBs
asm-i386/pgalloc.h: *  - flush_tlb_all() flushes all processes TLBs
asm-i386/pgalloc.h: *  - flush_tlb_mm(mm) flushes the specified mm context TLB's
asm-i386/pgalloc.h: *  - flush_tlb_page(vma, vmaddr) flushes one page
asm-i386/pgalloc.h: *  - flush_tlb_range(mm, start, end) flushes a range of pages
asm-i386/pgalloc.h: *  - flush_tlb_pgtables(mm, start, end) flushes a range of page tables
asm-i386/pgalloc.h: * and page-granular flushes are available only on i486 and up.
asm-i386/pgalloc.h:	if (mm == current->active_mm)
asm-i386/pgalloc.h:	if (vma->vm_mm == current->active_mm)
asm-i386/pgalloc.h:	if (mm == current->active_mm)
asm-i386/unistd.h:/* user-visible error numbers are in the range -1 - -124: see <asm-i386/errno.h> */
asm-i386/unistd.h:	if ((unsigned long)(res) >= (unsigned long)(-125)) { \
asm-i386/unistd.h:		errno = -(res); \
asm-i386/unistd.h:		res = -1; \
asm-i386/unistd.h:/* XXX - _foo needs to be __foo, while __NR_bar could be _NR_bar. */
asm-i386/unistd.h: * we need this inline - forking from kernel space will result
asm-i386/unistd.h: * calls - which means inline code for fork too, as otherwise we
asm-i386/unistd.h:	return waitpid(-1,wait_stat,0);
asm-i386/dma.h: *  controller 1: channels 0-3, byte operations, ports 00-1F
asm-i386/dma.h: *  controller 2: channels 4-7, word operations, ports C0-DF
asm-i386/dma.h: *  - ALL registers are 8 bits only, regardless of transfer size
asm-i386/dma.h: *  - channel 4 is not used - cascades 1 into 2.
asm-i386/dma.h: *  - channels 0-3 are byte - addresses/counts are for physical bytes
asm-i386/dma.h: *  - channels 5-7 are word - addresses/counts are for physical words
asm-i386/dma.h: *  - transfers must not cross physical 64K (0-3) or 128K (5-7) boundaries
asm-i386/dma.h: *  - transfer count loaded to registers is 1 less than actual count
asm-i386/dma.h: *  - controller 2 offsets are all even (2x offsets for controller 1)
asm-i386/dma.h: *  - page registers for 5-7 don't use data bit 0, represent 128K pages
asm-i386/dma.h: *  - page registers for 0-3 use bit 0, represent 64K pages
asm-i386/dma.h: *  Address mapping for channels 0-3:
asm-i386/dma.h: *  Address mapping for channels 5-7:
asm-i386/dma.h: * Again, channels 5-7 transfer _physical_ words (16 bits), so addresses
asm-i386/dma.h: * and counts _must_ be word-aligned (the lowest address bit is _ignored_ at
asm-i386/dma.h: * the hardware level, so odd-byte transfers aren't possible).
asm-i386/dma.h: * count - 1 : 64K => 0xFFFF, 1 => 0x0000.  Thus, count is always 1 or more,
asm-i386/dma.h: * and up to 128K bytes may be transferred on channels 5-7 in one operation. 
asm-i386/dma.h:#define DMA1_MASK_REG		0x0A	/* single-channel mask (w) */
asm-i386/dma.h:#define DMA1_CLEAR_FF_REG	0x0C	/* clear pointer flip-flop (w) */
asm-i386/dma.h:#define DMA1_MASK_ALL_REG       0x0F    /* all-channels mask (w) */
asm-i386/dma.h:#define DMA2_MASK_REG		0xD4	/* single-channel mask (w) */
asm-i386/dma.h:#define DMA2_CLEAR_FF_REG	0xD8	/* clear pointer flip-flop (w) */
asm-i386/dma.h:#define DMA2_MASK_ALL_REG       0xDE    /* all-channels mask (w) */
asm-i386/dma.h:#define DMA_MODE_CASCADE 0xC0   /* pass thru DREQ->HRQ, DACK<-HLDA only */
asm-i386/dma.h: * After that, keep track of it. :-)
asm-i386/dma.h: * --- In order to do that, the DMA routines below should ---
asm-i386/dma.h: * --- only be used while holding the DMA lock ! ---
asm-i386/dma.h: * Assumes dma flip-flop is clear.
asm-i386/dma.h: * NOTE 2: "count" represents _bytes_ and must be even for channels 5-7.
asm-i386/dma.h:        count--;
asm-i386/dma.h: * Assumes DMA flip-flop is clear.
asm-i386/dma.h:	/* using short to get 16-bit wrap around */
asm-i386/edd.h: * linux/include/asm-i386/edd.h
asm-i386/edd.h: * in the empty_zero_block that contains a list of BIOS-enumerated
asm-i386/edd.h:				   in empty_zero_block - treat this as 1 byte  */
asm-i386/elf.h:	(((x)->e_machine == EM_386) || ((x)->e_machine == EM_486))
asm-i386/elf.h:/* SVR4/i386 ABI (pages 3-31, 3-32) says that when the program starts %edx
asm-i386/elf.h:	_r->ebx = 0; _r->ecx = 0; _r->edx = 0; \
asm-i386/elf.h:	_r->esi = 0; _r->edi = 0; _r->ebp = 0; \
asm-i386/elf.h:	_r->eax = 0; \
asm-i386/elf.h:	pr_reg[0] = regs->ebx;				\
asm-i386/elf.h:	pr_reg[1] = regs->ecx;				\
asm-i386/elf.h:	pr_reg[2] = regs->edx;				\
asm-i386/elf.h:	pr_reg[3] = regs->esi;				\
asm-i386/elf.h:	pr_reg[4] = regs->edi;				\
asm-i386/elf.h:	pr_reg[5] = regs->ebp;				\
asm-i386/elf.h:	pr_reg[6] = regs->eax;				\
asm-i386/elf.h:	pr_reg[7] = regs->xds;				\
asm-i386/elf.h:	pr_reg[8] = regs->xes;				\
asm-i386/elf.h:	pr_reg[9] = regs->xds;	/* was fs and __fs */	\
asm-i386/elf.h:	pr_reg[10] = regs->xds;	/* was gs and __gs */	\
asm-i386/elf.h:	pr_reg[11] = regs->orig_eax;			\
asm-i386/elf.h:	pr_reg[12] = regs->eip;				\
asm-i386/elf.h:	pr_reg[13] = regs->xcs;				\
asm-i386/elf.h:	pr_reg[14] = regs->eflags;			\
asm-i386/elf.h:	pr_reg[15] = regs->esp;				\
asm-i386/elf.h:	pr_reg[16] = regs->xss;
asm-i386/ide.h: *  linux/include/asm-i386/ide.h
asm-i386/ide.h: *  Copyright (C) 1994-1996  Linus Torvalds & authors
asm-i386/ide.h:		hw->io_ports[i] = reg;
asm-i386/ide.h:		hw->io_ports[IDE_CONTROL_OFFSET] = ctrl_port;
asm-i386/ide.h:		hw->io_ports[IDE_CONTROL_OFFSET] = hw->io_ports[IDE_DATA_OFFSET] + 0x206;
asm-i386/ide.h:	hw->io_ports[IDE_IRQ_OFFSET] = 0;
asm-i386/ide.h:#include <asm-generic/ide_iops.h>
asm-i386/irq.h: *	<tomsoft@informatik.tu-chemnitz.de>
asm-i386/irq.h: * Since vectors 0x00-0x1f are used/reserved for the CPU,
asm-i386/irq.h: * the usable vector space is 0x20-0xff (224 vectors)
asm-i386/msr.h: * Access to machine-specific registers (available on 586 and better only)
asm-i386/msr.h:/* Centaur-Hauls/IDT defined MSRs. */
asm-i386/pci.h:   already-configured bus numbers - to be used for buggy BIOSes
asm-i386/pci.h: * NULL for PCI-like buses (ISA, EISA).
asm-i386/pci.h: * Returns non-NULL cpu-view pointer to the buffer if successful and
asm-i386/pci.h: * The 32-bit bus address to use is returned.
asm-i386/pci.h:	return ((dma_addr_t)(page - mem_map) *
asm-i386/pci.h: * mode for DMA.  This is the scather-gather version of the
asm-i386/pci.h: * The same as pci_dma_sync_single but for a scatter-gather list,
asm-i386/pci.h: * only drive the low 24-bits during PCI bus mastering, then
asm-i386/pci.h:#define sg_dma_address(sg)	((sg)->dma_address)
asm-i386/pci.h:#define sg_dma_len(sg)		((sg)->length)
asm-i386/smp.h: * the real APIC ID <-> CPU # mapping.
asm-i386/smp.h:#define smp_processor_id() (current->processor)
asm-i386/smp.h:	/* we don't want to mark this access volatile - bad code generation */
asm-i386/smp.h:	/* we don't want to mark this access volatile - bad code generation */
asm-i386/tlb.h:#include <asm-generic/tlb.h>
asm-i386/xor.h: * include/asm-i386/xor.h
asm-i386/xor.h: * Optimized RAID-5 checksumming functions for MMX and SSE.
asm-i386/xor.h: * High-speed RAID5 checksumming functions utilizing MMX instructions.
asm-i386/xor.h:	if (!(current->flags & PF_USEDFPU))				\
asm-i386/xor.h:	if (!(current->flags & PF_USEDFPU))				\
asm-i386/xor.h:#include <asm-generic/xor.h>
asm-i386/signal.h:#define SIGRTMAX	(_NSIG-1)
asm-i386/signal.h: * SA_INTERRUPT is a no-op, but left due to historical reasons. Use the
asm-i386/signal.h:#define SA_INTERRUPT	0x20000000 /* dummy -- ignored */
asm-i386/signal.h:#define SIG_ERR	((__sighandler_t)-1)	/* error return from signal */
asm-i386/signal.h:	__asm__("btsl %1,%0" : "=m"(*set) : "Ir"(_sig - 1) : "cc");
asm-i386/signal.h:	__asm__("btrl %1,%0" : "=m"(*set) : "Ir"(_sig - 1) : "cc");
asm-i386/signal.h:	unsigned long sig = _sig - 1;
asm-i386/signal.h:	return 1 & (set->sig[sig / _NSIG_BPW] >> (sig % _NSIG_BPW));
asm-i386/signal.h:		: "=r"(ret) : "m"(*set), "Ir"(_sig-1) : "cc");
asm-i386/signal.h:#define sigmask(sig)	(1UL << ((sig) - 1))
asm-i386/pgtable-3level.h: * Intel Physical Address Extension (PAE) Mode - three-level page
asm-i386/pgtable-3level.h: * PGDIR_SHIFT determines what a top-level page table entry can map
asm-i386/pgtable-3level.h: * PMD_SHIFT determines the size of the area a middle-level
asm-i386/pgtable-3level.h: * value and then use set_pte to update it.  -ben
asm-i386/pgtable-3level.h:	ptep->pte_high = pte.pte_high;
asm-i386/pgtable-3level.h:	ptep->pte_low = pte.pte_low;
asm-i386/pgtable-3level.h: * Pentium-II erratum A13: in PAE mode we explicitly have to flush
asm-i386/pgtable-3level.h: * the TLB via cr3 if the top-level pgd is changed...
asm-i386/pgtable-3level.h:/* Find an entry in the second-level page table.. */
asm-i386/pgtable-3level.h:	res.pte_low = xchg(&ptep->pte_low, 0);
asm-i386/pgtable-3level.h:	res.pte_high = ptep->pte_high;
asm-i386/pgtable-3level.h:	ptep->pte_high = 0;
asm-i386/pgtable-3level.h:#define pte_page(x)	(mem_map+(((x).pte_low >> PAGE_SHIFT) | ((x).pte_high << (32 - PAGE_SHIFT))))
asm-i386/pgtable-3level.h:	pte.pte_high = page_nr >> (32 - PAGE_SHIFT);
asm-i386/hc_sl811-hw.h:File: include/asm-i386/hc_sl811-hw.h
asm-i386/hc_sl811-hw.h:Splitt hardware depenc into file hc_sl811-x86.c and hc_sl811-arm.c.
asm-i386/hc_sl811-hw.h:Low level only for port io into hardware-include.
asm-i386/hc_sl811-hw.h:// #define sl811_write_index(hp,i) outb ((i), hp->hcport)
asm-i386/hc_sl811-hw.h:// #define sl811_write_data(hp,d) outb ((d), hp->hcport+1)
asm-i386/hc_sl811-hw.h:// #define sl811_write_index_data(hp,i,d) outw ((i)|(((__u16)(d)) << 8), hp->hcport)
asm-i386/hc_sl811-hw.h:// #define sl811_read_data(hp) ((__u8) inb (hp->hcport+1))
asm-i386/hc_sl811-hw.h:	return ((__u8) inb (hp->hcport+1));
asm-i386/hc_sl811-hw.h:	outb (index, hp->hcport);
asm-i386/hc_sl811-hw.h:	outb (data, hp->hcport+1);
asm-i386/hc_sl811-hw.h:	outw (index|(((__u16)data) << 8), hp->hcport);
asm-i386/hc_sl811-hw.h:	if (hp->hcport > 0) {
asm-i386/hc_sl811-hw.h:		release_region (hp->hcport, SIZEOF_IO_REGION);
asm-i386/hc_sl811-hw.h:		hp->hcport = 0;
asm-i386/hc_sl811-hw.h:		return -EBUSY;
asm-i386/hc_sl811-hw.h:	hp->hcport = base1;
asm-i386/hardirq.h:#define irq_exit(cpu, irq)	(local_irq_count(cpu)--)
asm-i386/hardirq.h:extern unsigned volatile long global_irq_lock; /* long for set_bit -RR */
asm-i386/hardirq.h:	--local_irq_count(cpu);
asm-i386/processor.h: * include/asm-i386/processor.h
asm-i386/processor.h:       	int	cpuid_level;	/* Maximum supported CPUID level, -1=no CPUID */
asm-i386/processor.h:	int 	x86_cache_size;  /* in KB - valid for CPUS which support this
asm-i386/processor.h: * Size of io_bitmap in longwords: 32 is ports 0-0x3ff.
asm-i386/processor.h:	long	st_space[20];	/* 8*10 bytes for each FP-reg = 80 bytes */
asm-i386/processor.h:	long	st_space[32];	/* 8*16 bytes for each FP-reg = 128 bytes */
asm-i386/processor.h:	long	xmm_space[32];	/* 8*16 bytes for each XMM-reg = 128 bytes */
asm-i386/processor.h:	long	st_space[20];	/* 8*10 bytes for each FP-reg = 80 bytes */
asm-i386/processor.h:	 * pads the TSS to be cacheline-aligned (size is 0x100)
asm-i386/processor.h:	unsigned long	debugreg[8];  /* %%db0-7 debug registers */
asm-i386/processor.h:	regs->xds = __USER_DS;					\
asm-i386/processor.h:	regs->xes = __USER_DS;					\
asm-i386/processor.h:	regs->xss = __USER_DS;					\
asm-i386/processor.h:	regs->xcs = __USER_CS;					\
asm-i386/processor.h:	regs->eip = new_eip;					\
asm-i386/processor.h:	regs->esp = new_esp;					\
asm-i386/processor.h:	return ((unsigned long *)t->esp)[3];
asm-i386/processor.h:#define get_task_struct(tsk)      atomic_inc(&virt_to_page(tsk)->count)
asm-i386/processor.h:/* REP NOP (PAUSE) is a good thing to insert into busy-wait loops. */
asm-i386/linux_logo.h: * include/asm-i386/linux_logo.h: This is a linux logo
asm-i386/mmu_context.h:		clear_bit(cpu, &prev->cpu_vm_mask);
asm-i386/mmu_context.h:		set_bit(cpu, &next->cpu_vm_mask);
asm-i386/mmu_context.h:		/* Re-load page tables */
asm-i386/mmu_context.h:		load_cr3(next->pgd);
asm-i386/mmu_context.h:		 * has a non-default LDT.
asm-i386/mmu_context.h:		if (next->context.size+prev->context.size)
asm-i386/mmu_context.h:			load_LDT(&next->context);
asm-i386/mmu_context.h:		if(!test_and_set_bit(cpu, &next->cpu_vm_mask)) {
asm-i386/mmu_context.h:			load_cr3(next->pgd);
asm-i386/mmu_context.h:			load_LDT(&next->context);
asm-i386/cobalt.h:/* Cobalt CPU registers -- relative to CO_CPU_VADDR, use co_cpu_*() */
asm-i386/cobalt.h:/* Cobalt APIC registers -- relative to CO_APIC_VADDR, use co_apic_*() */
asm-i386/cobalt.h:#define	CO_APIC_8259	12	/* serial, floppy, par-l-l, audio */
asm-i386/semaphore.h: * SMP- and interrupt-safe semaphores..
asm-i386/semaphore.h: * Modified 1996-12-23 by Dave Grothe <dave@gcom.com> to fix bugs in
asm-i386/semaphore.h: * Modified 1999-02-14 by Andrea Arcangeli, split the sched.c helper
asm-i386/semaphore.h: *		       functions in asm/sempahore-helper.h while fixing a
asm-i386/semaphore.h: *          1999-07-02 Artur Skawina <skawina@geocities.com>
asm-i386/semaphore.h: *                     Optimized "0(ecx)" -> "(ecx)" (the assembler does not
asm-i386/semaphore.h: * Modified 2001-01-01 Andreas Franck <afranck@gmx.de>
asm-i386/semaphore.h: *		       with -fomit-frame-pointer. It's not sure if this will
asm-i386/semaphore.h: * /pub/linux/src/semaphore/semaphore-2.0.24.tar.gz.
asm-i386/semaphore.h:	atomic_set(&sem->count, val);
asm-i386/semaphore.h:	sem->sleepers = 0;
asm-i386/semaphore.h:	init_waitqueue_head(&sem->wait);
asm-i386/semaphore.h:	sem->__magic = (int)&sem->__magic;
asm-i386/semaphore.h:	CHECK_MAGIC(sem->__magic);
asm-i386/semaphore.h:		LOCK "decl %0\n\t"     /* --sem->count */
asm-i386/semaphore.h:		:"=m" (sem->count)
asm-i386/semaphore.h: * it, return zero.  If we were interrupted, returns -EINTR
asm-i386/semaphore.h:	CHECK_MAGIC(sem->__magic);
asm-i386/semaphore.h:		LOCK "decl %1\n\t"     /* --sem->count */
asm-i386/semaphore.h:		:"=a" (result), "=m" (sem->count)
asm-i386/semaphore.h: * Non-blockingly attempt to down() a semaphore.
asm-i386/semaphore.h:	CHECK_MAGIC(sem->__magic);
asm-i386/semaphore.h:		LOCK "decl %1\n\t"     /* --sem->count */
asm-i386/semaphore.h:		:"=a" (result), "=m" (sem->count)
asm-i386/semaphore.h:	CHECK_MAGIC(sem->__magic);
asm-i386/semaphore.h:		LOCK "incl %0\n\t"     /* ++sem->count */
asm-i386/semaphore.h:		:"=m" (sem->count)
asm-i386/semaphore.h:	return atomic_read(&sem->count);
asm-i386/fcntl.h:/* open/fcntl - O_SYNC is only implemented on blocks devices and on files
asm-i386/fcntl.h:#define F_GETFL		3	/* get file->f_flags */
asm-i386/fcntl.h:#define F_SETFL		4	/* set file->f_flags */
asm-i386/locks.h:	while(lock_set_bit(0,&sp->lock))
asm-i386/locks.h:		if(sp->cpu==processor)
asm-i386/locks.h:			sp->users++;
asm-i386/locks.h:		while(sp->lock)
asm-i386/locks.h:			sp->spins++;
asm-i386/locks.h:	sp->users++;sp->cpu=processor;
asm-i386/locks.h:	if(!--sp->users)
asm-i386/locks.h:		sp->cpu= NO_PROC_ID;lock_clear_bit(0,&sp->lock);
asm-i386/locks.h:	if(lock_set_bit(0,&sp->lock))
asm-i386/locks.h:	sp->users++;
asm-i386/locks.h:	if(sp->priority<current->lock_order)
asm-i386/locks.h:		panic("lock order violation: %s (%d)\n", sp->name, current->lock_order);
asm-i386/locks.h:		sp->oldpri=current->lock_order;
asm-i386/locks.h:		current->lock_order=sp->priority;
asm-i386/locks.h:	if(current->lock_order!=sp->priority)
asm-i386/locks.h:		panic("lock release order violation %s (%d)\n", sp->name, current->lock_order);
asm-i386/locks.h:	pri=sp->oldpri;
asm-i386/locks.h:		current->lock_order=sp->pri;
asm-i386/rwsem.h: * Derived from asm-i386/semaphore.h
asm-i386/rwsem.h: * This should be totally fair - if anything is waiting, a process that wants a
asm-i386/rwsem.h:#define RWSEM_WAITING_BIAS		(-0x00010000)
asm-i386/rwsem.h:	sem->count = RWSEM_UNLOCKED_VALUE;
asm-i386/rwsem.h:	spin_lock_init(&sem->wait_lock);
asm-i386/rwsem.h:	INIT_LIST_HEAD(&sem->wait_list);
asm-i386/rwsem.h:	sem->debug = 0;
asm-i386/rwsem.h:		: "=m"(sem->count)
asm-i386/rwsem.h:		: "a"(sem), "m"(sem->count)
asm-i386/rwsem.h: * trylock for reading -- returns 1 if successful, 0 if contention
asm-i386/rwsem.h:		: "+m"(sem->count), "=&a"(result), "=&r"(tmp)
asm-i386/rwsem.h:		: "=m"(sem->count), "=d"(tmp)
asm-i386/rwsem.h:		: "a"(sem), "1"(tmp), "m"(sem->count)
asm-i386/rwsem.h: * trylock for writing -- returns 1 if successful, 0 if contention
asm-i386/rwsem.h:	signed long ret = cmpxchg(&sem->count,
asm-i386/rwsem.h:	__s32 tmp = -RWSEM_ACTIVE_READ_BIAS;
asm-i386/rwsem.h:		: "=m"(sem->count), "=d"(tmp)
asm-i386/rwsem.h:		: "a"(sem), "1"(tmp), "m"(sem->count)
asm-i386/rwsem.h:LOCK_PREFIX	"  xaddl     %%edx,(%%eax)\n\t" /* tries to transition 0xffff0001 -> 0x00000000 */
asm-i386/rwsem.h:		: "=m"(sem->count)
asm-i386/rwsem.h:		: "a"(sem), "i"(-RWSEM_ACTIVE_WRITE_BIAS), "m"(sem->count)
asm-i386/rwsem.h:		:"=m"(sem->count)
asm-i386/rwsem.h:		:"ir"(delta), "m"(sem->count));
asm-i386/rwsem.h:		: "+r"(tmp), "=m"(sem->count)
asm-i386/rwsem.h:		: "r"(sem), "m"(sem->count)
asm-i386/spinlock.h: * Remember to turn this off in 2.4. -ben
asm-i386/spinlock.h:#define spin_is_locked(x)	(*(volatile signed char *)(&(x)->lock) <= 0)
asm-i386/spinlock.h:		:"=m" (lock->lock) : : "memory"
asm-i386/spinlock.h:	if (lock->magic != SPINLOCK_MAGIC)
asm-i386/spinlock.h:		:"=q" (oldval), "=m" (lock->lock) \
asm-i386/spinlock.h:	if (lock->magic != SPINLOCK_MAGIC)
asm-i386/spinlock.h:		:"=q" (oldval), "=m" (lock->lock)
asm-i386/spinlock.h:	if (lock->magic != SPINLOCK_MAGIC) {
asm-i386/spinlock.h:		:"=m" (lock->lock) : : "memory");
asm-i386/spinlock.h: * Read-write spinlocks, allowing multiple readers
asm-i386/spinlock.h: * can "mix" irq-safe locks - any writer needs to get a
asm-i386/spinlock.h: * irq-safe write-lock, but readers can get non-irqsafe
asm-i386/spinlock.h: * read-locks.
asm-i386/spinlock.h: * On x86, we implement read-write locks as a 32-bit counter
asm-i386/spinlock.h: * The inline assembly is non-obvious. Think about it.
asm-i386/spinlock.h: * semaphore.h for details.  -ben
asm-i386/spinlock.h:	if (rw->magic != RWLOCK_MAGIC)
asm-i386/spinlock.h:	if (rw->magic != RWLOCK_MAGIC)
asm-i386/spinlock.h:#define read_unlock(rw)		asm volatile("lock ; incl %0" :"=m" ((rw)->lock) : : "memory")
asm-i386/spinlock.h:#define write_unlock(rw)	asm volatile("lock ; addl $" RW_LOCK_BIAS_STR ",%0":"=m" ((rw)->lock) : : "memory")
asm-i386/errno.h:#define	EXDEV		18	/* Cross-device link */
asm-i386/errno.h:#define	EROFS		30	/* Read-only file system */
asm-i386/errno.h:#define	ENOTSOCK	88	/* Socket operation on non-socket */
asm-i386/io_apic.h: * Intel IO-APIC support for SMP and UP systems.
asm-i386/io_apic.h: * The structure of the IO-APIC:
asm-i386/io_apic.h: * # of IO-APICs and # of IRQ routing registers
asm-i386/io_apic.h: * MP-BIOS irq configuration table structures:
asm-i386/io_apic.h:/* non-0 if default (table-less) MP configuration */
asm-i386/io_apic.h: * Synchronize the IO-APIC and the CPU by doing
asm-i386/io_apic.h: * a dummy read from the IO-APIC
asm-i386/io_apic.h: * If we use the IO-APIC for IRQ routing, disable automatic
asm-i386/byteorder.h:   it because inline assembly cannot be scheduled. -AK */
asm-i386/save_state.h: * Copyright 2001-2002 Pavel Machek <pavel@suse.cz>
asm-i386/save_state.h:                       :"r" ((thread)->debugreg[register]))
asm-i386/save_state.h: * buggy - it returns the value of the stack at the proper location, not the 
asm-i386/save_state.h:	if (current->thread.debugreg[7]){
asm-i386/save_state.h:                loaddebug(&current->thread, 0);
asm-i386/save_state.h:                loaddebug(&current->thread, 1);
asm-i386/save_state.h:                loaddebug(&current->thread, 2);
asm-i386/save_state.h:                loaddebug(&current->thread, 3);
asm-i386/save_state.h:                loaddebug(&current->thread, 6);
asm-i386/save_state.h:                loaddebug(&current->thread, 7);
asm-i386/save_state.h: * - descriptor tables
asm-i386/save_state.h: * - control registers
asm-i386/save_state.h: * - segment registers
asm-i386/save_state.h: * - flags
asm-i386/acpi.h: *  asm-i386/acpi.h
asm-i386/acpi.h: *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
asm-i386/acpi.h: * ACPI_SYSTEM_XFACE        - Interfaces to host OS (handlers, threads)
asm-i386/acpi.h: * ACPI_EXTERNAL_XFACE      - External ACPI interfaces 
asm-i386/acpi.h: * ACPI_INTERNAL_XFACE      - Internal ACPI interfaces
asm-i386/acpi.h: * ACPI_INTERNAL_VAR_XFACE  - Internal variable-parameter list interfaces
asm-i386/acpi.h:	return (new < 3) ? -1 : 0;
asm-i386/acpi.h:/* Fixmap pages to reserve for ACPI boot-time tables (see fixmap.h) */
asm-i386/apic.h:	 * - a single rmw on Pentium/82489DX
asm-i386/apic.h:	 * - a single write on P6+ cores (CONFIG_X86_GOOD_APIC)
asm-i386/softirq.h:		do { barrier(); local_bh_count(cpu)--; } while (0)
asm-i386/softirq.h: *    (char *)&local_bh_count - 8 == (char *)&softirq_pending
asm-i386/softirq.h:	if (!--*ptr)							\
asm-i386/softirq.h:			"cmpl $0, -8(%0);"				\
asm-i386/hw_irq.h: *	<tomsoft@informatik.tu-chemnitz.de>
asm-i386/hw_irq.h: * Vectors 0x20-0x2f are used for ISA interrupts.
asm-i386/hw_irq.h: * Special IRQ vectors used by the SMP architecture, 0xf0-0xff
asm-i386/hw_irq.h: *  TLB, reschedule and local APIC vectors are performance-critical.
asm-i386/hw_irq.h: *  Vectors 0xf0-0xfa are free (reserved for future Linux use).
asm-i386/hw_irq.h: * First APIC vector available to drivers: (vectors 0x30-0xee)
asm-i386/hw_irq.h: * Various low-level irq details needed by irq.c, process.c,
asm-i386/hw_irq.h:	"andl $-8192, %ebx\n\t"
asm-i386/hw_irq.h:	"pushl $"#v"-256\n\t" \
asm-i386/hw_irq.h:	"pushl $"#v"-256\n\t" \
asm-i386/hw_irq.h: * system calls and interrupted 'random user-space'. Thus we have
asm-i386/hw_irq.h:	"pushl $"#nr"-256\n\t" \
asm-i386/hw_irq.h:	eip -= (unsigned long) &_stext;
asm-i386/hw_irq.h:	 * Don't ignore out-of-bounds EIP values silently,
asm-i386/hw_irq.h:	if (eip > prof_len-1)
asm-i386/hw_irq.h:		eip = prof_len-1;
asm-i386/timex.h: * linux/include/asm-i386/timex.h
asm-i386/timex.h:#define FINETUNE ((((((long)LATCH * HZ - CLOCK_TICK_RATE) << SHIFT_HZ) * \
asm-i386/timex.h:		<< (SHIFT_SCALE-SHIFT_HZ)) / HZ)
asm-i386/bugs.h: *  include/asm-i386/bugs.h
asm-i386/bugs.h: *	- Rafael R. Reilova (moved everything from head.S),
asm-i386/bugs.h: *	- Channing Corn (tests & fixes),
asm-i386/bugs.h: *	- Andrew D. Balsa (code cleanup).
asm-i386/bugs.h: * This is included by init/main.c to check for architecture-dependent bugs.
asm-i386/bugs.h:__setup("no-hlt", no_halt);
asm-i386/bugs.h:__setup("mca-pentium", mca_pentium);
asm-i386/bugs.h:	 * Verify that the FXSAVE/FXRSTOR data will be 16-byte aligned.
asm-i386/bugs.h: * - In order to run on a i386, we need to be compiled for i386
asm-i386/bugs.h: * - In order to run on anything without a TSC, we need to be
asm-i386/bugs.h: * - In order to support the local APIC on a buggy Pentium machine,
asm-i386/bugs.h:		panic("Kernel compiled for PMMX+, assumes a local APIC without the read-before-write bug!");
asm-i386/namei.h: * linux/include/asm-i386/namei.h
asm-i386/namei.h: * Look at asm-sparc/namei.h for details.
asm-i386/i387.h: * include/asm-i386/i387.h
asm-i386/i387.h:	if ( tsk->flags & PF_USEDFPU ) \
asm-i386/i387.h:	if ( tsk->flags & PF_USEDFPU ) { \
asm-i386/i387.h:		tsk->flags &= ~PF_USEDFPU; \
asm-i386/desc.h: *   0 - null
asm-i386/desc.h: *   1 - not used
asm-i386/desc.h: *   2 - kernel code segment
asm-i386/desc.h: *   3 - kernel data segment
asm-i386/desc.h: *   4 - user code segment                  <-- new cacheline 
asm-i386/desc.h: *   5 - user data segment
asm-i386/desc.h: *   6 - not used
asm-i386/desc.h: *   7 - not used
asm-i386/desc.h: *   8 - APM BIOS support                   <-- new cacheline 
asm-i386/desc.h: *   9 - APM BIOS support
asm-i386/desc.h: *  10 - APM BIOS support
asm-i386/desc.h: *  11 - APM BIOS support
asm-i386/desc.h: * has an exclusive cacheline for the per-CPU TSS and LDT:
asm-i386/desc.h: *  12 - CPU#0 TSS                          <-- new cacheline 
asm-i386/desc.h: *  13 - CPU#0 LDT
asm-i386/desc.h: *  14 - not used 
asm-i386/desc.h: *  15 - not used 
asm-i386/desc.h: *  16 - CPU#1 TSS                          <-- new cacheline 
asm-i386/desc.h: *  17 - CPU#1 LDT
asm-i386/desc.h: *  18 - not used 
asm-i386/desc.h: *  19 - not used 
asm-i386/desc.h: *  ... NR_CPUS per-CPU TSS+LDT's if on SMP
asm-i386/desc.h:#define idt_descr (*(struct Xgt_desc_struct *)((char *)&idt - 2))
asm-i386/desc.h:#define gdt_descr (*(struct Xgt_desc_struct *)((char *)&gdt - 2))
asm-i386/desc.h:	void *segments = pc->ldt;
asm-i386/desc.h:	int count = pc->size;
asm-i386/cpufeature.h:#define NCAPINTS	6	/* Currently we have 6 32-bit words worth of info */
asm-i386/cpufeature.h:/* Intel-defined CPU features, CPUID level 0x00000001 (edx), word 0 */
asm-i386/cpufeature.h:#define X86_FEATURE_MSR		(0*32+ 5) /* Model-Specific Registers, RDMSR, WRMSR */
asm-i386/cpufeature.h:#define X86_FEATURE_PSE36	(0*32+17) /* 36-bit PSEs */
asm-i386/cpufeature.h:#define X86_FEATURE_XMM2	(0*32+26) /* Streaming SIMD Extensions-2 */
asm-i386/cpufeature.h:#define X86_FEATURE_HT		(0*32+28) /* Hyper-Threading */
asm-i386/cpufeature.h:#define X86_FEATURE_IA64	(0*32+30) /* IA-64 processor */
asm-i386/cpufeature.h:/* AMD-defined CPU features, CPUID level 0x80000001, word 1 */
asm-i386/cpufeature.h:#define X86_FEATURE_LM		(1*32+29) /* Long Mode (x86-64) */
asm-i386/cpufeature.h:/* Transmeta-defined CPU features, CPUID level 0x80860001, word 2 */
asm-i386/cpufeature.h:/* Other features, Linux-defined mapping, word 3 */
asm-i386/cpufeature.h:/* Intel-defined CPU features, CPUID level 0x00000001 (ecx), word 4 */
asm-i386/cpufeature.h:/* VIA/Cyrix/Centaur-defined CPU features, CPUID level 0xC0000001, word 5 */
asm-i386/cpufeature.h:#define X86_FEATURE_XSTORE	(5*32+ 2) /* on-CPU RNG present (xstore insn) */
asm-i386/cpufeature.h:#define cpu_has(c, bit)		test_bit(bit, (c)->x86_capability)
asm-i386/cpufeature.h: * comment-column:42
asm-i386/highmem.h: * Redesigned the x86 32-bit VM architecture to deal with 
asm-i386/highmem.h:#define LAST_PKMAP_MASK (LAST_PKMAP-1)
asm-i386/highmem.h:#define PKMAP_NR(virt)  ((virt-PKMAP_BASE) >> PAGE_SHIFT)
asm-i386/highmem.h: * The use of kmap_atomic/kunmap_atomic is discouraged - kmap/kunmap
asm-i386/highmem.h:	if (!pte_none(*(kmap_pte-idx)))
asm-i386/highmem.h:	set_pte(kmap_pte-idx, mk_pte(page, kmap_prot));
asm-i386/highmem.h:	pte_clear(kmap_pte-idx);
asm-i386/fixmap.h: * fixmap.h: compile-time virtual memory allocation
asm-i386/fixmap.h: * Here we define all the compile-time 'special' virtual
asm-i386/fixmap.h: * Also this lets us do fail-safe vmalloc(), we
asm-i386/fixmap.h: * vmalloc()-ed addresses never overlap.
asm-i386/fixmap.h: * these 'compile-time allocated' memory buffers are
asm-i386/fixmap.h: * fixed-size 4k pages. (or larger if used with an increment
asm-i386/fixmap.h: * fix-mapped?
asm-i386/fixmap.h:	FIX_APIC_BASE,	/* local (CPU) APIC) -- required for SMP or not */
asm-i386/fixmap.h:	FIX_IO_APIC_BASE_END = FIX_IO_APIC_BASE_0 + MAX_IO_APICS-1,
asm-i386/fixmap.h:	FIX_KMAP_END = FIX_KMAP_BEGIN+(KM_TYPE_NR*NR_CPUS)-1,
asm-i386/fixmap.h:	FIX_ACPI_END = FIX_ACPI_BEGIN + FIX_ACPI_PAGES - 1,
asm-i386/fixmap.h:	/* temporary boot-time mappings, used before ioremap() is functional */
asm-i386/fixmap.h:	FIX_BTMAP_BEGIN = FIX_BTMAP_END + NR_FIX_BTMAPS - 1,
asm-i386/fixmap.h:#define FIXADDR_START	(FIXADDR_TOP - __FIXADDR_SIZE)
asm-i386/fixmap.h:#define __fix_to_virt(x)	(FIXADDR_TOP - ((x) << PAGE_SHIFT))
asm-i386/fixmap.h: * directly without tranlation, we catch the bug with a NULL-deference
asm-i386/fixmap.h:	 * out-of-range indices).
asm-i386/init.h:#error "<asm/init.h> should never be used - use <linux/init.h> instead"
asm-i386/uaccess.h:#define get_fs()	(current->addr_limit)
asm-i386/uaccess.h:#define set_fs(x)	(current->addr_limit = (x))
asm-i386/uaccess.h:#define __addr_ok(addr) ((unsigned long)(addr) < (current->addr_limit.seg))
asm-i386/uaccess.h: * (u33)addr + (u33)size >= (u33)current->addr_limit.seg
asm-i386/uaccess.h: * This needs 33-bit arithmetic. We have a carry...
asm-i386/uaccess.h:		:"1" (addr),"g" ((int)(size)),"g" (current->addr_limit.seg)); \
asm-i386/uaccess.h: * access_ok: - Checks if a user space pointer is valid
asm-i386/uaccess.h: *        %VERIFY_WRITE is a superset of %VERIFY_READ - if it is safe
asm-i386/uaccess.h: * checks that the pointer is in the user space range - after calling
asm-i386/uaccess.h: * this function, memory access functions may still return -EFAULT.
asm-i386/uaccess.h: * verify_area: - Obsolete, use access_ok()
asm-i386/uaccess.h: * Returns zero if the memory block may be valid, -EFAULT
asm-i386/uaccess.h:	return access_ok(type,addr,size) ? 0 : -EFAULT;
asm-i386/uaccess.h: * These are the main single-value transfer routines.  They automatically
asm-i386/uaccess.h: * get_user: - Get a simple variable from user space.
asm-i386/uaccess.h: * @ptr must have pointer-to-simple-variable type, and the result of
asm-i386/uaccess.h: * Returns zero on success, or -EFAULT on error.
asm-i386/uaccess.h: * put_user: - Write a simple value into user space.
asm-i386/uaccess.h: * @ptr must have pointer-to-simple-variable type, and @x must be assignable
asm-i386/uaccess.h: * Returns zero on success, or -EFAULT on error.
asm-i386/uaccess.h: * __get_user: - Get a simple variable from user space, with less checking.
asm-i386/uaccess.h: * @ptr must have pointer-to-simple-variable type, and the result of
asm-i386/uaccess.h: * Returns zero on success, or -EFAULT on error.
asm-i386/uaccess.h: * __put_user: - Write a simple value into user space, with less checking.
asm-i386/uaccess.h: * @ptr must have pointer-to-simple-variable type, and @x must be assignable
asm-i386/uaccess.h: * Returns zero on success, or -EFAULT on error.
asm-i386/uaccess.h:	long __pu_err = -EFAULT;					\
asm-i386/uaccess.h:		: "A" (x), "r" (addr), "i"(-EFAULT), "0"(err))
asm-i386/uaccess.h:		: ltype (x), "m"(__m(addr)), "i"(-EFAULT), "0"(err))
asm-i386/uaccess.h:		: "m"(__m(addr)), "i"(-EFAULT), "0"(err))
asm-i386/uaccess.h: * copy_to_user: - Copy a block of data into user space.
asm-i386/uaccess.h: * copy_from_user: - Copy a block of data from user space.
asm-i386/uaccess.h: * __copy_to_user: - Copy a block of data into user space, with less checking.
asm-i386/uaccess.h: * __copy_from_user: - Copy a block of data from user space, with less checking.
asm-i386/uaccess.h: * strlen_user: - Get the size of a string in user space.
asm-i386/uaccess.h: * Get the size of a NUL-terminated string in user space.
asm-i386/mman.h:#define MAP_GROWSDOWN	0x0100		/* stack-like segment */
asm-i386/mman.h:#define MADV_NORMAL	0x0		/* default page-in behavior */
asm-i386/mman.h:#define MADV_RANDOM	0x1		/* page-in minimum required */
asm-i386/mman.h:#define MADV_SEQUENTIAL	0x2		/* read-ahead aggressively */
asm-i386/mman.h:#define MADV_WILLNEED	0x3		/* pre-fault pages */
asm-i386/posix_types.h: * This file is generally used by user-level software, so you need to
asm-i386/mtrr.h:    Copyright (C) 1997-1999  Richard Gooch
asm-i386/mtrr.h:    "write-combining",          /* 1 */
asm-i386/mtrr.h:    "write-through",            /* 4 */
asm-i386/mtrr.h:    "write-protect",            /* 5 */
asm-i386/mtrr.h:    "write-back",               /* 6 */
asm-i386/mtrr.h:    return -ENODEV;
asm-i386/mtrr.h:    return -ENODEV;
asm-i386/mtrr.h:    return -ENODEV;
asm-i386/mtrr.h:    return -ENODEV;
asm-i386/scatterlist.h: * Drivers must set either ->address or (preferred) ->page and ->offset
asm-i386/scatterlist.h: * Using ->page is recommended since it handles highmem data as well as
asm-i386/scatterlist.h: * low mem. ->address is restricted to data which has a virtual mapping, and
asm-i386/scatterlist.h: * it will go away in the future. Updating to ->page can be automated very
asm-i386/scatterlist.h: * easily -- something like
asm-i386/scatterlist.h: * sg->address = some_ptr;
asm-i386/scatterlist.h: * sg->page = virt_to_page(some_ptr);
asm-i386/scatterlist.h: * sg->offset = (unsigned long) some_ptr & ~PAGE_MASK;
asm-i386/smplock.h:	if (task->lock_depth >= 0) \
asm-i386/smplock.h: * Re-acquire the kernel lock
asm-i386/smplock.h:	if (task->lock_depth >= 0) \
asm-i386/smplock.h:	if (!++current->lock_depth)
asm-i386/smplock.h:		 "=m" (current->lock_depth));
asm-i386/smplock.h:	if (current->lock_depth < 0)
asm-i386/smplock.h:	if (--current->lock_depth < 0)
asm-i386/smplock.h:		 "=m" (current->lock_depth));
asm-i386/page.h:#define PAGE_MASK	(~(PAGE_SIZE-1))
asm-i386/page.h: *	Maybe the K6-III ?
asm-i386/page.h: * These are used to make use of C type-checking..
asm-i386/page.h:#define PAGE_ALIGN(addr)	(((addr)+PAGE_SIZE-1)&PAGE_MASK)
asm-i386/page.h:	size = (size-1) >> (PAGE_SHIFT-1);
asm-i386/page.h:	order = -1;
asm-i386/page.h:#define __MAXMEM		(-__PAGE_OFFSET-__VMALLOC_RESERVE)
asm-i386/page.h:#define MAXMEM			((unsigned long)(-PAGE_OFFSET-VMALLOC_RESERVE))
asm-i386/page.h:#define __pa(x)			((unsigned long)(x)-PAGE_OFFSET)
asm-i386/page.h:#define VALID_PAGE(page)	((page - mem_map) < max_mapnr)
asm-i386/pci-direct.h:#include "asm-x86_64/pci-direct.h"
asm-i386/pgtable-2level.h: * traditional i386 two-level paging structure:
asm-i386/pgtable-2level.h: * the i386 is two-level, so we don't really have any
asm-i386/pgtable-2level.h: * The "pgd_xxx()" functions here are trivial for a folded two-level
asm-i386/pgtable-2level.h:#define ptep_get_and_clear(xp)	__pte(xchg(&(xp)->pte_low, 0))
asm-i386/hdreg.h: *  linux/include/asm-i386/hdreg.h
asm-i386/hdreg.h: *  Copyright (C) 1994-1996  Linus Torvalds & authors
asm-i386/poll.h:/* The rest seem to be more-or-less nonstandard. Check them! */
asm-i386/types.h:/* DMA addresses come in generic and 64-bit flavours.  */
asm-i386/sembuf.h: * - 64-bit time_t to solve y2038 problem
asm-i386/sembuf.h: * - 2 miscellaneous 32-bit values
asm-i386/system.h:		     :"=m" (prev->thread.esp),"=m" (prev->thread.eip),	\
asm-i386/system.h:		     :"m" (next->thread.esp),"m" (next->thread.eip),	\
asm-i386/system.h:#define set_limit(ldt,limit) _set_limit( ((char *)&(ldt)) , ((limit)-1)>>12 )
asm-i386/system.h: * to do an SIMD/3DNOW!/MMX/FPU 64-bit store here, but that
asm-i386/system.h: * might have an implicit FPU-save as a cost, so it's not
asm-i386/system.h: * the instruction to be executed atomically, see page 3-102
asm-i386/system.h: *	  but generally the primitive is invalid, *ptr is output argument. --ANK
asm-i386/stat.h:	unsigned long	st_blocks;	/* Number 512-byte blocks allocated. */
asm-i386/mpspec.h:#define	MP_TRANSLATION  192  /* Used by IBM NUMA-Q to describe node locality */
asm-i386/checksum.h: * and adds in "sum" (32-bit)
asm-i386/checksum.h: * returns a 32-bit number suitable for feeding into itself
asm-i386/checksum.h: * it's best to have buff aligned on a 32-bit boundary
asm-i386/checksum.h: * checksums, and handles user-space pointer exceptions correctly, when needed.
asm-i386/checksum.h: * here even more important to align src and dst on a 32-bit (or even
asm-i386/checksum.h: * better 64-bit) boundary
asm-i386/checksum.h: * computes the checksum of the TCP/UDP pseudo-header
asm-i386/checksum.h: * returns a 16-bit checksum, already complemented
asm-i386/checksum.h: * this routine is used for miscellaneous IP-like checksums, mainly
asm-i386/checksum.h:		*err_ptr = -EFAULT;
asm-i386/checksum.h:	return -1; /* invalid checksum */
asm-i386/rwlock.h:/* include/asm-i386/rwlock.h
asm-i386/termios.h:#define N_IRDA		11	/* Linux IR - http://irda.sourceforge.net/ */
asm-i386/termios.h:#define N_SMSBLOCK	12	/* SMS block mode - for talking to GSM data cards about SMS messages */
asm-i386/termios.h:	get_user(__tmp,&(termio)->x); \
asm-i386/termios.h:	*(unsigned short *) &(termios)->x = __tmp; \
asm-i386/termios.h:	copy_from_user((termios)->c_cc, (termio)->c_cc, NCC); \
asm-i386/termios.h:	put_user((termios)->c_iflag, &(termio)->c_iflag); \
asm-i386/termios.h:	put_user((termios)->c_oflag, &(termio)->c_oflag); \
asm-i386/termios.h:	put_user((termios)->c_cflag, &(termio)->c_cflag); \
asm-i386/termios.h:	put_user((termios)->c_lflag, &(termio)->c_lflag); \
asm-i386/termios.h:	put_user((termios)->c_line,  &(termio)->c_line); \
asm-i386/termios.h:	copy_to_user((termio)->c_cc, (termios)->c_cc, NCC); \
asm-i386/user.h:   linux we use the 'trad-core' bfd).  There are quite a number of
asm-i386/user.h:   DATA: The data area is stored.  We use current->end_text to
asm-i386/user.h:   current->brk to pick up all of the user variables, plus any memory
asm-i386/user.h:   is demand-zero or if a page is totally unused, we just cover the entire
asm-i386/user.h:   current->start_stack, so we round each of these off in order to be able
asm-i386/user.h: * interacting with the FXSR-format floating point environment.  Floating
asm-i386/user.h:	long	st_space[20];	/* 8*10 bytes for each FP-reg = 80 bytes */
asm-i386/user.h:	long	st_space[32];	/* 8*16 bytes for each FP-reg = 128 bytes */
asm-i386/user.h:	long	xmm_space[32];	/* 8*16 bytes for each XMM-reg = 128 bytes */
asm-i386/user.h:/* When the kernel dumps core, it starts by dumping the user struct -
asm-i386/user.h:  int u_fpvalid;		/* True if math co-processor being used. */
asm-i386/user.h:  struct user_i387_struct i387;	/* Math Co-processor registers. */
asm-i386/user.h:  struct user_i387_struct* u_fpstate;	/* Math Co-processor pointer. */
asm-i386/vm86.h:#define VM86_UNKNOWN	1	/* unhandled GP fault - IO-instruction or similar */
asm-i386/vm86.h:#define VM86_TRAP	6	/* return due to DOS-debugger request */
asm-i386/vm86.h: * This is the stack-layout seen by the user space program when we have
asm-i386/vm86.h: * This is the (kernel) stack-layout when we have done a "SAVE_ALL" from vm86
asm-i386/vm86.h: * mode - the main change is that the old segment descriptors aren't
asm-i386/vm86.h: * this way. In front of 'return-eip' may be some data, depending on
asm-i386/vm86.h: * However, with GCC-2.7.2 and the current CFLAGS you see exactly this:
asm-i386/vm86.h:	long return-eip;        from call to vm86()
asm-i386/sl811-hw.h:File: include/asm-i386/sl811-hw.h
asm-i386/sl811-hw.h:Splitt hardware depens into file sl811-x86.h and sl811-arm.h.
asm-i386/sl811-hw.h:"hc->data_io" not used for x86 arch.
asm-i386/sl811-hw.h:Alternate IO-Base for second Controller (CF/USB1).
asm-i386/sl811-hw.h:Move Hardware depend header sl811-x86.h into include/asm-i386/sl811-hw.h.
asm-i386/sl811-hw.h:Low level only for port io into hardware-include.
asm-i386/sl811-hw.h:MODULE_PARM(io, "1-" __MODULE_STRING(MAX_CONTROLERS) "i");
asm-i386/sl811-hw.h:MODULE_PARM(irq, "1-" __MODULE_STRING(MAX_CONTROLERS) "i");
asm-i386/sl811-hw.h:	return ((__u8) inb (hc->addr_io+OFFSET_DATA_REG));
asm-i386/sl811-hw.h:	outb (index, hc->addr_io);
asm-i386/sl811-hw.h:	outb (data, hc->addr_io+OFFSET_DATA_REG);
asm-i386/sl811-hw.h:	outw (index|(((__u16)data) << 8), hc->addr_io);
asm-i386/sl811-hw.h:	if (hc->addr_io)
asm-i386/sl811-hw.h:		release_region(hc->addr_io, SIZEOF_IO_REGION);
asm-i386/sl811-hw.h:	hc->addr_io = 0;
asm-i386/sl811-hw.h:	if (hc->data_io)
asm-i386/sl811-hw.h:		release_region(hc->data_io, SIZEOF_IO_REGION);
asm-i386/sl811-hw.h:	hc->data_io = 0;
asm-i386/sl811-hw.h:		return -EBUSY;
asm-i386/sl811-hw.h:	hc->addr_io =	addr_io;
asm-i386/sl811-hw.h:	/* hc->data_io = data_io; */
asm-i386/serial.h: * include/asm-i386/serial.h
asm-i386/serial.h:	{ 0, BASE_BAUD, -1, 0, STD_COM_FLAGS},		/* ttySx device
asm-i386/pgtable.h: * The Linux memory management assumes a three-level page table setup. On
asm-i386/pgtable.h: * the i386, we use that, but "fold" the mid level into the top-level page
asm-i386/pgtable.h: * table, so that we physically have the same two-level page table as the
asm-i386/pgtable.h:/* Caches aren't brain-dead on the intel. */
asm-i386/pgtable.h: * for zero-mapped memory areas etc..
asm-i386/pgtable.h: * The Linux x86 paging architecture is 'compile-time dual-mode', it
asm-i386/pgtable.h: * implements both the traditional 2-level x86 page tables and the
asm-i386/pgtable.h: * newer 3-level PAE-mode page tables.
asm-i386/pgtable.h:# include <asm/pgtable-3level.h>
asm-i386/pgtable.h:# include <asm/pgtable-2level.h>
asm-i386/pgtable.h:#define PMD_MASK	(~(PMD_SIZE-1))
asm-i386/pgtable.h:#define PGDIR_MASK	(~(PGDIR_SIZE-1))
asm-i386/pgtable.h:#define KERNEL_PGD_PTRS (PTRS_PER_PGD-USER_PGD_PTRS)
asm-i386/pgtable.h:#define BOOT_KERNEL_PGD_PTRS (1024-BOOT_USER_PGD_PTRS)
asm-i386/pgtable.h: * any out-of-bounds memory accesses will hopefully be caught.
asm-i386/pgtable.h:#define VMALLOC_START	(((unsigned long) high_memory + 2*VMALLOC_OFFSET-1) & \
asm-i386/pgtable.h:						~(VMALLOC_OFFSET-1))
asm-i386/pgtable.h:# define VMALLOC_END	(PKMAP_BASE-2*PAGE_SIZE)
asm-i386/pgtable.h:# define VMALLOC_END	(FIXADDR_START-2*PAGE_SIZE)
asm-i386/pgtable.h: * the page directory entry points directly to a 4MB-aligned block of
asm-i386/pgtable.h:/* page table for 0-4MB for everybody */
asm-i386/pgtable.h:#define pages_to_mb(x) ((x) >> (20-PAGE_SHIFT))
asm-i386/pgtable.h:#define mk_pte(page, pgprot)	__mk_pte((page) - mem_map, (pgprot))
asm-i386/pgtable.h:/* to find an entry in a page-table-directory. */
asm-i386/pgtable.h:#define pgd_index(address) ((address >> PGDIR_SHIFT) & (PTRS_PER_PGD-1))
asm-i386/pgtable.h:#define pgd_offset(mm, address) ((mm)->pgd+pgd_index(address))
asm-i386/pgtable.h:/* to find an entry in a kernel page-table-directory */
asm-i386/pgtable.h:		(((address) >> PMD_SHIFT) & (PTRS_PER_PMD-1))
asm-i386/pgtable.h:/* Find an entry in the third-level page table.. */
asm-i386/pgtable.h:		((address >> PAGE_SHIFT) & (PTRS_PER_PTE - 1))
asm-i386/pgtable.h:/* Encode and de-code a swap entry */
asm-i386/unaligned.h: * get_unaligned - get value from possibly mis-aligned location
asm-i386/unaligned.h: * e.g. retrieving a u16 value from a location not u16-aligned.
asm-i386/unaligned.h: * put_unaligned - put value to a possibly mis-aligned location
asm-i386/unaligned.h: * e.g. writing a u16 value to a location not u16-aligned.
asm-i386/mca_dma.h: *   count by 2 when using 16-bit dma; that is not handled by these functions.
asm-i386/mca_dma.h: *   MODE_WRITE is vice-versa.  
asm-i386/mca_dma.h: *	mca_enable_dma	-	channel to enable DMA on
asm-i386/mca_dma.h: *	mca_disble_dma	-	channel to disable DMA on
asm-i386/mca_dma.h: *	mca_set_dma_addr -	load a 24bit DMA address
asm-i386/mca_dma.h: *	mca_get_dma_addr -	load a 24bit DMA address
asm-i386/mca_dma.h: *	mca_set_dma_count -	load a 16bit transfer count
asm-i386/mca_dma.h:	count--;  /* transfers one more than count -- correct for this */
asm-i386/mca_dma.h: *	mca_get_dma_residue -	get the remaining bytes to transfer
asm-i386/mca_dma.h: *	mca_set_dma_io -	set the port for an I/O transfer
asm-i386/mca_dma.h:	 * DMA from a port address -- set the io address
asm-i386/mca_dma.h: *	mca_set_dma_mode -	set the DMA mode
asm-i386/param.h:#define NOGROUP		(-1)
asm-i386/math_emu.h:   following a device-not-present interrupt, part of it saved
asm-i386/cache.h: * include/asm-i386/cache.h
asm-i386/string-486.h: * This string-include defines all string functions as inline
asm-i386/string-486.h: * normal. Most of the string-functions are rather heavily hand-optimized,
asm-i386/string-486.h: *			fixed - Petko Manolov (petkan@spct.net)
asm-i386/string-486.h: *	1999/10/14	3DNow memscpy() added - Petkan
asm-i386/string-486.h: *			and a few cleanups - Petkan
asm-i386/string-486.h:register char *tmp = (char *)(dest-1);
asm-i386/string-486.h:register char *tmp = (char *)(dest-1);
asm-i386/string-486.h:	"leal -1(%%esi),%0\n"
asm-i386/string-486.h:return __res-cs;
asm-i386/string-486.h:return (tmp-s-1);
asm-i386/string-486.h:	"cmpl $-1,%2\n\t"
asm-i386/string-486.h:**      This CPU favours 3DNow strongly (eg AMD K6-II, K6-III, Athlon)
asm-i386/string-486.h:	:"0" (n), "1" (n-1+(const char *)src), "2" (n-1+(char *)tmp)
asm-i386/siginfo.h:#define SI_PAD_SIZE	((SI_MAX_SIZE/sizeof(int)) - 3)
asm-i386/siginfo.h: * Digital reserves positive values for kernel-generated signals.
asm-i386/siginfo.h:#define SI_QUEUE	-1		/* sent by sigqueue */
asm-i386/siginfo.h:#define SI_TIMER __SI_CODE(__SI_TIMER,-2) /* sent by timer expiration */
asm-i386/siginfo.h:#define SI_MESGQ	-3		/* sent by real time mesq state change */
asm-i386/siginfo.h:#define SI_ASYNCIO	-4		/* sent by AIO completion */
asm-i386/siginfo.h:#define SI_SIGIO	-5		/* sent by queued SIGIO */
asm-i386/siginfo.h:#define SI_TKILL	-6		/* sent by tkill system call */
asm-i386/siginfo.h:#define SI_FROMUSER(siptr)	((siptr)->si_code <= 0)
asm-i386/siginfo.h:#define SI_FROMKERNEL(siptr)	((siptr)->si_code > 0)
asm-i386/siginfo.h:#define BUS_ADRERR	(__SI_FAULT|2)	/* non-existant physical address */
asm-i386/siginfo.h:#define SIGEV_PAD_SIZE	((SIGEV_MAX_SIZE/sizeof(int)) - 3)
asm-i386/siginfo.h:	if (from->si_code < 0)
asm-i386/siginfo.h:		memcpy(to, from, 3*sizeof(int) + sizeof(from->_sifields._sigchld));
asm-i386/floppy.h:(!(vdma) && ((unsigned long)(a)/K_64 != ((unsigned long)(a) + (s) - 1) / K_64))
asm-i386/floppy.h:		    lcount; lcount--, lptr++) {
asm-i386/floppy.h:		printk("DMA crossing 64-K boundary %p-%p\n", addr, addr+size);
asm-i386/floppy.h:		return -1;
asm-i386/floppy.h:static int FDC2 = -1;
asm-i386/sockios.h:/* Socket-level I/O control calls. */
asm-i386/keyboard.h: *  linux/include/asm-i386/keyboard.h
asm-i386/ioctl.h: * NOTE: This limits the max parameter size to 16kB -1 !
asm-i386/ioctl.h:#define _IOC_NRMASK	((1 << _IOC_NRBITS)-1)
asm-i386/ioctl.h:#define _IOC_TYPEMASK	((1 << _IOC_TYPEBITS)-1)
asm-i386/ioctl.h:#define _IOC_SIZEMASK	((1 << _IOC_SIZEBITS)-1)
asm-i386/ioctl.h:#define _IOC_DIRMASK	((1 << _IOC_DIRBITS)-1)
asm-i386/string.h:#include <asm/string-486.h>
asm-i386/string.h: * This string-include defines all string functions as inline
asm-i386/string.h: * normal. Most of the string-functions are rather heavily hand-optimized,
asm-i386/string.h: * used through-out, making for "slightly" unclear code :-)
asm-i386/string.h:	"leal -1(%%esi),%0\n"
asm-i386/string.h: * We get link-time errors if the structure sizes do not match.
asm-i386/string.h:	 "1" (n-1+(const char *)src),
asm-i386/string.h:	 "2" (n-1+(char *)dest)
asm-i386/string.h: * area at compile-time..
asm-i386/string.h:	"cmpl $-1,%1\n\t"
asm-i386/ioctls.h:#define TIOCGPTN	_IOR('T',0x30, unsigned int) /* Get Pty Number (of pty-mux device) */
asm-i386/msgbuf.h: * - 64-bit time_t to solve y2038 problem
asm-i386/msgbuf.h: * - 2 miscellaneous 32-bit values
asm-i386/socket.h:/* Security levels - as per NRL IPv6 - don't actually do anything */
asm-i386/socket.h:/* Nasty libc5 fixup - bletch */
asm-i386/socket.h:#define SOCK_RDM	4		/* reliably-delivered message	*/
asm-i386/debugreg.h:   debug registers.  Registers 0-3 contain the addresses we wish to trap on */
asm-i386/debugreg.h:#define DR_STEP		(0x4000)	/* single-step */
asm-i386/debugreg.h:   bits - each field corresponds to one of the four debug registers,
asm-ia64/sn/arc/hinv.h: * Copyright (C) 2000-2003 Silicon Graphics, Inc. All rights reserved.
asm-ia64/sn/arc/hinv.h:#define SGI_ARCS_VERS	64			/* sgi 64-bit version */
asm-ia64/sn/arc/types.h: * Copyright (c) 1999,2001-2003 Silicon Graphics, Inc.  All Rights Reserved.
asm-ia64/sn/arc/types.h:/* The pointer types.  We're 64-bit and the firmware is also 64-bit, so
asm-ia64/sn/pci/pic.h: * Copyright (C) 1992 - 1997, 2000-2003 Silicon Graphics, Inc. All rights reserved.
asm-ia64/sn/pci/pic.h: * The PIC ASIC is a follow-on to the Bridge and Xbridge ASICs.
asm-ia64/sn/pci/pic.h: * ------------------
asm-ia64/sn/pci/pic.h: *     The current PCI-X bus specification now defines that the parent
asm-ia64/sn/pci/pic.h: *     numbering which PCI-X requires in configuration space. In the past we
asm-ia64/sn/pci/pic.h: *     correlated Configs pace and our device space 0 <-> 0, 1 <-> 1, etc.
asm-ia64/sn/pci/pic.h: *     PCI-X requires we start a 1, not 0 and currently the PX brick
asm-ia64/sn/pci/pic.h: * The net effect is that all config space access are off-by-one with 
asm-ia64/sn/pci/pic.h: * relation to other per-slot accesses on the PIC.   
asm-ia64/sn/pci/pic.h: * ----------|---------------------------------------
asm-ia64/sn/pci/pic.h: * ----------|---------------------------------------
asm-ia64/sn/pci/pic.h:	/* Identification Register  -- read-only */
asm-ia64/sn/pci/pic.h:	/* Status Register  -- read-only */
asm-ia64/sn/pci/pic.h:	/* Upper Address Holding Register Bus Side Errors  -- read-only */
asm-ia64/sn/pci/pic.h:	/* Lower Address Holding Register Bus Side Errors  -- read-only */
asm-ia64/sn/pci/pic.h:	/* Control Register  -- read/write */
asm-ia64/sn/pci/pic.h:	/* PCI Request Time-out Value Register  -- read/write */
asm-ia64/sn/pci/pic.h:	/* Interrupt Destination Upper Address Register  -- read/write */
asm-ia64/sn/pci/pic.h:	/* Interrupt Destination Lower Address Register  -- read/write */
asm-ia64/sn/pci/pic.h:	/* Command Word Holding Register Bus Side  -- read-only */
asm-ia64/sn/pci/pic.h:	/* LLP Configuration Register (Bus 0 Only)  -- read/write */
asm-ia64/sn/pci/pic.h:	/* PCI Target Flush Register  -- read-only */
asm-ia64/sn/pci/pic.h:	/* Command Word Holding Register Link Side  -- read-only */
asm-ia64/sn/pci/pic.h:	/* Response Buffer Error Upper Address Holding  -- read-only */
asm-ia64/sn/pci/pic.h:	/* Response Buffer Error Lower Address Holding  -- read-only */
asm-ia64/sn/pci/pic.h:	/* Test Pin Control Register  -- read/write */
asm-ia64/sn/pci/pic.h:	/* Address Holding Register Link Side Errors  -- read-only */
asm-ia64/sn/pci/pic.h:	/* Direct Map Register  -- read/write */
asm-ia64/sn/pci/pic.h:	/* PCI Map Fault Address Register  -- read-only */
asm-ia64/sn/pci/pic.h:	/* Arbitration Priority Register  -- read/write */
asm-ia64/sn/pci/pic.h:	/* Internal Ram Parity Error Register  -- read-only */
asm-ia64/sn/pci/pic.h:	/* PCI Time-out Register  -- read/write */
asm-ia64/sn/pci/pic.h:	/* PCI Type 1 Configuration Register  -- read/write */
asm-ia64/sn/pci/pic.h:	/* PCI Bus Error Upper Address Holding Register  -- read-only */
asm-ia64/sn/pci/pic.h:	/* PCI Bus Error Lower Address Holding Register  -- read-only */
asm-ia64/sn/pci/pic.h:	/* PCIX Error Address Register  -- read-only */
asm-ia64/sn/pci/pic.h:	/* PCIX Error Attribute Register  -- read-only */
asm-ia64/sn/pci/pic.h:	/* PCIX Error Data Register  -- read-only */
asm-ia64/sn/pci/pic.h:	/* PCIX Read Request Timeout Error Register  -- read-only */
asm-ia64/sn/pci/pic.h:	/* Interrupt Status Register  -- read-only */
asm-ia64/sn/pci/pic.h:	/* Interrupt Enable Register  -- read/write */
asm-ia64/sn/pci/pic.h:	/* Reset Interrupt Status Register  -- write-only */
asm-ia64/sn/pci/pic.h:	/* Interrupt Mode Register  -- read/write */
asm-ia64/sn/pci/pic.h:	/* Interrupt Device Register  -- read/write */
asm-ia64/sn/pci/pic.h:	/* Host Error Field Register  -- read/write */
asm-ia64/sn/pci/pic.h:	/* Interrupt Pin 0 Host Address Register  -- read/write */
asm-ia64/sn/pci/pic.h:	/* Interrupt Pin 1 Host Address Register  -- read/write */
asm-ia64/sn/pci/pic.h:	/* Interrupt Pin 2 Host Address Register  -- read/write */
asm-ia64/sn/pci/pic.h:	/* Interrupt Pin 3 Host Address Register  -- read/write */
asm-ia64/sn/pci/pic.h:	/* Interrupt Pin 4 Host Address Register  -- read/write */
asm-ia64/sn/pci/pic.h:	/* Interrupt Pin 5 Host Address Register  -- read/write */
asm-ia64/sn/pci/pic.h:	/* Interrupt Pin 6 Host Address Register  -- read/write */
asm-ia64/sn/pci/pic.h:	/* Interrupt Pin 7 Host Address Register  -- read/write */
asm-ia64/sn/pci/pic.h:	/* Error Interrupt View Register  -- read-only */
asm-ia64/sn/pci/pic.h:	/* Multiple Interrupt Register  -- read-only */
asm-ia64/sn/pci/pic.h:	/* Force Always Interrupt 0 Register  -- write-only */
asm-ia64/sn/pci/pic.h:	/* Force Always Interrupt 1 Register  -- write-only */
asm-ia64/sn/pci/pic.h:	/* Force Always Interrupt 2 Register  -- write-only */
asm-ia64/sn/pci/pic.h:	/* Force Always Interrupt 3 Register  -- write-only */
asm-ia64/sn/pci/pic.h:	/* Force Always Interrupt 4 Register  -- write-only */
asm-ia64/sn/pci/pic.h:	/* Force Always Interrupt 5 Register  -- write-only */
asm-ia64/sn/pci/pic.h:	/* Force Always Interrupt 6 Register  -- write-only */
asm-ia64/sn/pci/pic.h:	/* Force Always Interrupt 7 Register  -- write-only */
asm-ia64/sn/pci/pic.h:	/* Force w/Pin Interrupt 0 Register  -- write-only */
asm-ia64/sn/pci/pic.h:	/* Force w/Pin Interrupt 1 Register  -- write-only */
asm-ia64/sn/pci/pic.h:	/* Force w/Pin Interrupt 2 Register  -- write-only */
asm-ia64/sn/pci/pic.h:	/* Force w/Pin Interrupt 3 Register  -- write-only */
asm-ia64/sn/pci/pic.h:	/* Force w/Pin Interrupt 4 Register  -- write-only */
asm-ia64/sn/pci/pic.h:	/* Force w/Pin Interrupt 5 Register  -- write-only */
asm-ia64/sn/pci/pic.h:	/* Force w/Pin Interrupt 6 Register  -- write-only */
asm-ia64/sn/pci/pic.h:	/* Force w/Pin Interrupt 7 Register  -- write-only */
asm-ia64/sn/pci/pic.h:	/* Device 0 Register  -- read/write */
asm-ia64/sn/pci/pic.h:	/* Device 1 Register  -- read/write */
asm-ia64/sn/pci/pic.h:	/* Device 2 Register  -- read/write */
asm-ia64/sn/pci/pic.h:	/* Device 3 Register  -- read/write */
asm-ia64/sn/pci/pic.h:	/* Device 0 Write Request Buffer Register  -- read-only */
asm-ia64/sn/pci/pic.h:	/* Device 1 Write Request Buffer Register  -- read-only */
asm-ia64/sn/pci/pic.h:	/* Device 2 Write Request Buffer Register  -- read-only */
asm-ia64/sn/pci/pic.h:	/* Device 3 Write Request Buffer Register  -- read-only */
asm-ia64/sn/pci/pic.h:	/* Even Device Response Buffer Register  -- read/write */
asm-ia64/sn/pci/pic.h:	/* Odd Device Response Buffer Register  -- read/write */
asm-ia64/sn/pci/pic.h:	/* Read Response Buffer Status Register  -- read-only */
asm-ia64/sn/pci/pic.h:	/* Read Response Buffer Clear Register  -- write-only */
asm-ia64/sn/pci/pic.h:	/* PCI RR 0 Upper Address Match Register  -- read-only */
asm-ia64/sn/pci/pic.h:	/* PCI RR 0 Lower Address Match Register  -- read-only */
asm-ia64/sn/pci/pic.h:	/* PCI RR 1 Upper Address Match Register  -- read-only */
asm-ia64/sn/pci/pic.h:	/* PCI RR 1 Lower Address Match Register  -- read-only */
asm-ia64/sn/pci/pic.h:	/* PCI RR 2 Upper Address Match Register  -- read-only */
asm-ia64/sn/pci/pic.h:	/* PCI RR 2 Lower Address Match Register  -- read-only */
asm-ia64/sn/pci/pic.h:	/* PCI RR 3 Upper Address Match Register  -- read-only */
asm-ia64/sn/pci/pic.h:	/* PCI RR 3 Lower Address Match Register  -- read-only */
asm-ia64/sn/pci/pic.h:	/* PCI RR 4 Upper Address Match Register  -- read-only */
asm-ia64/sn/pci/pic.h:	/* PCI RR 4 Lower Address Match Register  -- read-only */
asm-ia64/sn/pci/pic.h:	/* PCI RR 5 Upper Address Match Register  -- read-only */
asm-ia64/sn/pci/pic.h:	/* PCI RR 5 Lower Address Match Register  -- read-only */
asm-ia64/sn/pci/pic.h:	/* PCI RR 6 Upper Address Match Register  -- read-only */
asm-ia64/sn/pci/pic.h:	/* PCI RR 6 Lower Address Match Register  -- read-only */
asm-ia64/sn/pci/pic.h:	/* PCI RR 7 Upper Address Match Register  -- read-only */
asm-ia64/sn/pci/pic.h:	/* PCI RR 7 Lower Address Match Register  -- read-only */
asm-ia64/sn/pci/pic.h:	/* PCI RR 8 Upper Address Match Register  -- read-only */
asm-ia64/sn/pci/pic.h:	/* PCI RR 8 Lower Address Match Register  -- read-only */
asm-ia64/sn/pci/pic.h:	/* PCI RR 9 Upper Address Match Register  -- read-only */
asm-ia64/sn/pci/pic.h:	/* PCI RR 9 Lower Address Match Register  -- read-only */
asm-ia64/sn/pci/pic.h:	/* PCI RR 10 Upper Address Match Register  -- read-only */
asm-ia64/sn/pci/pic.h:	/* PCI RR 10 Lower Address Match Register  -- read-only */
asm-ia64/sn/pci/pic.h:	/* PCI RR 11 Upper Address Match Register  -- read-only */
asm-ia64/sn/pci/pic.h:	/* PCI RR 11 Lower Address Match Register  -- read-only */
asm-ia64/sn/pci/pic.h:	/* PCI RR 12 Upper Address Match Register  -- read-only */
asm-ia64/sn/pci/pic.h:	/* PCI RR 12 Lower Address Match Register  -- read-only */
asm-ia64/sn/pci/pic.h:	/* PCI RR 13 Upper Address Match Register  -- read-only */
asm-ia64/sn/pci/pic.h:	/* PCI RR 13 Lower Address Match Register  -- read-only */
asm-ia64/sn/pci/pic.h:	/* PCI RR 14 Upper Address Match Register  -- read-only */
asm-ia64/sn/pci/pic.h:	/* PCI RR 14 Lower Address Match Register  -- read-only */
asm-ia64/sn/pci/pic.h:	/* PCI RR 15 Upper Address Match Register  -- read-only */
asm-ia64/sn/pci/pic.h:	/* PCI RR 15 Lower Address Match Register  -- read-only */
asm-ia64/sn/pci/pic.h:	/* Buffer 0 Flush Count with Data Touch Register  -- read/write */
asm-ia64/sn/pci/pic.h:	/* Buffer 0 Flush Count w/o Data Touch Register  -- read/write */
asm-ia64/sn/pci/pic.h:	/* Buffer 0 Request in Flight Count Register  -- read/write */
asm-ia64/sn/pci/pic.h:	/* Buffer 0 Prefetch Request Count Register  -- read/write */
asm-ia64/sn/pci/pic.h:	/* Buffer 0 Total PCI Retry Count Register  -- read/write */
asm-ia64/sn/pci/pic.h:	/* Buffer 0 Max PCI Retry Count Register  -- read/write */
asm-ia64/sn/pci/pic.h:	/* Buffer 0 Max Latency Count Register  -- read/write */
asm-ia64/sn/pci/pic.h:	/* Buffer 0 Clear All Register  -- read/write */
asm-ia64/sn/pci/pic.h:	/* Buffer 2 Flush Count with Data Touch Register  -- read/write */
asm-ia64/sn/pci/pic.h:	/* Buffer 2 Flush Count w/o Data Touch Register  -- read/write */
asm-ia64/sn/pci/pic.h:	/* Buffer 2 Request in Flight Count Register  -- read/write */
asm-ia64/sn/pci/pic.h:	/* Buffer 2 Prefetch Request Count Register  -- read/write */
asm-ia64/sn/pci/pic.h:	/* Buffer 2 Total PCI Retry Count Register  -- read/write */
asm-ia64/sn/pci/pic.h:	/* Buffer 2 Max PCI Retry Count Register  -- read/write */
asm-ia64/sn/pci/pic.h:	/* Buffer 2 Max Latency Count Register  -- read/write */
asm-ia64/sn/pci/pic.h:	/* Buffer 2 Clear All Register  -- read/write */
asm-ia64/sn/pci/pic.h:	/* Buffer 4 Flush Count with Data Touch Register  -- read/write */
asm-ia64/sn/pci/pic.h:	/* Buffer 4 Flush Count w/o Data Touch Register  -- read/write */
asm-ia64/sn/pci/pic.h:	/* Buffer 4 Request in Flight Count Register  -- read/write */
asm-ia64/sn/pci/pic.h:	/* Buffer 4 Prefetch Request Count Register  -- read/write */
asm-ia64/sn/pci/pic.h:	/* Buffer 4 Total PCI Retry Count Register  -- read/write */
asm-ia64/sn/pci/pic.h:	/* Buffer 4 Max PCI Retry Count Register  -- read/write */
asm-ia64/sn/pci/pic.h:	/* Buffer 4 Max Latency Count Register  -- read/write */
asm-ia64/sn/pci/pic.h:	/* Buffer 4 Clear All Register  -- read/write */
asm-ia64/sn/pci/pic.h:	/* Buffer 6 Flush Count with Data Touch Register  -- read/write */
asm-ia64/sn/pci/pic.h:	/* Buffer 6 Flush Count w/o Data Touch Register  -- read/write */
asm-ia64/sn/pci/pic.h:	/* Buffer 6 Request in Flight Count Register  -- read/write */
asm-ia64/sn/pci/pic.h:	/* Buffer 6 Prefetch Request Count Register  -- read/write */
asm-ia64/sn/pci/pic.h:	/* Buffer 6 Total PCI Retry Count Register  -- read/write */
asm-ia64/sn/pci/pic.h:	/* Buffer 6 Max PCI Retry Count Register  -- read/write */
asm-ia64/sn/pci/pic.h:	/* Buffer 6 Max Latency Count Register  -- read/write */
asm-ia64/sn/pci/pic.h:	/* Buffer 6 Clear All Register  -- read/write */
asm-ia64/sn/pci/pic.h:	/* Buffer 8 Flush Count with Data Touch Register  -- read/write */
asm-ia64/sn/pci/pic.h:	/* Buffer 8 Flush Count w/o Data Touch Register  -- read/write */
asm-ia64/sn/pci/pic.h:	/* Buffer 8 Request in Flight Count Register  -- read/write */
asm-ia64/sn/pci/pic.h:	/* Buffer 8 Prefetch Request Count Register  -- read/write */
asm-ia64/sn/pci/pic.h:	/* Buffer 8 Total PCI Retry Count Register  -- read/write */
asm-ia64/sn/pci/pic.h:	/* Buffer 8 Max PCI Retry Count Register  -- read/write */
asm-ia64/sn/pci/pic.h:	/* Buffer 8 Max Latency Count Register  -- read/write */
asm-ia64/sn/pci/pic.h:	/* Buffer 8 Clear All Register  -- read/write */
asm-ia64/sn/pci/pic.h:	/* Buffer 10 Flush Count with Data Touch Register  -- read/write */
asm-ia64/sn/pci/pic.h:	/* Buffer 10 Flush Count w/o Data Touch Register  -- read/write */
asm-ia64/sn/pci/pic.h:	/* Buffer 10 Request in Flight Count Register  -- read/write */
asm-ia64/sn/pci/pic.h:	/* Buffer 10 Prefetch Request Count Register  -- read/write */
asm-ia64/sn/pci/pic.h:	/* Buffer 10 Total PCI Retry Count Register  -- read/write */
asm-ia64/sn/pci/pic.h:	/* Buffer 10 Max PCI Retry Count Register  -- read/write */
asm-ia64/sn/pci/pic.h:	/* Buffer 10 Max Latency Count Register  -- read/write */
asm-ia64/sn/pci/pic.h:	/* Buffer 10 Clear All Register  -- read/write */
asm-ia64/sn/pci/pic.h:	/* Buffer 12 Flush Count with Data Touch Register  -- read/write */
asm-ia64/sn/pci/pic.h:	/* Buffer 12 Flush Count w/o Data Touch Register  -- read/write */
asm-ia64/sn/pci/pic.h:	/* Buffer 12 Request in Flight Count Register  -- read/write */
asm-ia64/sn/pci/pic.h:	/* Buffer 12 Prefetch Request Count Register  -- read/write */
asm-ia64/sn/pci/pic.h:	/* Buffer 12 Total PCI Retry Count Register  -- read/write */
asm-ia64/sn/pci/pic.h:	/* Buffer 12 Max PCI Retry Count Register  -- read/write */
asm-ia64/sn/pci/pic.h:	/* Buffer 12 Max Latency Count Register  -- read/write */
asm-ia64/sn/pci/pic.h:	/* Buffer 12 Clear All Register  -- read/write */
asm-ia64/sn/pci/pic.h:	/* Buffer 14 Flush Count with Data Touch Register  -- read/write */
asm-ia64/sn/pci/pic.h:	/* Buffer 14 Flush Count w/o Data Touch Register  -- read/write */
asm-ia64/sn/pci/pic.h:	/* Buffer 14 Request in Flight Count Register  -- read/write */
asm-ia64/sn/pci/pic.h:	/* Buffer 14 Prefetch Request Count Register  -- read/write */
asm-ia64/sn/pci/pic.h:	/* Buffer 14 Total PCI Retry Count Register  -- read/write */
asm-ia64/sn/pci/pic.h:	/* Buffer 14 Max PCI Retry Count Register  -- read/write */
asm-ia64/sn/pci/pic.h:	/* Buffer 14 Max Latency Count Register  -- read/write */
asm-ia64/sn/pci/pic.h:	/* Buffer 14 Clear All Register  -- read/write */
asm-ia64/sn/pci/pic.h:	/* PCIX Read Buffer 0 Address Register  -- read-only */
asm-ia64/sn/pci/pic.h:	/* PCIX Read Buffer 0 Attribute Register  -- read-only */
asm-ia64/sn/pci/pic.h:	/* PCIX Read Buffer 1 Address Register  -- read-only */
asm-ia64/sn/pci/pic.h:	/* PCIX Read Buffer 1 Attribute Register  -- read-only */
asm-ia64/sn/pci/pic.h:	/* PCIX Read Buffer 2 Address Register  -- read-only */
asm-ia64/sn/pci/pic.h:	/* PCIX Read Buffer 2 Attribute Register  -- read-only */
asm-ia64/sn/pci/pic.h:	/* PCIX Read Buffer 3 Address Register  -- read-only */
asm-ia64/sn/pci/pic.h:	/* PCIX Read Buffer 3 Attribute Register  -- read-only */
asm-ia64/sn/pci/pic.h:	/* PCIX Read Buffer 4 Address Register  -- read-only */
asm-ia64/sn/pci/pic.h:	/* PCIX Read Buffer 4 Attribute Register  -- read-only */
asm-ia64/sn/pci/pic.h:	/* PCIX Read Buffer 5 Address Register  -- read-only */
asm-ia64/sn/pci/pic.h:	/* PCIX Read Buffer 5 Attribute Register  -- read-only */
asm-ia64/sn/pci/pic.h:	/* PCIX Read Buffer 6 Address Register  -- read-only */
asm-ia64/sn/pci/pic.h:	/* PCIX Read Buffer 6 Attribute Register  -- read-only */
asm-ia64/sn/pci/pic.h:	/* PCIX Read Buffer 7 Address Register  -- read-only */
asm-ia64/sn/pci/pic.h:	/* PCIX Read Buffer 7 Attribute Register  -- read-only */
asm-ia64/sn/pci/pic.h:	/* PCIX Read Buffer 8 Address Register  -- read-only */
asm-ia64/sn/pci/pic.h:	/* PCIX Read Buffer 8 Attribute Register  -- read-only */
asm-ia64/sn/pci/pic.h:	/* PCIX Read Buffer 9 Address Register  -- read-only */
asm-ia64/sn/pci/pic.h:	/* PCIX Read Buffer 9 Attribute Register  -- read-only */
asm-ia64/sn/pci/pic.h:	/* PCIX Read Buffer 10 Address Register  -- read-only */
asm-ia64/sn/pci/pic.h:	/* PCIX Read Buffer 10 Attribute Register  -- read-only */
asm-ia64/sn/pci/pic.h:	/* PCIX Read Buffer 11 Address Register  -- read-only */
asm-ia64/sn/pci/pic.h:	/* PCIX Read Buffer 11 Attribute Register  -- read-only */
asm-ia64/sn/pci/pic.h:	/* PCIX Read Buffer 12 Address Register  -- read-only */
asm-ia64/sn/pci/pic.h:	/* PCIX Read Buffer 12 Attribute Register  -- read-only */
asm-ia64/sn/pci/pic.h:	/* PCIX Read Buffer 13 Address Register  -- read-only */
asm-ia64/sn/pci/pic.h:	/* PCIX Read Buffer 13 Attribute Register  -- read-only */
asm-ia64/sn/pci/pic.h:	/* PCIX Read Buffer 14 Address Register  -- read-only */
asm-ia64/sn/pci/pic.h:	/* PCIX Read Buffer 14 Attribute Register  -- read-only */
asm-ia64/sn/pci/pic.h:	/* PCIX Read Buffer 15 Address Register  -- read-only */
asm-ia64/sn/pci/pic.h:	/* PCIX Read Buffer 15 Attribute Register  -- read-only */
asm-ia64/sn/pci/pic.h:	/* PCIX Write Buffer 0 Address Register  -- read-only */
asm-ia64/sn/pci/pic.h:	/* PCIX Write Buffer 0 Attribute Register  -- read-only */
asm-ia64/sn/pci/pic.h:	/* PCIX Write Buffer 0 Valid Register  -- read-only */
asm-ia64/sn/pci/pic.h:	/* PCIX Write Buffer 1 Address Register  -- read-only */
asm-ia64/sn/pci/pic.h:	/* PCIX Write Buffer 1 Attribute Register  -- read-only */
asm-ia64/sn/pci/pic.h:	/* PCIX Write Buffer 1 Valid Register  -- read-only */
asm-ia64/sn/pci/pic.h:	/* PCIX Write Buffer 2 Address Register  -- read-only */
asm-ia64/sn/pci/pic.h:	/* PCIX Write Buffer 2 Attribute Register  -- read-only */
asm-ia64/sn/pci/pic.h:	/* PCIX Write Buffer 2 Valid Register  -- read-only */
asm-ia64/sn/pci/pic.h:	/* PCIX Write Buffer 3 Address Register  -- read-only */
asm-ia64/sn/pci/pic.h:	/* PCIX Write Buffer 3 Attribute Register  -- read-only */
asm-ia64/sn/pci/pic.h:	/* PCIX Write Buffer 3 Valid Register  -- read-only */
asm-ia64/sn/pci/pic.h:	/* PCIX Write Buffer 4 Address Register  -- read-only */
asm-ia64/sn/pci/pic.h:	/* PCIX Write Buffer 4 Attribute Register  -- read-only */
asm-ia64/sn/pci/pic.h:	/* PCIX Write Buffer 4 Valid Register  -- read-only */
asm-ia64/sn/pci/pic.h:	/* PCIX Write Buffer 5 Address Register  -- read-only */
asm-ia64/sn/pci/pic.h:	/* PCIX Write Buffer 5 Attribute Register  -- read-only */
asm-ia64/sn/pci/pic.h:	/* PCIX Write Buffer 5 Valid Register  -- read-only */
asm-ia64/sn/pci/pic.h:	/* PCIX Write Buffer 6 Address Register  -- read-only */
asm-ia64/sn/pci/pic.h:	/* PCIX Write Buffer 6 Attribute Register  -- read-only */
asm-ia64/sn/pci/pic.h:	/* PCIX Write Buffer 6 Valid Register  -- read-only */
asm-ia64/sn/pci/pic.h:	/* PCIX Write Buffer 7 Address Register  -- read-only */
asm-ia64/sn/pci/pic.h:	/* PCIX Write Buffer 7 Attribute Register  -- read-only */
asm-ia64/sn/pci/pic.h:	/* PCIX Write Buffer 7 Valid Register  -- read-only */
asm-ia64/sn/pci/pic.h: * the upper 16-bits of the address when certain error occurs (see error cases
asm-ia64/sn/pci/pic.h: * the address which either can be accessed as a word or double word. Sub-
asm-ia64/sn/pci/pic.h: * The control register is a read/write register which holds control informa-
asm-ia64/sn/pci/pic.h: * PCI/PCI-X Request Time-out Value Register
asm-ia64/sn/pci/pic.h: * containing the upper 16-bits of address of the host to which the interrupt
asm-ia64/sn/pci/pic.h: * which contains the entire address of the host to which the interrupt is tar-
asm-ia64/sn/pci/pic.h: * chapter). Errors are indicated with error bits in the interrupt status regis-
asm-ia64/sn/pci/pic.h: * PCI/PCI-X Target Flush Register
asm-ia64/sn/pci/pic.h: * The command word holding is a read-only register that holds the com-
asm-ia64/sn/pci/pic.h: * mand word of a Crosstalk packet when request fifo overflow or unexpect-
asm-ia64/sn/pci/pic.h: * interrupt status register. Subsequent errors are not logged until this inter-
asm-ia64/sn/pci/pic.h: * register which contains the upper 16-bits of the address when error asso-
asm-ia64/sn/pci/pic.h: * The address holding register is a read only register which contains the ad-
asm-ia64/sn/pci/pic.h: * This register defines the priority and bus time out timing in PCI bus arbi-
asm-ia64/sn/pci/pic.h: * Time-out Register
asm-ia64/sn/pci/pic.h: * accesses to PCI/PCI-X.
asm-ia64/sn/pci/pic.h: * PCI/PCI-X Type 1 Configuration Register
asm-ia64/sn/pci/pic.h: * This register is use during accesses to the PCI/PCI-X type 1 configuration
asm-ia64/sn/pci/pic.h: * PCI-X Error Address Register
asm-ia64/sn/pci/pic.h: * This register contains the address on the PCI-X bus when an error oc-
asm-ia64/sn/pci/pic.h: * PCI-X Error Attribute Register
asm-ia64/sn/pci/pic.h: * This register contains the attribute data on the PCI-X bus when an error
asm-ia64/sn/pci/pic.h: * PCI-X Error Data Register
asm-ia64/sn/pci/pic.h: * This register contains the Data on the PCI-X bus when an error occurred.
asm-ia64/sn/pci/pic.h: * PCI-X Read Request Timeout Error Register
asm-ia64/sn/pci/pic.h: * This register contains a pointer into the PCI-X read data structure.
asm-ia64/sn/pci/pic.h: * This register indicates if any interrupt occurs more than once without be-
asm-ia64/sn/pci/pic.h: * A write to this data independent write only register will force a set inter-
asm-ia64/sn/pci/pic.h: * is already active an addition set interrupt packet is set. All buffer flush op-
asm-ia64/sn/pci/pic.h: * When read, this register will return a 0x00 after the write buffer associat-
asm-ia64/sn/pci/pic.h: * This register is use to allocate the read response buffers for the even num-
asm-ia64/sn/pci/pic.h: * This register is use to allocate the read response buffers for the odd num-
asm-ia64/sn/pci/pic.h: * register which contains the upper 16-bits of the address and status used to
asm-ia64/sn/pci/pic.h: * This counter is incremented on each bus clock while the request is in-
asm-ia64/sn/pci/pic.h: * This counter is incremented each time a PCI bus retry occurs and the ad-
asm-ia64/sn/pci/pic.h: * request in-flight. A word write to this address clears the count.
asm-ia64/sn/pci/pic.h: * which was in-flight for this buffer. A word write to this address clears the
asm-ia64/sn/pci/pic.h: * request which was in-flight for this buffer. A word write to this address
asm-ia64/sn/pci/pic.h: * PCI-X Registers
asm-ia64/sn/pci/pic.h: * PCI-X Read Buffer (x) Attribute Register
asm-ia64/sn/pci/pic.h: * PCI-X Write Buffer (x) Address Register
asm-ia64/sn/pci/pic.h: * PCI-X Write Buffer (x) Attribute Register
asm-ia64/sn/pci/pic.h: * PCI-X Write Buffer (x) Valid Register
asm-ia64/sn/pci/pic.h: * This register contains the valid or inuse cache lines for this buffer struc-
asm-ia64/sn/pci/bridge.h: * Copyright (c) 1992-1997,2000-2003 Silicon Graphics, Inc. All rights reserved.
asm-ia64/sn/pci/bridge.h: * bridge.h - header file for bridge chip and bridge portion of xbridge chip
asm-ia64/sn/pci/bridge.h: * The PIC asic is a follow-on to Xbridge and most of its registers are
asm-ia64/sn/pci/bridge.h:#define IOPGOFF(x)		((x) & (IOPGSIZE-1))
asm-ia64/sn/pci/bridge.h: * using 32-bit loads and stores.
asm-ia64/sn/pci/bridge.h:    /* 0x000000-0x00FFFF -- Local Registers */
asm-ia64/sn/pci/bridge.h:    /* 0x000000-0x000057 -- Standard Widget Configuration */
asm-ia64/sn/pci/bridge.h:    /* 0x000058-0x00007F -- Bridge-specific Widget Configuration */
asm-ia64/sn/pci/bridge.h:    /* 0x000080-0x00008F -- PMU */
asm-ia64/sn/pci/bridge.h:    /* 0x000090-0x00009F -- SSRAM */
asm-ia64/sn/pci/bridge.h:    /* 0x0000A0-0x0000AF -- Arbitration */
asm-ia64/sn/pci/bridge.h:    /* 0x0000B0-0x0000BF -- Number In A Can or ATE Parity Error */
asm-ia64/sn/pci/bridge.h:    /* 0x0000C0-0x0000FF -- PCI/GIO */
asm-ia64/sn/pci/bridge.h:    /* 0x000100-0x0001FF -- Interrupt */
asm-ia64/sn/pci/bridge.h:    /* 0x000200-0x0003FF -- Device */
asm-ia64/sn/pci/bridge.h:    /* 0x000400-0x0005FF -- Performance Monitor Registers (even only) */
asm-ia64/sn/pci/bridge.h:    /* 0x000600-0x0009FF -- PCI/X registers */
asm-ia64/sn/pci/bridge.h:    /* 0x000A00-0x000BFF -- PCI/X Read&Write Buffer */
asm-ia64/sn/pci/bridge.h:    char		    _pad_000c00[0x010000 - 0x000c00];
asm-ia64/sn/pci/bridge.h:    /* 0x010000-0x011fff -- Internal Address Translation Entry RAM */
asm-ia64/sn/pci/bridge.h:	bridge_ate_t	    wr;	/* write-only */    /* 0x01{0000,,,1FF8} */
asm-ia64/sn/pci/bridge.h:	    bridgereg_t	    rd; /* read-only */     /* 0x01{0004,,,1FFC} */
asm-ia64/sn/pci/bridge.h:    /* 0x012000-0x013fff -- Internal Address Translation Entry RAM LOW */
asm-ia64/sn/pci/bridge.h:	bridgereg_t	    rd; /* read-only */	    /* 0x01{2004,,,3FFC} */
asm-ia64/sn/pci/bridge.h:    char		    _pad_014000[0x18000 - 0x014000];
asm-ia64/sn/pci/bridge.h:    /* 0x18000-0x197F8 -- PIC Write Request Ram */
asm-ia64/sn/pci/bridge.h:				/* 0x18000 - 0x187F8 */
asm-ia64/sn/pci/bridge.h:				/* 0x18800 - 0x18FF8 */
asm-ia64/sn/pci/bridge.h:				/* 0x19000 - 0x197F8 */
asm-ia64/sn/pci/bridge.h:    char		    _pad_019800[0x20000 - 0x019800];
asm-ia64/sn/pci/bridge.h:    /* 0x020000-0x027FFF -- PCI Device Configuration Spaces */
asm-ia64/sn/pci/bridge.h:    /* 0x028000-0x028FFF -- PCI Type 1 Configuration Space */
asm-ia64/sn/pci/bridge.h:    } b_type1_cfg;				    /* 0x028000-0x029000 */
asm-ia64/sn/pci/bridge.h:    char		    _pad_029000[0x007000];  /* 0x029000-0x030000 */
asm-ia64/sn/pci/bridge.h:    /* 0x030000-0x030007 -- PCI Interrupt Acknowledge Cycle */
asm-ia64/sn/pci/bridge.h:    } b_pci_iack;				    /* 0x030000-0x030007 */
asm-ia64/sn/pci/bridge.h:    uchar_t		    _pad_030007[0x04fff8];  /* 0x030008-0x07FFFF */
asm-ia64/sn/pci/bridge.h:    /* 0x080000-0x0FFFFF -- External Address Translation Entry RAM */
asm-ia64/sn/pci/bridge.h:    /* 0x100000-0x1FFFFF -- Reserved */
asm-ia64/sn/pci/bridge.h:    char		    _pad_100000[0x200000-0x100000];
asm-ia64/sn/pci/bridge.h:    /* 0x200000-0xBFFFFF -- PCI/GIO Device Spaces */
asm-ia64/sn/pci/bridge.h:    /* 0xC00000-0xFFFFFF -- External Flash Proms 1,0 */
asm-ia64/sn/pci/bridge.h:	uchar_t		    c[0x400000 / 1];	/* read-only */
asm-ia64/sn/pci/bridge.h:	uint16_t	    s[0x400000 / 2];	/* read-write */
asm-ia64/sn/pci/bridge.h:	uint32_t	    l[0x400000 / 4];	/* read-only */
asm-ia64/sn/pci/bridge.h:	uint64_t	    d[0x400000 / 8];	/* read-only */
asm-ia64/sn/pci/bridge.h: * regularly against the offsets of the like-named fields
asm-ia64/sn/pci/bridge.h: * this request in-flight. A word write to this address clears the count.
asm-ia64/sn/pci/bridge.h: * which was in-flight for this buffer. A word write to this address
asm-ia64/sn/pci/bridge.h: * request which was in-flight for this buffer. A word write to this
asm-ia64/sn/pci/bridge.h:#define BRIDGE_DEVIO(x)		((x)<=1 ? BRIDGE_DEVIO0+(x)*BRIDGE_DEVIO_2MB : BRIDGE_DEVIO2+((x)-2)*BRIDGE_DEVIO_1MB)
asm-ia64/sn/pci/bridge.h:        PCIBRIDGE_DEVIO2(busnum)+((x)-2)*BRIDGE_DEVIO_1MB)
asm-ia64/sn/pci/bridge.h:#define PCIBR_BRIDGE_DEVIO0(ps)     PCIBRIDGE_DEVIO0((ps)->bs_busnum)
asm-ia64/sn/pci/bridge.h:#define PCIBR_BRIDGE_DEVIO1(ps)     PCIBRIDGE_DEVIO1((ps)->bs_busnum)
asm-ia64/sn/pci/bridge.h:#define PCIBR_BRIDGE_DEVIO2(ps)     PCIBRIDGE_DEVIO2((ps)->bs_busnum)
asm-ia64/sn/pci/bridge.h:#define PCIBR_BRIDGE_DEVIO(ps, s)   PCIBRIDGE_DEVIO((ps)->bs_busnum, s)
asm-ia64/sn/pci/bridge.h:#define PCIBR_TYPE1_CFG(ps)         PCIBRIDGE_TYPE1_CFG((ps)->bs_busnum)
asm-ia64/sn/pci/bridge.h:    ((IS_PIC_SOFT(ps)) ? PCIBRIDGE_TYPE0_CFG_DEV((ps)->bs_busnum, s+1) : \
asm-ia64/sn/pci/bridge.h:		  	     PCIBRIDGE_TYPE0_CFG_DEV((ps)->bs_busnum, s))
asm-ia64/sn/pci/bridge.h:    ((IS_PIC_SOFT(ps)) ? PCIBRIDGE_TYPE0_CFG_DEVF((ps)->bs_busnum,(s+1),f) : \
asm-ia64/sn/pci/bridge.h:			     PCIBRIDGE_TYPE0_CFG_DEVF((ps)->bs_busnum,s,f))
asm-ia64/sn/pci/bridge.h:/* Bridge Bus time-out register bits definition */
asm-ia64/sn/pci/bridge.h:/* Defines for the virtual channels so we don't hardcode 0-3 within code */
asm-ia64/sn/pci/bridge.h:#define VCHAN2	2	/* virtual channel 2 - PIC only */
asm-ia64/sn/pci/bridge.h:#define VCHAN3	3	/* virtual channel 3 - PIC only */
asm-ia64/sn/pci/bridge.h:/* PIC: PCI-X Read Buffer Attribute Register (RBAR) */
asm-ia64/sn/pci/bridge.h: * because PIC deviates from Bridge/Xbridge by not supporting a big-window
asm-ia64/sn/pci/bridge.h:		((adr) & (BRIDGE_DIRECT_32_SEG_SIZE - 1)) + PHYS_RAMBASE)
asm-ia64/sn/pci/bridge.h:/* 64-bit address attribute masks */
asm-ia64/sn/pci/pci_bus_cvlink.h: * Copyright (C) 1992 - 1997, 2000-2003 Silicon Graphics, Inc. All rights reserved.
asm-ia64/sn/pci/pci_bus_cvlink.h:	(((struct sn_device_sysdata *)((dev)->sysdata))->isa64) = 1
asm-ia64/sn/pci/pci_bus_cvlink.h:#define IS_PCIA64(dev)	(((dev)->dma_mask == 0xffffffffffffffffUL) || \
asm-ia64/sn/pci/pci_bus_cvlink.h:		(((struct sn_device_sysdata *)((dev)->sysdata))->isa64))
asm-ia64/sn/pci/pci_bus_cvlink.h:#define IS_PCI32G(dev)	((dev)->dma_mask >= 0xffffffff)
asm-ia64/sn/pci/pci_bus_cvlink.h:#define IS_PCI32L(dev)	((dev)->dma_mask < 0xffffffff)
asm-ia64/sn/pci/pci_bus_cvlink.h:#define IS_PIC_DEVICE(dev) ((struct sn_device_sysdata *)dev->sysdata)->isPIC
asm-ia64/sn/pci/pci_bus_cvlink.h:	(((struct sn_device_sysdata *)((pci_dev)->sysdata))->vhdl)
asm-ia64/sn/pci/pci_bus_cvlink.h:	(((struct sn_widget_sysdata *)((pci_bus)->sysdata))->vhdl)
asm-ia64/sn/pci/pciio_private.h: * Copyright (C) 1992 - 1997, 2000-2003 Silicon Graphics, Inc. All rights reserved.
asm-ia64/sn/pci/pciio_private.h: * pciio_private.h -- private definitions for pciio
asm-ia64/sn/pci/pciio_private.h:    pciio_function_t        c_func;	/* which func (on multi-func cards) */
asm-ia64/sn/pci/pciba.h: * Copyright (C) 1997, 2001-2003 Silicon Graphics, Inc. All rights reserved.
asm-ia64/sn/pci/pciba.h: * in the little-endian PCI numbering). This can actually
asm-ia64/sn/pci/pciba.h:/* PCIIOCGETID: arg is ptr to 32-bit int,
asm-ia64/sn/pci/pciba.h: * returns the 32-bit ID value with VENDOR
asm-ia64/sn/pci/pciba.h:/* PCIIOCSETCMD: arg is ptr to a 16-bit short,
asm-ia64/sn/pci/pciba.h:/* PCIIOCGETREV: arg is ptr to an 8-bit char,
asm-ia64/sn/pci/pciba.h: * which will get the 8-bit revision number.
asm-ia64/sn/pci/pciba.h:/* PCIIOCGETHTYPE: arg is ptr to an 8-bit char,
asm-ia64/sn/pci/pciba.h: * which will get the 8-bit header type.
asm-ia64/sn/pci/pciba.h:/* PCIIOCGETBASE(n): arg is ptr to a 32-bit int,
asm-ia64/sn/pci/pciba.h:   with non-constant 'n.'  */
asm-ia64/sn/pci/pciba.h: * and free physical memory for use in user-triggered
asm-ia64/sn/pci/pciba.h:/* pio cache-mode ioctl defines.  current only uncached accelerated */
asm-ia64/sn/pci/pcibr.h: * Copyright (C) 1992-1997,2000-2003 Silicon Graphics, Inc. All rights reserved.
asm-ia64/sn/pci/pcibr.h: * all 32-bit Direct Mapping memory accesses will be directed.
asm-ia64/sn/pci/pcibr.h: * Bridge-specific flags that can be set via pcibr_device_flags_set
asm-ia64/sn/pci/pcibr.h: * more generic and are maniuplated through PCI-generic interfaces.
asm-ia64/sn/pci/pcibr.h: * Note that all PCI implementation-specific flags (Bridge flags, in
asm-ia64/sn/pci/pcibr.h: * this case) are in bits 15-31.  The lower 15 bits are reserved
asm-ia64/sn/pci/pcibr.h: * for PCI-generic flags.
asm-ia64/sn/pci/pcibr.h:#define PCI_MULTI_FUNC_ERR       28     /* multi-function card error */
asm-ia64/sn/pci/pcibr.h:#define PCI_SLOT_RBAR_ALLOC_ERR  29     /* slot PCI-X RBAR alloc error */
asm-ia64/sn/pci/pciio.h: * Copyright (C) 1992 - 1997, 2000-2003 Silicon Graphics, Inc. All rights reserved.
asm-ia64/sn/pci/pciio.h: * pciio.h -- platform-independent PCI interface
asm-ia64/sn/pci/pciio.h:#define PCIIO_VENDOR_ID_NONE	(-1)
asm-ia64/sn/pci/pciio.h:#define PCIIO_DEVICE_ID_NONE	(-1)
asm-ia64/sn/pci/pciio.h: *	using 64-bit DMA addresses. Unless this
asm-ia64/sn/pci/pciio.h: *	and the device doing the DMA is little-endian;
asm-ia64/sn/pci/pciio.h: *	32-bit-wide values are maintained. This is a
asm-ia64/sn/pci/pciio.h: *	PCIIO_DMA_CMD. CPU Accesses to 16-bit fields
asm-ia64/sn/pci/pciio.h: *	must have their address xor-ed with 2, and
asm-ia64/sn/pci/pciio.h: *	addresses xor-ed with 3 relative to what the
asm-ia64/sn/pci/pciio.h: * Also, note that PCI-generic flags (PCIIO_) are
asm-ia64/sn/pci/pciio.h: * in bits 0-14. The upper bits, 15-31, are reserved
asm-ia64/sn/pci/pciio.h: * for PCI implementation-specific flags.
asm-ia64/sn/pci/pciio.h: *      organized little-endian fashion, this is the
asm-ia64/sn/pci/pciio.h: *      significance within the 32-bit word; byte
asm-ia64/sn/pci/pciio.h: *      XORed with 3, and addresses for 16-bit accesses
asm-ia64/sn/pci/pciio.h: *      as well, require use of 32-bit accesses to their
asm-ia64/sn/pci/pciio.h: *	+---------------------------+
asm-ia64/sn/pci/pciio.h: *	+---------------------------+
asm-ia64/sn/pci/pciio.h: * sn_pci_set_vchan - Set the requested Virtual Channel bits into the mapped DMA 
asm-ia64/sn/pci/pciio.h:		return -1;
asm-ia64/sn/pci/pci_defs.h: * Copyright (c) 1992-1997,2000-2003 Silicon Graphics, Inc. All rights reserved.
asm-ia64/sn/pci/pci_defs.h:/* Bit layout of address fields for Type-1
asm-ia64/sn/pci/pci_defs.h:/* Bit layout of address fields for Type-1
asm-ia64/sn/pci/pci_defs.h: * the 32-bit word as part of the register
asm-ia64/sn/pci/pci_defs.h:     /* XXX- these might be DEC 21152 specific */
asm-ia64/sn/pci/pci_defs.h:#define	PCI_CMD_F_BK_BK_ENABLE	0x200		/* Fast Back-to-Back Enable */
asm-ia64/sn/pci/pci_defs.h:#define	PCI_STAT_F_BK_BK_CAP	0x0080		/* Fast Back-to-Back Capable */
asm-ia64/sn/pci/pci_defs.h:#define PCI_BCTRL_F_BK_BK_ENABLE 0x0080		/* Enable Fast Back-to-Back on secondary bus */
asm-ia64/sn/pci/pci_defs.h:#define PCI_BCTRL_MSTR_ABT_MODE	0x0020		/* Master Abort Mode: 0 => do not report Master-Aborts */
asm-ia64/sn/pci/pci_defs.h: * PCI_STAT_CAP_LIST being non-zero in the PCI_CFG_STATUS register.  If
asm-ia64/sn/pci/pci_defs.h: * device-specific portion of the configuration header where the first
asm-ia64/sn/pci/pci_defs.h: * the list) and capability-specific data.  Each capability block starts with
asm-ia64/sn/pci/pci_defs.h: * this are capability-dependent.
asm-ia64/sn/pci/pci_defs.h:#define	PCI_CAP_PCIX		0x07		/* PCI-X */
asm-ia64/sn/pci/pci_defs.h: * XXX- These largely duplicate PCI_TYPE1 constants at the top
asm-ia64/sn/pci/pci_defs.h:  * XXX- should probaly be moved to a mace-specific header
asm-ia64/sn/pci/pci_defs.h: * PCI-X Capability
asm-ia64/sn/pci/pci_defs.h: * PCI-X Capability
asm-ia64/sn/pci/pcibr_private.h: * Copyright (C) 1992 - 1997, 2000-2003 Silicon Graphics, Inc. All rights reserved.
asm-ia64/sn/pci/pcibr_private.h: * pcibr_private.h -- private definitions for pcibr
asm-ia64/sn/pci/pcibr_private.h:/* XXX: habeck: maybe make PCIBR_DEBUG() always available?  Even in non-
asm-ia64/sn/pci/pcibr_private.h: * are the same.  (0->0, 1->1, 2->2,... 7->7)  BUT in the PIC the external
asm-ia64/sn/pci/pcibr_private.h: * slot number is always 1 greater than the internal device number (1->0, 
asm-ia64/sn/pci/pcibr_private.h: * 2->1, 3->2, 4->3).  This is due to the fact that the PCI-X spec requires
asm-ia64/sn/pci/pcibr_private.h:#define PCIBR_INFO_SLOT_GET_EXT(info)	    (((pcibr_info_t)info)->f_slot)
asm-ia64/sn/pci/pcibr_private.h:#define PCIBR_INFO_SLOT_GET_INT(info)	    (((pcibr_info_t)info)->f_dev)
asm-ia64/sn/pci/pcibr_private.h:            (IS_PIC_SOFT((pcibr_soft)) ? ((slot) - 1) : (slot)) : \
asm-ia64/sn/pci/pcibr_private.h: * per-connect point pcibr data, including standard pciio data in-line:
asm-ia64/sn/pci/pcibr_private.h:#define	f_func		f_c.c_func	/* which func (on multi-func cards) */
asm-ia64/sn/pci/pcibr_private.h:    /* pcibr-specific connection state */
asm-ia64/sn/pci/pcibr_private.h:/* defines for pcibr_soft_s->bs_bridge_type */
asm-ia64/sn/pci/pcibr_private.h:#define IS_XBRIDGE_SOFT(ps) (ps->bs_bridge_type == PCIBR_BRIDGETYPE_XBRIDGE)
asm-ia64/sn/pci/pcibr_private.h:#define IS_PIC_SOFT(ps)     (ps->bs_bridge_type == PCIBR_BRIDGETYPE_PIC)
asm-ia64/sn/pci/pcibr_private.h:		(IS_PIC_SOFT(ps) && ((ps)->bs_busnum == (bus)))
asm-ia64/sn/pci/pcibr_private.h:#define IS_BRIDGE_SOFT(ps)  (ps->bs_bridge_type == PCIBR_BRIDGETYPE_BRIDGE)
asm-ia64/sn/pci/pcibr_private.h:	((1 << XWIDGET_PART_REV_NUM_REV(pcibr_soft->bs_rev_num)) & pv)
asm-ia64/sn/pci/pcibr_private.h:#define PV855271 (1 << 1) /* PIC: PIC: use virt chan iff 64-bit device. */
asm-ia64/sn/pci/pcibr_private.h:/* defines for pcibr_soft_s->bs_bridge_mode */
asm-ia64/sn/pci/pcibr_private.h:#define IS_PCIX(ps)	((ps)->bs_bridge_mode & BUSTYPE_MASK)
asm-ia64/sn/pci/pcibr_private.h:#define IS_33MHZ(ps)	((ps)->bs_bridge_mode == PCIBR_BRIDGEMODE_PCI_33)
asm-ia64/sn/pci/pcibr_private.h:#define IS_66MHZ(ps)	(((ps)->bs_bridge_mode == PCIBR_BRIDGEMODE_PCI_66) || \
asm-ia64/sn/pci/pcibr_private.h:			 ((ps)->bs_bridge_mode == PCIBR_BRIDGEMODE_PCIX_66))
asm-ia64/sn/pci/pcibr_private.h:#define IS_100MHZ(ps)	((ps)->bs_bridge_mode == PCIBR_BRIDGEMODE_PCIX_100)
asm-ia64/sn/pci/pcibr_private.h:#define IS_133MHZ(ps)	((ps)->bs_bridge_mode == PCIBR_BRIDGEMODE_PCIX_133)
asm-ia64/sn/pci/pcibr_private.h: * is zero.  Otherwise use ((ps->bs_max_slot+1) - ps->bs_min_slot)
asm-ia64/sn/pci/pcibr_private.h:#define PCIBR_NUM_SLOTS(ps) (ps->bs_max_slot+1)
asm-ia64/sn/pci/pcibr_private.h:    iopaddr_t               bs_dir_xbase;	/* xtalk address for 32-bit PCI direct map */
asm-ia64/sn/pci/pcibr_private.h:    xwidgetnum_t	    bs_dir_xport;	/* xtalk port for 32-bit PCI direct map */
asm-ia64/sn/pci/pcibr_private.h:    vertex_hdl_t	    bs_noslot_conn;	/* NO-SLOT connection point */
asm-ia64/sn/pci/pcibr_private.h:	/* some devices (ioc3 in non-slotted
asm-ia64/sn/pci/pcibr_private.h:        /* PCI Hot-Plug status word */
asm-ia64/sn/pci/pcibr_private.h:	 * converted over to multifunction-
asm-ia64/sn/pci/pcibr_private.h:#define	bss_vendor_id	bss_infos[0]->f_vendor
asm-ia64/sn/pci/pcibr_private.h:#define	bss_device_id	bss_infos[0]->f_device
asm-ia64/sn/pci/pcibr_private.h:#define	bss_window	bss_infos[0]->f_window
asm-ia64/sn/pci/pcibr_private.h:	/* Number of "uses" of PMU, 32-bit direct,
asm-ia64/sn/pci/pcibr_private.h:	 * and 64-bit direct DMA (0:none, <0: trans,
asm-ia64/sn/pci/pcibr_private.h:    /* PIC PCI-X Read Buffer Management :
asm-ia64/sn/pci/pcibr_private.h:     * bs_pcix_num_funcs: the total number of PCI-X functions
asm-ia64/sn/pci/pcibr_private.h:     * As it stands now, we do not re-enable the error interrupt
asm-ia64/sn/pci/pcibr_private.h:     * Bridge-wide endianness control for
asm-ia64/sn/pci/pcibr_private.h:     * large-window PIO mappings
asm-ia64/sn/pci/pcibr_private.h: * Number of bridge non-fatal error interrupts we can see before
asm-ia64/sn/pci/pcibr_private.h:#define pcibr_lock(pcibr_soft)		io_splock(pcibr_soft->bs_lock)
asm-ia64/sn/pci/pcibr_private.h:#define pcibr_unlock(pcibr_soft, s)	io_spunlock(pcibr_soft->bs_lock,s)
asm-ia64/sn/sn2/io.h: * Copyright (C) 2000-2003 Silicon Graphics, Inc. All rights reserved.
asm-ia64/sn/sn2/io.h:	unsigned char ret = -1;
asm-ia64/sn/sn2/io.h:	unsigned short ret = -1;
asm-ia64/sn/sn2/io.h:	unsigned int ret = -1;
asm-ia64/sn/sn2/shub_mmr.h: * Copyright (c) 2001-2003 Silicon Graphics, Inc.  All rights reserved.
asm-ia64/sn/sn2/shub_mmr.h:/*   Description:  Throttle Data-bus Ownership Transitions              */
asm-ia64/sn/sn2/shub_mmr.h:/*                Graphics-write Credit Count for CPU 0                 */
asm-ia64/sn/sn2/shub_mmr.h:/*                Graphics-write Credit Count for CPU 1                 */
asm-ia64/sn/sn2/shub_mmr.h:/*   Description:  GFX credits are tracked by D-words                   */
asm-ia64/sn/sn2/shub_mmr.h:/*   Description:  GFX credits are tracked by D-words and messages      */
asm-ia64/sn/sn2/shub_mmr.h:/*   Description:  GFX credits are tracked by D-words                   */
asm-ia64/sn/sn2/shub_mmr.h:/*   Description:  GFX credits are tracked by D-words and messages      */
asm-ia64/sn/sn2/shub_mmr.h:/*              Graphics-write Skid Credit Count for CPU 0              */
asm-ia64/sn/sn2/shub_mmr.h:/*              Graphics-write Skid Credit Count for CPU 1              */
asm-ia64/sn/sn2/shub_mmr.h:/*                 Graphics-write Stall Limit for CPU 0                 */
asm-ia64/sn/sn2/shub_mmr.h:/*                 Graphics-write Stall Limit for CPU 1                 */
asm-ia64/sn/sn2/shub_mmr.h:/*                 Graphics-write Stall Timer for CPU 0                 */
asm-ia64/sn/sn2/shub_mmr.h:/*                 Graphics-write Stall Timer for CPU 1                 */
asm-ia64/sn/sn2/shub_mmr.h:/*                   Graphics-write Window for CPU 0                    */
asm-ia64/sn/sn2/shub_mmr.h:/*                   Graphics-write Window for CPU 1                    */
asm-ia64/sn/sn2/shub_mmr.h:/*               Graphics-write Interrupt Limit for CPU 0               */
asm-ia64/sn/sn2/shub_mmr.h:/*               Graphics-write Interrupt Limit for CPU 1               */
asm-ia64/sn/sn2/shub_mmr.h:/*   Description:  Re-enable GFX stall logic for this processor         */
asm-ia64/sn/sn2/shub_mmr.h:/*   Description:  Re-enable GFX stall logic for this processor         */
asm-ia64/sn/sn2/shub_mmr.h:/*               SHub Inter-Processor Interrupt Registers               */
asm-ia64/sn/sn2/shub_mmr.h:/*           SHub Inter-Processor Interrupt Enable Registers            */
asm-ia64/sn/sn2/shub_mmr.h:/*   Description:  Enables 32-bit (plus sideband) channel phits         */
asm-ia64/sn/sn2/shub_mmr.h:/*   Description:  Enables nearly dc-free encoding for AC-coupling      */
asm-ia64/sn/sn2/shub_mmr.h:/*                    low order 64-bit captured word                    */
asm-ia64/sn/sn2/shub_mmr.h:/*   Description:  low order 64-bit captured word                       */
asm-ia64/sn/sn2/shub_mmr.h:/*                   high order 64-bit captured word                    */
asm-ia64/sn/sn2/shub_mmr.h:/*   Description:  high order 64-bit captured word                      */
asm-ia64/sn/sn2/shub_mmr.h:/*   Description:  Enables 32-bit (plus sideband) channel phits         */
asm-ia64/sn/sn2/shub_mmr.h:/*   Description:  Enables nearly dc-free encoding for AC-coupling      */
asm-ia64/sn/sn2/shub_mmr.h:/*                    low order 64-bit captured word                    */
asm-ia64/sn/sn2/shub_mmr.h:/*   Description:  low order 64-bit captured word                       */
asm-ia64/sn/sn2/shub_mmr.h:/*                   high order 64-bit captured word                    */
asm-ia64/sn/sn2/shub_mmr.h:/*   Description:  high order 64-bit captured word                      */
asm-ia64/sn/sn2/shub_mmr.h:/*   Description:  ni select for plane-hint 1                           */
asm-ia64/sn/sn2/shub_mmr.h:/*   Description:  ni select for plane-hint 1                           */
asm-ia64/sn/sn2/shub_mmr.h:/*   Description:  ni select for plane-hint 1                           */
asm-ia64/sn/sn2/shub_mmr.h:/*   Description:  ni select for plane-hint 1                           */
asm-ia64/sn/sn2/shub_mmr.h:/*                    LB Test-point Trigger Compare                     */
asm-ia64/sn/sn2/shub_mmr.h:/*                  LB Test-point Trigger Compare Data                  */
asm-ia64/sn/sn2/shub_mmr.h:/*   Description:  An un-correctable ECC error was detected             */
asm-ia64/sn/sn2/shub_mmr.h:/*   Description:  Mask memory time-out detection                       */
asm-ia64/sn/sn2/shub_mmr.h:/*   Description:  Mask PIO time-out detection                          */
asm-ia64/sn/sn2/shub_mmr.h:/*   Description:  Mask un-correctable ECC error detection              */
asm-ia64/sn/sn2/shub_mmr.h:/*   Description:  Mask CRB time-out errors                             */
asm-ia64/sn/sn2/shub_mmr.h:/*   Description:  Mask PIO time-out errors                             */
asm-ia64/sn/sn2/shub_mmr.h:/*   Description:  Mask un-correctable ECC error detection              */
asm-ia64/sn/sn2/shub_mmr.h:/*   Description:  An un-correctable ECC error was detected             */
asm-ia64/sn/sn2/shub_mmr.h:/*             MD-to-PI Reply Virtual Channel Configuration             */
asm-ia64/sn/sn2/shub_mmr.h:/*            MD-to-PI Request Virtual Channel Configuration            */
asm-ia64/sn/sn2/shub_mmr.h:/*             XN-to-PI Reply Virtual Channel Configuration             */
asm-ia64/sn/sn2/shub_mmr.h:/*            XN-to-PI Request Virtual Channel Configuration            */
asm-ia64/sn/sn2/shub_mmr.h:/*   Description:  An un-correctable ECC error was detected             */
asm-ia64/sn/sn2/shub_mmr.h:/*   Description:  An un-correctable ECC error was detected             */
asm-ia64/sn/sn2/shub_mmr.h:/*   Description:  CRB CAM Time-out Status.                             */
asm-ia64/sn/sn2/shub_mmr.h:/*   Description:  CRB's XB pipe detected a CRB time-out                */
asm-ia64/sn/sn2/shub_mmr.h:/*   Description:  CRB's XB pipe detected a PIO time-out                */
asm-ia64/sn/sn2/shub_mmr.h:/*   Description:  An un-correctable ECC error was detected             */
asm-ia64/sn/sn2/shub_mmr.h:/*   Description:  CRB's XB pipe detected a CRB time-out                */
asm-ia64/sn/sn2/shub_mmr.h:/*   Description:  CRB's XB pipe detected a PIO time-out                */
asm-ia64/sn/sn2/shub_mmr.h:/*   Description:  An un-correctable ECC error was detected             */
asm-ia64/sn/sn2/shub_mmr.h:/*   Description:  An un-correctable ECC error was detected             */
asm-ia64/sn/sn2/shub_mmr.h:/*   Description:  CRB's XB pipe detected a CRB time-out                */
asm-ia64/sn/sn2/shub_mmr.h:/*   Description:  CRB's XB pipe detected a PIO time-out                */
asm-ia64/sn/sn2/shub_mmr.h:/*   Description:  An un-correctable ECC error was detected             */
asm-ia64/sn/sn2/shub_mmr.h:/*   Description:  An un-correctable ECC error was detected             */
asm-ia64/sn/sn2/shub_mmr.h:/*   Description:  CRB's XB pipe detected a CRB time-out                */
asm-ia64/sn/sn2/shub_mmr.h:/*   Description:  CRB's XB pipe detected a PIO time-out                */
asm-ia64/sn/sn2/shub_mmr.h:/*   Description:  An un-correctable ECC error was detected             */
asm-ia64/sn/sn2/shub_mmr.h:/*   Description:  An un-correctable ECC error was detected             */
asm-ia64/sn/sn2/shub_mmr.h:/*                PI-to-MD Reply Virtual Channel Status                 */
asm-ia64/sn/sn2/shub_mmr.h:/*               PI-to-MD Request Virtual Channel Status                */
asm-ia64/sn/sn2/shub_mmr.h:/*                PI-to-XN Reply Virtual Channel Status                 */
asm-ia64/sn/sn2/shub_mmr.h:/*               PI-to-XN Request Virtual Channel Status                */
asm-ia64/sn/sn2/shub_mmr.h:/*                MD-to-PI Reply Virtual Channel Status                 */
asm-ia64/sn/sn2/shub_mmr.h:/*               MD-to-PI Request Virtual Channel Status                */
asm-ia64/sn/sn2/shub_mmr.h:/*                XN-to-PI Reply Virtual Channel Status                 */
asm-ia64/sn/sn2/shub_mmr.h:/*               XN-to-PI Request Virtual Channel Status                */
asm-ia64/sn/sn2/shub_mmr.h:/*   Description:  Replace Checkbyte One-Shot                           */
asm-ia64/sn/sn2/shub_mmr.h:/*   Description:  Replace Checkbyte One-Shot                           */
asm-ia64/sn/sn2/shub_mmr.h:/*   Description:  ECC header0 (bits 63 - 0)                            */
asm-ia64/sn/sn2/shub_mmr.h:/*   Description:  ECC header1 (bits 104 - 64)                          */
asm-ia64/sn/sn2/shub_mmr.h:/*   Description:  ECC header0 (bits 63 - 0)                            */
asm-ia64/sn/sn2/shub_mmr.h:/*   Description:  ECC header1 (bits 104 - 64)                          */
asm-ia64/sn/sn2/shub_mmr.h:/*   Description:  Message data payload length, 0 - 63                  */
asm-ia64/sn/sn2/shub_mmr.h:/*   Description:  Counter event select (0-greater than, 1-equal)       */
asm-ia64/sn/sn2/shub_mmr.h:/*   Description:  Counter polarity select (0-negative edge, 1-positiv  */
asm-ia64/sn/sn2/shub_mmr.h:/*   Description:  Counter mode select (0-internal, 1-external)         */
asm-ia64/sn/sn2/shub_mmr.h:/*         Shubs 0 - 63 Present. Used for invalidate generation         */
asm-ia64/sn/sn2/shub_mmr.h:/*   Description:  Shubs 0 - 63 Present configuration                   */
asm-ia64/sn/sn2/shub_mmr.h:/*        Shubs 64 - 127 Present. Used for invalidate generation        */
asm-ia64/sn/sn2/shub_mmr.h:/*   Description:  Shubs 64 - 127 Present configuration                 */
asm-ia64/sn/sn2/shub_mmr.h:/*       Shubs 128 - 191 Present. Used for invalidate generation        */
asm-ia64/sn/sn2/shub_mmr.h:/*   Description:  Shubs 128 - 191 Present configuration                */
asm-ia64/sn/sn2/shub_mmr.h:/*       Shubs 192 - 255 Present. Used for invalidate generation        */
asm-ia64/sn/sn2/shub_mmr.h:/*   Description:  Shubs 192 - 255 Present configuration                */
asm-ia64/sn/sn2/shub_mmr.h:/*   Description:  Counter 0 up event select (1-greater than, 0-equal)  */
asm-ia64/sn/sn2/shub_mmr.h:/*   Description:  Counter 0 up polarity select (1-negative edge, 0-po  */
asm-ia64/sn/sn2/shub_mmr.h:/*   Description:  Counter 0 up mode select (1-internal, 0-external)    */
asm-ia64/sn/sn2/shub_mmr.h:/*   Description:  Counter 0 down event select (1-greater than, 0-equa  */
asm-ia64/sn/sn2/shub_mmr.h:/*   Description:  Counter 0 down polarity select (1-negative edge, 0-  */
asm-ia64/sn/sn2/shub_mmr.h:/*   Description:  Counter 0 down mode select (1-internal, 0-external)  */
asm-ia64/sn/sn2/shub_mmr.h:/*   Description:  Counter 1 up event select (1-greater than, 0-equal)  */
asm-ia64/sn/sn2/shub_mmr.h:/*   Description:  Counter 1 up polarity select (1-negative edge, 0-po  */
asm-ia64/sn/sn2/shub_mmr.h:/*   Description:  Counter 1 up mode select (1-internal, 0-external)    */
asm-ia64/sn/sn2/shub_mmr.h:/*   Description:  Counter 1 down event select (1-greater than, 0-equa  */
asm-ia64/sn/sn2/shub_mmr.h:/*   Description:  Counter 1 down polarity select (1-negative edge, 0-  */
asm-ia64/sn/sn2/shub_mmr.h:/*   Description:  Counter 1 down mode select (1-internal, 0-external)  */
asm-ia64/sn/sn2/shub_mmr.h:/*   Description:  Counter 2 up event select (1-greater than, 0-equal)  */
asm-ia64/sn/sn2/shub_mmr.h:/*   Description:  Counter 2 up polarity select (1-negative edge, 0-po  */
asm-ia64/sn/sn2/shub_mmr.h:/*   Description:  Counter 2 up mode select (1-internal, 0-external)    */
asm-ia64/sn/sn2/shub_mmr.h:/*   Description:  Counter 2 down event select (1-greater than, 0-equa  */
asm-ia64/sn/sn2/shub_mmr.h:/*   Description:  Counter 2 down polarity select (1-negative edge, 0-  */
asm-ia64/sn/sn2/shub_mmr.h:/*   Description:  Counter 2 down mode select (1-internal, 0-external)  */
asm-ia64/sn/sn2/shub_mmr.h:/*   Description:  Counter 3 up event select (1-greater than, 0-equal)  */
asm-ia64/sn/sn2/shub_mmr.h:/*   Description:  Counter 3 up polarity select (1-negative edge, 0-po  */
asm-ia64/sn/sn2/shub_mmr.h:/*   Description:  Counter 3 up mode select (1-internal, 0-external)    */
asm-ia64/sn/sn2/shub_mmr.h:/*   Description:  Counter 3 down event select (1-greater than, 0-equa  */
asm-ia64/sn/sn2/shub_mmr.h:/*   Description:  Counter 3 down polarity select (1-negative edge, 0-  */
asm-ia64/sn/sn2/shub_mmr.h:/*   Description:  Counter 3 down mode select (1-internal, 0-external)  */
asm-ia64/sn/sn2/shub_mmr.h:/*   Description:  Counter 4 up event select (1-greater than, 0-equal)  */
asm-ia64/sn/sn2/shub_mmr.h:/*   Description:  Counter 4 up polarity select (1-negative edge, 0-po  */
asm-ia64/sn/sn2/shub_mmr.h:/*   Description:  Counter 4 up mode select (1-internal, 0-external)    */
asm-ia64/sn/sn2/shub_mmr.h:/*   Description:  Counter 4 down event select (1-greater than, 0-equa  */
asm-ia64/sn/sn2/shub_mmr.h:/*   Description:  Counter 4 down polarity select (1-negative edge, 0-  */
asm-ia64/sn/sn2/shub_mmr.h:/*   Description:  Counter 4 down mode select (1-internal, 0-external)  */
asm-ia64/sn/sn2/shub_mmr.h:/*   Description:  Counter 5 up event select (1-greater than, 0-equal)  */
asm-ia64/sn/sn2/shub_mmr.h:/*   Description:  Counter 5 up polarity select (1-negative edge, 0-po  */
asm-ia64/sn/sn2/shub_mmr.h:/*   Description:  Counter 5 up mode select (1-internal, 0-external)    */
asm-ia64/sn/sn2/shub_mmr.h:/*   Description:  Counter 5 down event select (1-greater than, 0-equa  */
asm-ia64/sn/sn2/shub_mmr.h:/*   Description:  Counter 5 down polarity select (1-negative edge, 0-  */
asm-ia64/sn/sn2/shub_mmr.h:/*   Description:  Counter 5 down mode select (1-internal, 0-external)  */
asm-ia64/sn/sn2/shub_mmr.h:/*   Description:  Counter 6 up event select (1-greater than, 0-equal)  */
asm-ia64/sn/sn2/shub_mmr.h:/*   Description:  Counter 6 up polarity select (1-negative edge, 0-po  */
asm-ia64/sn/sn2/shub_mmr.h:/*   Description:  Counter 6 up mode select (1-internal, 0-external)    */
asm-ia64/sn/sn2/shub_mmr.h:/*   Description:  Counter 6 down event select (1-greater than, 0-equa  */
asm-ia64/sn/sn2/shub_mmr.h:/*   Description:  Counter 6 down polarity select (1-negative edge, 0-  */
asm-ia64/sn/sn2/shub_mmr.h:/*   Description:  Counter 6 down mode select (1-internal, 0-external)  */
asm-ia64/sn/sn2/shub_mmr.h:/*   Description:  Counter 7 up event select (1-greater than, 0-equal)  */
asm-ia64/sn/sn2/shub_mmr.h:/*   Description:  Counter 7 up polarity select (1-negative edge, 0-po  */
asm-ia64/sn/sn2/shub_mmr.h:/*   Description:  Counter 7 up mode select (1-internal, 0-external)    */
asm-ia64/sn/sn2/shub_mmr.h:/*   Description:  Counter 7 down event select (1-greater than, 0-equa  */
asm-ia64/sn/sn2/shub_mmr.h:/*   Description:  Counter 7 down polarity select (1-negative edge, 0-  */
asm-ia64/sn/sn2/shub_mmr.h:/*   Description:  Counter 7 down mode select (1-internal, 0-external)  */
asm-ia64/sn/sn2/shub_mmr.h:/*   Description:  Counter event select (1-greater than, 0-equal)       */
asm-ia64/sn/sn2/shub_mmr.h:/*   Description:  Counter polarity select (1-negative edge, 0-positiv  */
asm-ia64/sn/sn2/shub_mmr.h:/*   Description:  Counter mode select (1-internal, 0-external)         */
asm-ia64/sn/sn2/shub_mmr.h:/*   Description:  Counter event select (0-greater than, 1-equal)       */
asm-ia64/sn/sn2/shub_mmr.h:/*   Description:  Counter polarity select (0-negative edge, 1-positiv  */
asm-ia64/sn/sn2/shub_mmr.h:/*   Description:  Counter event select (1-greater than, 0-equal)       */
asm-ia64/sn/sn2/shub_mmr.h:/*   Description:  Counter polarity select (1-negative edge, 0-positiv  */
asm-ia64/sn/sn2/shub_mmr.h:/*   Description:  Counter mode select (1-internal, 0-external)         */
asm-ia64/sn/sn2/shub_mmr.h:/*                       PTC Time-out parmaeters                        */
asm-ia64/sn/sn2/shub_mmr.h:/*   Description:  PTC time-out period                                  */
asm-ia64/sn/sn2/shub_mmr.h:/*   Description:  PTC time-out valid                                   */
asm-ia64/sn/sn2/shub_mmr.h:/*                           Real-time Clock                            */
asm-ia64/sn/sn2/shub_mmr.h:/*   Description:  Real-time Clock                                      */
asm-ia64/sn/sn2/shub_mmr.h:/*   Description:  CRB Time-out Prescale Factor                         */
asm-ia64/sn/sn2/shub_mmr.h:/*   Description:  CRB Time-out Skid                                    */
asm-ia64/sn/sn2/shub_mmr.h:/*   Description:  indicates a non-existent memory error captured       */
asm-ia64/sn/sn2/shub_mmr.h:/*   Description:  non-existent memory error                            */
asm-ia64/sn/sn2/shub_mmr.h:/*   Description:  non-existent memory error                            */
asm-ia64/sn/sn2/shub_mmr.h:/*   Description:  non-existent memory error                            */
asm-ia64/sn/sn2/shub_mmr.h:/*   Description:  enable local poisoning for dir table fall-through    */
asm-ia64/sn/sn2/shub_mmr.h:/*   Description:  priority was greater-equal                           */
asm-ia64/sn/sn2/shub_mmr.h:/*   Description:  priority was greater-equal                           */
asm-ia64/sn/sn2/shub_mmr.h:/*   Description:  priority greater-equal                               */
asm-ia64/sn/sn2/shub_mmr.h:/*   Description:  shrd,sxro,sub-state                                  */
asm-ia64/sn/sn2/shub_mmr.h:/*   Description:  priority greater-equal                               */
asm-ia64/sn/sn2/shub_mmr.h:/*   Description:  shrd,sxro,sub-state                                  */
asm-ia64/sn/sn2/shub_mmr.h:/*   Description:  enable local poisoning for dir table fall-through    */
asm-ia64/sn/sn2/shub_mmr.h:/*   Description:  priority was greater-equal                           */
asm-ia64/sn/sn2/shub_mmr.h:/*   Description:  priority was greater-equal                           */
asm-ia64/sn/sn2/shub_mmr.h:/*   Description:  priority greater-equal                               */
asm-ia64/sn/sn2/shub_mmr.h:/*   Description:  shrd,sxro,sub-state                                  */
asm-ia64/sn/sn2/shub_mmr.h:/*   Description:  priority greater-equal                               */
asm-ia64/sn/sn2/shub_mmr.h:/*   Description:  shrd,sxro,sub-state                                  */
asm-ia64/sn/sn2/geo.h: * Copyright (C) 1992 - 1997, 2000-2003 Silicon Graphics, Inc. All rights reserved.
asm-ia64/sn/sn2/shub_md.h: * Copyright (c) 2001, 2002-2003 Silicon Graphics, Inc.  All rights reserved.
asm-ia64/sn/sn2/shub_md.h:/* SN2 supports a mostly-flat address space with 4 CPU-visible, evenly spaced, 
asm-ia64/sn/sn2/shub_md.h:                 ------------
asm-ia64/sn/sn2/shub_md.h:                 |----------|
asm-ia64/sn/sn2/shub_md.h:                 |----------|
asm-ia64/sn/sn2/shub_md.h:                 |----------|
asm-ia64/sn/sn2/shub_md.h:                 ------------
asm-ia64/sn/sn2/shub_md.h:                 ------------
asm-ia64/sn/sn2/shub_md.h:                 ------------
asm-ia64/sn/sn2/shub_md.h:                 ------------
asm-ia64/sn/sn2/shub_md.h:                 |----------|
asm-ia64/sn/sn2/shub_md.h:                 |----------|
asm-ia64/sn/sn2/shub_md.h:                 |----------|
asm-ia64/sn/sn2/shub_md.h:                 ------------
asm-ia64/sn/sn2/shub_md.h:   DIMM[0-3]_CS field in SH_[x,y,jnr]_DIMM_CFG for each dimm slot.   
asm-ia64/sn/sn2/shubio.h: * Copyright (C) 1992 - 1997, 2000-2003 Silicon Graphics, Inc. All rights reserved.
asm-ia64/sn/sn2/shubio.h:#define HUB_NUM_BIG_WINDOW      (IIO_NUM_ITTES - 1)
asm-ia64/sn/sn2/shubio.h:#define    IIO_IGFX0                 0x00400140    /* IO Graphics Node-Widget Map 0 */
asm-ia64/sn/sn2/shubio.h:#define    IIO_IGFX1                 0x00400148    /* IO Graphics Node-Widget Map 1 */
asm-ia64/sn/sn2/shubio.h: * Description:  This is a read-write enabled register. It controls     *
asm-ia64/sn/sn2/shubio.h: * Description:  A write to this register of the 64-bit value           *
asm-ia64/sn/sn2/shubio.h: * disabled. These fields assume that 0=TNUM=7 (i.e., Bridge-centric    *
asm-ia64/sn/sn2/shubio.h: * Description:  All II-detected non-BTE error interrupts are           *
asm-ia64/sn/sn2/shubio.h: * write-responses are converted to graphics credits and returned to    *
asm-ia64/sn/sn2/shubio.h: * write-responses are converted to graphics credits and returned to    *
asm-ia64/sn/sn2/shubio.h: * registers. Each register maps a Shub Big Window to a 48-bit          *
asm-ia64/sn/sn2/shubio.h: * For M-mode (128 nodes, 8 GBytes/node), SysAD[31:29] (Big Window      *
asm-ia64/sn/sn2/shubio.h: * (M-mode), however only <SUP >7</SUP>/<SUB >32nds</SUB> of this       *
asm-ia64/sn/sn2/shubio.h: * For the N-mode (256 nodes, 4 GBytes/node), SysAD[30:28] (Big         *
asm-ia64/sn/sn2/shubio.h: * 8-GBytes per widget (N-mode), only <SUP >7</SUP>/<SUB >32nds</SUB>   *
asm-ia64/sn/sn2/shubio.h: * registers. Each register maps a Shub Big Window to a 48-bit          *
asm-ia64/sn/sn2/shubio.h: * For M-mode (128 nodes, 8 GBytes/node), SysAD[31:29] (Big Window      *
asm-ia64/sn/sn2/shubio.h: * (M-mode), however only <SUP >7</SUP>/<SUB >32nds</SUB> of this       *
asm-ia64/sn/sn2/shubio.h: * For the N-mode (256 nodes, 4 GBytes/node), SysAD[30:28] (Big         *
asm-ia64/sn/sn2/shubio.h: * 8-GBytes per widget (N-mode), only <SUP >7</SUP>/<SUB >32nds</SUB>   *
asm-ia64/sn/sn2/shubio.h: * registers. Each register maps a Shub Big Window to a 48-bit          *
asm-ia64/sn/sn2/shubio.h: * For M-mode (128 nodes, 8 GBytes/node), SysAD[31:29] (Big Window      *
asm-ia64/sn/sn2/shubio.h: * (M-mode), however only <SUP >7</SUP>/<SUB >32nds</SUB> of this       *
asm-ia64/sn/sn2/shubio.h: * For the N-mode (256 nodes, 4 GBytes/node), SysAD[30:28] (Big         *
asm-ia64/sn/sn2/shubio.h: * 8-GBytes per widget (N-mode), only <SUP >7</SUP>/<SUB >32nds</SUB>   *
asm-ia64/sn/sn2/shubio.h: * registers. Each register maps a SHub Big Window to a 48-bit          *
asm-ia64/sn/sn2/shubio.h: * For M-mode (128 nodes, 8 GBytes/node), SysAD[31:29] (Big Window      *
asm-ia64/sn/sn2/shubio.h: * (M-mode), however only <SUP >7</SUP>/<SUB >32nds</SUB> of this       *
asm-ia64/sn/sn2/shubio.h: * For the N-mode (256 nodes, 4 GBytes/node), SysAD[30:28] (Big         *
asm-ia64/sn/sn2/shubio.h: * 8-GBytes per widget (N-mode), only <SUP >7</SUP>/<SUB >32nds</SUB>   *
asm-ia64/sn/sn2/shubio.h: * registers. Each register maps a SHub Big Window to a 48-bit          *
asm-ia64/sn/sn2/shubio.h: * For M-mode (128 nodes, 8 GBytes/node), SysAD[31:29] (Big Window      *
asm-ia64/sn/sn2/shubio.h: * (M-mode), however only <SUP >7</SUP>/<SUB >32nds</SUB> of this       *
asm-ia64/sn/sn2/shubio.h: * For the N-mode (256 nodes, 4 GBytes/node), SysAD[30:28] (Big         *
asm-ia64/sn/sn2/shubio.h: * 8-GBytes per widget (N-mode), only <SUP >7</SUP>/<SUB >32nds</SUB>   *
asm-ia64/sn/sn2/shubio.h: * registers. Each register maps a Shub Big Window to a 48-bit          *
asm-ia64/sn/sn2/shubio.h: * For M-mode (128 nodes, 8 GBytes/node), SysAD[31:29] (Big Window      *
asm-ia64/sn/sn2/shubio.h: * (M-mode), however only <SUP >7</SUP>/<SUB >32nds</SUB> of this       *
asm-ia64/sn/sn2/shubio.h: * For the N-mode (256 nodes, 4 GBytes/node), SysAD[30:28] (Big         *
asm-ia64/sn/sn2/shubio.h: * 8-GBytes per widget (N-mode), only <SUP >7</SUP>/<SUB >32nds</SUB>   *
asm-ia64/sn/sn2/shubio.h: * registers. Each register maps a Shub Big Window to a 48-bit          *
asm-ia64/sn/sn2/shubio.h: * For M-mode (128 nodes, 8 GBytes/node), SysAD[31:29] (Big Window      *
asm-ia64/sn/sn2/shubio.h: * (M-mode), however only <SUP >7</SUP>/<SUB >32nds</SUB> of this       *
asm-ia64/sn/sn2/shubio.h: * For the N-mode (256 nodes, 4 GBytes/node), SysAD[30:28] (Big         *
asm-ia64/sn/sn2/shubio.h: * 8-GBytes per widget (N-mode), only <SUP >7</SUP>/<SUB >32nds</SUB>   *
asm-ia64/sn/sn2/shubio.h: *  A write to this register of the 56-bit value "Pup+Bun" will cause	*
asm-ia64/sn/sn2/shubio.h: *  The Shub DEBUG unit provides a 3-bit selection signal to the        *
asm-ia64/sn/sn2/shubio.h: * II core and a 3-bit selection signal to the fsbclk domain in the II  *
asm-ia64/sn/sn2/shubio.h: * address to be loaded in bits 39:0 is the 40-bit TRex+ physical       *
asm-ia64/sn/sn2/shubio.h: * transfers are always cacheline-aligned.                              *
asm-ia64/sn/sn2/shubio.h: * address to be loaded in bits 39:0 is the 40-bit TRex+ physical       *
asm-ia64/sn/sn2/shubio.h: * transfers are always cacheline-aligned.                              *
asm-ia64/sn/sn2/shubio.h: * address to be loaded in bits 39:0 is the 40-bit TRex+ physical       *
asm-ia64/sn/sn2/shubio.h: * transfers are always cacheline-aligned.                              *
asm-ia64/sn/sn2/shubio.h: * address to be loaded in bits 39:0 is the 40-bit TRex+ physical       *
asm-ia64/sn/sn2/shubio.h: * transfers are always cacheline-aligned.                              *
asm-ia64/sn/sn2/shubio.h:#define IIO_WIDPRTE_A(x)	IIO_PRTE_A(((x) - 8)) /* widget ID to its PRTE num */
asm-ia64/sn/sn2/shubio.h:#define IIO_WIDPRTE_B(x)	IIO_PRTE_B(((x) - 8)) /* widget ID to its PRTE num */
asm-ia64/sn/sn2/shubio.h:#define IIO_BTE_OFF_1   	(IIO_IBLS_1 - IIO_IBLS_0) /* Offset from base to BTE 1 */
asm-ia64/sn/sn2/shubio.h:#define BTEOFF_SRC              (IIO_BTE_SRC_0 - IIO_BTE_STAT_0)
asm-ia64/sn/sn2/shubio.h:#define BTEOFF_DEST             (IIO_BTE_DEST_0 - IIO_BTE_STAT_0)
asm-ia64/sn/sn2/shubio.h:#define BTEOFF_CTRL             (IIO_BTE_CTRL_0 - IIO_BTE_STAT_0)
asm-ia64/sn/sn2/shubio.h:#define BTEOFF_NOTIFY           (IIO_BTE_NOTIFY_0 - IIO_BTE_STAT_0)
asm-ia64/sn/sn2/shubio.h:#define BTEOFF_INT              (IIO_BTE_INT_0 - IIO_BTE_STAT_0)
asm-ia64/sn/sn2/shubio.h: * 0, 8 - 0xF
asm-ia64/sn/sn2/shubio.h:                        (_x) - (HUB_WIDGET_ID_MIN-1)) << 3) )
asm-ia64/sn/sn2/shubio.h:#define IIO_IGFX_W_NUM_MASK	((1<<IIO_IGFX_W_NUM_BITS)-1)
asm-ia64/sn/sn2/shubio.h:#define IIO_IGFX_PI_NUM_MASK	((1<<IIO_IGFX_PI_NUM_BITS)-1)
asm-ia64/sn/sn2/shubio.h:#define IIO_IGFX_N_NUM_MASK	((1<<IIO_IGFX_N_NUM_BITS)-1)
asm-ia64/sn/sn2/shubio.h:#define IIO_IGFX_P_NUM_MASK	((1<<IIO_IGFX_P_NUM_BITS)-1)
asm-ia64/sn/sn2/shubio.h:#define HUB_NUM_BIG_WINDOW      (IIO_NUM_ITTES - 1)
asm-ia64/sn/sn2/shubio.h:/* XXX - This is now tuneable:
asm-ia64/sn/sn2/shubio.h: * Easy access macros for CRBs, all 5 registers (A-E)
asm-ia64/sn/sn2/shubio.h:#define IIO_IIDEM_WIDGETDEV_MASK(w, d)  ((uint64_t)(1ULL << (8 * ((w) - 8) + (d))))
asm-ia64/sn/sn2/shubio.h:#define HUB_PIO_FIRE_N_FORGET   0x2     /* PIO in fire-and-forget mode */
asm-ia64/sn/sn2/arch.h: * Copyright (C) 1992 - 1997, 2000-2003 Silicon Graphics, Inc. All rights reserved.
asm-ia64/sn/sn2/intr.h: * Copyright (C) 1992 - 1997, 2000-2003 Silicon Graphics, Inc. All rights reserved.
asm-ia64/sn/sn2/sn_private.h: * Copyright (C) 1992 - 1997, 2000-2003 Silicon Graphics, Inc. All rights reserved.
asm-ia64/sn/sn2/sn_private.h:#define	hub_piomap_xt_piomap(hp)	(&hp->hpio_xtalk_info)
asm-ia64/sn/sn2/sn_private.h:#define	hub_piomap_hub_v(hp)	(hp->hpio_hub)
asm-ia64/sn/sn2/sn_private.h:#define	hub_piomap_winnum(hp)	(hp->hpio_bigwin_num)
asm-ia64/sn/sn2/sn_private.h:#define	hubinfo_to_hubv(hinfo, hub_v)	(hinfo->h_nodepda->node_vertex)
asm-ia64/sn/sn2/sn_private.h:			(&hinfo->h_big_window_piomap[win])
asm-ia64/sn/sn2/sn_private.h:			(&hinfo->h_small_window_piomap[win])
asm-ia64/sn/sn2/sn_private.h:/* cpu-specific information stored under INFO_LBL_CPU_INFO */
asm-ia64/sn/sn2/addrs.h: * Copyright (c) 2001-2003 Silicon Graphics, Inc.  All rights reserved.
asm-ia64/sn/sn2/addrs.h: *  +-+---------+----+--------------+
asm-ia64/sn/sn2/addrs.h: *  +-+---------+----+--------------+
asm-ia64/sn/sn2/addrs.h:#define TO_PHYS_MASK		0x0001ffcfffffffff	/* Note - clear AS bits */
asm-ia64/sn/sn2/addrs.h:/* non-II mmr's start at top of big window space (4G) */
asm-ia64/sn/sn2/addrs.h: * general address defines - for code common to SN0/SN1/SN2
asm-ia64/sn/sn2/addrs.h:#define CALIAS_BASE             LOCAL_CACHEABLE_BASE			/* cached node-local memory */
asm-ia64/sn/sn2/addrs.h:#define UALIAS_BASE             (UNCACHED | LOCAL_CACHEABLE_BASE)	/* uncached node-local memory */
asm-ia64/sn/sn2/addrs.h:                                  (x & (NODE_ADDRSPACE_SIZE - 1)) )
asm-ia64/sn/sn2/addrs.h:#define BWIN_SIZEMASK           (BWIN_SIZE - 1)
asm-ia64/sn/sn2/shub_mmr_t.h: * Copyright (c) 2001-2003 Silicon Graphics, Inc.  All rights reserved.
asm-ia64/sn/sn2/shub_mmr_t.h:/*                Graphics-write Credit Count for CPU 0                 */
asm-ia64/sn/sn2/shub_mmr_t.h:/*                Graphics-write Credit Count for CPU 1                 */
asm-ia64/sn/sn2/shub_mmr_t.h:/*              Graphics-write Skid Credit Count for CPU 0              */
asm-ia64/sn/sn2/shub_mmr_t.h:/*              Graphics-write Skid Credit Count for CPU 1              */
asm-ia64/sn/sn2/shub_mmr_t.h:/*                 Graphics-write Stall Limit for CPU 0                 */
asm-ia64/sn/sn2/shub_mmr_t.h:/*                 Graphics-write Stall Limit for CPU 1                 */
asm-ia64/sn/sn2/shub_mmr_t.h:/*                 Graphics-write Stall Timer for CPU 0                 */
asm-ia64/sn/sn2/shub_mmr_t.h:/*                 Graphics-write Stall Timer for CPU 1                 */
asm-ia64/sn/sn2/shub_mmr_t.h:/*                   Graphics-write Window for CPU 0                    */
asm-ia64/sn/sn2/shub_mmr_t.h:/*                   Graphics-write Window for CPU 1                    */
asm-ia64/sn/sn2/shub_mmr_t.h:/*               Graphics-write Interrupt Limit for CPU 0               */
asm-ia64/sn/sn2/shub_mmr_t.h:/*               Graphics-write Interrupt Limit for CPU 1               */
asm-ia64/sn/sn2/shub_mmr_t.h:/*               SHub Inter-Processor Interrupt Registers               */
asm-ia64/sn/sn2/shub_mmr_t.h:/*           SHub Inter-Processor Interrupt Enable Registers            */
asm-ia64/sn/sn2/shub_mmr_t.h:/*                    low order 64-bit captured word                    */
asm-ia64/sn/sn2/shub_mmr_t.h:/*                   high order 64-bit captured word                    */
asm-ia64/sn/sn2/shub_mmr_t.h:/*                    low order 64-bit captured word                    */
asm-ia64/sn/sn2/shub_mmr_t.h:/*                   high order 64-bit captured word                    */
asm-ia64/sn/sn2/shub_mmr_t.h:/*                    LB Test-point Trigger Compare                     */
asm-ia64/sn/sn2/shub_mmr_t.h:/*                  LB Test-point Trigger Compare Data                  */
asm-ia64/sn/sn2/shub_mmr_t.h:/*             MD-to-PI Reply Virtual Channel Configuration             */
asm-ia64/sn/sn2/shub_mmr_t.h:/*            MD-to-PI Request Virtual Channel Configuration            */
asm-ia64/sn/sn2/shub_mmr_t.h:/*             XN-to-PI Reply Virtual Channel Configuration             */
asm-ia64/sn/sn2/shub_mmr_t.h:/*            XN-to-PI Request Virtual Channel Configuration            */
asm-ia64/sn/sn2/shub_mmr_t.h:/*                PI-to-MD Reply Virtual Channel Status                 */
asm-ia64/sn/sn2/shub_mmr_t.h:/*               PI-to-MD Request Virtual Channel Status                */
asm-ia64/sn/sn2/shub_mmr_t.h:/*                PI-to-XN Reply Virtual Channel Status                 */
asm-ia64/sn/sn2/shub_mmr_t.h:/*               PI-to-XN Request Virtual Channel Status                */
asm-ia64/sn/sn2/shub_mmr_t.h:/*                MD-to-PI Reply Virtual Channel Status                 */
asm-ia64/sn/sn2/shub_mmr_t.h:/*               MD-to-PI Request Virtual Channel Status                */
asm-ia64/sn/sn2/shub_mmr_t.h:/*                XN-to-PI Reply Virtual Channel Status                 */
asm-ia64/sn/sn2/shub_mmr_t.h:/*               XN-to-PI Request Virtual Channel Status                */
asm-ia64/sn/sn2/shub_mmr_t.h:/*         Shubs 0 - 63 Present. Used for invalidate generation         */
asm-ia64/sn/sn2/shub_mmr_t.h:/*        Shubs 64 - 127 Present. Used for invalidate generation        */
asm-ia64/sn/sn2/shub_mmr_t.h:/*       Shubs 128 - 191 Present. Used for invalidate generation        */
asm-ia64/sn/sn2/shub_mmr_t.h:/*       Shubs 192 - 255 Present. Used for invalidate generation        */
asm-ia64/sn/sn2/shub_mmr_t.h:/*                       PTC Time-out parmaeters                        */
asm-ia64/sn/sn2/shub_mmr_t.h:/*                           Real-time Clock                            */
asm-ia64/sn/sn2/shub.h: * Copyright (c) 2001-2003 Silicon Graphics, Inc.  All rights reserved.
asm-ia64/sn/sn2/shub.h: *   16 bits wide. This space requires address bits 31-27 to be set, and
asm-ia64/sn/sn2/shub.h: *   The LED addresses are write-only. To read the LEDs, you need to use
asm-ia64/sn/sn2/shub.h: *   SH_JUNK_BUS_LED0-3, defined in shub_mmr.h
asm-ia64/sn/sn2/slotnum.h: * Copyright (c) 1992-1997,2001-2003 Silicon Graphics, Inc. All rights reserved.
asm-ia64/sn/nodepda.h: * Copyright (C) 1992 - 1997, 2000-2003 Silicon Graphics, Inc. All rights reserved.
asm-ia64/sn/nodepda.h: * NUMA Node-Specific Data structures are defined in this file.
asm-ia64/sn/nodepda.h: * Node-specific data structure.
asm-ia64/sn/nodepda.h: * all per-node data structures. 
asm-ia64/sn/nodepda.h:	void 		*pdinfo;	/* Platform-dependent per-node info */
asm-ia64/sn/nodepda.h: *	nodepda			-> to access node PDA for the node on which code is running
asm-ia64/sn/nodepda.h: *	subnodepda		-> to access subnode PDA for the subnode on which code is running
asm-ia64/sn/nodepda.h: *	NODEPDA(cnode)		-> to access node PDA for cnodeid 
asm-ia64/sn/nodepda.h: *	SUBNODEPDA(cnode,sn)	-> to access subnode PDA for cnodeid/subnode
asm-ia64/sn/nodepda.h:#define	NODEPDA(cnode)		(nodepda->pernode_pdaindr[cnode])
asm-ia64/sn/nodepda.h:#define NODE_MODULEID(cnode)    geo_module((NODEPDA(cnode)->geoid))
asm-ia64/sn/nodepda.h:#define NODE_SLOTID(cnode)	(NODEPDA(cnode)->slotdesc)
asm-ia64/sn/nodepda.h:#define cnodeid_to_vertex(cnodeid) (NODEPDA(cnodeid)->node_vertex)
asm-ia64/sn/io.h: * Copyright (C) 2000-2003 Silicon Graphics, Inc.  All Rights Reserved.
asm-ia64/sn/io.h:#define IIO_ITTE_OFFSET_MASK	((1<<IIO_ITTE_OFFSET_BITS)-1)
asm-ia64/sn/io.h:#define IIO_ITTE_WIDGET_MASK	((1<<IIO_ITTE_WIDGET_BITS)-1)
asm-ia64/sn/io.h: * 0, 8 - 0xF
asm-ia64/sn/io.h:			(_x) - (HUB_WIDGET_ID_MIN-1)) << 3) )
asm-ia64/sn/ksys/l1.h: * Copyright (C) 1992-1997,2000-2003 Silicon Graphics, Inc.  All Rights Reserved.
asm-ia64/sn/ksys/l1.h:#define L1_ARG_INT		0x00	/* 4-byte integer (big-endian)	*/
asm-ia64/sn/ksys/l1.h:#define L1_ARG_ASCII		0x01	/* null-terminated ASCII string */
asm-ia64/sn/ksys/l1.h:#define L1_RESP_IROUTER	(-  1)	/* iRouter error	        */
asm-ia64/sn/ksys/l1.h:#define L1_RESP_ARGC	(-100)	/* arg count mismatch	        */
asm-ia64/sn/ksys/l1.h:#define L1_RESP_REQC	(-101)	/* bad request code	        */
asm-ia64/sn/ksys/l1.h:#define L1_RESP_NAVAIL	(-104)	/* requested data not available */
asm-ia64/sn/ksys/l1.h:#define L1_RESP_ARGVAL	(-105)  /* arg value out of range       */
asm-ia64/sn/ksys/l1.h:#define L1_RESP_INVAL   (-107)  /* requested data invalid       */
asm-ia64/sn/ksys/l1.h:					   (console-hosting) node */
asm-ia64/sn/ksys/elsc.h: * Copyright (C) 1992-1997, 2000-2003 Silicon Graphics, Inc.  All Rights Reserved.
asm-ia64/sn/ksys/elsc.h: *   so ELSC error codes begin at -100.
asm-ia64/sn/ksys/elsc.h:#define ELSC_ERROR_CMD_SEND	       (-100)	/* Error sending command    */
asm-ia64/sn/ksys/elsc.h:#define ELSC_ERROR_CMD_CHECKSUM	       (-101)	/* Command checksum bad     */
asm-ia64/sn/ksys/elsc.h:#define ELSC_ERROR_CMD_UNKNOWN	       (-102)	/* Unknown command          */
asm-ia64/sn/ksys/elsc.h:#define ELSC_ERROR_CMD_ARGS	       (-103)	/* Invalid argument(s)      */
asm-ia64/sn/ksys/elsc.h:#define ELSC_ERROR_CMD_PERM	       (-104)	/* Permission denied	    */
asm-ia64/sn/ksys/elsc.h:#define ELSC_ERROR_CMD_STATE	       (-105)	/* not allowed in this state*/
asm-ia64/sn/ksys/elsc.h:#define ELSC_ERROR_RESP_TIMEOUT	       (-110)	/* ELSC response timeout    */
asm-ia64/sn/ksys/elsc.h:#define ELSC_ERROR_RESP_CHECKSUM       (-111)	/* Response checksum bad    */
asm-ia64/sn/ksys/elsc.h:#define ELSC_ERROR_RESP_FORMAT	       (-112)	/* Response format error    */
asm-ia64/sn/ksys/elsc.h:#define ELSC_ERROR_RESP_DIR	       (-113)	/* Response direction error */
asm-ia64/sn/ksys/elsc.h:#define ELSC_ERROR_MSG_LOST	       (-120)	/* Queue full; msg. lost    */
asm-ia64/sn/ksys/elsc.h:#define ELSC_ERROR_LOCK_TIMEOUT	       (-121)	/* ELSC response timeout    */
asm-ia64/sn/ksys/elsc.h:#define ELSC_ERROR_DATA_SEND	       (-122)	/* Error sending data       */
asm-ia64/sn/ksys/elsc.h:#define ELSC_ERROR_NIC		       (-123)	/* NIC processing error     */
asm-ia64/sn/ksys/elsc.h:#define ELSC_ERROR_NVMAGIC	       (-124)	/* Bad magic no. in NVRAM   */
asm-ia64/sn/ksys/elsc.h:#define ELSC_ERROR_MODULE	       (-125)	/* Moduleid processing err  */
asm-ia64/sn/sv.h: * Copyright (C) 2000-2003 Silicon Graphics, Inc.  All Rights Reserved.
asm-ia64/sn/sv.h: *   SV_INTS - the monitor lock can be acquired from interrupts (and
asm-ia64/sn/sv.h: * n < 0 : interrupted,  -n jiffies remaining on timeout, or -1 if timeout == 0
asm-ia64/sn/sv.h:	ASSERT(sv_mon_type == (sv->sv_flags & SV_MON_MASK));
asm-ia64/sn/sv.h:	if(sv->sv_mon_lock)
asm-ia64/sn/sv.h:		ASSERT(lock == sv->sv_mon_lock);
asm-ia64/sn/sv.h:		sv->sv_mon_lock = lock;
asm-ia64/sn/invent.h: * Copyright (C) 1992 - 1997, 2000-2003 Silicon Graphics, Inc. All rights reserved.
asm-ia64/sn/invent.h: * sys/sn/invent.h --  Kernel Hardware Inventory
asm-ia64/sn/invent.h: * This list can then be accessed through syssgi() by user-level programs
asm-ia64/sn/invent.h: * of an inventory item class and a class-specific type.  Each instance may
asm-ia64/sn/invent.h: * also specify a 32-bit "state" which might be size, readiness, or
asm-ia64/sn/invent.h:#define GRAPH_VERTEX_NONE ((vertex_hdl_t)-1)
asm-ia64/sn/invent.h:	int	inv_type;		/* class sub-type of object */
asm-ia64/sn/invent.h: *       of this file up-to-date with the work going on in various engineering
asm-ia64/sn/invent.h:/*** add post-5.2 classes here for backward compatibility ***/
asm-ia64/sn/invent.h:/* states for class INV_IOBD type INV_EVERESTIO -- value of eb_type field */
asm-ia64/sn/invent.h:#define INV_PCCARD	21	/* PC-card (PCMCIA) devices */
asm-ia64/sn/invent.h:#define INV_PR_PCI64_D	21	/* Prisa PCI-64 Dual channel */
asm-ia64/sn/invent.h:#define INV_ISA_DMA	19	/* DMA mode ISA serial -- O2 */
asm-ia64/sn/invent.h:				      state = 0 -> output only
asm-ia64/sn/invent.h:				      state = 1 -> bi-directional */
asm-ia64/sn/invent.h:#define TPGY10	        17      /* Sony GY-10  */
asm-ia64/sn/invent.h:#define TPFUJDIANA1     23      /* Fujitsu Diana-1 (M1016/M1017) */
asm-ia64/sn/invent.h:#define TPFUJDIANA2     24      /* Fujitsu Diana-2 (M2483) */
asm-ia64/sn/invent.h:#define TPFUJDIANA3     25      /* Fujitsu Diana-3 (M2488) */
asm-ia64/sn/invent.h:#define TPGY2120        30      /* Sony GY-2120 (replaces GY-10)  */
asm-ia64/sn/invent.h:#define INV_GR1BP	2	/* OBSOLETE - use INV_GR1BIT24 instead */
asm-ia64/sn/invent.h:#define INV_GR1ZBUFFER	3	/* OBSOLETE - use INV_GR1ZBUF24 instead */
asm-ia64/sn/invent.h:#define INV_VTX		13	/* RealityEngine graphics - VTX variant */
asm-ia64/sn/invent.h:#define INV_GR1ZBUF24 	0x100   /* has z-buffer option */
asm-ia64/sn/invent.h:#define INV_GR2_Z	0x1	/* has z-buffer option */
asm-ia64/sn/invent.h:#define INV_GR2_GR5	0x200	/* board GR3 with 4 GEs, hinv prints GR5-XZ */
asm-ia64/sn/invent.h:#define INV_GR2_XS	0x0     /* GR2-XS */
asm-ia64/sn/invent.h:#define INV_GR2_XSZ	0x1     /* GR2-XS with z-buffer */
asm-ia64/sn/invent.h:#define INV_GR2_XS24	0x2     /* GR2-XS24 */
asm-ia64/sn/invent.h:#define INV_GR2_XS24Z	0x3     /* GR2-XS24 with z-buffer */
asm-ia64/sn/invent.h:#define INV_GR2_XSM	0x4     /* GR2-XSM */
asm-ia64/sn/invent.h:#define INV_GR2_ELAN	0x7	/* GR2-Elan */
asm-ia64/sn/invent.h:#define	INV_GR2_XZ	0x13	/* GR2-XZ */
asm-ia64/sn/invent.h:#define	INV_GR3_XSM	0x44	/* GR3-XSM */
asm-ia64/sn/invent.h:#define	INV_GR3_ELAN	0x47	/* GR3-Elan */
asm-ia64/sn/invent.h:#define	INV_GU1_EXTREME	0xa3	/* GU1-Extreme */
asm-ia64/sn/invent.h:#define INV_NET_HIPPIS		9	/* HIPPI-Serial */
asm-ia64/sn/invent.h:#define	INV_NET_GSN		10	/* GSN (aka HIPPI-6400) */
asm-ia64/sn/invent.h:#define INV_TOKEN_FV	9	/* Formation fv1600 Token-Ring board */
asm-ia64/sn/invent.h:#define INV_ATM_GIO64	15	/* ATM OC-3c Mez card */
asm-ia64/sn/invent.h:#define INV_ETHER_EP	16	/* 8-port E-Plex Ethernet */
asm-ia64/sn/invent.h:#define INV_ISDN_48XP	20	/* Xircom PRI-48XP */
asm-ia64/sn/invent.h:#define INV_HIPPIS_XTK	22	/* Xtalk HIPPI-Serial */
asm-ia64/sn/invent.h:#define INV_ATM_QUADOC3	23	/* Xtalk Quad OC-3c ATM interface */
asm-ia64/sn/invent.h: * Note: the lun is encoded in bits 8-15 of the state.  The
asm-ia64/sn/invent.h:#define INV_WORM	4	/* write-once-read-many (e.g. optical disks) */
asm-ia64/sn/invent.h:#define INV_CDROM	5	/* CD-ROM  */
asm-ia64/sn/invent.h:#define INV_OPTICAL	7	/* optical disks (read-write) */
asm-ia64/sn/invent.h:#define	INV_VIDEO_INDY		5	/* Indy Video - kal vid on Newport
asm-ia64/sn/invent.h:#define INV_VIDEO_XTHD		13	/* XIO XT-HDTV video */
asm-ia64/sn/invent.h:#define INV_VIDEO_XTDIGVID      14      /* XIO XT-HDDIGVID video */
asm-ia64/sn/invent.h:#define INV_VINO_INDY_NOSW	0x20	/* nebulous - means s/w not installed */
asm-ia64/sn/invent.h:#define INV_MISC_OTHER		3	/* non-specific type */
asm-ia64/sn/invent.h: * HUB types - none yet
asm-ia64/sn/alenlist.h: * Copyright (C) 1992 - 1997, 2000-2003 Silicon Graphics, Inc. All rights reserved.
asm-ia64/sn/alenlist.h:#define ALENLIST_FAILURE (-1)
asm-ia64/sn/cdl.h: * Copyright (C) 1992-1997,2000-2003 Silicon Graphics, Inc. All rights reserved.
asm-ia64/sn/cdl.h: *	that have self-identifying devices; initially
asm-ia64/sn/bte.h: * Copyright (c) 2000-2003 Silicon Graphics, Inc.  All Rights Reserved.
asm-ia64/sn/bte.h: * Foundation, Inc., 59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm-ia64/sn/bte.h:#define L1_CACHE_MASK		(L1_CACHE_BYTES - 1)
asm-ia64/sn/bte.h:#define BTE_LEN_MASK ((1 << BTE_LEN_BITS) - 1)
asm-ia64/sn/bte.h:	(*pda.cpu_bte_if[_x]->most_rcnt_na & (IBLS_BUSY | IBLS_ERROR)) && \
asm-ia64/sn/bte.h:	(!(spin_trylock(&(pda.cpu_bte_if[_x]->spinlock)))) \
asm-ia64/sn/bte.h:#define BTEREG_LNSTAT_ADDR ((u64 *)(bte->bte_base_addr))
asm-ia64/sn/bte.h:#define BTEREG_SRC_ADDR ((u64 *)(bte->bte_base_addr + BTEOFF_SRC))
asm-ia64/sn/bte.h:#define BTEREG_DEST_ADDR ((u64 *)(bte->bte_base_addr + BTEOFF_DEST))
asm-ia64/sn/bte.h:#define BTEREG_CTRL_ADDR ((u64 *)(bte->bte_base_addr + BTEOFF_CTRL))
asm-ia64/sn/bte.h:#define BTEREG_NOTIF_ADDR ((u64 *)(bte->bte_base_addr + BTEOFF_NOTIFY))
asm-ia64/sn/bte.h:	int bte_num;		/* 0 --> BTE0, 1 --> BTE1           */
asm-ia64/sn/geo.h: * Copyright (C) 1992 - 1997, 2000-2003 Silicon Graphics, Inc. All rights reserved.
asm-ia64/sn/geo.h:/* Include a platform-specific geo.h.  It must define at least:
asm-ia64/sn/geo.h: * platform-specific geo.h file) */
asm-ia64/sn/hcl.h: * Copyright (C) 1992-1997,2000-2003 Silicon Graphics, Inc. All rights reserved.
asm-ia64/sn/hcl.h: * Special pre-defined edge labels.
asm-ia64/sn/nag.h: * Copyright (c) 2001-2003 Silicon Graphics, Inc.  All rights reserved.
asm-ia64/sn/pda.h: * Copyright (C) 1992 - 1997, 2000-2003 Silicon Graphics, Inc. All rights reserved.
asm-ia64/sn/pda.h: * CPU-specific data structure.
asm-ia64/sn/pda.h: * all SN per-cpu data structures. 
asm-ia64/sn/pda.h:#define CACHE_ALIGN(x)	(((x) + SMP_CACHE_BYTES-1) & ~(SMP_CACHE_BYTES-1))
asm-ia64/sn/pda.h: * Per-cpu private data area for each cpu. The PDA is located immediately after
asm-ia64/sn/pda.h: * Seems like we should should cache-line align the pda so that any changes in the
asm-ia64/sn/pda.h:#define CPU_DATA_END	CACHE_ALIGN((long)&(((struct cpuinfo_ia64*)0)->platform_specific))
asm-ia64/sn/pio.h: * Copyright (C) 1992 - 1997, 2000-2003 Silicon Graphics, Inc. All rights reserved.
asm-ia64/sn/pio.h: * pioaddr_t	- The kernel virtual address that a PIO can be done upon.
asm-ia64/sn/pio.h: * iopaddr_t	- the physical io space relative address (e.g. VME A16S 0x0800).
asm-ia64/sn/pio.h: * iosapce_t	- specifies the io address space to be mapped/accessed.
asm-ia64/sn/pio.h: * piomap_t	- the handle returned by pio_alloc() and used with all the pio
asm-ia64/sn/pio.h:	iobush_t	pio_bushandle;	/* bus-level handle */
asm-ia64/sn/pio.h:#define	pio_seterrf(p,f)	(p)->pio_errfunc = (f)
asm-ia64/sn/pio.h:#define	pio_geterrf(p)		(p)->pio_errfunc
asm-ia64/sn/pio.h:#define PIOREG_NULL	(-1)
asm-ia64/sn/sgi.h: * Copyright (C) 2000-2003 Silicon Graphics, Inc. All rights reserved.
asm-ia64/sn/sgi.h:#define CNODEID_NONE ((cnodeid_t)-1)
asm-ia64/sn/sgi.h:#define CPU_NONE		(-1)
asm-ia64/sn/sgi.h:	int rd_shift;		/* shift for extracted value, - >>, + << */
asm-ia64/sn/kldir.h: * Copyright (C) 1992-1997,1999,2001-2003 Silicon Graphics, Inc.  All Rights Reserved.
asm-ia64/sn/kldir.h: * 0x2000000 (32M)         +-----------------------------------------+
asm-ia64/sn/kldir.h: * 0x1F80000 (31.5M)       +-----------------------------------------+
asm-ia64/sn/kldir.h: * 0x1C00000 (30M)         +-----------------------------------------+
asm-ia64/sn/kldir.h: * 0x0800000 (28M)         +-----------------------------------------+
asm-ia64/sn/kldir.h: * 0x1B00000 (27M)         +-----------------------------------------+
asm-ia64/sn/kldir.h: * 0x1A00000 (26M)         +-----------------------------------------+
asm-ia64/sn/kldir.h: * 0x1800000 (24M)         +-----------------------------------------+
asm-ia64/sn/kldir.h: * 0x1600000 (22M)         +-----------------------------------------+
asm-ia64/sn/kldir.h: *                         +-----------------------------------------+
asm-ia64/sn/kldir.h: * 0x190000 (2M--)         +-----------------------------------------+
asm-ia64/sn/kldir.h: * 0x34000 (208K)          +-----------------------------------------+
asm-ia64/sn/kldir.h: * 0x25000 (148K)          +-----------------------------------------+
asm-ia64/sn/kldir.h: *                         |      KLCONFIG - II (temp)               |
asm-ia64/sn/kldir.h: *                         |    ----------------------------         |
asm-ia64/sn/kldir.h: *                         |      UNIX NON-DEBUG Version             |
asm-ia64/sn/kldir.h: * 0x19000 (100K)          +-----------------------------------------+
asm-ia64/sn/kldir.h: * 0x19000 (100K)          +-----------------------------------------+
asm-ia64/sn/kldir.h: * 0x12000 (72K)           +-----------------------------------------+
asm-ia64/sn/kldir.h: * 0x11c00 (71K)           +-----------------------------------------+
asm-ia64/sn/kldir.h: * 0x11a00 (70.5K)         +-----------------------------------------+
asm-ia64/sn/kldir.h: * 0x11800 (70K)           +-----------------------------------------+
asm-ia64/sn/kldir.h: * 0x11600 (69.5K)         +-----------------------------------------+
asm-ia64/sn/kldir.h: * 0x11400 (69K)           +-----------------------------------------+
asm-ia64/sn/kldir.h: * 0x11000 (68K)           +-----------------------------------------+
asm-ia64/sn/kldir.h: * 0x10800  (66k)	   +-----------------------------------------+
asm-ia64/sn/kldir.h: * 0x10400 (65K)           +-----------------------------------------+
asm-ia64/sn/kldir.h: * 0x10000 (64K)           +-----------------------------------------+
asm-ia64/sn/kldir.h: *                         |      KLCONFIG - I (permanent) (48K)     |
asm-ia64/sn/kldir.h: * 0x4000 (16K)            +-----------------------------------------+
asm-ia64/sn/kldir.h: * 0x3000 (12K)            +-----------------------------------------+
asm-ia64/sn/kldir.h: * 0x2c00 (11K)            +-----------------------------------------+
asm-ia64/sn/kldir.h: * 0x2800 (10K)            +-----------------------------------------+
asm-ia64/sn/kldir.h: * 0x2400 (9K)             +-----------------------------------------+
asm-ia64/sn/kldir.h: * 0x2000 (8K)             +-----------------------------------------+
asm-ia64/sn/kldir.h: * 0x1000 (4K)             +-----------------------------------------+
asm-ia64/sn/kldir.h: * 0x800  (2k)	           +-----------------------------------------+
asm-ia64/sn/kldir.h: * 0x400 (1K)              +-----------------------------------------+
asm-ia64/sn/kldir.h: * 0x0   (0K)              +-----------------------------------------+
asm-ia64/sn/kldir.h: * 0x4000000 (64M)         +-----------------------------------------+
asm-ia64/sn/kldir.h: * 0x3000000 (48M)         +-----------------------------------------+
asm-ia64/sn/kldir.h: * 0x2102000 (>33M)        +-----------------------------------------+
asm-ia64/sn/kldir.h: * 0x2000000 (32M)         +-----------------------------------------+
asm-ia64/sn/kldir.h: * 0x1F80000 (31.5M)       +-----------------------------------------+
asm-ia64/sn/kldir.h: * 0x1C00000 (28M)         +-----------------------------------------+
asm-ia64/sn/kldir.h: * 0x1A00000 (26M)         +-----------------------------------------+
asm-ia64/sn/kldir.h: * 0x1800000 (24M)         +-----------------------------------------+
asm-ia64/sn/kldir.h: * 0x1500000 (21M)         +-----------------------------------------+
asm-ia64/sn/kldir.h: * 0x1400000 (20M)         +-----------------------------------------+
asm-ia64/sn/kldir.h: * 0x1300000 (19M)         +-----------------------------------------+
asm-ia64/sn/kldir.h: *                         +-----------------------------------------+
asm-ia64/sn/kldir.h: * 0x0310000 (3.1M)        +-----------------------------------------+
asm-ia64/sn/kldir.h: * 0x006C000 (432K)        +-----------------------------------------+
asm-ia64/sn/kldir.h: * 0x004C000 (304K)        +-----------------------------------------+
asm-ia64/sn/kldir.h: *                         |      UNIX NON-DEBUG Version             |
asm-ia64/sn/kldir.h: * 0x0040000 (256K)        +-----------------------------------------+
asm-ia64/sn/kldir.h: * 0x40000 (256K)          +-----------------------------------------+
asm-ia64/sn/kldir.h: * 0x30000 (192K)          +-----------------------------------------+
asm-ia64/sn/kldir.h: * 0x20000 (128K)          +-----------------------------------------+
asm-ia64/sn/kldir.h: * 0x19000 (100K)          +-----------------------------------------+
asm-ia64/sn/kldir.h: * 0x18800 (98K)           +-----------------------------------------+
asm-ia64/sn/kldir.h: * 0x18400 (97K)           +-----------------------------------------+
asm-ia64/sn/kldir.h: * 0x18000 (96K)           +-----------------------------------------+
asm-ia64/sn/kldir.h: * 0x13c00 (79K)           +-----------------------------------------+
asm-ia64/sn/kldir.h: * 0x11c00 (71K)           +-----------------------------------------+
asm-ia64/sn/kldir.h: * 0x10800 (66k)	   +-----------------------------------------+
asm-ia64/sn/kldir.h: * 0x10400 (65K)           +-----------------------------------------+
asm-ia64/sn/kldir.h: * 0x10000 (64K)           +-----------------------------------------+
asm-ia64/sn/kldir.h: * 0x0b400 (45K)           +-----------------------------------------+
asm-ia64/sn/kldir.h: * 0x0b000 (44K)           +-----------------------------------------+
asm-ia64/sn/kldir.h: * 0x0a000 (40K)           +-----------------------------------------+
asm-ia64/sn/kldir.h: * 0x09000 (36K)           +-----------------------------------------+
asm-ia64/sn/kldir.h: * 0x08800 (34K)           +-----------------------------------------+
asm-ia64/sn/kldir.h: * 0x08400 (33K)           +-----------------------------------------+
asm-ia64/sn/kldir.h: * 0x08000 (32K)           +-----------------------------------------+
asm-ia64/sn/kldir.h: * 0x04000 (16K)           +-----------------------------------------+
asm-ia64/sn/kldir.h: * 0x03000 (12K)           +-----------------------------------------+
asm-ia64/sn/kldir.h: * 0x02c00 (11K)           +-----------------------------------------+
asm-ia64/sn/kldir.h: * 0x02800 (10K)           +-----------------------------------------+
asm-ia64/sn/kldir.h: * 0x02400 (9K)            +-----------------------------------------+
asm-ia64/sn/kldir.h: * 0x02000 (8K)            +-----------------------------------------+
asm-ia64/sn/kldir.h: * 0x01000 (4K)            +-----------------------------------------+
asm-ia64/sn/kldir.h: * 0x00800 (2k)	           +-----------------------------------------+
asm-ia64/sn/kldir.h: * 0x00400 (1K)            +-----------------------------------------+
asm-ia64/sn/kldir.h: * 0x00000 (0K)            +-----------------------------------------+
asm-ia64/sn/kldir.h: *  - the appropriate elspec files in irix/kern/master.d
asm-ia64/sn/kldir.h: *  - NODEBUGUNIX_ADDR in SN/SN1/addrs.h
asm-ia64/sn/kldir.h: *  - IP27_FREEMEM_OFFSET below
asm-ia64/sn/kldir.h: *  - KERNEL_START_OFFSET below (if supporting cells)
asm-ia64/sn/kldir.h:#define IP27_FREEMEM_SIZE		(-1)
asm-ia64/sn/xtalk/xswitch.h: * Copyright (C) 1992-1997,2000-2003 Silicon Graphics, Inc.  All Rights Reserved.
asm-ia64/sn/xtalk/xswitch.h: * xswitch.h - controls the format of the data
asm-ia64/sn/xtalk/xbow_info.h: * Copyright (C) 1992-1997,2000-2003 Silicon Graphics, Inc.  All Rights Reserved.
asm-ia64/sn/xtalk/xtalk.h: * Copyright (C) 1992-1997, 2000-2003 Silicon Graphics, Inc.  All Rights Reserved.
asm-ia64/sn/xtalk/xtalk.h: * xtalk.h -- platform-independent crosstalk interface
asm-ia64/sn/xtalk/xtalk.h: * User-level device driver visible types
asm-ia64/sn/xtalk/xtalk.h:#define XWIDGET_NONE		(-1)
asm-ia64/sn/xtalk/xtalk.h:#define XWIDGET_PART_NUM_NONE	(-1)
asm-ia64/sn/xtalk/xtalk.h:#define XWIDGET_REV_NUM_NONE	(-1)
asm-ia64/sn/xtalk/xtalk.h:#define XWIDGET_MFG_NUM_NONE	(-1)
asm-ia64/sn/xtalk/xtalk.h: * low-level interrupt code may invoke this function later in order to
asm-ia64/sn/xtalk/xtalk.h: * crosstalk device to (re-)target an interrupt.  A function of this type
asm-ia64/sn/xtalk/xwidget.h: * Copyright (C) 1992-1997,2000-2003 Silicon Graphics, Inc. All Rights Reserved.
asm-ia64/sn/xtalk/xwidget.h: * xwidget.h - generic crosstalk widget header file
asm-ia64/sn/xtalk/xwidget.h: * according to the crosstalk spec, only 32-bits access to the widget
asm-ia64/sn/xtalk/xwidget.h: * configuration registers is allowed.  some widgets may allow 64-bits
asm-ia64/sn/xtalk/xwidget.h:	(((hwid1)->part_num == (hwid2)->part_num) && \
asm-ia64/sn/xtalk/xwidget.h:	(((hwid1)->mfg_num == XWIDGET_MFG_NUM_NONE) || \
asm-ia64/sn/xtalk/xwidget.h:	((hwid2)->mfg_num == XWIDGET_MFG_NUM_NONE) || \
asm-ia64/sn/xtalk/xwidget.h:	((hwid1)->mfg_num == (hwid2)->mfg_num)))
asm-ia64/sn/xtalk/xbow.h: * Copyright (C) 1992-1997,2000-2003 Silicon Graphics, Inc. All Rights Reserved.
asm-ia64/sn/xtalk/xbow.h: * xbow.h - header file for crossbow chip and xbow section of xbridge
asm-ia64/sn/xtalk/xbow.h:    /* standard widget configuration                       0x000000-0x000057 */
asm-ia64/sn/xtalk/xbow.h:    /* xbow-specific widget configuration                  0x000058-0x0000FF */
asm-ia64/sn/xtalk/xbow.h:    /* xbow-specific widget configuration                  0x000058-0x0000FF */
asm-ia64/sn/xtalk/xbow.h:    /* Link Specific Registers, port 8..15                 0x000100-0x000300 */
asm-ia64/sn/xtalk/xbow.h:#define xb_link(p)      xb_link_raw[(p) & (MAX_XBOW_PORTS - 1)]
asm-ia64/sn/xtalk/xbow.h:    int			    xb_port;	/* port number (0-15) */
asm-ia64/sn/xtalk/xbow.h:				(XBOW_W0_RST_FNC + ((x) - 7) * 8) : \
asm-ia64/sn/xtalk/xbow.h:#define	XB_LINK_REG_BASE(x)	(XB_LINK_BASE + ((x) & (MAX_XBOW_PORTS - 1)) * XB_LINK_OFFSET)
asm-ia64/sn/xtalk/xtalk_private.h: * Copyright (C) 1992-1997, 2000-2003 Silicon Graphics, Inc.  All Rights Reserved.
asm-ia64/sn/xtalk/xtalk_private.h: * xtalk_private.h -- private definitions for xtalk
asm-ia64/sn/xtalk/xtalk_private.h:    xtalk_intr_vector_t     xi_vector;	/* 8-bit interrupt vector */
asm-ia64/sn/xtalk/xtalk_private.h:#define	xtalk_intr_arg(xt)	((xt)->xi_sfarg)
asm-ia64/sn/xtalk/xtalk_private.h:		(((_hwid)->part_num == XBOW_WIDGET_PART_NUM ) &&  	\
asm-ia64/sn/xtalk/xtalk_private.h:		 ((_hwid)->mfg_num == XBOW_WIDGET_MFGR_NUM ))
asm-ia64/sn/xtalk/xtalk_private.h:		(((_hwid)->part_num == XXBOW_WIDGET_PART_NUM ||		\
asm-ia64/sn/xtalk/xtalk_private.h:		  (_hwid)->part_num == PXBOW_WIDGET_PART_NUM) &&  	\
asm-ia64/sn/xtalk/xtalk_private.h:		 ((_hwid)->mfg_num == XXBOW_WIDGET_MFGR_NUM ))
asm-ia64/sn/xtalk/xtalkaddrs.h: * Copyright (C) 1992-1997,2000-2003 Silicon Graphics, Inc. All Rights Reserved.
asm-ia64/sn/xtalk/xtalkaddrs.h: * Format for non-Memory accesses:
asm-ia64/sn/xtalk/xtalkaddrs.h: *  +--------------+------------------------------------------------+
asm-ia64/sn/xtalk/xtalkaddrs.h: *  +----+---------+------------------------------------------------+
asm-ia64/sn/xtalk/xtalkaddrs.h: * By design, this looks exactly like a 0-extended SN0 Address, so
asm-ia64/sn/xtalk/xtalkaddrs.h: * Format for non-Memory accesses:
asm-ia64/sn/xtalk/xtalkaddrs.h: *  +--------------+------+---------+------+--+---------------------+
asm-ia64/sn/xtalk/xtalkaddrs.h: *  +----+---------+------+---------+------+--+---------------------+
asm-ia64/sn/xtalk/xtalkaddrs.h: *                              00 -> PI
asm-ia64/sn/xtalk/xtalkaddrs.h: *                              01 -> MD
asm-ia64/sn/xtalk/xtalkaddrs.h: *                              10 -> IO
asm-ia64/sn/xtalk/xtalkaddrs.h: *                              11 -> NI
asm-ia64/sn/xtalk/xtalkaddrs.h:/* Hub-specific xtalk definitions */
asm-ia64/sn/xtalk/xtalkaddrs.h: * Pre-calculate the fixed portion of a crosstalk address that maps
asm-ia64/sn/xtalk/xtalkaddrs.h: * Always do a 32-bit read, because some widgets, e.g., Bridge, require so.
asm-ia64/sn/xtalk/xtalkaddrs.h: * Widget ID is at offset 0 for 64-bit access.  Add 4 to get lower 32 bits
asm-ia64/sn/labelcl.h: * Copyright (C) 1992 - 1997, 2000-2003 Silicon Graphics, Inc. All rights reserved.
asm-ia64/sn/labelcl.h:#define INFO_DESC_PRIVATE (-1)      	/* default */
asm-ia64/sn/labelcl.h:#define STRTBL_BASIC_SIZE ((size_t)(((struct string_table_item *)0)->string))
asm-ia64/sn/uart16550.h: * Copyright (C) 1992-1997,2000-2003 Silicon Graphics, Inc. All rights reserved.
asm-ia64/sn/uart16550.h:#define		MCR_OUT1	0x04	/* Aux output - not used */
asm-ia64/sn/uart16550.h:#define SIOC_EXTCLK (SIOC | 1)  /* select/de-select external clock */
asm-ia64/sn/uart16550.h:#define SIOC_RS422  (SIOC | 2)  /* select/de-select RS422 protocol */
asm-ia64/sn/uart16550.h:#define ISA_SERIAL0_Rx_OVERRUN	0x02000000	/* Receive DMA over-run  */
asm-ia64/sn/uart16550.h:#define ISA_SERIAL1_Rx_OVERRUN	0x80000000	/* Receive DMA over-run  */
asm-ia64/sn/module.h: * Copyright (C) 1992 - 1997, 2000-2003 Silicon Graphics, Inc. All rights reserved.
asm-ia64/sn/module.h:/* Well-known module IDs */
asm-ia64/sn/module.h:#define MODULE_UNKNOWN		(-2) /* initial value of klconfig brd_module */
asm-ia64/sn/module.h:/* #define INVALID_MODULE	(-1) ** generic invalid moduleid_t (arch.h) */
asm-ia64/sn/module.h: *	31-16	Rack ID (encoded class, group, number - 16-bit unsigned int)
asm-ia64/sn/module.h: *	 15-8	Brick type (8-bit ascii character)
asm-ia64/sn/module.h: *	  7-0	Bay (brick position in rack (0-63) - 8-bit unsigned int)
asm-ia64/sn/module.h: * a 3-decimal-digit number.
asm-ia64/sn/module.h:#define RACK_GET_GROUP(_r)              (((_r) - RACK_GET_CLASS(_r) *   \
asm-ia64/sn/module.h:#define RACK_GET_NUM(_r)                (((_r) - RACK_GET_CLASS(_r) *   \
asm-ia64/sn/module.h:            RACK_CLASS_DVDR - RACK_GET_GROUP(_r) *      \
asm-ia64/sn/module.h:	( (((unsigned)1<<RACK_GROUP_BITS(_r)) - 1) << RACK_GROUP_SHFT(_r) )
asm-ia64/sn/module.h:	( (((unsigned)1<<RACK_NUM_BITS(_r)) - 1) << RACK_NUM_SHFT(_r) )
asm-ia64/sn/module.h:	((_r) |= ((_n) - 1) << RACK_NUM_SHFT(_r) & RACK_NUM_MASK(_r))
asm-ia64/sn/module.h:#define MODULE_CMP(_m1, _m2)    (((_m1)&(MODULE_RACK_MASK|MODULE_BPOS_MASK)) -\
asm-ia64/sn/vector.h: * Copyright (C) 1992 - 1997, 2000-2003 Silicon Graphics, Inc. All rights reserved.
asm-ia64/sn/vector.h:#define NET_VEC_BAD             ((net_vec_t) -1)
asm-ia64/sn/vector.h:#define NET_ERROR_HARDWARE	(-1)	/* Hardware error	*/
asm-ia64/sn/vector.h:#define NET_ERROR_OVERRUN	(-2)	/* Extra response(s)	*/
asm-ia64/sn/vector.h:#define NET_ERROR_REPLY		(-3)	/* Reply parms mismatch */
asm-ia64/sn/vector.h:#define NET_ERROR_ADDRESS	(-4)	/* Addr error response	*/
asm-ia64/sn/vector.h:#define NET_ERROR_COMMAND	(-5)	/* Cmd error response	*/
asm-ia64/sn/vector.h:#define NET_ERROR_PROT		(-6)	/* Prot error response	*/
asm-ia64/sn/vector.h:#define NET_ERROR_TIMEOUT	(-7)	/* Too many retries	*/
asm-ia64/sn/vector.h:#define NET_ERROR_VECTOR	(-8)	/* Invalid vector/path	*/
asm-ia64/sn/vector.h:#define NET_ERROR_ROUTERLOCK	(-9)	/* Timeout locking rtr	*/
asm-ia64/sn/vector.h:#define NET_ERROR_INVAL		(-10)	/* Invalid vector request */
asm-ia64/sn/mmtimer_private.h: * Copyright (c) 2001-2003 Silicon Graphics, Inc.  All rights reserved.
asm-ia64/sn/mmtimer_private.h: * 11/01/01 - jbarnes - initial revision
asm-ia64/sn/clksupport.h: * Copyright (C) 2000-2003 Silicon Graphics, Inc. All rights reserved.
asm-ia64/sn/clksupport.h: * in the system. The clock is synchronized across nodes - all nodes see the
asm-ia64/sn/clksupport.h: *	RTC_COUNTER_ADDR - contains the address of the counter 
asm-ia64/sn/clksupport.h: *	GET_RTC_COUNTER() - macro to read the value of the clock
asm-ia64/sn/clksupport.h: *	RTC_CYCLES_PER_SEC - clock frequency in ticks per second	
asm-ia64/sn/sndrv.h: * Copyright (c) 2002-2003 Silicon Graphics, Inc.  All Rights Reserved.
asm-ia64/sn/sndrv.h: * Foundation, Inc., 59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm-ia64/sn/sndrv.h:#define SNDRV_UKNOWN_DEVICE		-1
asm-ia64/sn/arch.h: * Copyright (C) 1995-1997,1999,2001-2003 Silicon Graphics, Inc.  All rights reserved.
asm-ia64/sn/arch.h:#define CNODE_TO_CPU_BASE(_cnode)	(NODEPDA(_cnode)->node_first_cpu)
asm-ia64/sn/arch.h:#define INVALID_NASID		((nasid_t)-1)
asm-ia64/sn/arch.h:#define INVALID_CNODEID		((cnodeid_t)-1)
asm-ia64/sn/arch.h:#define INVALID_PNODEID		((pnodeid_t)-1)
asm-ia64/sn/arch.h:#define INVALID_SLAB            (slabid_t)-1
asm-ia64/sn/arch.h:#define INVALID_MODULE		((moduleid_t)-1)
asm-ia64/sn/arch.h:#define	INVALID_PARTID		((partid_t)-1)
asm-ia64/sn/ifconfig_net.h: * Copyright (C) 2000-2003 Silicon Graphics, Inc. All rights reserved.
asm-ia64/sn/klclock.h: * Copyright (C) 1996, 2001-2003 Silicon Graphics, Inc. All rights reserved.
asm-ia64/sn/klclock.h:/* Defines for the SGS-Thomson M48T35 clock */
asm-ia64/sn/driver.h: * Copyright (C) 1992 - 1997, 2000-2003 Silicon Graphics, Inc. All rights reserved.
asm-ia64/sn/driver.h:/* system interrupt resource handle -- returned from intr_alloc */
asm-ia64/sn/driver.h: * A basic, platform-independent description of I/O requirements for
asm-ia64/sn/driver.h:						 * non-threaded interrupt 
asm-ia64/sn/ioerror.h: * Copyright (C) 1992 - 1997, 2000-2003 Silicon Graphics, Inc. All rights reserved.
asm-ia64/sn/ioerror.h: * that is known to be a read-modify-write cycle. It is
asm-ia64/sn/ioerror.h: * List of error numbers returned by error handling sub-system.
asm-ia64/sn/ioerror.h: *      - Error handling often involves translating one form of address to other
asm-ia64/sn/ioerror.h: *      - This provides a way to dump all error related information in any layer
asm-ia64/sn/ioerror.h:#define	IOERROR_INIT(e)		do { (e)->ie_v.iev_a = 0; } while (0)
asm-ia64/sn/ioerror.h:#define	IOERROR_SETVALUE(e,f,v)	do { (e)->ie_ ## f = (v); (e)->ie_v.iev_b.ievb_ ## f = 1; } while (0)
asm-ia64/sn/ioerror.h:#define	IOERROR_FIELDVALID(e,f)	((unsigned long long)((e)->ie_v.iev_b.ievb_ ## f) != (unsigned long long) 0)
asm-ia64/sn/ioerror.h:#define	IOERROR_NOGETVALUE(e,f)	(ASSERT(IOERROR_FIELDVALID(e,f)), ((e)->ie_ ## f))
asm-ia64/sn/ioerror.h:#define	IOERROR_GETVALUE(p,e,f)	ASSERT(IOERROR_FIELDVALID(e,f)); p=((e)->ie_ ## f)
asm-ia64/sn/rw_mmr.h: * Copyright (C) 2002-2003 Silicon Graphics, Inc.  All Rights Reserved.
asm-ia64/sn/rw_mmr.h: * 	pio_phys_read_mmr  - read an MMR
asm-ia64/sn/rw_mmr.h: * 	pio_phys_write_mmr - write an MMR
asm-ia64/sn/rw_mmr.h: * 	pio_atomic_phys_write_mmrs - atomically write 2 MMRs with psr.ic=0
asm-ia64/sn/klconfig.h: * Copyright (C) 1992-1997,1999,2001-2003 Silicon Graphics, Inc.  All Rights Reserved.
asm-ia64/sn/klconfig.h:/* lboard_t->brd_flags fields */
asm-ia64/sn/klconfig.h:/* klinfo->flags fields */
asm-ia64/sn/klconfig.h:#define IS_CONSOLE_IOC3(i)	((((klinfo_t *)i)->flags) & KLINFO_INSTALL)
asm-ia64/sn/klconfig.h:        (KL_CONFIG_HDR(_nasid)->ch_board_info)
asm-ia64/sn/klconfig.h:        (KL_CONFIG_HDR(_nasid)->ch_board_info = (_off))
asm-ia64/sn/klconfig.h:        (lboard_t *)((KL_CONFIG_HDR(_nasid)->ch_board_info) ?		\
asm-ia64/sn/klconfig.h:	 NODE_OFFSET_TO_K0((_nasid), KL_CONFIG_HDR(_nasid)->ch_board_info) : \
asm-ia64/sn/klconfig.h:	(lboard_t *)((KL_CONFIG_HDR(_nasid)->ch_board_info) ?           \
asm-ia64/sn/klconfig.h:	 NODE_OFFSET_TO_LBOARD((_nasid), KL_CONFIG_HDR(_nasid)->ch_board_info) : \
asm-ia64/sn/klconfig.h:#define KL_CONFIG_MAGIC(_nasid)		(KL_CONFIG_HDR(_nasid)->ch_magic)
asm-ia64/sn/klconfig.h:        (KL_CONFIG_HDR(_nasid)->ch_magic == KLCFGINFO_MAGIC)
asm-ia64/sn/klconfig.h:                  (KL_CONFIG_HDR(_nasid)->ch_magic = KLCFGINFO_MAGIC)
asm-ia64/sn/klconfig.h:/* --- New Macros for the changed kl_config_hdr_t structure --- */
asm-ia64/sn/klconfig.h:			((__psunsigned_t)_k + (_k->ch_malloc_hdr_off)))
asm-ia64/sn/klconfig.h:			((__psunsigned_t)_k + (_k->ch_cons_off)))
asm-ia64/sn/klconfig.h:/* ------------------------------------------------------------- */
asm-ia64/sn/klconfig.h:#define KL_CONFIG_BOARD_NASID(_brd)	((_brd)->brd_nasid)
asm-ia64/sn/klconfig.h:#define KL_CONFIG_BOARD_SET_NEXT(_brd, _off)	((_brd)->brd_next = (_off))
asm-ia64/sn/klconfig.h:#define KL_CONFIG_DUPLICATE_BOARD(_brd)	((_brd)->brd_flags & DUPLICATE_BOARD)
asm-ia64/sn/klconfig.h:               ((_xbowp)->xbow_port_info[(_link) - BASE_XBOW_PORT].port_flag & XBOW_PORT_HUB)
asm-ia64/sn/klconfig.h:               ((_xbowp)->xbow_port_info[(_link) - BASE_XBOW_PORT].port_flag & XBOW_PORT_IO)
asm-ia64/sn/klconfig.h:               ((_xbowp)->xbow_port_info[(_link) - BASE_XBOW_PORT].port_flag & XBOW_PORT_ENABLE)
asm-ia64/sn/klconfig.h:               ((_xbowp)->xbow_port_info[(_link) - BASE_XBOW_PORT].port_nasid)
asm-ia64/sn/klconfig.h: * node.(TBD - Need a way to treat ROUTER boards.)
asm-ia64/sn/klconfig.h: * There are 2 different structures to represent these boards -
asm-ia64/sn/klconfig.h: * lboard - Local board, rboard - remote board. These 2 structures
asm-ia64/sn/klconfig.h: * is used to find out its type - no unions are used.
asm-ia64/sn/klconfig.h: +------------+      +------------+      +------------+      +------------+
asm-ia64/sn/klconfig.h: |  lboard    |  +-->|   lboard   |  +-->|   rboard   |  +-->|   lboard   |
asm-ia64/sn/klconfig.h: +------------+  |   +------------+  |   +------------+  |   +------------+
asm-ia64/sn/klconfig.h: +------------+  |   +------------+  |   +------------+  |   +------------+
asm-ia64/sn/klconfig.h: | offset     |--+   |  offset    |--+   |  offset    |--+   |offset=NULL |
asm-ia64/sn/klconfig.h: +------------+      +------------+      +------------+      +------------+
asm-ia64/sn/klconfig.h: +------------+
asm-ia64/sn/klconfig.h: +------------+       +--------------------------------+
asm-ia64/sn/klconfig.h: | compt 1    |------>| type, rev, diaginfo, size ...  |  (CPU)
asm-ia64/sn/klconfig.h: +------------+       +--------------------------------+
asm-ia64/sn/klconfig.h: | compt 2    |--+
asm-ia64/sn/klconfig.h: +------------+  |    +--------------------------------+
asm-ia64/sn/klconfig.h: |  ...       |  +--->| type, rev, diaginfo, size ...  |  (MEM_BANK)
asm-ia64/sn/klconfig.h: +------------+       +--------------------------------+
asm-ia64/sn/klconfig.h: | errinfo    |--+
asm-ia64/sn/klconfig.h: +------------+  |    +--------------------------------+
asm-ia64/sn/klconfig.h:                 +--->|r/l brd errinfo,compt err flags |
asm-ia64/sn/klconfig.h:                      +--------------------------------+
asm-ia64/sn/klconfig.h: * be used. If the NODE is non-zero (remote) then each offset should
asm-ia64/sn/klconfig.h:#define KL_CPU_NONE		(-1)	/* no cpu present in slot */
asm-ia64/sn/klconfig.h:					    and the non-graphics widget boards */
asm-ia64/sn/klconfig.h:#define IS_MIO_PRESENT(l)	((l->brd_type == KLTYPE_BASEIO) && \
asm-ia64/sn/klconfig.h:				 (l->brd_flags & SECOND_NIC_PRESENT))
asm-ia64/sn/klconfig.h:#define BOARD_SLOT(_brd)	((_brd)->brd_slot)
asm-ia64/sn/klconfig.h:#define KLCF_CLASS(_brd)	KLCLASS((_brd)->brd_type)
asm-ia64/sn/klconfig.h:#define KLCF_TYPE(_brd)		KLTYPE((_brd)->brd_type)
asm-ia64/sn/klconfig.h:#define KLCF_REMOTE(_brd)  	(((_brd)->struct_type & LOCAL_BOARD) ? 0 : 1)
asm-ia64/sn/klconfig.h:#define KLCF_NUM_COMPS(_brd)	((_brd)->brd_numcompts)
asm-ia64/sn/klconfig.h:#define KLCF_MODULE_ID(_brd)	((_brd)->brd_module)
asm-ia64/sn/klconfig.h:#define KLCF_NEXT(_brd) 		((_brd)->brd_next ? (lboard_t *)((_brd)->brd_next):  NULL)
asm-ia64/sn/klconfig.h:						(_brd)->brd_compts[(_ndx)]))
asm-ia64/sn/klconfig.h:		(NODE_OFFSET_TO_K0(NASID_GET(_brd), (_comp)->errinfo))
asm-ia64/sn/klconfig.h:        ((_brd)->brd_next ?     \
asm-ia64/sn/klconfig.h:         (NODE_OFFSET_TO_LBOARD(NASID_GET(_brd), (_brd)->brd_next)): NULL)
asm-ia64/sn/klconfig.h:                ((((_brd)->brd_compts[(_ndx)]) == 0) ? 0 : \
asm-ia64/sn/klconfig.h:			(NODE_OFFSET_TO_KLINFO(NASID_GET(_brd), (_brd)->brd_compts[(_ndx)])))
asm-ia64/sn/klconfig.h:                (NODE_OFFSET_TO_K0(NASID_GET(_brd), (_comp)->errinfo))
asm-ia64/sn/klconfig.h:#define KLCF_COMP_TYPE(_comp)	((_comp)->struct_type)
asm-ia64/sn/klconfig.h:#define KLCF_BRIDGE_W_ID(_comp)	((_comp)->physid)	/* Widget ID */
asm-ia64/sn/klconfig.h:	unsigned char	widid;	          /* Widget id - if applicable */
asm-ia64/sn/klconfig.h:	nasid_t		nasid;            /* node number - from parent */
asm-ia64/sn/klconfig.h:#define KLCONFIG_INFO_ENABLED(_i)	((_i)->flags & KLINFO_ENABLE)
asm-ia64/sn/klconfig.h:                            ((_info)->membnk_bnksz[(_bank)])
asm-ia64/sn/klconfig.h:                            ((_info)->membnk_attr & (MEMBNK_PREMIUM << (_bank)))
asm-ia64/sn/klconfig.h:				KLCF_COMP(_l, _l->brd_numcompts))
asm-ia64/sn/klconfig.h:typedef struct klvmeb_s {                          /* VME BRIDGE - PCI CTLR */
asm-ia64/sn/klconfig.h:typedef struct klvmed_s {                          /* VME DEVICE - VME BOARD */
asm-ia64/sn/klconfig.h:/* XXX - Don't we need the number of ports here?!? */
asm-ia64/sn/klconfig.h: * TBD - Can the ARCS and device driver related info also be included in the
asm-ia64/sn/klconfig.h: * TBD - Allocation issues. 
asm-ia64/sn/sn_cpuid.h: * Copyright (C) 2000-2003 Silicon Graphics, Inc. All rights reserved.
asm-ia64/sn/sn_cpuid.h: *	   CPUID - a number in range of 0..NR_CPUS-1 that uniquely identifies
asm-ia64/sn/sn_cpuid.h: *	   CPUNUM - On IA64, a cpunum and cpuid are the same. This is NOT true
asm-ia64/sn/sn_cpuid.h: *			hard_smp_processor_id()- cpu_physical_id of current processor
asm-ia64/sn/sn_cpuid.h: *			cpu_physical_id(cpuid) - convert a <cpuid> to a <physical_cpuid>
asm-ia64/sn/sn_cpuid.h: *			cpu_logical_id(phy_id) - convert a <physical_cpuid> to a <cpuid> 
asm-ia64/sn/sn_cpuid.h: *				* not real efficient - don't use in perf critical code
asm-ia64/sn/sn_cpuid.h: *         LID - processor defined register (see PRM V2).
asm-ia64/sn/sn_cpuid.h: *		31:28 - id   Contains 0-3 to identify the cpu on the node
asm-ia64/sn/sn_cpuid.h: *		27:16 - eid  Contains the NASID
asm-ia64/sn/sn_cpuid.h: *          -----   -----           -----   -----       CPU
asm-ia64/sn/sn_cpuid.h: *          -----   -----           -----   -----
asm-ia64/sn/sn_cpuid.h: *             -------                 -------  
asm-ia64/sn/sn_cpuid.h: *             ------------      -------------
asm-ia64/sn/sn_cpuid.h: *             |          |----- |           |        CNODEID (0..num_compact_nodes-1)
asm-ia64/sn/sn_cpuid.h: *             ------------      -------------
asm-ia64/sn/sn_cpuid.h: * NOTE: on non-MP systems, only cpuid 0 exists
asm-ia64/sn/sn_cpuid.h: * cpuid_to_slice  - convert a cpuid to the slice that it resides on
asm-ia64/sn/sn_cpuid.h: * cpuid_to_nasid  - convert a cpuid to the NASID that it resides on
asm-ia64/sn/sn_cpuid.h: * cpuid_to_cnodeid  - convert a cpuid to the cnode that it resides on
asm-ia64/sn/sn_cpuid.h: * cnodeid_to_nasid - convert a cnodeid to a NASID
asm-ia64/sn/sn_cpuid.h: * nasid_to_cnodeid - convert a NASID to a cnodeid
asm-ia64/sn/sn_cpuid.h: * cnode_slice_to_cpuid - convert a codeid & slice to a cpuid
asm-ia64/sn/sn_cpuid.h: * cpuid_to_subnode - convert a cpuid to the subnode it resides on.
asm-ia64/sn/ioc3.h: * Copyright (c) 2002-2003 Silicon Graphics, Inc.  All Rights Reserved.
asm-ia64/sn/ioc3.h: * Foundation, Inc., 59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm-ia64/sn/ioc3.h:	volatile u8		fill0[0x150 - 0x142 - 1];
asm-ia64/sn/ioc3.h:	volatile u8		fill1[0x158 - 0x152 - 1];
asm-ia64/sn/ioc3.h:	volatile u8		fill2[0x168 - 0x15a - 1];
asm-ia64/sn/ioc3.h:	volatile u8		fill3[0x170 - 0x169 - 1];
asm-ia64/sn/ioc3.h:	volatile u32	pad1[(0x20000 - 0x00154) / 4];
asm-ia64/sn/ioc3.h:	volatile u32	pad2[(0x40000 - 0x20180) / 4];
asm-ia64/sn/ioc3.h:	volatile u32	ssram[(0x80000 - 0x40000) / 4];
asm-ia64/sn/ioc3.h:	   0x80000 -   Access to the generic devices selected with   DEV0
asm-ia64/sn/ioc3.h:	   0xA0000 -   Access to the generic devices selected with   DEV1
asm-ia64/sn/ioc3.h:	   0xC0000 -   Access to the generic devices selected with   DEV2
asm-ia64/sn/ioc3.h:	   0xE0000 -   Access to the generic devices selected with   DEV3
asm-ia64/sn/ioc3.h:/* ------------------------------------------------------------------------- */
asm-ia64/sn/ioc3.h:#define SSCR_RX_RING_DCD 0x00040000	/* post RX record on delta-DCD */
asm-ia64/sn/ioc3.h:#define SSCR_RX_RING_CTS 0x00080000	/* post RX record on delta-CTS */
asm-ia64/sn/ioc3.h:#define SIO_IR_SA_INT		0x00000040	/* port A pass-thru intr */
asm-ia64/sn/ioc3.h:#define SIO_IR_PP_INT		0x00040000	/* P port pass-thru intr */
asm-ia64/sn/ioc3.h:#define IOC3_PENDING_INTRS(mem) (PCI_INW(&((mem)->sio_ir)) & \
asm-ia64/sn/ioc3.h:				 PCI_INW(&((mem)->sio_ies_ro)))
asm-ia64/sn/ioc3.h:#define SIO_CR_ARB_DIAG_IDLE	0x00400000	/* 0 -> active request (ro) */
asm-ia64/sn/ioc3.h:	 100 / INT_OUT_NS_PER_TICK - 1)
asm-ia64/sn/ioc3.h:#define IOC3_ALL_SUBDEVS	((1<<ioc3_nsubdevs)-1)
asm-ia64/sn/ioc4.h: * Copyright (c) 2002-2003 Silicon Graphics, Inc.  All Rights Reserved.
asm-ia64/sn/ioc4.h: * Foundation, Inc., 59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm-ia64/sn/ioc4.h: * ioc4.h - IOC4 chip header file
asm-ia64/sn/ioc4.h: * The IOC4 chip is a 32-bit PCI device that provides 4 serial ports,
asm-ia64/sn/ioc4.h: * an IDE bus interface, a PC keyboard/mouse interface, and a real-time
asm-ia64/sn/ioc4.h: * It includes an optimized DMA buffer management, and a store-and-forward
asm-ia64/sn/ioc4.h:/* These registers are read-only for general kernel code. To modify
asm-ia64/sn/ioc4.h:#define IOC4_STCIR_0_P	        0x08008	/* (read-only) */
asm-ia64/sn/ioc4.h:#define IOC4_SRPIR_0_P	        0x0800C	/* (read-only) */
asm-ia64/sn/ioc4.h:#define IOC4_UART_LSMSMCR_0_P   0x08018	/* (read-only) */
asm-ia64/sn/ioc4.h:#define IOC4_STCIR_1_P	        0x0C008	/* (read-only) */
asm-ia64/sn/ioc4.h:#define IOC4_SRPIR_1_P	        0x0C00C	/* (read-only) */
asm-ia64/sn/ioc4.h:#define IOC4_UART_LSMSMCR_1_P   0x0C018	/* (read-only) */
asm-ia64/sn/ioc4.h:#define IOC4_STCIR_2_P	        0x10008	/* (read-only) */
asm-ia64/sn/ioc4.h:#define IOC4_SRPIR_2_P	        0x1000C	/* (read-only) */
asm-ia64/sn/ioc4.h:#define IOC4_UART_LSMSMCR_2_P   0x10018	/* (read-only) */
asm-ia64/sn/ioc4.h:#define IOC4_STCIR_3_P	        0x14008	/* (read-only) */
asm-ia64/sn/ioc4.h:#define IOC4_SRPIR_3_P	        0x1400C	/* (read-only) */
asm-ia64/sn/ioc4.h:#define IOC4_UART_LSMSMCR_3_P   0x14018	/* (read-only) */
asm-ia64/sn/ioc4.h:#define IOC4_SIO_IR_S0_INT	        0x00000040 /* Port 0 pass-thru intr */
asm-ia64/sn/ioc4.h:#define IOC4_OTHER_IR_ATA_INT           0x00000001 /* ATAPI intr pass-thru */
asm-ia64/sn/ioc4.h:#define IOC4_PENDING_SIO_INTRS(mem)     (PCI_INW(&((mem)->sio_ir)) & \
asm-ia64/sn/ioc4.h:				         PCI_INW(&((mem)->sio_ies_ro)))
asm-ia64/sn/ioc4.h:#define IOC4_PENDING_OTHER_INTRS(mem)   (PCI_INW(&((mem)->other_ir)) & \
asm-ia64/sn/ioc4.h:				         PCI_INW(&((mem)->other_ies_ro)))
asm-ia64/sn/ioc4.h:#define IOC4_SIO_CR_ARB_DIAG		0x00000070 /* Current non-ATA PCI bus
asm-ia64/sn/ioc4.h:#define IOC4_SIO_CR_SIO_DIAG_IDLE	0x00000080 /* 0 -> active request among
asm-ia64/sn/ioc4.h:#define IOC4_SIO_CR_ATA_DIAG_IDLE	0x00000100 /* 0 -> active request from
asm-ia64/sn/ioc4.h:#define IOC4_SIO_CR_ATA_DIAG_ACTIVE     0x00000200 /* 1 -> ATA request is winner */ 
asm-ia64/sn/ioc4.h:	 100 / IOC4_INT_OUT_NS_PER_TICK - 1)
asm-ia64/sn/ioc4.h:#define IOC4_ATA_TIMING_ADR_SETUP	0x00000003 /* Clocks of addr set-up */
asm-ia64/sn/ioc4.h:#define IOC4_ATA_DMA_CTRL_STRAT		0x00000001 /* 1 -> start DMA engine */
asm-ia64/sn/ioc4.h:#define IOC4_ATA_DMA_CTRL_STOP		0x00000002 /* 1 -> stop DMA engine */
asm-ia64/sn/ioc4.h:#define IOC4_ATA_DMA_CTRL_DIR		0x00000004 /* 1 -> ATA bus data copied
asm-ia64/sn/ioc4.h:#define IOC4_SSCR_RX_RING_DCD   0x00040000 /* Post RX record on delta-DCD */
asm-ia64/sn/ioc4.h:#define IOC4_SSCR_RX_RING_CTS   0x00080000 /* Post RX record on delta-CTS */
asm-ia64/sn/ioc4.h:    char                    pci_fill1[0x58 - 0x3c - 4];
asm-ia64/sn/ioc4.h:    /* These registers are read-only for general kernel code.  To
asm-ia64/sn/ioc4.h:    char		    misc_fill4[0x100 - 0x5C - 4];
asm-ia64/sn/ioc4.h:    char		    ata_fill1[0x140 - 0x120 - 4];
asm-ia64/sn/ioc4.h:    char		    ata_fill2[0x200 - 0x15C - 4];
asm-ia64/sn/ioc4.h:    char		    km_fill1[0x300 - 0x210 - 4];
asm-ia64/sn/ioc4.h:#define IOC4_ALL_SUBDEVS	((1 << ioc4_nsubdevs) - 1)
asm-ia64/sn/intr.h: * Copyright (C) 1992 - 1997, 2000-2003 Silicon Graphics, Inc. All rights reserved.
asm-ia64/sn/leds.h: * Copyright (C) 2000-2003 Silicon Graphics, Inc. All rights reserved.
asm-ia64/sn/sn_private.h: * Copyright (C) 1992-1997,2000-2003 Silicon Graphics, Inc. All rights reserved.
asm-ia64/sn/addrs.h: * Copyright (c) 1992-1999,2001-2003 Silicon Graphics, Inc. All rights reserved.
asm-ia64/sn/addrs.h:#define	SWIN_SIZEMASK		(SWIN_SIZE - 1)
asm-ia64/sn/addrs.h: * to Xtalk address in the range 0 -> SWINZ_SIZEMASK
asm-ia64/sn/addrs.h: * The following define the major position-independent aliases used
asm-ia64/sn/addrs.h: *	LBOOT  -- 256MB in size, reads in the LBOOT area result in
asm-ia64/sn/addrs.h: *			other directory-bus connected devices.
asm-ia64/sn/addrs.h: *	IALIAS -- 8MB in size, reads in the IALIAS result in uncached
asm-ia64/sn/addrs.h: * As all other non-II mmr's located at the top of big window
asm-ia64/sn/addrs.h: * Software structure locations -- permanently fixed
asm-ia64/sn/addrs.h: * Software structure locations -- indirected through KLDIR
asm-ia64/sn/addrs.h:#define KLCONFIG_SIZE(nasid)	KLD_KLCONFIG(nasid)->size
asm-ia64/sn/addrs.h:#define GDA_ADDR(nasid)		KLD_GDA(nasid)->pointer
asm-ia64/sn/addrs.h:#define GDA_SIZE(nasid)		KLD_GDA(nasid)->size
asm-ia64/sn/dmamap.h: * Copyright (C) 1992-1997,2000-2003 Silicon Graphics, Inc. All rights reserved.
asm-ia64/sn/serialio.h: * Foundation, Inc., 59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm-ia64/sn/serialio.h: * declares a set of per-port private data areas describing each
asm-ia64/sn/serialio.h:#define L_LOCKED(port, flag) (((port)->sio_lockcalls & (flag)) == 0 || \
asm-ia64/sn/serialio.h: * module, providing black-box access to the hardware by the upper
asm-ia64/sn/serialio.h: * the case of non-support, the upper layer may work around the problem
asm-ia64/sn/serialio.h: * return -1 if the hardware is no longer present.
asm-ia64/sn/serialio.h:    ((p)->sio_calldown->down_open(p))
asm-ia64/sn/serialio.h:    ((p)->sio_calldown->down_config(p, a, b, c, d, e))
asm-ia64/sn/serialio.h:    ((p)->sio_calldown->down_enable_hfc(p, enb))
asm-ia64/sn/serialio.h: * internal clock is used. If cf is non-zero external clock is used
asm-ia64/sn/serialio.h:    ((p)->sio_calldown->down_set_extclk(p, cf))
asm-ia64/sn/serialio.h:    ((p)->sio_calldown->down_write(p, buf, len))
asm-ia64/sn/serialio.h:    ((p)->sio_calldown->down_du_write(p, buf, len))
asm-ia64/sn/serialio.h:     ((p)->sio_calldown->down_du_flush(p))
asm-ia64/sn/serialio.h:    ((p)->sio_calldown->down_break(p, brk))
asm-ia64/sn/serialio.h:    ((p)->sio_calldown->down_enable_tx(p, 1))
asm-ia64/sn/serialio.h:    ((p)->sio_calldown->down_enable_tx(p, 0))
asm-ia64/sn/serialio.h: * has a parity error, the first call to DOWN_READ will return bytes 0-4
asm-ia64/sn/serialio.h: * subsequent call to DOWN_READ returns bytes 6-9. The upper layer
asm-ia64/sn/serialio.h:    ((p)->sio_calldown->down_read(p, buf, len))
asm-ia64/sn/serialio.h:    ((p)->sio_calldown->down_notification(p, mask, on))
asm-ia64/sn/serialio.h:    ((p)->sio_calldown->down_rx_timeout(p, t))
asm-ia64/sn/serialio.h:    ((p)->sio_calldown->down_set_DTR(p, dtr))
asm-ia64/sn/serialio.h:    ((p)->sio_calldown->down_set_RTS(p, rts))
asm-ia64/sn/serialio.h:    ((p)->sio_calldown->down_query_DCD(p))
asm-ia64/sn/serialio.h:    ((p)->sio_calldown->down_query_CTS(p))
asm-ia64/sn/serialio.h:    ((p)->sio_calldown->down_set_protocol(p, proto))
asm-ia64/sn/serialio.h:    ((p)->sio_calldown->down_mapid(p, arg))
asm-ia64/sn/serialio.h:    ((p)->sio_calldown->down_map(p, vt, off))
asm-ia64/sn/serialio.h:    ((p)->sio_calldown->down_unmap(p))
asm-ia64/sn/serialio.h:    ((p)->sio_calldown->down_set_sscr(p, arg, flag))
asm-ia64/sn/serialio.h: * black-box access to the upper level kernel interface by the
asm-ia64/sn/serialio.h:    ((p)->sio_callup ? (p)->sio_callup->up_data_ready(p):(void)0)
asm-ia64/sn/serialio.h:    ((p)->sio_callup ? (p)->sio_callup->up_output_lowat(p):(void)0)
asm-ia64/sn/serialio.h:    ((p)->sio_callup ? (p)->sio_callup->up_ncs(p, ncs):(void)0)
asm-ia64/sn/serialio.h:    ((p)->sio_callup ? (p)->sio_callup->up_dDCD(p, dcd):(void)0)
asm-ia64/sn/serialio.h:    ((p)->sio_callup ? (p)->sio_callup->up_dCTS(p, cts):(void)0)
asm-ia64/sn/serialio.h:    if ((up = (p)->sio_callup)) \
asm-ia64/sn/serialio.h:	up->up_detach(p); \
asm-ia64/sn/serialio.h:#define SIO_LOCK_PORT(port, flags)	spin_lock_irqsave(&port->sio_lock, flags)
asm-ia64/sn/serialio.h:#define SIO_UNLOCK_PORT(port, flags)	spin_unlock_irqrestore(&port->sio_lock, flags)
asm-ia64/sn/serialio.h:#define MIDIDEV_UNREGISTERED -1    /* Initialization for portidx field of miditype structure */
asm-ia64/sn/prio.h: * Copyright (C) 1992 - 1997, 2000-2003 Silicon Graphics, Inc. All rights reserved.
asm-ia64/sn/prio.h:#define PRIO_FAIL       (-1) 
asm-ia64/sn/router.h: * Copyright (C) 1992 - 1997, 2000-2003 Silicon Graphics, Inc. All rights reserved.
asm-ia64/sn/router.h:#define ALL_PORTS ((1 << MAX_ROUTER_PORTS) - 1)	/* for 0 based references */
asm-ia64/sn/router.h:#define PORT_INVALID (-1)	 /* Invalid port number              */
asm-ia64/sn/router.h:#define	IS_META(_rp)	((_rp)->flags & PCFG_ROUTER_META)
asm-ia64/sn/router.h:#define	IS_REPEATER(_rp)((_rp)->flags & PCFG_ROUTER_REPEATER)
asm-ia64/sn/router.h:				 (_L) + (count) - MAX_ROUTER_PORTS :	\
asm-ia64/sn/router.h:				 (_LD) - (_LS) :			\
asm-ia64/sn/router.h:				 (_LD) + MAX_ROUTER_PORTS - (_LS))
asm-ia64/sn/router.h:#define RR_PROT_CONF		0x00010	/* Inter-partition protection conf. */
asm-ia64/sn/router.h:#define RR_DEBUG_ADDR		0x00038 /* Debug address select - debug port*/
asm-ia64/sn/router.h:/* Port-specific registers (_L is the link number from 1 to 8) */
asm-ia64/sn/router.h:#define RR_STATUS_ERROR(_L)	(((_L+1) & 0xe) << 15 | ((_L+1) & 0x1) << 11 | 0x0008) /* Port-related errs  */
asm-ia64/sn/router.h:#define RPCONF_RESETOK(_L)	(UINT64_CAST 1 << ((_L) - 1))
asm-ia64/sn/router.h:#define RGPD_MGLBLNHBR_ID_SHFT	12	/* -global neighbor ID */
asm-ia64/sn/router.h:#define RGPD_MGLBLNHBR_VLD_SHFT	11	/* -global neighbor Valid */
asm-ia64/sn/router.h:#define RGPD_MGLBLPORT_SHFT	8	/* -global neighbor Port */
asm-ia64/sn/router.h:#define RDPARM_SENDERROR(_L)	(UINT64_CAST 1 << ((_L) -  1))
asm-ia64/sn/router.h:#define PROBE_RESULT_BAD	(-1)		/* Set if any of the router
asm-ia64/sn/router.h:/* All utilizations are on a scale from 0 - 1023. */
asm-ia64/sn/router.h: * Router port-oriented information
asm-ia64/sn/router.h:#define ROUTER_INFO_PRINT(_rip,_where)	(_rip->ri_print |= _where)	
asm-ia64/sn/router.h:					(_rip->ri_print & _where)	
asm-ia64/sn/router.h:#define ROUTER_INFO_LOCK(_rip,_s)	_s = mutex_spinlock(&(_rip->ri_lock))
asm-ia64/sn/router.h:#define ROUTER_INFO_UNLOCK(_rip,_s)	mutex_spinunlock(&(_rip->ri_lock),_s)
asm-ia64/sn/router.h:			/* number-in-a-can (unique) for the router */
asm-ia64/sn/router.h:#define RRM_RESETOK(_L)		(UINT64_CAST 1 << ((_L) - 1))
asm-ia64/sn/router.h:#define RTABLE_SHFT(_L)		(4 * ((_L) - 1))
asm-ia64/sn/types.h: * Copyright (C) 1999,2001-2003 Silicon Graphics, Inc.  All Rights Reserved.
asm-ia64/sn/types.h:typedef signed short	nasid_t;	/* node id in numa-as-id space */
asm-ia64/sn/types.h:typedef unsigned int    moduleid_t;     /* user-visible module number type */
asm-ia64/sn/simulator.h: * Copyright (C) 2000-2003 Silicon Graphics, Inc. All rights reserved.
asm-ia64/sn/ioconfig_bus.h: * Foundation, Inc., 59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm-ia64/sn/iograph.h: * Copyright (C) 1992-1997,2000-2003 Silicon Graphics, Inc. All rights reserved.
asm-ia64/sn/iograph.h: * During initialization, platform-dependent kernel code establishes some
asm-ia64/sn/iograph.h: * info labels that are used across various platforms -- it serves as an
asm-ia64/sn/iograph.h: * ad-hoc registry.
asm-ia64/sn/iograph.h:#define EDGE_LBL_ISDN                   "isdn"		/* Digi PCI ISDN-BRI card */
asm-ia64/sn/iograph.h:#define EDGE_LBL_LINUX_BUS              EDGE_LBL_LINUX "/bus/pci-x"
asm-ia64/sn/iograph.h:#define EDGE_LBL_PCIX			"pci-x"
asm-ia64/sn/iograph.h:#define EDGE_LBL_MADGE_TR               "Madge-tokenring"
asm-ia64/sn/iograph.h:								* 32-bit Direct
asm-ia64/sn/sn_fru.h: * Copyright (C) 1992-1997,1999-2003 Silicon Graphics, Inc. All rights reserved.
asm-ia64/sn/fetchop.h: * Copyright (c) 2001-2003 Silicon Graphics, Inc.  All rights reserved.
asm-ia64/sn/fetchop.h: * cached cache-line is modified, when that line is flushed, it will
asm-ia64/sn/fetchop.h: *	fetchop_kalloc_page	- Allocate/initialize 1 fetchop page on the
asm-ia64/sn/fetchop.h: *	fetchop_kfree_page	- Free a previously allocated fetchop page
asm-ia64/sn/sn_sal.h: * Copyright (c) 2000-2003 Silicon Graphics, Inc.  All rights reserved.
asm-ia64/sn/sn_sal.h: * Service-specific constants
asm-ia64/sn/sn_sal.h:#define SALRET_INVALID_ARG	-2
asm-ia64/sn/sn_sal.h:#define SALRET_ERROR		-3
asm-ia64/sn/sn_sal.h: * sn_sal_rev_major - get the major SGI SAL revision number
asm-ia64/sn/sn_sal.h:	return (int)systab->sal_b_rev_major;
asm-ia64/sn/sn_sal.h: * sn_sal_rev_minor - get the minor SGI SAL revision number
asm-ia64/sn/sn_sal.h:	return (int)systab->sal_b_rev_minor;
asm-ia64/sn/sn_sal.h: * ia64_sn_pod_mode - call the SN_SAL_POD_MODE function
asm-ia64/sn/sn_sal.h: * Change or query the coherence domain for this partition. Each cpu-based
asm-ia64/sn/sn_sal.h: * nasid is represented by a bit in an array of 64-bit words:
asm-ia64/sn/sn_sal.h:	spin_lock(&NODEPDA(cnodeid)->bist_lock);
asm-ia64/sn/sn_sal.h:	spin_unlock(&NODEPDA(cnodeid)->bist_lock);
asm-ia64/sn/sn_sal.h: * ia64_sn_fru_capture - tell the system controller to capture hw state
asm-ia64/sn/hcl_util.h: * Copyright (C) 1992 - 1997, 2000-2003 Silicon Graphics, Inc. All rights reserved.
asm-ia64/sn/hwgfs.h: * Copyright (C) 1992 - 1997, 2000-2003 Silicon Graphics, Inc. All rights reserved.
asm-ia64/sn/ioerror_handling.h: * Copyright (C) 1992 - 1997, 2000-2003 Silicon Graphics, Inc. All rights reserved.
asm-ia64/sn/ioerror_handling.h:	 * that the device has been software-enabled after software-
asm-ia64/sn/ioerror_handling.h:#define ERROR_CONTEXT_IGNORE	((error_context_t)-1ll)
asm-ia64/sn/ioerror_handling.h:#define ERROR_ACTION_IGNORE	((error_action_f)-1ll)
asm-ia64/sn/ioerror_handling.h:			return(-1);					 
asm-ia64/sn/ioerror_handling.h:			return(-2);					   
asm-ia64/sn/slotnum.h: * Copyright (C) 1992-1997,2000-2003 Silicon Graphics, Inc. All rights reserved.
asm-ia64/io.h: * versions of the single-IO instructions (inb_p/inw_p/..).
asm-ia64/io.h: * Copyright (C) 1998-2002 Hewlett-Packard Co
asm-ia64/io.h: *	David Mosberger-Tang <davidm@hpl.hp.com>
asm-ia64/io.h:#define IO_SPACE_PORT(port)		((port) & (IO_SPACE_SIZE - 1))
asm-ia64/io.h:	return (unsigned long) address - PAGE_OFFSET;
asm-ia64/io.h: * Please use the PCI-DMA interface defined in <asm/pci.h> instead.
asm-ia64/io.h: * not IA-64 specific.
asm-ia64/io.h:	if (space->sparse)
asm-ia64/io.h:	return (void *) (space->mmio_base | offset);
asm-ia64/io.h:		while (count--)
asm-ia64/io.h:		while (count--)
asm-ia64/io.h:		while (count--)
asm-ia64/io.h:		while (count--)
asm-ia64/io.h:		while (count--)
asm-ia64/io.h:		while (count--)
asm-ia64/io.h:		while (count--)
asm-ia64/io.h:		while (count--)
asm-ia64/io.h:		while (count--)
asm-ia64/io.h:		while (count--)
asm-ia64/io.h:		while (count--)
asm-ia64/io.h:		while (count--)
asm-ia64/io.h: * Unfortunately, some platforms are broken and do not follow the IA-64 architecture
asm-ia64/io.h: * On ia-64, we access the physical I/O memory space through the uncached kernel region.
asm-ia64/atomic.h: * Copyright (C) 1998, 1999, 2002 Hewlett-Packard Co
asm-ia64/atomic.h: *	David Mosberger-Tang <davidm@hpl.hp.com>
asm-ia64/atomic.h: * On IA-64, counter must always be volatile to ensure that that the
asm-ia64/atomic.h:#define atomic_read(v)		((v)->counter)
asm-ia64/atomic.h:#define atomic_set(v,i)		(((v)->counter) = (i))
asm-ia64/atomic.h:		new = old - i;
asm-ia64/atomic.h:	   || (i == -1) || (i == -4) || (i == -8) || (i == -16)))	\
asm-ia64/atomic.h:	 ? ia64_fetch_and_add(i, &(v)->counter)				\
asm-ia64/atomic.h:	   || (i == -1) || (i == -4) || (i == -8) || (i == -16)))	\
asm-ia64/atomic.h:	 ? ia64_fetch_and_add(-(i), &(v)->counter)			\
asm-ia64/delay.h: * Delay routines using a pre-computed "cycles/usec" value.
asm-ia64/delay.h: * Copyright (C) 1998, 1999 Hewlett-Packard Co
asm-ia64/delay.h: * Copyright (C) 1998, 1999 David Mosberger-Tang <davidm@hpl.hp.com>
asm-ia64/delay.h:	while (__builtin_expect ((__s32) result == -1, 0))
asm-ia64/delay.h:	__asm__ __volatile__("mov ar.lc=%0;;" :: "r"(loops - 1));
asm-ia64/delay.h:	unsigned long cycles = usecs*local_cpu_data->cyc_per_usec;
asm-ia64/delay.h:	while (ia64_get_itc() - start < cycles)
asm-ia64/delay.h:	unsigned long cycles = nsecs*local_cpu_data->cyc_per_usec/1000;
asm-ia64/delay.h:	while (ia64_get_itc() - start < cycles)
asm-ia64/ipcbuf.h: * The ipc64_perm structure for IA-64 architecture.
asm-ia64/ipcbuf.h: * - 32-bit seq
asm-ia64/ipcbuf.h: * - 2 miscellaneous 64-bit values
asm-ia64/parport.h: * parport.h: platform-specific PC-style parport initialisation
asm-ia64/shmbuf.h: * The shmid64_ds structure for IA-64 architecture.
asm-ia64/shmbuf.h: * - 2 miscellaneous 64-bit values
asm-ia64/bitops.h: * Copyright (C) 1998-2003 Hewlett-Packard Co
asm-ia64/bitops.h: *	David Mosberger-Tang <davidm@hpl.hp.com>
asm-ia64/bitops.h: * set_bit - Atomically set a bit in memory
asm-ia64/bitops.h: * restricted to acting on a single-word quantity.
asm-ia64/bitops.h: * hw-defined data-structures, so we can't easily change these operations to force a
asm-ia64/bitops.h: * __set_bit - Set a bit in memory
asm-ia64/bitops.h: * Unlike set_bit(), this function is non-atomic and may be reordered.
asm-ia64/bitops.h: * clear_bit - Clears a bit in memory
asm-ia64/bitops.h: * change_bit - Toggle a bit in memory
asm-ia64/bitops.h: * restricted to acting on a single-word quantity.
asm-ia64/bitops.h: * __change_bit - Toggle a bit in memory
asm-ia64/bitops.h: * Unlike change_bit(), this function is non-atomic and may be reordered.
asm-ia64/bitops.h: * test_and_set_bit - Set a bit and return its old value
asm-ia64/bitops.h: * __test_and_set_bit - Set a bit and return its old value
asm-ia64/bitops.h: * This operation is non-atomic and can be reordered.  
asm-ia64/bitops.h: * test_and_clear_bit - Clear a bit and return its old value
asm-ia64/bitops.h: * __test_and_clear_bit - Clear a bit and return its old value
asm-ia64/bitops.h: * This operation is non-atomic and can be reordered.  
asm-ia64/bitops.h: * test_and_change_bit - Change a bit and return its new value
asm-ia64/bitops.h: * ffz - find the first zero bit in a memory region
asm-ia64/bitops.h: * Returns the bit-number (0..63) of the first (least significant) zero bit, not
asm-ia64/bitops.h:	__asm__ ("popcnt %0=%1" : "=r" (result) : "r" (x & (~x - 1)));
asm-ia64/bitops.h: * __ffs - find first bit in word.
asm-ia64/bitops.h:	__asm__ ("popcnt %0=%1" : "=r" (result) : "r" ((x - 1) & ~x));
asm-ia64/bitops.h: * find_last_zero_bit - find the last zero bit in a 64 bit quantity
asm-ia64/bitops.h:	return exp - 0xffff;
asm-ia64/bitops.h: * of bits set) of a N-bit word
asm-ia64/bitops.h:	size -= result;
asm-ia64/bitops.h:		tmp |= ~0UL >> (64-offset);
asm-ia64/bitops.h:		size -= 64;
asm-ia64/bitops.h:		size -= 64;
asm-ia64/div64.h: * Copyright (C) 1999 Hewlett-Packard Co
asm-ia64/div64.h: * Copyright (C) 1999 David Mosberger-Tang <davidm@hpl.hp.com>
asm-ia64/div64.h: * vsprintf uses this to divide a 64-bit integer N by a small integer BASE.
asm-ia64/div64.h: * This is incredibly hard on IA-64...
asm-ia64/resource.h: * Based on <asm-i386/resource.h>.
asm-ia64/resource.h: *	David Mosberger-Tang <davidm@hpl.hp.com>, Hewlett-Packard Co
asm-ia64/resource.h:#define RLIMIT_MEMLOCK	8		/* max locked-in-memory address space */
asm-ia64/ptrace.h: * Copyright (C) 1998-2001 Suresh Siddha <suresh.b.siddha@intel.com>  
asm-ia64/ptrace.h: * Copyright (C) 1998-2001 Hewlett-Packard Co
asm-ia64/ptrace.h: * Copyright (C) 1998-2001 David Mosberger-Tang <davidm@hpl.hp.com>
asm-ia64/ptrace.h: *            +----------------------+	-------	IA64_STK_OFFSET
asm-ia64/ptrace.h: *            +----------------------+	 |
asm-ia64/ptrace.h: *            +----------------------+	 |
asm-ia64/ptrace.h: *	      +----------------------+	 |
asm-ia64/ptrace.h: *	      +----------------------+	 |  ---	IA64_RBS_OFFSET
asm-ia64/ptrace.h: * current -> |			     |   |  |
asm-ia64/ptrace.h: *	      +----------------------+ -------
asm-ia64/ptrace.h: * Base-2 logarithm of number of pages to allocate per task structure
asm-ia64/ptrace.h: * THIS STRUCTURE MUST BE A MULTIPLE 16-BYTE IN SIZE
asm-ia64/ptrace.h:	unsigned long ar_fpsr;		/* floating-point status register */
asm-ia64/ptrace.h:	unsigned long ar_unat;		/* NaT bits for r4-r7 */
asm-ia64/ptrace.h:# define ia64_task_regs(t)		(((struct pt_regs *) ((char *) (t) + IA64_STK_OFFSET)) - 1)
asm-ia64/ptrace.h:# define ia64_psr(regs)			((struct ia64_psr *) &(regs)->cr_ipsr)
asm-ia64/ptrace.h:# define user_mode(regs)		(((struct ia64_psr *) &(regs)->cr_ipsr)->cpl != 0)
asm-ia64/ptrace.h:		ia64_task_regs(current)->r8 = 0;	\
asm-ia64/ptrace.h:/* indices to application-registers array in pt_all_user_regs */
asm-ia64/pgalloc.h: * This hopefully works with any (fixed) ia-64 page-size, as defined
asm-ia64/pgalloc.h: * Copyright (C) 1998-2002 Hewlett-Packard Co
asm-ia64/pgalloc.h: *	David Mosberger-Tang <davidm@hpl.hp.com>
asm-ia64/pgalloc.h: * completely re-init them the same way, then free them up.  This wasted
asm-ia64/pgalloc.h:#define pgd_quicklist		(local_cpu_data->pgd_quick)
asm-ia64/pgalloc.h:#define pmd_quicklist		(local_cpu_data->pmd_quick)
asm-ia64/pgalloc.h:#define pte_quicklist		(local_cpu_data->pte_quick)
asm-ia64/pgalloc.h:#define pgtable_cache_size	(local_cpu_data->pgtable_cache_sz)
asm-ia64/pgalloc.h:		--pgtable_cache_size;
asm-ia64/pgalloc.h:		--pgtable_cache_size;
asm-ia64/pgalloc.h:		--pgtable_cache_size;
asm-ia64/pgalloc.h:	if (mm == current->active_mm)
asm-ia64/pgalloc.h: * exit().  fork() ends up here because the copy-on-write mechanism needs to write-protect
asm-ia64/pgalloc.h:	mm->context = 0;
asm-ia64/pgalloc.h:	if (atomic_read(&mm->mm_users) == 0)
asm-ia64/pgalloc.h: * Page-granular tlb flush.
asm-ia64/pgalloc.h:	flush_tlb_range(vma->vm_mm, (addr & PAGE_MASK), (addr & PAGE_MASK) + PAGE_SIZE);
asm-ia64/pgalloc.h:	if (vma->vm_mm == current->active_mm)
asm-ia64/pgalloc.h:		vma->vm_mm->context = 0;
asm-ia64/pgalloc.h: * table corresponding to address range [START-END).
asm-ia64/pgalloc.h:	if (unlikely(end - start >= 1024*1024*1024*1024UL
asm-ia64/pgalloc.h:		     || rgn_index(start) != rgn_index(end - 1)))
asm-ia64/pgalloc.h:	clear_bit(PG_arch_1, &(page)->flags);	\
asm-ia64/pgalloc.h: * IA-64 doesn't have any external MMU info: the page tables contain all the necessary
asm-ia64/pgalloc.h: * information.  However, we use this macro to take care of any (delayed) i-cache flushing
asm-ia64/pgalloc.h:	if (test_bit(PG_arch_1, &page->flags))
asm-ia64/pgalloc.h:		return;				/* i-cache is already coherent with d-cache */
asm-ia64/pgalloc.h:	set_bit(PG_arch_1, &page->flags);	/* mark page as clean */
asm-ia64/unistd.h: * IA-64 Linux syscall numbers and inline-functions.
asm-ia64/unistd.h: * Copyright (C) 1998-2001 Hewlett-Packard Co
asm-ia64/unistd.h: *	David Mosberger-Tang <davidm@hpl.hp.com>
asm-ia64/unistd.h:/* 1230-1232: reserved for futex and sched_[sg]etaffinity */
asm-ia64/unistd.h:/* 1234-1235: reserved for {alloc,free}_hugepages */
asm-ia64/unistd.h:/* 1238-1242: reserved for io_{setup,destroy,getevents,submit,cancel} */
asm-ia64/unistd.h:	return wait4(-1, wait_stat, 0, 0);
asm-ia64/dma.h: * Copyright (C) 1998-2001 Hewlett-Packard Co
asm-ia64/dma.h: * Copyright (C) 1998-2001 David Mosberger-Tang <davidm@hpl.hp.com>
asm-ia64/elf.h: * Copyright (C) 1998, 1999, 2002 Hewlett-Packard Co
asm-ia64/elf.h: *	David Mosberger-Tang <davidm@hpl.hp.com>
asm-ia64/elf.h:#define elf_check_arch(x) ((x)->e_machine == EM_IA_64)
asm-ia64/elf.h:/* Least-significant four bits of ELF header's e_flags are OS-specific.  The bits are
asm-ia64/elf.h: * elf_gregset_t contains the application-level state in the following order:
asm-ia64/elf.h: *	r0-r31
asm-ia64/elf.h: *	NaT bits (for r0-r31; bit N == 1 iff rN is a NaT)
asm-ia64/elf.h: *	predicate registers (p0-p63)
asm-ia64/elf.h: *	b0-b7
asm-ia64/fpu.h: * Copyright (C) 1998, 1999, 2002, 2003 Hewlett-Packard Co
asm-ia64/fpu.h: *	David Mosberger-Tang <davidm@hpl.hp.com>
asm-ia64/fpu.h:#define FPSR_TRAP_ZD	(1 << 2)	/* zero-divide trap disabled */
asm-ia64/fpu.h:/* floating-point status field controls: */
asm-ia64/fpu.h:#define FPSF_FTZ	(1 << 0)		/* flush-to-zero */
asm-ia64/fpu.h:#define FPSF_WRE	(1 << 1)		/* widest-range exponent */
asm-ia64/fpu.h:/* floating-point status field flags: */
asm-ia64/fpu.h:/* floating-point rounding control: */
asm-ia64/fpu.h:/* This default value is the same as HP-UX uses.  Don't change it
asm-ia64/fpu.h:		long double __dummy;	/* force 16-byte alignment */
asm-ia64/ide.h: *  linux/include/asm-ia64/ide.h
asm-ia64/ide.h: *  Copyright (C) 1994-1996  Linus Torvalds & authors
asm-ia64/ide.h:		hw->io_ports[i] = reg;
asm-ia64/ide.h:		hw->io_ports[IDE_CONTROL_OFFSET] = ctrl_port;
asm-ia64/ide.h:		hw->io_ports[IDE_CONTROL_OFFSET] = hw->io_ports[IDE_DATA_OFFSET] + 0x206;
asm-ia64/ide.h:	hw->io_ports[IDE_IRQ_OFFSET] = 0;
asm-ia64/ide.h:#include <asm-generic/ide_iops.h>
asm-ia64/irq.h: * Copyright (C) 1999-2000, 2002 Hewlett-Packard Co
asm-ia64/irq.h: *	David Mosberger-Tang <davidm@hpl.hp.com>
asm-ia64/mca.h:#define IA64_MCA_RENDEZ_TIMEOUT		(20 * 1000)	/* value in milliseconds - 20 seconds */
asm-ia64/mca.h:	u64		imsto_pal_proc;		/* PAL_PROC entry point - physical addr */
asm-ia64/mca.h:	u64		imsto_sal_proc;		/* SAL_PROC entry point - physical addr */
asm-ia64/mca.h:	u64		imsto_sal_gp;		/* GP of the SAL - physical */
asm-ia64/mca.h:	IA64_MCA_WARM_BOOT	=	-1,	/* Warm boot of the system need from SAL */
asm-ia64/mca.h:	IA64_MCA_COLD_BOOT	=	-2,	/* Cold boot of the system need from SAL */
asm-ia64/mca.h:	IA64_MCA_HALT		=	-3	/* System to be halted by SAL */
asm-ia64/mca.h:	IA64_MCA_NEW_CONTEXT	=	-1	/* SAL to return to new context */
asm-ia64/mca.h:	u64		imots_sal_gp;		/* GP of the SAL - physical */
asm-ia64/pal.h: * This is based on Intel IA-64 Architecture Software Developer's Manual rev 1.0
asm-ia64/pal.h: * chapter 11 IA-64 Processor Abstraction Layer
asm-ia64/pal.h: * Copyright (C) 1998-2001 Hewlett-Packard Co
asm-ia64/pal.h: *	David Mosberger-Tang <davidm@hpl.hp.com>
asm-ia64/pal.h: * 00/03/23     cfleck  Modified processor min-state save area to match updated PAL & SAL info
asm-ia64/pal.h: * Note that some of these calls use a static-register only calling
asm-ia64/pal.h:#define PAL_ENTER_IA_32_ENV	33	/* enter IA-32 system environment */
asm-ia64/pal.h:#define PAL_TEST_PROC		258	/* perform late processor self-test */
asm-ia64/pal.h:#define PAL_STATUS_UNIMPLEMENTED	(-1)	/* Unimplemented procedure */
asm-ia64/pal.h:#define PAL_STATUS_EINVAL		(-2)	/* Invalid argument */
asm-ia64/pal.h:#define PAL_STATUS_ERROR		(-3)	/* Error */
asm-ia64/pal.h:#define PAL_STATUS_CACHE_INIT_FAIL	(-4)	/* Could not initialize the
asm-ia64/pal.h:				at		: 2,	/* 2-1 Cache mem attr*/
asm-ia64/pal.h:				reserved	: 5,	/* 7-3 Reserved */
asm-ia64/pal.h:				associativity	: 8,	/* 16-8 Associativity*/
asm-ia64/pal.h:				line_size	: 8,	/* 23-17 Line size */
asm-ia64/pal.h:				stride		: 8,	/* 31-24 Stride */
asm-ia64/pal.h:				store_latency	: 8,	/*39-32 Store latency*/
asm-ia64/pal.h:				load_latency	: 8,	/* 47-40 Load latency*/
asm-ia64/pal.h:				store_hints	: 8,	/* 55-48 Store hints*/
asm-ia64/pal.h:				load_hints	: 8;	/* 63-56 Load hints */
asm-ia64/pal.h:				alias_boundary	: 8,	/* 39-32 aliased addr
asm-ia64/pal.h:				tag_ls_bit	: 8,	/* 47-40 LSb of addr*/
asm-ia64/pal.h:				tag_ms_bit	: 8,	/* 55-48 MSb of addr*/
asm-ia64/pal.h:				reserved	: 8;	/* 63-56 Reserved */
asm-ia64/pal.h:#define PAL_CACHE_HINT_NTEMP_1		1	/* Non-temporal level 1 */
asm-ia64/pal.h:#define PAL_CACHE_HINT_NTEMP_ALL	3	/* Non-temporal all levels */
asm-ia64/pal.h:				tagprot_lsb	: 6, /* Least -do- */
asm-ia64/pal.h:		u64		cache_type	: 8,	/* 7-0 cache type */
asm-ia64/pal.h:				level		: 8,	/* 15-8 level of the
asm-ia64/pal.h:				way		: 8,	/* 23-16 way in the set
asm-ia64/pal.h:				part		: 8,	/* 31-24 part of the
asm-ia64/pal.h:				reserved	: 32;	/* 63-32 is reserved*/
asm-ia64/pal.h:		u64		cache_type	: 8,	/* 7-0 cache type */
asm-ia64/pal.h:				level		: 8,	/* 15-8 level of the
asm-ia64/pal.h:				way		: 8,	/* 23-16 way in the set
asm-ia64/pal.h:				part		: 8,	/* 31-24 part of the
asm-ia64/pal.h:				mesi		: 8,	/* 39-32 cache line
asm-ia64/pal.h:				start		: 8,	/* 47-40 lsb of data to
asm-ia64/pal.h:				length		: 8,	/* 55-48 #bits to
asm-ia64/pal.h:				trigger		: 8;	/* 63-56 Trigger error
asm-ia64/pal.h:	u64			pcli_data;		/* 64-bit data, tag, protection bits .. */
asm-ia64/pal.h:			hd		: 1,	/* Non-essential hw
asm-ia64/pal.h:			pm		: 1,	/* Precise min-state save area */
asm-ia64/pal.h:						 * during cache-cache
asm-ia64/pal.h:	u64	pmsa_gr[15];		/* GR1	- GR15		   */
asm-ia64/pal.h:	u64	pmsa_bank0_gr[16];	/* GR16 - GR31		   */
asm-ia64/pal.h:	u64	pmsa_bank1_gr[16];	/* GR16 - GR31		   */
asm-ia64/pal.h:		features_avail->pal_bus_features_val = iprv.v0;
asm-ia64/pal.h:		features_status->pal_bus_features_val = iprv.v1;
asm-ia64/pal.h:		features_control->pal_bus_features_val = iprv.v2;
asm-ia64/pal.h:		conf->pcci_status                 = iprv.status;
asm-ia64/pal.h:		conf->pcci_info_1.pcci1_data      = iprv.v0;
asm-ia64/pal.h:		conf->pcci_info_2.pcci2_data      = iprv.v1;
asm-ia64/pal.h:		conf->pcci_reserved               = iprv.v2;
asm-ia64/pal.h:		prot->pcpi_status           = iprv.status;
asm-ia64/pal.h:		prot->pcp_info[0].pcpi_data = iprv.v0 & 0xffffffff;
asm-ia64/pal.h:		prot->pcp_info[1].pcpi_data = iprv.v0 >> 32;
asm-ia64/pal.h:		prot->pcp_info[2].pcpi_data = iprv.v1 & 0xffffffff;
asm-ia64/pal.h:		prot->pcp_info[3].pcpi_data = iprv.v1 >> 32;
asm-ia64/pal.h:		prot->pcp_info[4].pcpi_data = iprv.v2 & 0xffffffff;
asm-ia64/pal.h:		prot->pcp_info[5].pcpi_data = iprv.v2 >> 32;
asm-ia64/pal.h:/* Write the data and tag of a processor-controlled cache line for diags */
asm-ia64/pal.h:/* Switch from IA64-system environment to IA-32 system environment */
asm-ia64/pal.h: * self-test and the required alignment of memory.
asm-ia64/pal.h:		pm_info->ppmi_data = iprv.v0;
asm-ia64/pal.h:		return -1;
asm-ia64/pal.h:		ptce->base = iprv.v0;
asm-ia64/pal.h:		ptce->count[0] = iprv.v1 >> 32;
asm-ia64/pal.h:		ptce->count[1] = iprv.v1 & 0xffffffff;
asm-ia64/pal.h:		ptce->stride[0] = iprv.v2 >> 32;
asm-ia64/pal.h:		ptce->stride[1] = iprv.v2 & 0xffffffff;
asm-ia64/pal.h:		hints->ph_data = iprv.v1;
asm-ia64/pal.h: * This is usually called in IA-32 mode.
asm-ia64/pal.h:/* Perform the second phase of processor self-test. */
asm-ia64/pal.h:		pal_min_version->pal_version_val = iprv.v0;
asm-ia64/pal.h:		pal_cur_version->pal_version_val = iprv.v1;
asm-ia64/pal.h:		tc_info->pti_val = iprv.v0;
asm-ia64/pal.h:		vm_info_1->pvi1_val = iprv.v0;
asm-ia64/pal.h:		vm_info_2->pvi2_val = iprv.v1;
asm-ia64/pal.h:		tr_valid->piv_val = iprv.v0;
asm-ia64/pci.h: * Can be used to override the logic in pci_scan_bus for skipping already-configured bus
asm-ia64/pci.h: * numbers - to be used for buggy BIOSes or architectures with incomplete PCI setup by the
asm-ia64/pci.h: * Dynamic DMA mapping API.  See Documentation/DMA-mapping.txt for details.
asm-ia64/pci.h:#define pci_unmap_addr(ptr, addr_name)		((ptr)->addr_name)
asm-ia64/pci.h:#define pci_unmap_addr_set(ptr, addr_name, val)	(((ptr)->addr_name) = (val))
asm-ia64/pci.h:#define pci_unmap_len(ptr, len_name)		((ptr)->len_name)
asm-ia64/pci.h:#define pci_unmap_len_set(ptr, len_name, val)	(((ptr)->len_name) = (val))
asm-ia64/pci.h:/* The ia64 platform always supports 64-bit addressing. */
asm-ia64/pci.h:#define sg_dma_address(sg)	((sg)->dma_address)
asm-ia64/pci.h:#define sg_dma_len(sg)		((sg)->dma_length)
asm-ia64/pci.h:#define PCI_CONTROLLER(dev) ((struct pci_controller *) dev->sysdata)
asm-ia64/pci.h:#define PCI_SEGMENT(dev)    (PCI_CONTROLLER(dev)->segment)
asm-ia64/sal.h: * This is based on version 2.5 of the manual "IA-64 System
asm-ia64/sal.h: * Copyright (C) 1998, 1999, 2001, 2003 Hewlett-Packard Co
asm-ia64/sal.h: *	David Mosberger-Tang <davidm@hpl.hp.com>
asm-ia64/sal.h:	u64 vector;		/* interrupt vector in range 0x10-0xff */
asm-ia64/sal.h:	 * The rest of this structure consists of variable-length arrays, which can't be
asm-ia64/sal.h:	 * This is what the rest looked like if C supported variable-length arrays:
asm-ia64/sal.h:	 ((char *) _l->info + ((_l->valid.num_cache_check + _l->valid.num_tlb_check		\
asm-ia64/sal.h:				+ _l->valid.num_bus_check + _l->valid.num_reg_file_check	\
asm-ia64/sal.h:				+ _l->valid.num_ms_check) * sizeof(sal_log_mod_error_info_t)	\
asm-ia64/sal.h:/* SAL log over-all, multi-section error record structure (processor+platform) */
asm-ia64/sal.h: * non-monarch processor at the end of machine check processing.
asm-ia64/sal.h:/* Update the contents of PAL block in the non-volatile storage device */
asm-ia64/rse.h: * Copyright (C) 1998, 1999 Hewlett-Packard Co
asm-ia64/rse.h: * Copyright (C) 1998, 1999 David Mosberger-Tang <davidm@hpl.hp.com>
asm-ia64/rse.h: * used in applications, so be careful about the name-space and give
asm-ia64/rse.h: * some consideration to non-GNU C compilers (though __inline__ is
asm-ia64/rse.h:	unsigned long slots = (bsp - bspstore);
asm-ia64/rse.h:	return slots - (ia64_rse_slot_num(bspstore) + slots)/0x40;
asm-ia64/rse.h:		delta -= 0x3e;
asm-ia64/smp.h: * Copyright (C) 2001-2003 Hewlett-Packard Co
asm-ia64/smp.h: *	David Mosberger-Tang <davidm@hpl.hp.com>
asm-ia64/smp.h:#define smp_processor_id()	(current->processor)
asm-ia64/smp.h: * don't use this in performance-critical code.
asm-ia64/tlb.h:#define local_mmu_gathers local_cpu_data->mmu_gathers
asm-ia64/tlb.h:#include <asm-generic/tlb.h>
asm-ia64/vga.h: *	Copyright (C) 2002 Hewlett-Packard Co
asm-ia64/vga.h: * 2002/07/19	davidm@hpl.hp.com	Access frame-buffer memory via readX/writeX.
asm-ia64/xor.h: * include/asm-ia64/xor.h
asm-ia64/xor.h: * Optimized RAID-5 checksumming functions for IA-64.
asm-ia64/xor.h:#include <asm-generic/xor.h>
asm-ia64/machvec_dig.h: * platform's machvec structure.  When compiling a non-generic kernel,
asm-ia64/signal.h: * Modified 1998-2001
asm-ia64/signal.h: *	David Mosberger-Tang <davidm@hpl.hp.com>, Hewlett-Packard Co
asm-ia64/signal.h: * glibc-2.x.  Hence the #ifdef __KERNEL__ ugliness.
asm-ia64/signal.h:#define SIGRTMAX	(_NSIG-1)
asm-ia64/signal.h: * SA_INTERRUPT is a no-op, but left due to historical reasons.
asm-ia64/signal.h:#define SA_INTERRUPT	0x20000000 /* dummy -- ignored */
asm-ia64/signal.h:#define SIG_ERR	((__sighandler_t)-1)	/* error return from signal */
asm-ia64/machvec_sn2.h: * Copyright (c) 2002-2003 Silicon Graphics, Inc.  All Rights Reserved.
asm-ia64/machvec_sn2.h: * Foundation, Inc., 59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm-ia64/machvec_sn2.h: * platform's machvec structure.  When compiling a non-generic kernel,
asm-ia64/kregs.h: * Copyright (C) 2001-2002 Hewlett-Packard Co
asm-ia64/kregs.h: *	David Mosberger-Tang <davidm@hpl.hp.com>
asm-ia64/kregs.h:#define IA64_KR_FPU_OWNER	5	/* ar.k5: fpu-owner (UP only, at the moment) */
asm-ia64/kregs.h:#define IA64_TR_CURRENT_STACK	2	/* dtr2: maps kernel's memory- & register-stacks */
asm-ia64/kregs.h:#define IA64_DCR_BE_BIT		 1	/* big-endian default */
asm-ia64/kregs.h:#define IA64_DCR_LC_BIT		 2	/* ia32 lock-check enable */
asm-ia64/kregs.h:#define IA64_DCR_DP_BIT		 9	/* defer page-not-present faults */
asm-ia64/kregs.h:#define IA64_ISR_NA_BIT		35	/* non-access */
asm-ia64/kregs.h:#define IA64_ISR_RS_BIT		37	/* mandatory register-stack exception */
asm-ia64/kregs.h:/* ISR code field for non-access instructions */
asm-ia64/hardirq.h: * Copyright (C) 1998-2001 Hewlett-Packard Co
asm-ia64/hardirq.h: * Copyright (C) 1998-2001 David Mosberger-Tang <davidm@hpl.hp.com>
asm-ia64/hardirq.h: * No irq_cpustat_t for IA-64.  The data is held in the per-CPU data structure.
asm-ia64/hardirq.h:#define softirq_pending(cpu)		(cpu_data(cpu)->softirq_pending)
asm-ia64/hardirq.h:#define ksoftirqd_task(cpu)		(cpu_data(cpu)->ksoftirqd)
asm-ia64/hardirq.h:#define irq_count(cpu)			(cpu_data(cpu)->irq_stat.f.irq_count)
asm-ia64/hardirq.h:#define bh_count(cpu)			(cpu_data(cpu)->irq_stat.f.bh_count)
asm-ia64/hardirq.h:#define syscall_count(cpu)		/* unused on IA-64 */
asm-ia64/hardirq.h:#define local_softirq_pending()		(local_cpu_data->softirq_pending)
asm-ia64/hardirq.h:#define local_ksoftirqd_task()		(local_cpu_data->ksoftirqd)
asm-ia64/hardirq.h:#define really_local_irq_count()	(local_cpu_data->irq_stat.f.irq_count)	/* XXX fix me */
asm-ia64/hardirq.h:#define really_local_bh_count()		(local_cpu_data->irq_stat.f.bh_count)	/* XXX fix me */
asm-ia64/hardirq.h:#define local_syscall_count()		/* unused on IA-64 */
asm-ia64/hardirq.h:#define in_interrupt()			(local_cpu_data->irq_stat.irq_and_bh_counts != 0)
asm-ia64/hardirq.h:#define in_irq()			(local_cpu_data->irq_stat.f.irq_count != 0)
asm-ia64/hardirq.h:# define local_irq_exit(irq)		(really_local_irq_count()--)
asm-ia64/hardirq.h:	really_local_irq_count()--;
asm-ia64/shmparam.h: * get attached.  The IA-64 architecture says that there may be a
asm-ia64/shmparam.h: * To reduce the chance of this, we set SHMLBA to 1MB. --davidm 00/12/20
asm-ia64/sigcontext.h: * Copyright (C) 1998, 1999, 2001 Hewlett-Packard Co
asm-ia64/sigcontext.h: * Copyright (C) 1998, 1999, 2001 David Mosberger-Tang <davidm@hpl.hp.com>
asm-ia64/sigcontext.h:#define IA64_SC_FLAG_FPH_VALID_BIT		2	/* is state in f[32]-f[127] valid? */
asm-ia64/sigcontext.h:	unsigned long		sc_ar_fpsr;	/* floating-point status register */
asm-ia64/sigcontext.h:	struct ia64_fpreg	sc_fr[128];	/* floating-point registers */
asm-ia64/processor.h: * Copyright (C) 1998-2002 Hewlett-Packard Co
asm-ia64/processor.h: *	David Mosberger-Tang <davidm@hpl.hp.com>
asm-ia64/processor.h: * TASK_SIZE really is a mis-named.  It really is the maximum user
asm-ia64/processor.h: * space address (plus one).  On IA-64, there are five regions of 2TB
asm-ia64/processor.h:#define TASK_SIZE		(current->thread.task_size)
asm-ia64/processor.h:#define TASK_UNMAPPED_BASE	(current->thread.map_base)
asm-ia64/processor.h:#define IA64_THREAD_FPH_VALID	(__IA64_UL(1) << 0)	/* floating-point high state valid? */
asm-ia64/processor.h: * CPU type, hardware bug flags, and per-CPU state.  Frequently used
asm-ia64/processor.h:	/* irq_stat must be 64-bit aligned */
asm-ia64/processor.h:	/* CPUID-derived information: */
asm-ia64/processor.h: * The "local" data pointer.  It points to the per-CPU data of the currently executing
asm-ia64/processor.h: * CPU, much like "current" points to the per-task data of the currently executing task.
asm-ia64/processor.h: * the node that contains the cpu. This minimizes off-node memory references.  cpu_data
asm-ia64/processor.h: * On non-NUMA systems, cpu_data is a static array allocated at compile time.  References
asm-ia64/processor.h:# define cpu_data(cpu)		local_cpu_data->cpu_data[cpu]
asm-ia64/processor.h:# define numa_node_id()		(local_cpu_data->nodeid)
asm-ia64/processor.h:	(task)->thread.flags = (((task)->thread.flags & ~IA64_THREAD_UAC_MASK)			\
asm-ia64/processor.h:	put_user(((task)->thread.flags & IA64_THREAD_UAC_MASK) >> IA64_THREAD_UAC_SHIFT,	\
asm-ia64/processor.h:	(task)->thread.flags = (((task)->thread.flags & ~IA64_THREAD_FPEMU_MASK)		\
asm-ia64/processor.h:	put_user(((task)->thread.flags & IA64_THREAD_FPEMU_MASK) >> IA64_THREAD_FPEMU_SHIFT,	\
asm-ia64/processor.h:	unsigned long pfm_ovfl_block_reset;/* non-zero if we need to block or reset regs on ovfl */
asm-ia64/processor.h:	-1				/* last_fph_cpu*/	\
asm-ia64/processor.h:	regs->cr_ipsr = ((regs->cr_ipsr | (IA64_PSR_BITS_TO_SET | IA64_PSR_CPL))		\
asm-ia64/processor.h:	regs->cr_iip = new_ip;									\
asm-ia64/processor.h:	regs->ar_rsc = 0xf;		/* eager mode, privilege level 3 */			\
asm-ia64/processor.h:	regs->ar_rnat = 0;									\
asm-ia64/processor.h:	regs->ar_bspstore = current->thread.rbs_bot;						\
asm-ia64/processor.h:	regs->ar_fpsr = FPSR_DEFAULT;								\
asm-ia64/processor.h:	regs->loadrs = 0;									\
asm-ia64/processor.h:	regs->r8 = current->mm->dumpable;	/* set "don't zap registers" flag */		\
asm-ia64/processor.h:	regs->r12 = new_sp - 16;	/* allocate 16 byte scratch area */			\
asm-ia64/processor.h:	if (!__builtin_expect (current->mm->dumpable, 1)) {					\
asm-ia64/processor.h:		regs->ar_pfs = 0;								\
asm-ia64/processor.h:		regs->pr = 0;									\
asm-ia64/processor.h:		regs->b6 = 0;									\
asm-ia64/processor.h:		regs->r1 = 0; regs->r2 = 0; regs->r3 = 0;					\
asm-ia64/processor.h:		regs->r13 = 0; regs->r14 = 0; regs->r15 = 0;					\
asm-ia64/processor.h:		regs->r9  = 0; regs->r11 = 0;							\
asm-ia64/processor.h:		regs->r16 = 0; regs->r17 = 0; regs->r18 = 0; regs->r19 = 0;			\
asm-ia64/processor.h:		regs->r20 = 0; regs->r21 = 0; regs->r22 = 0; regs->r23 = 0;			\
asm-ia64/processor.h:		regs->r24 = 0; regs->r25 = 0; regs->r26 = 0; regs->r27 = 0;			\
asm-ia64/processor.h:		regs->r28 = 0; regs->r29 = 0; regs->r30 = 0; regs->r31 = 0;			\
asm-ia64/processor.h:		regs->ar_ccv = 0;								\
asm-ia64/processor.h:		regs->ar_csd = 0;                                                               \
asm-ia64/processor.h:		regs->ar_ssd = 0;                                                               \
asm-ia64/processor.h:		regs->b0 = 0; regs->b7 = 0;							\
asm-ia64/processor.h:		regs->f6.u.bits[0] = 0; regs->f6.u.bits[1] = 0;					\
asm-ia64/processor.h:		regs->f7.u.bits[0] = 0; regs->f7.u.bits[1] = 0;					\
asm-ia64/processor.h:		regs->f8.u.bits[0] = 0; regs->f8.u.bits[1] = 0;					\
asm-ia64/processor.h:		regs->f9.u.bits[0] = 0; regs->f9.u.bits[1] = 0;					\
asm-ia64/processor.h:		regs->f10.u.bits[0] = 0; regs->f10.u.bits[1] = 0;				\
asm-ia64/processor.h:		regs->f11.u.bits[0] = 0; regs->f11.u.bits[1] = 0;				\
asm-ia64/processor.h: * NOTE 1: Only a kernel-only process (ie the swapper or direct
asm-ia64/processor.h:	_regs->cr_iip + ia64_psr(_regs)->ri;		\
asm-ia64/processor.h:#define KSTK_ESP(tsk)  ((tsk)->thread.ksp)
asm-ia64/processor.h:	(__ia64_islfo_task->thread.last_fph_cpu == smp_processor_id()				\
asm-ia64/processor.h:	__ia64_slfo_task->thread.last_fph_cpu = smp_processor_id();			\
asm-ia64/processor.h:#define ia64_drop_fpu(t)	((t)->thread.last_fph_cpu = -1)
asm-ia64/processor.h:/* save f32-f127 at FPH */
asm-ia64/processor.h:/* load f32-f127 from FPH */
asm-ia64/processor.h: * Note that the only way T can block is through a call to schedule() -> switch_to().
asm-ia64/processor.h:	struct task_struct *p = (void *) ((unsigned long) t - IA64_TASK_THREAD_OFFSET);
asm-ia64/processor.h:#define get_task_struct(tsk)	atomic_inc(&virt_to_page(tsk)->count)
asm-ia64/processor.h:	return (w >> n) | (w << (64 - n));
asm-ia64/processor.h:#define ia64_rotl(w,n)	ia64_rotr((w), (64) - (n))
asm-ia64/linux_logo.h: * include/asm-ia64/linux_logo.h: This is a linux logo
asm-ia64/unwind.h: * Copyright (C) 1999-2000, 2003 Hewlett-Packard Co
asm-ia64/unwind.h: *	David Mosberger-Tang <davidm@hpl.hp.com>
asm-ia64/unwind.h: * full-blown stack unwinding with all the bells and whitles, so there
asm-ia64/unwind.h: * is not much point in implementing the full IA-64 unwind API (though
asm-ia64/unwind.h: * Prepare to unwind from interruption.  The pt-regs and switch-stack structures must have
asm-ia64/unwind.h: * be "adjacent" (no state modifications between pt-regs and switch-stack).
asm-ia64/unwind.h: * Unwind until the return pointer is in user-land (or until an error
asm-ia64/unwind.h:#define unw_is_intr_frame(info)	(((info)->flags & UNW_FLAG_INTERRUPT_FRAME) != 0)
asm-ia64/unwind.h:	*valp = (info)->ip;
asm-ia64/unwind.h:	*valp = (info)->sp;
asm-ia64/unwind.h:	*valp = (info)->psp;
asm-ia64/unwind.h:	*valp = (info)->bsp;
asm-ia64/unwind.h:	*valp = *(info)->cfm_loc;
asm-ia64/unwind.h:	*(info)->cfm_loc = val;
asm-ia64/unwind.h:	if (!info->rp_loc)
asm-ia64/unwind.h:		return -1;
asm-ia64/unwind.h:	*val = *info->rp_loc;
asm-ia64/mmu_context.h: * Copyright (C) 1998-2002 Hewlett-Packard Co
asm-ia64/mmu_context.h: *	David Mosberger-Tang <davidm@hpl.hp.com>
asm-ia64/mmu_context.h: * Context numbers are implemented using ia-64 region ids.  Since the IA-64 TLB does not
asm-ia64/mmu_context.h: * per-CPU variable, which is checked in the routine below. Called by activate_mm().
asm-ia64/mmu_context.h:	if (unlikely(local_cpu_data->need_tlb_flush)) {
asm-ia64/mmu_context.h:		local_cpu_data->need_tlb_flush = 0;
asm-ia64/mmu_context.h:	mm_context_t context = mm->context;
asm-ia64/mmu_context.h:		/* re-check, now that we've got the lock: */
asm-ia64/mmu_context.h:		context = mm->context;
asm-ia64/mmu_context.h:			mm->context = context = ia64_ctx.next++;
asm-ia64/mmu_context.h: * Initialize context number to some sane value.  MM is guaranteed to be a brand-new
asm-ia64/mmu_context.h: * address-space, so no TLB flushing is needed, ever.
asm-ia64/mmu_context.h:	mm->context = 0;
asm-ia64/mmu_context.h:		/* in the unlikely event of a TLB-flush by another thread, redo the load: */
asm-ia64/mmu_context.h:	} while (unlikely(context != mm->context));
asm-ia64/mmu_context.h:	 * touch user-space.
asm-ia64/mmu_context.h:	ia64_set_kr(IA64_KR_PT_BASE, __pa(next->pgd));
asm-ia64/semaphore.h: * Copyright (C) 1998-2000 Hewlett-Packard Co
asm-ia64/semaphore.h: * Copyright (C) 1998-2000 David Mosberger-Tang <davidm@hpl.hp.com>
asm-ia64/semaphore.h:	CHECK_MAGIC(sem->__magic);
asm-ia64/semaphore.h:	if (atomic_dec_return(&sem->count) < 0)
asm-ia64/semaphore.h:	CHECK_MAGIC(sem->__magic);
asm-ia64/semaphore.h:	if (atomic_dec_return(&sem->count) < 0)
asm-ia64/semaphore.h:	CHECK_MAGIC(sem->__magic);
asm-ia64/semaphore.h:	if (atomic_dec_return(&sem->count) < 0)
asm-ia64/semaphore.h:	CHECK_MAGIC(sem->__magic);
asm-ia64/semaphore.h:	if (atomic_inc_return(&sem->count) <= 0)
asm-ia64/semaphore.h:	return atomic_read(&sem->count);
asm-ia64/fcntl.h: * Based on <asm-i386/fcntl.h>.
asm-ia64/fcntl.h: * Modified 1998-2000
asm-ia64/fcntl.h: *	David Mosberger-Tang <davidm@hpl.hp.com>, Hewlett-Packard Co.
asm-ia64/fcntl.h: * open/fcntl - O_SYNC is only implemented on blocks devices and on
asm-ia64/fcntl.h:#define O_DIRECT	 040000	/* direct disk access hint - currently ignored */
asm-ia64/fcntl.h:#define F_GETFL		3	/* get file->f_flags */
asm-ia64/fcntl.h:#define F_SETFL		4	/* set file->f_flags */
asm-ia64/mmzone.h: * Copyright (c) 2002 Kimio Suganuma <k-suganuma@da.jp.nec.com>
asm-ia64/perfmon.h: * Copyright (C) 2001-2003 Hewlett-Packard Co
asm-ia64/perfmon.h:#define PFM_FL_UNSECURE		 0x40   /* allow unsecure monitoring for non self-monitoring task */
asm-ia64/perfmon.h:	unsigned int	ft_version;	/* perfmon: major [16-31], minor [0-15] */
asm-ia64/perfmon.h:	unsigned int	ft_smpl_version;/* sampling format: major [16-31], minor [0-15] */
asm-ia64/perfmon.h: * It is exported as Read-Only at this point. It is directly followed by the
asm-ia64/perfmon.h: * describe the content of the local_cpu_date->pfm_syst_info field
asm-ia64/perfmon.h:#define PFM_CPUINFO_CLEAR(v)	local_cpu_data->pfm_syst_info &= ~(v)
asm-ia64/perfmon.h:#define PFM_CPUINFO_SET(v)	local_cpu_data->pfm_syst_info |= (v)
asm-ia64/module.h: * modutils/obj/obj-ia64.c
asm-ia64/module.h:	kmod->archdata_start = (const char *) &archdata;
asm-ia64/module.h:	kmod->archdata_end   = (const char *) (&archdata + 1);
asm-ia64/module.h:	if (!mod_member_present(mod, archdata_start) || !mod->archdata_start)
asm-ia64/module.h:	archdata = (struct archdata *)(mod->archdata_start);
asm-ia64/module.h:	if (archdata->unw_start == 0)
asm-ia64/module.h:	if (archdata->unw_table) {
asm-ia64/module.h:		printk(KERN_ERR "module_arch_init: archdata->unw_table must be zero.\n");
asm-ia64/module.h:	if (!mod_bound(archdata->gp, 0, mod)) {
asm-ia64/module.h:		printk(KERN_ERR "module_arch_init: archdata->gp out of bounds.\n");
asm-ia64/module.h:	if (!mod_bound(archdata->unw_start, 0, mod)) {
asm-ia64/module.h:		printk(KERN_ERR "module_arch_init: archdata->unw_start out of bounds.\n");
asm-ia64/module.h:	if (!mod_bound(archdata->unw_end, 0, mod)) {
asm-ia64/module.h:		printk(KERN_ERR "module_arch_init: archdata->unw_end out of bounds.\n");
asm-ia64/module.h:	if (!mod_bound(archdata->segment_base, 0, mod)) {
asm-ia64/module.h:		printk(KERN_ERR "module_arch_init: archdata->segment_base out of bounds.\n");
asm-ia64/module.h:	archdata->unw_table = unw_add_unwind_table(mod->name,
asm-ia64/module.h:						   (unsigned long) archdata->segment_base,
asm-ia64/module.h:						   (unsigned long) archdata->gp,
asm-ia64/module.h:						   archdata->unw_start, archdata->unw_end);
asm-ia64/module.h:	if (mod_member_present(mod, archdata_start) && mod->archdata_start) {
asm-ia64/module.h:		archdata = (struct archdata *)(mod->archdata_start);
asm-ia64/module.h:		if (archdata->unw_table != NULL)
asm-ia64/module.h:			unw_remove_unwind_table((void *) archdata->unw_table);
asm-ia64/rwsem.h: * asm-ia64/rwsem.h: R/W semaphores for ia64
asm-ia64/rwsem.h: * Based on asm-i386/rwsem.h and other architecture implementation.
asm-ia64/rwsem.h:#define RWSEM_WAITING_BIAS		(-0x00010000)
asm-ia64/rwsem.h:	sem->count = RWSEM_UNLOCKED_VALUE;
asm-ia64/rwsem.h:	spin_lock_init(&sem->wait_lock);
asm-ia64/rwsem.h:	INIT_LIST_HEAD(&sem->wait_list);
asm-ia64/rwsem.h:	sem->debug = 0;
asm-ia64/rwsem.h:			      "=r"(result) : "r"(&sem->count) : "memory");
asm-ia64/rwsem.h:		old = sem->count;
asm-ia64/rwsem.h:	} while (cmpxchg_acq(&sem->count, old, new) != old);
asm-ia64/rwsem.h:	__asm__ __volatile__ ("fetchadd4.rel %0=[%1],-1" :
asm-ia64/rwsem.h:			      "=r"(result) : "r"(&sem->count) : "memory");
asm-ia64/rwsem.h:	if (result < 0 && (--result & RWSEM_ACTIVE_MASK) == 0)
asm-ia64/rwsem.h:		old = sem->count;
asm-ia64/rwsem.h:		new = old - RWSEM_ACTIVE_WRITE_BIAS;
asm-ia64/rwsem.h:	} while (cmpxchg_rel(&sem->count, old, new) != old);
asm-ia64/rwsem.h: * trylock for reading -- returns 1 if successful, 0 if contention
asm-ia64/rwsem.h:	while ((tmp = sem->count) >= 0) {
asm-ia64/rwsem.h:		if (tmp == cmpxchg_acq(&sem->count, tmp, tmp+1)) {
asm-ia64/rwsem.h: * trylock for writing -- returns 1 if successful, 0 if contention
asm-ia64/rwsem.h:	int tmp = cmpxchg_acq(&sem->count, RWSEM_UNLOCKED_VALUE,
asm-ia64/rwsem.h:		old = sem->count;
asm-ia64/rwsem.h:		new = old - RWSEM_WAITING_BIAS;
asm-ia64/rwsem.h:	} while (cmpxchg_rel(&sem->count, old, new) != old);
asm-ia64/rwsem.h:#define rwsem_atomic_add(delta, sem)	atomic_add(delta, (atomic_t *)(&(sem)->count))
asm-ia64/rwsem.h:#define rwsem_atomic_update(delta, sem)	atomic_add_return(delta, (atomic_t *)(&(sem)->count))
asm-ia64/spinlock.h: * Copyright (C) 1998-2001 Hewlett-Packard Co
asm-ia64/spinlock.h: *	David Mosberger-Tang <davidm@hpl.hp.com>
asm-ia64/spinlock.h:#define spin_lock_init(x)			((x)->lock = 0)
asm-ia64/spinlock.h: * Streamlined test_and_set_bit(0, (x)).  We use test-and-test-and-set
asm-ia64/spinlock.h: * rather than a simple xchg to avoid writing the cache-line when
asm-ia64/spinlock.h:	register char *addr __asm__ ("r31") = (char *) &(x)->lock;			\
asm-ia64/spinlock.h:		: "=r"(result) : "r"(1), "r"(&(x)->lock) : "ar.ccv", "memory");		\
asm-ia64/spinlock.h:#define spin_is_locked(x)	((x)->lock != 0)
asm-ia64/spinlock.h:#define spin_unlock(x)		do { barrier(); ((spinlock_t *) x)->lock = 0;} while (0)
asm-ia64/spinlock.h:#define spin_unlock_wait(x)	do { barrier(); } while ((x)->lock)
asm-ia64/spinlock.h:#define spin_lock_init(x)			((x)->lock = 0)
asm-ia64/spinlock.h: * Streamlined test_and_set_bit(0, (x)).  We use test-and-test-and-set
asm-ia64/spinlock.h: * rather than a simple xchg to avoid writing the cache-line when
asm-ia64/spinlock.h:	:: "r"(&(x)->lock) : "ar.ccv", "p7", "r2", "r29", "memory")
asm-ia64/spinlock.h:#define spin_is_locked(x)	((x)->lock != 0)
asm-ia64/spinlock.h:#define spin_unlock(x)		do { barrier(); ((spinlock_t *) x)->lock = 0; } while (0)
asm-ia64/spinlock.h:#define spin_trylock(x)		(cmpxchg_acq(&(x)->lock, 0, 1) == 0)
asm-ia64/spinlock.h:#define spin_unlock_wait(x)	do { barrier(); } while ((x)->lock)
asm-ia64/spinlock.h:			      "2:\tfetchadd4.rel %0 = [%1], -1\n"		\
asm-ia64/spinlock.h:	__asm__ __volatile__ ("fetchadd4.rel %0 = [%1], -1\n"			\
asm-ia64/spinlock.h:		"dep r29 = -1, r0, 31, 1\n"					\
asm-ia64/errno.h: * Based on <asm-i386/errno.h>.
asm-ia64/errno.h: *	David Mosberger-Tang <davidm@hpl.hp.com>, Hewlett-Packard Co
asm-ia64/errno.h:#define	EXDEV		18	/* Cross-device link */
asm-ia64/errno.h:#define	EROFS		30	/* Read-only file system */
asm-ia64/errno.h:#define	ENOTSOCK	88	/* Socket operation on non-socket */
asm-ia64/topology.h: * linux/include/asm-ia64/topology.h
asm-ia64/topology.h: * Not implemented here. Multi-level hierarchies detected with
asm-ia64/byteorder.h: *	David Mosberger-Tang <davidm@hpl.hp.com>, Hewlett-Packard Co.
asm-ia64/acpi.h: *  asm-ia64/acpi.h
asm-ia64/acpi.h: *  Copyright (C) 2000,2001 J.I. Lee <jung-ik.lee@intel.com>
asm-ia64/acpi.h: *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
asm-ia64/acpi.h: * ACPI_SYSTEM_XFACE        - Interfaces to host OS (handlers, threads)
asm-ia64/acpi.h: * ACPI_EXTERNAL_XFACE      - External ACPI interfaces
asm-ia64/acpi.h: * ACPI_INTERNAL_XFACE      - Internal ACPI interfaces
asm-ia64/acpi.h: * ACPI_INTERNAL_VAR_XFACE  - Internal variable-parameter list interfaces
asm-ia64/acpi.h:		"and    r29=-4,r29\n"   \
asm-ia64/acpi.h:		"(p8) mov %0=-1\n"      \
asm-ia64/acpi.h:		"and    r29=-4,r29\n"   \
asm-ia64/softirq.h: * Copyright (C) 1998-2001 Hewlett-Packard Co
asm-ia64/softirq.h: *	David Mosberger-Tang <davidm@hpl.hp.com>
asm-ia64/softirq.h:#define __local_bh_enable()	do { barrier(); really_local_bh_count()--; } while (0)
asm-ia64/hw_irq.h: * Copyright (C) 2001, 2002 Hewlett-Packard Co
asm-ia64/hw_irq.h: *	David Mosberger-Tang <davidm@hpl.hp.com>
asm-ia64/hw_irq.h: * 1,3-14 are reserved from firmware
asm-ia64/hw_irq.h: * 16-255 (vectored external interrupts) are available
asm-ia64/hw_irq.h: * Vectors 0x10-0x1f are used for low priority interrupts, e.g. CMCI.
asm-ia64/hw_irq.h:#define IA64_CMCP_VECTOR		0x1d	/* corrected machine-check polling vector */
asm-ia64/hw_irq.h:#define IA64_CMC_VECTOR			0x1f	/* corrected machine-check interrupt vector */
asm-ia64/hw_irq.h: * Vectors 0x20-0x2f are reserved for legacy ISA IRQs.
asm-ia64/hw_irq.h:#define IA64_TIMER_VECTOR		0xef	/* use highest-prio group 15 interrupt for timer */
asm-ia64/hw_irq.h:#define IA64_IPI_VECTOR			0xfe	/* inter-processor interrupt vector */
asm-ia64/hw_irq.h:/* IA64 inter-cpu interrupt related definitions */
asm-ia64/hw_irq.h:/* Delivery modes for inter-cpu interrupts */
asm-ia64/hw_irq.h:        IA64_IPI_DM_EXTINT =    0x7,    /* pend an 8259-compatible interrupt. */
asm-ia64/hw_irq.h:extern struct hw_interrupt_type irq_type_ia64_lsapic;	/* CPU-internal interrupt controller */
asm-ia64/hw_irq.h: * Default implementations for the irq-descriptor API:
asm-ia64/hw_irq.h: * Next follows the irq descriptor interface.  On IA-64, each CPU supports 256 interrupt
asm-ia64/hw_irq.h: * vectors.  On smaller systems, there is a one-to-one correspondence between interrupt
asm-ia64/hw_irq.h: * interrupt domain that a CPU belongs to.  This API abstracts such platform-dependent
asm-ia64/hw_irq.h:/* Extract the IA-64 vector that corresponds to IRQ.  */
asm-ia64/hw_irq.h: * Convert the local IA-64 vector to the corresponding irq number.  This translation is
asm-ia64/timex.h: * Copyright (C) 1998-2001 Hewlett-Packard Co
asm-ia64/timex.h: * Copyright (C) 1998-2001 David Mosberger-Tang <davidm@hpl.hp.com>
asm-ia64/timex.h: * 2001/01/18 davidm	Removed CLOCK_TICK_RATE.  It makes no sense on IA-64.
asm-ia64/bugs.h: * This is included by init/main.c to check for architecture-dependent bugs.
asm-ia64/bugs.h: * Based on <asm-alpha/bugs.h>.
asm-ia64/bugs.h: *	David Mosberger-Tang <davidm@hpl.hp.com>,  Hewlett-Packard Co.
asm-ia64/bugs.h: * I don't know of any ia-64 bugs yet..
asm-ia64/namei.h: *	David Mosberger-Tang <davidm@hpl.hp.com>, Hewlett-Packard Co
asm-ia64/namei.h:#define EMUL_PREFIX_LINUX_IA32 "emul/ia32-linux/"
asm-ia64/namei.h:	switch (current->personality) {
asm-ia64/termbits.h: * Based on <asm-i386/termbits.h>.
asm-ia64/termbits.h: *	David Mosberger-Tang <davidm@hpl.hp.com>, Hewlett-Packard Co
asm-ia64/fpswa.h: * Floating-point Software Assist
asm-ia64/ia32.h:#define IA32_PAGE_MASK		(~(IA32_PAGE_SIZE - 1))
asm-ia64/ia32.h:#define IA32_PAGE_ALIGN(addr)	(((addr) + IA32_PAGE_SIZE - 1) & IA32_PAGE_MASK)
asm-ia64/ia32.h: * interacting with the FXSR-format floating point environment.  Floating
asm-ia64/ia32.h:	/* 8*10 bytes for each FP-reg = 80 bytes */
asm-ia64/ia32.h:	int	st_space[32];	/* 8*16 bytes for each FP-reg = 128 bytes */
asm-ia64/ia32.h:	int	xmm_space[32];	/* 8*16 bytes for each XMM-reg = 128 bytes */
asm-ia64/ia32.h:				((ka)->sa.sa_handler = (__sighandler_t)		\
asm-ia64/ia32.h:#define IA32_SA_HANDLER(ka)	((unsigned long) (ka)->sa.sa_handler & 0xffffffff)
asm-ia64/ia32.h:#define IA32_SA_RESTORER(ka)	((unsigned long) (ka)->sa.sa_handler >> 32)
asm-ia64/ia32.h:	unsigned int	st_blocks;	/* Number 512-byte blocks allocated. */
asm-ia64/ia32.h:		int _pad[((128/sizeof(int)) - 3)];
asm-ia64/ia32.h: * IA-32 ELF specific definitions for IA-64.
asm-ia64/ia32.h:#define elf_check_arch(x) ((x)->e_machine == EM_386)
asm-ia64/ia32.h: * The system segments (GDT, TSS, LDT) have to be mapped below 4GB so the IA-32 engine can
asm-ia64/ia32.h:	(current->personality = (IBCS2) ? PER_SVR4 : PER_LINUX)
asm-ia64/ia32.h: * IA-32 ELF specific definitions for IA-64.
asm-ia64/ia32.h:/* Unscramble an IA-32 segment descriptor into the IA-64 format.  */
asm-ia64/ia32.h:	ia64_psr(regs)->cpl = 3;	/* set user mode */			\
asm-ia64/ia32.h:	ia64_psr(regs)->ri = 0;		/* clear return slot number */		\
asm-ia64/ia32.h:	ia64_psr(regs)->is = 1;		/* IA-32 instruction set */		\
asm-ia64/ia32.h:	regs->cr_iip = new_ip;							\
asm-ia64/ia32.h:	regs->ar_rsc = 0xc;		/* enforced lazy mode, priv. level 3 */	\
asm-ia64/ia32.h:	regs->ar_rnat = 0;							\
asm-ia64/ia32.h:	regs->loadrs = 0;							\
asm-ia64/ia32.h:	regs->r12 = new_sp;							\
asm-ia64/uaccess.h: * this code is executed in kernel mode and uses user-specified
asm-ia64/uaccess.h: * associated and, if so, sets r8 to -EFAULT and clears r9 to 0 and
asm-ia64/uaccess.h: * Based on <asm-alpha/uaccess.h>.
asm-ia64/uaccess.h: * Copyright (C) 1998, 1999, 2001, 2003 Hewlett-Packard Co
asm-ia64/uaccess.h: *	David Mosberger-Tang <davidm@hpl.hp.com>
asm-ia64/uaccess.h:#define USER_DS		((mm_segment_t) { TASK_SIZE-1 })	/* cf. access_ok() */
asm-ia64/uaccess.h:#define get_fs()  (current->addr_limit)
asm-ia64/uaccess.h:#define set_fs(x) (current->addr_limit = (x))
asm-ia64/uaccess.h: * user-level space.  In order to do this efficiently, we make sure that the page at
asm-ia64/uaccess.h:	return access_ok(type,addr,size) ? 0 : -EFAULT;
asm-ia64/uaccess.h: * These are the main single-value transfer routines.  They automatically
asm-ia64/uaccess.h: * (a) re-use the arguments for side effects (sizeof/typeof is ok)
asm-ia64/uaccess.h:	register long __gu_err asm ("r8") = -EFAULT;		\
asm-ia64/uaccess.h:	register long __pu_err asm ("r8") = -EFAULT;		\
asm-ia64/uaccess.h:/* Returns: -EFAULT if exception before terminator, N if the entire
asm-ia64/uaccess.h:	long __sfu_ret = -EFAULT;					\
asm-ia64/uaccess.h:	int addr;	/* gp-relative address of insn this fixup is for */
asm-ia64/uaccess.h:	int cont;	/* gp-relative continuation address; if bit 2 is set, r9 is set to 0 */
asm-ia64/uaccess.h:#define SEARCH_EXCEPTION_TABLE(regs) search_exception_table(regs->cr_iip + ia64_psr(regs)->ri);
asm-ia64/uaccess.h:#define SEARCH_EXCEPTION_TABLE(regs) search_exception_table(regs->cr_iip);
asm-ia64/mman.h: * Based on <asm-i386/mman.h>.
asm-ia64/mman.h: * Modified 1998-2000
asm-ia64/mman.h: *	David Mosberger-Tang <davidm@hpl.hp.com>, Hewlett-Packard Co
asm-ia64/mman.h:#define MAP_GROWSDOWN	0x0100		/* stack-like segment */
asm-ia64/mman.h:#define MAP_GROWSUP	0x0200		/* register stack-like segment */
asm-ia64/mman.h:#define MAP_WRITECOMBINED 0x10000	/* write-combine the area */
asm-ia64/mman.h:#define MADV_NORMAL	0x0		/* default page-in behavior */
asm-ia64/mman.h:#define MADV_RANDOM	0x1		/* page-in minimum required */
asm-ia64/mman.h:#define MADV_SEQUENTIAL	0x2		/* read-ahead aggressively */
asm-ia64/mman.h:#define MADV_WILLNEED	0x3		/* pre-fault pages */
asm-ia64/posix_types.h: * This file is generally used by user-level software, so you need to
asm-ia64/posix_types.h: * Based on <asm-alpha/posix_types.h>.
asm-ia64/posix_types.h: * Modified 1998-2000
asm-ia64/posix_types.h: *	David Mosberger-Tang <davidm@hpl.hp.com>, Hewlett-Packard Co
asm-ia64/posix_types.h:#define	__FD_SET(d, set)	((set)->fds_bits[__FDELT(d)] |= __FDMASK(d))
asm-ia64/posix_types.h:#define	__FD_CLR(d, set)	((set)->fds_bits[__FDELT(d)] &= ~__FDMASK(d))
asm-ia64/posix_types.h:#define	__FD_ISSET(d, set)	(((set)->fds_bits[__FDELT(d)] & __FDMASK(d)) != 0)
asm-ia64/posix_types.h:	fdsetp->fds_bits[_tmp] |= (1UL<<_rem);
asm-ia64/posix_types.h:	fdsetp->fds_bits[_tmp] &= ~(1UL<<_rem);
asm-ia64/posix_types.h:	return (p->fds_bits[_tmp] & (1UL<<_rem)) != 0;
asm-ia64/posix_types.h: * for a 256-bit fd_set)
asm-ia64/posix_types.h:	unsigned long *tmp = p->fds_bits;
asm-ia64/posix_types.h:		i--;
asm-ia64/scatterlist.h: * Modified 1998-1999, 2001-2002
asm-ia64/scatterlist.h: *	David Mosberger-Tang <davidm@hpl.hp.com>, Hewlett-Packard Co
asm-ia64/smplock.h:	if (task->lock_depth >= 0)
asm-ia64/smplock.h: * Re-acquire the kernel lock
asm-ia64/smplock.h:	if (task->lock_depth >= 0)
asm-ia64/smplock.h:	if (!++current->lock_depth)
asm-ia64/smplock.h:	if (--current->lock_depth < 0)
asm-ia64/asmmacro.h: * Copyright (C) 2000-2001 Hewlett-Packard Co
asm-ia64/asmmacro.h: * Copyright (C) 2000-2001 David Mosberger-Tang <davidm@hpl.hp.com>
asm-ia64/numa.h:#define NODEMASK_WORDCOUNT       ((NR_NODES+(BITS_PER_LONG-1))/BITS_PER_LONG)
asm-ia64/numa.h:#define NODE_MASK_NONE   { [0 ... ((NR_NODES+BITS_PER_LONG-1)/BITS_PER_LONG)-1] = 0 }
asm-ia64/page.h: * Copyright (C) 1998, 1999 Hewlett-Packard Co
asm-ia64/page.h: * Copyright (C) 1998, 1999 David Mosberger-Tang <davidm@hpl.hp.com>
asm-ia64/page.h:#define PAGE_MASK		(~(PAGE_SIZE - 1))
asm-ia64/page.h:#define PAGE_ALIGN(addr)	(((addr) + PAGE_SIZE - 1) & PAGE_MASK)
asm-ia64/page.h:# error Unsupported IA-64 HugeTLB Page Size!
asm-ia64/page.h:#define HPAGE_MASK                  (~(HPAGE_SIZE - 1))
asm-ia64/page.h:#define RGN_MAP_LIMIT	((1UL << (4*PAGE_SHIFT - 12)) - PAGE_SIZE)	/* per region addr limit */
asm-ia64/page.h:# define __pa(x)		((x) - PAGE_OFFSET)
asm-ia64/page.h:#define MAP_NR_DENSE(addr)	(((unsigned long) (addr) - PAGE_OFFSET) >> PAGE_SHIFT)
asm-ia64/page.h:#define page_to_phys(page)	((page - mem_map) << PAGE_SHIFT)
asm-ia64/page.h:#define VALID_PAGE(page)	(((page - mem_map) < max_mapnr) && ia64_page_valid(page))
asm-ia64/page.h:		unsigned long off : 61;		/* intra-region offset */
asm-ia64/page.h:#define __va(x)		({ia64_va _v; _v.l = (long) (x); _v.f.reg = -1; _v.p;})
asm-ia64/page.h:#define htlbpage_to_page(x) ((REGION_NUMBER(x) << 61) | (REGION_OFFSET(x) >> (HPAGE_SHIFT-PAGE_SHIFT)))
asm-ia64/page.h:#define HUGETLB_PAGE_ORDER	(HPAGE_SHIFT - PAGE_SHIFT)
asm-ia64/page.h:	double d = size - 1;
asm-ia64/page.h:	order = order - PAGE_SHIFT - 0xffff + 1;
asm-ia64/page.h:   * These are used to make use of C type-checking..
asm-ia64/page.h:					 (((current->thread.flags & IA64_THREAD_XSTACK) != 0)	\
asm-ia64/hdreg.h: *  linux/include/asm-ia64/hdreg.h
asm-ia64/hdreg.h: *  Copyright (C) 1994-1996  Linus Torvalds & authors
asm-ia64/poll.h: * poll(2) bit definitions.  Based on <asm-i386/poll.h>.
asm-ia64/poll.h: *	David Mosberger-Tang <davidm@hpl.hp.com>, Hewlett-Packard Co
asm-ia64/current.h: * Modified 1998-2000
asm-ia64/current.h: *	David Mosberger-Tang <davidm@hpl.hp.com>, Hewlett-Packard Co
asm-ia64/types.h: * application is Linux specific so (user-) name space pollution is
asm-ia64/types.h: * Based on <asm-alpha/types.h>.
asm-ia64/types.h: * Modified 1998-2000
asm-ia64/types.h: *	David Mosberger-Tang <davidm@hpl.hp.com>, Hewlett-Packard Co
asm-ia64/types.h:/* DMA addresses are 64-bits wide, in general.  */
asm-ia64/sembuf.h: * The semid64_ds structure for IA-64 architecture.
asm-ia64/sembuf.h: * - 2 miscellaneous 64-bit values
asm-ia64/system.h: * Copyright (C) 1998-2002 Hewlett-Packard Co
asm-ia64/system.h: *	David Mosberger-Tang <davidm@hpl.hp.com>
asm-ia64/system.h: *   wmb():	Guarantees that all preceding stores to memory-
asm-ia64/system.h: * XXX check on these---I suspect what Linus really wants here is
asm-ia64/system.h:# define IS_IA32_PROCESS(regs)	(ia64_psr(regs)->is != 0)
asm-ia64/system.h: * Disabling access to the fph partition and the debug-register
asm-ia64/system.h:# define PERFMON_IS_SYSWIDE() (local_cpu_data->pfm_syst_info & 0x1)
asm-ia64/system.h:	((t)->thread.flags & (IA64_THREAD_DBG_VALID|IA64_THREAD_PM_VALID)	\
asm-ia64/system.h:	ia64_psr(ia64_task_regs(next))->dfh = !ia64_is_local_fpu_owner(next);			 \
asm-ia64/system.h: * In the SMP case, we save the fph state when context-switching away from a thread that
asm-ia64/system.h: * pick up the state from task->thread.fph, avoiding the complication of having to fetch
asm-ia64/system.h:	if (ia64_psr(ia64_task_regs(prev))->mfh && ia64_is_local_fpu_owner(prev)) {				\
asm-ia64/system.h:		ia64_psr(ia64_task_regs(prev))->mfh = 0;			\
asm-ia64/system.h:		(prev)->thread.flags |= IA64_THREAD_FPH_VALID;			\
asm-ia64/system.h:		__ia64_save_fpu((prev)->thread.fph);				\
asm-ia64/stat.h: *	David Mosberger-Tang <davidm@hpl.hp.com>, Hewlett-Packard Co
asm-ia64/machvec_hpsim.h: * platform's machvec structure.  When compiling a non-generic kernel,
asm-ia64/checksum.h: *	David Mosberger-Tang <davidm@hpl.hp.com>, Hewlett-Packard Co
asm-ia64/checksum.h: * Computes the checksum of the TCP/UDP pseudo-header returns a 16-bit
asm-ia64/checksum.h: * and adds in "sum" (32-bit)
asm-ia64/checksum.h: * returns a 32-bit number suitable for feeding into itself
asm-ia64/checksum.h: * it's best to have buff aligned on a 32-bit boundary
asm-ia64/checksum.h: * Here it is even more important to align src and dst on a 32-bit (or
asm-ia64/checksum.h: * even better 64-bit) boundary.
asm-ia64/checksum.h: * ia-64 we have just one address space, so this is identical to the
asm-ia64/checksum.h: * This routine is used for miscellaneous IP-like checksums, mainly in
asm-ia64/machvec_hpzx1.h: * platform's machvec structure.  When compiling a non-generic kernel,
asm-ia64/termios.h: *	David Mosberger-Tang <davidm@hpl.hp.com>, Hewlett-Packard Co
asm-ia64/termios.h:#define N_IRDA		11	/* Linux IR - http://irda.sourceforge.net/ */
asm-ia64/termios.h:#define N_SMSBLOCK	12	/* SMS block mode - for talking to GSM data cards about SMS msgs */
asm-ia64/termios.h:	get_user(__tmp,&(termio)->x);			\
asm-ia64/termios.h:	*(unsigned short *) &(termios)->x = __tmp;	\
asm-ia64/termios.h:	copy_from_user((termios)->c_cc, (termio)->c_cc, NCC);	\
asm-ia64/termios.h:	put_user((termios)->c_iflag, &(termio)->c_iflag);	\
asm-ia64/termios.h:	put_user((termios)->c_oflag, &(termio)->c_oflag);	\
asm-ia64/termios.h:	put_user((termios)->c_cflag, &(termio)->c_cflag);	\
asm-ia64/termios.h:	put_user((termios)->c_lflag, &(termio)->c_lflag);	\
asm-ia64/termios.h:	put_user((termios)->c_line,  &(termio)->c_line);	\
asm-ia64/termios.h:	copy_to_user((termio)->c_cc, (termios)->c_cc, NCC);	\
asm-ia64/user.h: * linux we use the `trad-core' bfd).  The file contents are as
asm-ia64/user.h: *  data: The data segment follows next.  We use current->end_text to
asm-ia64/user.h: *	current->brk to pick up all of the user variables, plus any memory
asm-ia64/user.h: *	page is demand-zero or if a page is totally unused, we just cover
asm-ia64/user.h: *	current->start_stack, so we round each of these in order to be able
asm-ia64/user.h: *	David Mosberger-Tang <davidm@hpl.hp.com>, Hewlett-Packard Co
asm-ia64/statfs.h: * Based on <asm-i386/statfs.h>.
asm-ia64/statfs.h: *	David Mosberger-Tang <davidm@hpl.hp.com>, Hewlett-Packard Co
asm-ia64/intrinsics.h: * Compiler-dependent intrinsics.
asm-ia64/intrinsics.h: * Copyright (C) 2002-2003 Hewlett-Packard Co
asm-ia64/intrinsics.h: *	David Mosberger-Tang <davidm@hpl.hp.com>
asm-ia64/intrinsics.h:	if ((i) == -16)									\
asm-ia64/intrinsics.h:		IA64_FETCHADD(_tmp, _v, -16, sizeof(*(v)));				\
asm-ia64/intrinsics.h:	else if ((i) == -8)								\
asm-ia64/intrinsics.h:		IA64_FETCHADD(_tmp, _v, -8, sizeof(*(v)));				\
asm-ia64/intrinsics.h:	else if ((i) == -4)								\
asm-ia64/intrinsics.h:		IA64_FETCHADD(_tmp, _v, -4, sizeof(*(v)));				\
asm-ia64/intrinsics.h:	else if ((i) == -2)								\
asm-ia64/intrinsics.h:		IA64_FETCHADD(_tmp, _v, -2, sizeof(*(v)));				\
asm-ia64/intrinsics.h:	else if ((i) == -1)								\
asm-ia64/intrinsics.h:		IA64_FETCHADD(_tmp, _v, -1, sizeof(*(v)));				\
asm-ia64/intrinsics.h:	if (_cmpxchg_bugcheck_count-- <= 0) {					\
asm-ia64/serial.h: * include/asm-ia64/serial.h
asm-ia64/serial.h:#define CONFIG_SERIAL_DETECT_IRQ	/* on IA-64, we always want to autodetect irqs */
asm-ia64/serial.h:	{ 0, BASE_BAUD, -1, 0, STD_COM_FLAGS},		/* ttySx device
asm-ia64/pgtable.h: * the IA-64 page table tree.
asm-ia64/pgtable.h: * This hopefully works with any (fixed) IA-64 page-size, as defined
asm-ia64/pgtable.h: * Copyright (C) 1998-2002 Hewlett-Packard Co
asm-ia64/pgtable.h: *	David Mosberger-Tang <davidm@hpl.hp.com>
asm-ia64/pgtable.h:#define _PAGE_MA_NAT		(0x7 <<  2)	/* not-a-thing attribute */
asm-ia64/pgtable.h:#define _PAGE_PPN_MASK		(((__IA64_UL(1) << IA64_MAX_PHYS_BITS) - 1) & ~0xfffUL)
asm-ia64/pgtable.h: * PGDIR_SHIFT determines what a first-level page table entry can map.
asm-ia64/pgtable.h:#define PGDIR_SHIFT		(PAGE_SHIFT + 2*(PAGE_SHIFT-3))
asm-ia64/pgtable.h:#define PGDIR_MASK		(~(PGDIR_SIZE-1))
asm-ia64/pgtable.h:#define PTRS_PER_PGD		(__IA64_UL(1) << (PAGE_SHIFT-3))
asm-ia64/pgtable.h:#define USER_PTRS_PER_PGD	(5*PTRS_PER_PGD/8)	/* regions 0-4 are user regions */
asm-ia64/pgtable.h: * PMD_SHIFT determines the size of the area a second-level page table
asm-ia64/pgtable.h:#define PMD_SHIFT	(PAGE_SHIFT + (PAGE_SHIFT-3))
asm-ia64/pgtable.h:#define PMD_MASK	(~(PMD_SIZE-1))
asm-ia64/pgtable.h:#define PTRS_PER_PMD	(__IA64_UL(1) << (PAGE_SHIFT-3))
asm-ia64/pgtable.h:#define PTRS_PER_PTE	(__IA64_UL(1) << (PAGE_SHIFT-3))
asm-ia64/pgtable.h: * page-out routines.
asm-ia64/pgtable.h: * In a private shared memory segment, we do a copy-on-write if a task
asm-ia64/pgtable.h:#define __P010	PAGE_READONLY	/* write to priv pg -> copy & make writable */
asm-ia64/pgtable.h:#define __S010	PAGE_SHARED	/* we don't have (and don't need) write-only */
asm-ia64/pgtable.h:	return (addr & (local_cpu_data->unimpl_pa_mask)) == 0;
asm-ia64/pgtable.h: * require a hash-, or multi-level tree-lookup or something of that
asm-ia64/pgtable.h: * XXX Need to implement this for IA-64.
asm-ia64/pgtable.h: * Now come the defines and routines to manage and access the three-level
asm-ia64/pgtable.h: * the PTE in a page table.  Nothing special needs to be on IA-64.
asm-ia64/pgtable.h:#define VMALLOC_END_INIT        (0xa000000000000000 + (1UL << (4*PAGE_SHIFT - 9))) 
asm-ia64/pgtable.h:	pte_val(__pte) = ((page - mem_map) << PAGE_SHIFT) | pgprot_val(pgprot);	\
asm-ia64/pgtable.h:#define pte_write(pte)	((unsigned) (((pte_val(pte) & _PAGE_AR_MASK) >> _PAGE_AR_SHIFT) - 2) <= 4)
asm-ia64/pgtable.h: * Macro to make mark a page protection value as "write-combining".
asm-ia64/pgtable.h: * other bits as well.  Accesses through a write-combining translation
asm-ia64/pgtable.h:	unsigned long l1index = (address >> PGDIR_SHIFT) & ((PTRS_PER_PGD >> 3) - 1);
asm-ia64/pgtable.h:	return (region << (PAGE_SHIFT - 6)) | l1index;
asm-ia64/pgtable.h:/* The offset in the 1-level directory is given by the 3 region bits
asm-ia64/pgtable.h:   (61..63) and the seven level-1 bits (33-39).  */
asm-ia64/pgtable.h:	return mm->pgd + pgd_index(address);
asm-ia64/pgtable.h:	(init_mm.pgd + (((addr) >> PGDIR_SHIFT) & (PTRS_PER_PGD - 1)))
asm-ia64/pgtable.h:/* Find an entry in the second-level page table.. */
asm-ia64/pgtable.h:	((pmd_t *) pgd_page(*(dir)) + (((addr) >> PMD_SHIFT) & (PTRS_PER_PMD - 1)))
asm-ia64/pgtable.h:/* Find an entry in the third-level page table.. */
asm-ia64/pgtable.h:	((pte_t *) pmd_page(*(dir)) + (((addr) >> PAGE_SHIFT) & (PTRS_PER_PTE - 1)))
asm-ia64/pgtable.h: * for zero-mapped memory areas etc..
asm-ia64/pgtable.h:#define HUGETLB_PGDIR_SHIFT	(HPAGE_SHIFT + 2*(PAGE_SHIFT-3))
asm-ia64/pgtable.h:#define HUGETLB_PGDIR_MASK	(~(HUGETLB_PGDIR_SIZE-1))
asm-ia64/pgtable.h: * Identity-mapped regions use a large page size.  We'll call such large pages
asm-ia64/pgtable.h:#define KERNEL_TR_PAGE_NUM	((KERNEL_START - PAGE_OFFSET) / KERNEL_TR_PAGE_SIZE)
asm-ia64/unaligned.h: * The main single-value unaligned transfer routines.
asm-ia64/unaligned.h: * Based on <asm-alpha/unaligned.h>.
asm-ia64/unaligned.h: * Copyright (C) 1998, 1999, 2003 Hewlett-Packard Co
asm-ia64/unaligned.h: *	David Mosberger-Tang <davidm@hpl.hp.com>
asm-ia64/unaligned.h:	return ptr->x;
asm-ia64/unaligned.h:	return ptr->x;
asm-ia64/unaligned.h:	return ptr->x;
asm-ia64/unaligned.h:	ptr->x = val;
asm-ia64/unaligned.h:	ptr->x = val;
asm-ia64/unaligned.h:	ptr->x = val;
asm-ia64/mca_asm.h: * Copyright (C) 2000 Hewlett-Packard Co.
asm-ia64/mca_asm.h: * Copyright (C) 2000 David Mosberger-Tang <davidm@hpl.hp.com>
asm-ia64/mca_asm.h:	dep	temp1 = -1, temp1, PSR_MC, 1;						\
asm-ia64/mca_asm.h: *		lower 32-bits of old psr.(Also the old psr has the data and
asm-ia64/mca_asm.h: *	+-----------------------+
asm-ia64/mca_asm.h: *	|       [BSP - BSPSTORE]|
asm-ia64/mca_asm.h: *	+-----------------------+
asm-ia64/mca_asm.h: *	+-----------------------+
asm-ia64/mca_asm.h: *	+-----------------------+
asm-ia64/mca_asm.h: *	+-----------------------+
asm-ia64/mca_asm.h: *	+-----------------------+
asm-ia64/mca_asm.h: *	+-----------------------+ <-------- Bottom of new stack frame
asm-ia64/mca_asm.h: * NOTE: Look at section 6.11 in Intel IA-64 Architecture Software Developer's
asm-ia64/mca_asm.h: *	1. Allocate a zero-sized frame
asm-ia64/mca_asm.h:	add     p_stackframe=-rse_ndirty_words_offset+rse_bspstore_offset,p_stackframe;;\
asm-ia64/mca_asm.h:	add     p_stackframe=-rse_bspstore_offset+rse_rnat_offset,p_stackframe;;\
asm-ia64/mca_asm.h:	add     p_stackframe=-rse_rnat_offset+rse_pfs_offset,p_stackframe;;	\
asm-ia64/mca_asm.h:	add     p_stackframe=-rse_pfs_offset+rse_ifs_offset,p_stackframe;;	\
asm-ia64/mca_asm.h:	add     p_stackframe=-rse_ifs_offset+rse_rsc_offset,p_stackframe;;	\
asm-ia64/param.h: * Based on <asm-i386/param.h>.
asm-ia64/param.h: * Modified 1998, 1999, 2002-2003
asm-ia64/param.h: *    David Mosberger-Tang <davidm@hpl.hp.com>, Hewlett-Packard Co
asm-ia64/param.h:# define NOGROUP	(-1)
asm-ia64/cache.h: * Copyright (C) 1998-2000 Hewlett-Packard Co
asm-ia64/cache.h: *	David Mosberger-Tang <davidm@hpl.hp.com>
asm-ia64/cache.h:   * uni-processor:
asm-ia64/siginfo.h: * Based on <asm-i386/siginfo.h>.
asm-ia64/siginfo.h: * Modified 1998-2002
asm-ia64/siginfo.h: *	David Mosberger-Tang <davidm@hpl.hp.com>, Hewlett-Packard Co
asm-ia64/siginfo.h:#define SI_PAD_SIZE	((SI_MAX_SIZE/sizeof(int)) - 4)
asm-ia64/siginfo.h: * si_code is non-zero and __ISR_VALID is set in si_flags.
asm-ia64/siginfo.h: * Positive values for kernel-generated signals.
asm-ia64/siginfo.h:#define SI_QUEUE	(-1)		/* sent by sigqueue */
asm-ia64/siginfo.h:#define SI_TIMER __SI_CODE(__SI_TIMER,-2) /* sent by timer expiration */
asm-ia64/siginfo.h:#define SI_MESGQ	(-3)		/* sent by real time mesq state change */
asm-ia64/siginfo.h:#define SI_ASYNCIO	(-4)		/* sent by AIO completion */
asm-ia64/siginfo.h:#define SI_SIGIO	(-5)		/* sent by queued SIGIO */
asm-ia64/siginfo.h:#define SI_TKILL	(-6)		/* sent by tkill system call */
asm-ia64/siginfo.h:#define SI_FROMUSER(siptr)	((siptr)->si_code <= 0)
asm-ia64/siginfo.h:#define SI_FROMKERNEL(siptr)	((siptr)->si_code > 0)
asm-ia64/siginfo.h:#define __ILL_BNDMOD	(__SI_FAULT|11)	/* bundle-update (modification) in progress */
asm-ia64/siginfo.h:#define BUS_ADRERR	(__SI_FAULT|2)	/* non-existant physical address */
asm-ia64/siginfo.h:#define SIGEV_PAD_SIZE	((SIGEV_MAX_SIZE/sizeof(int)) - 4)
asm-ia64/siginfo.h:	if (from->si_code < 0)
asm-ia64/siginfo.h:		memcpy(to, from, 4*sizeof(int) + sizeof(from->_sifields._sigprof));
asm-ia64/sockios.h: * Socket-level I/O control calls.
asm-ia64/sockios.h: * Based on <asm-i386/sockios.h>.
asm-ia64/sockios.h: *	David Mosberger-Tang <davidm@hpl.hp.com>, Hewlett-Packard Co
asm-ia64/ptrace_offsets.h: * Copyright (C) 1999 Hewlett-Packard Co
asm-ia64/ptrace_offsets.h: * Copyright (C) 1999 David Mosberger-Tang <davidm@hpl.hp.com>
asm-ia64/ptrace_offsets.h: *		struct ia64_fpreg fph[96];		// f32-f127
asm-ia64/ptrace_offsets.h: *		struct ia64_fpreg f2;			// f2-f5
asm-ia64/ptrace_offsets.h: *		struct ia64_fpreg f10;			// f10-f31
asm-ia64/ptrace_offsets.h: *		unsigned long r4;			// r4-r7
asm-ia64/ptrace_offsets.h: *		unsigned long b1;			// b1-b5
asm-ia64/keyboard.h: * Copyright (C) 1998, 1999, 2001 Hewlett-Packard Co
asm-ia64/keyboard.h: * Copyright (C) 1998, 1999, 2001 David Mosberger-Tang <davidm@hpl.hp.com>
asm-ia64/a.out.h: * Modified 1998-2000, 2002
asm-ia64/a.out.h: *	David Mosberger-Tang <davidm@hpl.hp.com>, Hewlett-Packard Co.
asm-ia64/ioctl.h: * Based on <asm-i386/ioctl.h>.
asm-ia64/ioctl.h: *	David Mosberger-Tang <davidm@hpl.hp.com>, Hewlett-Packard Co
asm-ia64/ioctl.h: * NOTE: This limits the max parameter size to 16kB -1 !
asm-ia64/ioctl.h:#define _IOC_NRMASK	((1 << _IOC_NRBITS)-1)
asm-ia64/ioctl.h:#define _IOC_TYPEMASK	((1 << _IOC_TYPEBITS)-1)
asm-ia64/ioctl.h:#define _IOC_SIZEMASK	((1 << _IOC_SIZEBITS)-1)
asm-ia64/ioctl.h:#define _IOC_DIRMASK	((1 << _IOC_DIRBITS)-1)
asm-ia64/string.h: * Copyright (C) 1998-2000, 2002 Hewlett-Packard Co
asm-ia64/string.h: *	David Mosberger-Tang <davidm@hpl.hp.com>
asm-ia64/string.h:#include <linux/config.h>	/* remove this once we remove the A-step workaround... */
asm-ia64/break.h: * IA-64 Linux break numbers.
asm-ia64/break.h: * Copyright (C) 1999 Hewlett-Packard Co
asm-ia64/break.h: * Copyright (C) 1999 David Mosberger-Tang <davidm@hpl.hp.com>
asm-ia64/break.h: * OS-specific debug break numbers:
asm-ia64/break.h: * OS-specific break numbers:
asm-ia64/ioctls.h: * Based on <asm-i386/ioctls.h>
asm-ia64/ioctls.h: *	David Mosberger-Tang <davidm@hpl.hp.com>, Hewlett-Packard Co
asm-ia64/ioctls.h:#define TIOCGPTN	_IOR('T',0x30, unsigned int) /* Get Pty Number (of pty-mux device) */
asm-ia64/msgbuf.h: * The msqid64_ds structure for IA-64 architecture.
asm-ia64/msgbuf.h: * - 2 miscellaneous 64-bit values
asm-ia64/nodedata.h: * Copyright (c) 2002 Kimio Suganuma <k-suganuma@da.jp.nec.com>
asm-ia64/nodedata.h:	 * The fields are read-only (after boot). They contain pointers to various structures
asm-ia64/nodedata.h:	 * off-node references.
asm-ia64/nodedata.h:#define local_node_data		(local_cpu_data->node_data)
asm-ia64/nodedata.h:#define node_data(node)	(local_node_data->node_data_ptrs[node])
asm-ia64/nodedata.h: * NODE_DATA 	- should be used in all code not related to system
asm-ia64/nodedata.h:#define NODE_DATA(nid)		(local_node_data->pg_data_ptrs[nid])
asm-ia64/machvec.h: * Machine vector for IA-64.
asm-ia64/machvec.h: * Copyright (C) 1999-2001 Hewlett-Packard Co.
asm-ia64/machvec.h: *	David Mosberger-Tang <davidm@hpl.hp.com>
asm-ia64/machvec.h:/* PCI-DMA interface: */
asm-ia64/machvec.h: * IA-64 Architecture Software Developer's Manual).  Unfortunately,
asm-ia64/machvec.h:#  error Unknown configuration.  Update asm-ia64/machvec.h.
asm-ia64/socket.h: * Based on <asm-i386/socket.h>.
asm-ia64/socket.h: * Modified 1998-2000
asm-ia64/socket.h: *	David Mosberger-Tang <davidm@hpl.hp.com>, Hewlett-Packard Co
asm-ia64/socket.h:/* Security levels - as per NRL IPv6 - don't actually do anything */
asm-ia64/socket.h:/* Nast libc5 fixup - bletch */
asm-ia64/socket.h:#define SOCK_RDM	4		/* reliably-delivered message	*/
asm-m68k/q40_master.h:#define Q40_RTC_MNTH        (*(volatile unsigned char *)(Q40_RTC_BASE-4))
asm-m68k/q40_master.h:#define Q40_RTC_DATE        (*(volatile unsigned char *)(Q40_RTC_BASE-8))
asm-m68k/q40_master.h:#define Q40_RTC_DOW         (*(volatile unsigned char *)(Q40_RTC_BASE-12))
asm-m68k/q40_master.h:#define Q40_RTC_HOUR        (*(volatile unsigned char *)(Q40_RTC_BASE-16))
asm-m68k/q40_master.h:#define Q40_RTC_MINS        (*(volatile unsigned char *)(Q40_RTC_BASE-20))
asm-m68k/q40_master.h:#define Q40_RTC_SECS        (*(volatile unsigned char *)(Q40_RTC_BASE-24))
asm-m68k/q40_master.h:#define Q40_RTC_CTRL        (*(volatile unsigned char *)(Q40_RTC_BASE-28))
asm-m68k/io.h: * linux/include/asm-m68k/io.h 
asm-m68k/io.h: * 4/1/00 RZ: - rewritten to avoid clashes between ISA/PCI and other
asm-m68k/io.h: *            - added Q40 support
asm-m68k/io.h: *            - added skeleton for GG-II and Amiga PCMCIA
asm-m68k/io.h: * 2/3/01 RZ: - moved a few more defs into raw_io.h
asm-m68k/io.h:/* GG-II Zorro to ISA bridge */
asm-m68k/io.h:/* those can be defined for both ISA and PCI - it won't work though */
asm-m68k/intersil.h:#define intersil_clear() (void)intersil_clock->int_reg
asm-m68k/swim_iop.h:#define	gcrOnMFMErr	-400	/* GCR (400/800K) on HD media */
asm-m68k/swim_iop.h:#define	verErr		-84	/* verify failed */
asm-m68k/swim_iop.h:#define	fmt2Err		-83	/* cant get enough sync during format */
asm-m68k/swim_iop.h:#define	fmt1Err		-82	/* can't find sector 0 after track format */
asm-m68k/swim_iop.h:#define	sectNFErr	-81	/* can't find sector */
asm-m68k/swim_iop.h:#define	seekErr		-80	/* drive error during seek */
asm-m68k/swim_iop.h:#define	spdAdjErr	-79	/* can't set drive speed */
asm-m68k/swim_iop.h:#define	twoSideErr	-78	/* drive is single-sided */
asm-m68k/swim_iop.h:#define	initIWMErr	-77	/* error during initialization */
asm-m68k/swim_iop.h:#define	tk0badErr	-76	/* track zero is bad */
asm-m68k/swim_iop.h:#define	cantStepErr	-75	/* drive error during step */
asm-m68k/swim_iop.h:#define	wrUnderrun	-74	/* write underrun occurred */
asm-m68k/swim_iop.h:#define	badDBtSlp	-73	/* bad data bitslip marks */
asm-m68k/swim_iop.h:#define	badDCksum	-72	/* bad data checksum */
asm-m68k/swim_iop.h:#define	noDtaMkErr	-71	/* can't find data mark */
asm-m68k/swim_iop.h:#define	badBtSlpErr	-70	/* bad address bitslip marks */
asm-m68k/swim_iop.h:#define	badCksmErr	-69	/* bad address-mark checksum */
asm-m68k/swim_iop.h:#define	dataVerErr	-68	/* read-verify failed */
asm-m68k/swim_iop.h:#define	noAdrMkErr	-67	/* can't find an address mark */
asm-m68k/swim_iop.h:#define	noNybErr	-66	/* no nybbles? disk is probably degaussed */
asm-m68k/swim_iop.h:#define	offLinErr	-65	/* no disk in drive */
asm-m68k/swim_iop.h:#define	noDriveErr	-64	/* drive isn't connected */
asm-m68k/swim_iop.h:#define	nsDrvErr	-56	/* no such drive */
asm-m68k/swim_iop.h:#define	paramErr	-50	/* bad positioning information */
asm-m68k/swim_iop.h:#define	wPrErr		-44	/* write protected */
asm-m68k/swim_iop.h:#define	openErr		-23	/* already initialized */
asm-m68k/swim_iop.h:	__u8	num_sides;	/* 0x80 if two-sided format supported     */
asm-m68k/swim_iop.h:	__u8	two_sided;	/* 0xff if two-sided format diskette      */
asm-m68k/swim_iop.h:	__u8	install;	/* +1 = install, -1 = remove, 0 = neither */
asm-m68k/atomic.h:#define atomic_read(v)		((v)->counter)
asm-m68k/atomic.h:#define atomic_set(v, i)	(((v)->counter) = i)
asm-m68k/adb_mouse.h: * linux/include/asm-m68k/adb_mouse.h
asm-m68k/adb_mouse.h: * 27-10-97 Michael Schmitz
asm-m68k/atafdreg.h:#define FDCCMD_RESTORE  (0x00)   /*  -                   */
asm-m68k/atafdreg.h:#define FDCCMD_STOT     (0x60)   /*  -                   */
asm-m68k/atafdreg.h:#define FDCCMD_RDSEC    (0x80)   /*  -   TYP 2 Commands  */
asm-m68k/atafdreg.h:#define FDCCMD_WRSEC    (0xa0)   /*  -          "        */
asm-m68k/atafdreg.h:#define FDCCMD_RDADR    (0xc0)   /*  -                   */
asm-m68k/atafdreg.h:#define FDCCMD_WRTRA    (0xf0)   /*  -                   */
asm-m68k/atafdreg.h:#define FDCCMD_FORCI    (0xd0)   /*  -   TYP 4 Command   */
asm-m68k/atafdreg.h:#define FDCCMDADD_H     (0x08)   /* wait for spin-up */
asm-m68k/atafdreg.h:/* PSG Port A Bit Nr 0 .. Side Sel .. 0 -> Side 1  1 -> Side 2 */
asm-m68k/delay.h: * Delay routines, using a pre-computed "loops_per_jiffy" value.
asm-m68k/ipcbuf.h: * - 32-bit mode_t and seq
asm-m68k/ipcbuf.h: * - 2 miscellaneous 32-bit values
asm-m68k/q40_keyboard.h: *  linux/include/asm-m68k/q40_keyboard.h
asm-m68k/parport.h: * parport.h: platform-specific PC-style parport initialisation
asm-m68k/shmbuf.h: * - 64-bit time_t to solve y2038 problem
asm-m68k/shmbuf.h: * - 2 miscellaneous 32-bit values
asm-m68k/bitops.h: * They use the standard big-endian m680x0 bit ordering.
asm-m68k/bitops.h:		if (--size == 0)
asm-m68k/bitops.h:			return (p - addr) << 5;
asm-m68k/bitops.h:	num = ~*--p;
asm-m68k/bitops.h:			      : "=d" (res) : "d" (num & -num));
asm-m68k/bitops.h:	return ((p - addr) << 5) + (res ^ 31);
asm-m68k/bitops.h:				      : "=d" (res) : "d" (num & -num));
asm-m68k/bitops.h:                set = 32 - bit;
asm-m68k/bitops.h:	res = find_first_zero_bit (p, size - 32 * (p - addr));
asm-m68k/bitops.h:			      : "=d" (res) : "d" (~word & -~word));
asm-m68k/bitops.h:	__asm__ __volatile__("bfffo %1{#0:#0},%0" : "=d" (cnt) : "dm" (x & -x));
asm-m68k/bitops.h:	return 32 - cnt;
asm-m68k/bitops.h: * of bits set) of a N-bit word
asm-m68k/bitops.h:		if (--size == 0)
asm-m68k/bitops.h:			return (p - addr) << 4;
asm-m68k/bitops.h:	num = ~*--p;
asm-m68k/bitops.h:			      : "=d" (res) : "d" (num & -num));
asm-m68k/bitops.h:	return ((p - addr) << 4) + (res ^ 31);
asm-m68k/bitops.h:		if (--size == 0)
asm-m68k/bitops.h:			return (p - addr) << 5;
asm-m68k/bitops.h:	--p;
asm-m68k/bitops.h:	return (p - addr) * 32 + res;
asm-m68k/bitops.h:				return (p - addr) * 32 + res;
asm-m68k/bitops.h:	res = ext2_find_first_zero_bit (p, size - 32 * (p - addr));
asm-m68k/bitops.h:	return (p - addr) * 32 + res;
asm-m68k/amipcmcia.h:** asm-m68k/pcmcia.h -- Amiga Linux PCMCIA Definitions
asm-m68k/resource.h:#define RLIMIT_MEMLOCK	8		/* max locked-in-memory address space */
asm-m68k/ptrace.h:#define user_mode(regs) (!((regs)->sr & PS_S))
asm-m68k/ptrace.h:#define instruction_pointer(regs) ((regs)->pc)
asm-m68k/pgalloc.h:	if (mm == current->mm)
asm-m68k/pgalloc.h:	if (mm == current->mm)
asm-m68k/pgalloc.h:	if (vma->vm_mm == current->mm)
asm-m68k/pgalloc.h:		short n = (endaddr - address + PAGE_SIZE - 1) / PAGE_SIZE;
asm-m68k/pgalloc.h:		while (--n >= 0) {
asm-m68k/unistd.h:/* user-visible error numbers are in the range -1 - -122: see
asm-m68k/unistd.h:   <asm-m68k/errno.h> */
asm-m68k/unistd.h:	if ((unsigned long)(res) >= (unsigned long)(-125)) { \
asm-m68k/unistd.h:		int __err = -(res); \
asm-m68k/unistd.h:		res = -1; \
asm-m68k/unistd.h: * we need this inline - forking from kernel space will result
asm-m68k/unistd.h: * calls - which means inline code for fork too, as otherwise we
asm-m68k/unistd.h:	return waitpid(-1,wait_stat,0);
asm-m68k/math-emu.h:/* quotient byte, assumes big-endian, of course */
asm-m68k/math-emu.h:		__count--;				\
asm-m68k/math-emu.h:#define FPDATA		((struct fp_data *)current->thread.fp)
asm-m68k/math-emu.h:	movestack	(\nr-1),\arg2,\arg3,\arg4,\arg5
asm-m68k/math-emu.h:	move.l	\arg1,-(%sp)
asm-m68k/math-emu.h:.macro	printf	bit=-1,string,nr=0,arg1,arg2,arg3,arg4,arg5
asm-m68k/math-emu.h:	movem.l	%d0/%d1/%a0/%a1,-(%sp)
asm-m68k/math-emu.h:	btst	%d0,fp_debugprint+((31-\bit)/8)
asm-m68k/math-emu.h:	btst	#\bit,fp_debugprint+((31-\bit)/8)
asm-m68k/math-emu.h:	movem.l	%d0/%a0,-(%sp)
asm-m68k/math-emu.h:	moveq	#'-',%d0
asm-m68k/elf.h:#define elf_check_arch(x) ((x)->e_machine == EM_68K)
asm-m68k/elf.h:#define ELF_PLAT_INIT(_r, load_addr)	_r->a1 = 0
asm-m68k/elf.h:	pr_reg[0] = regs->d1;						\
asm-m68k/elf.h:	pr_reg[1] = regs->d2;						\
asm-m68k/elf.h:	pr_reg[2] = regs->d3;						\
asm-m68k/elf.h:	pr_reg[3] = regs->d4;						\
asm-m68k/elf.h:	pr_reg[4] = regs->d5;						\
asm-m68k/elf.h:	pr_reg[7] = regs->a0;						\
asm-m68k/elf.h:	pr_reg[8] = regs->a1;						\
asm-m68k/elf.h:	pr_reg[9] = regs->a2;						\
asm-m68k/elf.h:	pr_reg[14] = regs->d0;						\
asm-m68k/elf.h:	pr_reg[16] = regs->orig_d0;					\
asm-m68k/elf.h:	pr_reg[17] = regs->sr;						\
asm-m68k/elf.h:	pr_reg[18] = regs->pc;						\
asm-m68k/elf.h:	pr_reg[19] = (regs->format << 12) | regs->vector;		\
asm-m68k/elf.h:	  struct switch_stack *sw = ((struct switch_stack *)regs) - 1;	\
asm-m68k/elf.h:	  pr_reg[5] = sw->d6;						\
asm-m68k/elf.h:	  pr_reg[6] = sw->d7;						\
asm-m68k/elf.h:	  pr_reg[10] = sw->a3;						\
asm-m68k/elf.h:	  pr_reg[11] = sw->a4;						\
asm-m68k/elf.h:	  pr_reg[12] = sw->a5;						\
asm-m68k/elf.h:	  pr_reg[13] = sw->a6;						\
asm-m68k/cachectl.h:#define FLUSH_SCOPE_ALL     3	/* Flush the whole cache -- superuser only */
asm-m68k/ide.h: *  linux/include/asm-m68k/ide.h
asm-m68k/ide.h: *  Copyright (C) 1994-1996  Linus Torvalds & authors
asm-m68k/ide.h: *  - Bjoern Brauel
asm-m68k/ide.h: *  - Kars de Jong
asm-m68k/ide.h: *  - Torsten Ebeling
asm-m68k/ide.h: *  - Dwight Engen
asm-m68k/ide.h: *  - Thorsten Floeck
asm-m68k/ide.h: *  - Roman Hodek
asm-m68k/ide.h: *  - Guenther Kelleter
asm-m68k/ide.h: *  - Chris Lawrence
asm-m68k/ide.h: *  - Michael Rausch
asm-m68k/ide.h: *  - Christian Sauer
asm-m68k/ide.h: *  - Michael Schmitz
asm-m68k/ide.h: *  - Jes Soerensen
asm-m68k/ide.h: *  - Michael Thurm
asm-m68k/ide.h: *  - Geert Uytterhoeven
asm-m68k/ide.h: * Get rid of defs from io.h - ide has its private and conflicting versions
asm-m68k/ide.h:				panic( "Falcon IDE hasn't ST-DMA lock in interrupt" );
asm-m68k/ide.h:#define ide_ack_intr(hwif)	((hwif)->hw.ack_intr ? (hwif)->hw.ack_intr(hwif) : 1)
asm-m68k/irq.h: * General interrupt sources are the level 1-7.
asm-m68k/irq.h:#define IRQ7		(7)	/* level 7 interrupt (non-maskable) */
asm-m68k/irq.h: * The IRQ_MACHSPEC bit is now gone - the only thing it did was to
asm-m68k/irq.h: * we save some unnecessary overhead at run-time. 
asm-m68k/irq.h: *                                                      01/11/97 - Jes
asm-m68k/irq.h: * various flags for request_irq() - the Amiga now uses the standard
asm-m68k/irq.h: * mechanism like all other architectures - SA_INTERRUPT and SA_SHIRQ
asm-m68k/pci.h: * asm-m68k/pci_m68k.h - m68k specific PCI declarations.
asm-m68k/shm.h:   bits 0-1 (PAGE_PRESENT) is  = 0
asm-m68k/shm.h:   bit 31 (SHM_READ_ONLY) flag whether the page belongs to a read-only attach
asm-m68k/shm.h:   others are reduced by 2. --m */
asm-m68k/shm.h:#define SHM_ID_MASK	((1<<_SHM_ID_BITS)-1)
asm-m68k/shm.h:#define SHM_IDX_MASK	((1<<_SHM_IDX_BITS)-1)
asm-m68k/rtc.h:/* asm-m68k/rtc.h
asm-m68k/rtc.h:#define RTC_UIE 0x10		/* update-finished interrupt enable */
asm-m68k/rtc.h:#define RTC_SQWE 0x08		/* enable square-wave output */
asm-m68k/rtc.h:#define RTC_24H 0x02		/* 24 hour mode - else hours bit 7 means pm */
asm-m68k/rtc.h:#define RTC_DST_EN 0x01	        /* auto switch DST - works f. USA only */
asm-m68k/rtc.h:	 * by the RTC when initially set to a non-zero value.
asm-m68k/rtc.h:		return -EINVAL;
asm-m68k/rtc.h:		return -EINVAL;
asm-m68k/tlb.h:#include <asm-generic/tlb.h>
asm-m68k/xor.h:#include <asm-generic/xor.h>
asm-m68k/amigahw.h:** asm-m68k/amigahw.h -- This header defines some macros and pointers for
asm-m68k/amigahw.h:#define ZTWO_PADDR(x) (((unsigned long)(x))-zTwoBase)
asm-m68k/amigahw.h:  unsigned int  :28, cntrl1:4;	/* control-byte 1 */
asm-m68k/amigahw.h:  unsigned int  :28, cntrl2:4;	/* control-byte 2 */  
asm-m68k/amigahw.h:  unsigned int  :28, cntrl3:4;	/* control-byte 3 */
asm-m68k/amigahw.h:  unsigned int  :28, cntrl1:4;	/* control-byte 1 */
asm-m68k/amigahw.h:  unsigned int  :28, cntrl2:4;	/* control-byte 2 */  
asm-m68k/amigahw.h:  unsigned int  :28, cntrl3:4;	/* control-byte 3 */
asm-m68k/signal.h:#define SIGRTMAX	(_NSIG-1)
asm-m68k/signal.h: * SA_INTERRUPT is a no-op, but left due to historical reasons. Use the
asm-m68k/signal.h:#define SA_INTERRUPT	0x20000000 /* dummy -- ignored */
asm-m68k/signal.h:#define SIG_ERR	((__sighandler_t)-1)	/* error return from signal */
asm-m68k/signal.h:	__asm__("bfset %0{%1,#1}" : "=m" (*set) : "id" ((_sig - 1) ^ 31)
asm-m68k/signal.h:	__asm__("bfclr %0{%1,#1}" : "=m"(*set) : "id"((_sig - 1) ^ 31)
asm-m68k/signal.h:	unsigned long sig = _sig - 1;
asm-m68k/signal.h:	return 1 & (set->sig[sig / _NSIG_BPW] >> (sig % _NSIG_BPW));
asm-m68k/signal.h:		: "=d"(ret) : "m"(*set), "id"((_sig-1) ^ 31));
asm-m68k/signal.h:#define sigmask(sig)	(1UL << ((sig) - 1))
asm-m68k/signal.h:	__asm__("bfffo %1{#0,#0},%0" : "=d"(word) : "d"(word & -word) : "cc");
asm-m68k/virtconvert.h:	return (unsigned long)vaddr - PAGE_OFFSET + m68k_memory[0].addr;
asm-m68k/virtconvert.h:	return (void *)(paddr - m68k_memory[0].addr + PAGE_OFFSET);
asm-m68k/virtconvert.h:#define bus_to_virt(a) (phys_to_virt((a) - (MACH_IS_HADES ? 0x80000000 : 0)))
asm-m68k/virtconvert.h:#define __page_address(page)      (PAGE_OFFSET + (((page) - mem_map) << PAGE_SHIFT))
asm-m68k/apollodma.h: *  controller 1: channels 0-3, byte operations, ports 00-1F
asm-m68k/apollodma.h: *  controller 2: channels 4-7, word operations, ports C0-DF
asm-m68k/apollodma.h: *  - ALL registers are 8 bits only, regardless of transfer size
asm-m68k/apollodma.h: *  - channel 4 is not used - cascades 1 into 2.
asm-m68k/apollodma.h: *  - channels 0-3 are byte - addresses/counts are for physical bytes
asm-m68k/apollodma.h: *  - channels 5-7 are word - addresses/counts are for physical words
asm-m68k/apollodma.h: *  - transfers must not cross physical 64K (0-3) or 128K (5-7) boundaries
asm-m68k/apollodma.h: *  - transfer count loaded to registers is 1 less than actual count
asm-m68k/apollodma.h: *  - controller 2 offsets are all even (2x offsets for controller 1)
asm-m68k/apollodma.h: *  - page registers for 5-7 don't use data bit 0, represent 128K pages
asm-m68k/apollodma.h: *  - page registers for 0-3 use bit 0, represent 64K pages
asm-m68k/apollodma.h: *  Address mapping for channels 0-3:
asm-m68k/apollodma.h: *  Address mapping for channels 5-7:
asm-m68k/apollodma.h: * Again, channels 5-7 transfer _physical_ words (16 bits), so addresses
asm-m68k/apollodma.h: * and counts _must_ be word-aligned (the lowest address bit is _ignored_ at
asm-m68k/apollodma.h: * the hardware level, so odd-byte transfers aren't possible).
asm-m68k/apollodma.h: * count - 1 : 64K => 0xFFFF, 1 => 0x0000.  Thus, count is always 1 or more,
asm-m68k/apollodma.h: * and up to 128K bytes may be transferred on channels 5-7 in one operation. 
asm-m68k/apollodma.h:#define DMA1_MASK_REG		(IO_DMA1_BASE+0x0A) /* single-channel mask (w) */
asm-m68k/apollodma.h:#define DMA1_CLEAR_FF_REG	(IO_DMA1_BASE+0x0C) /* clear pointer flip-flop (w) */
asm-m68k/apollodma.h:#define DMA1_MASK_ALL_REG       (IO_DMA1_BASE+0x0F) /* all-channels mask (w) */
asm-m68k/apollodma.h:#define DMA2_MASK_REG		(IO_DMA2_BASE+0x14) /* single-channel mask (w) */
asm-m68k/apollodma.h:#define DMA2_CLEAR_FF_REG	(IO_DMA2_BASE+0x18) /* clear pointer flip-flop (w) */
asm-m68k/apollodma.h:#define DMA2_MASK_ALL_REG       (IO_DMA2_BASE+0x1E) /* all-channels mask (w) */
asm-m68k/apollodma.h:#define DMA_MODE_CASCADE 0xC0   /* pass thru DREQ->HRQ, DACK<-HLDA only */
asm-m68k/apollodma.h: * After that, keep track of it. :-)
asm-m68k/apollodma.h: * --- In order to do that, the DMA routines below should ---
asm-m68k/apollodma.h: * --- only be used while holding the DMA lock ! ---
asm-m68k/apollodma.h: * Assumes dma flip-flop is clear.
asm-m68k/apollodma.h: * NOTE 2: "count" represents _bytes_ and must be even for channels 5-7.
asm-m68k/apollodma.h:        count--;
asm-m68k/apollodma.h: * Assumes DMA flip-flop is clear.
asm-m68k/apollodma.h:	/* using short to get 16-bit wrap around */
asm-m68k/blinken.h:** asm/blinken.h -- m68k blinkenlights support (currently hp300 only)
asm-m68k/setup.h:** asm/setup.h -- Definition of the Linux/m68k setup information
asm-m68k/setup.h:#define FPUB_SUNFPA    4                       /* Sun-3 FPA */
asm-m68k/setup.h:#define MMUB_SUN3      5                       /* Custom Sun-3 */
asm-m68k/hardirq.h:#define irq_exit(cpu)		(local_irq_count(cpu)--)
asm-m68k/processor.h: * include/asm-m68k/processor.h
asm-m68k/processor.h:	regs->pc = pc;
asm-m68k/processor.h:	regs->sr &= ~0x2000;
asm-m68k/processor.h:	struct switch_stack *sw = (struct switch_stack *)t->ksp;
asm-m68k/processor.h:	if (sw->retpc > (unsigned long)scheduling_functions_start_here &&
asm-m68k/processor.h:	    sw->retpc < (unsigned long)scheduling_functions_end_here)
asm-m68k/processor.h:		return ((unsigned long *)sw->a6)[1];
asm-m68k/processor.h:		return sw->retpc;
asm-m68k/processor.h:	if ((tsk)->thread.esp0 > PAGE_SIZE && \
asm-m68k/processor.h:	    (VALID_PAGE(virt_to_page((tsk)->thread.esp0)))) \
asm-m68k/processor.h:	      eip = ((struct pt_regs *) (tsk)->thread.esp0)->pc; \
asm-m68k/processor.h:#define	KSTK_ESP(tsk)	((tsk) == current ? rdusp() : (tsk)->thread.usp)
asm-m68k/processor.h:#define get_task_struct(tsk)      atomic_inc(&virt_to_page(tsk)->count)
asm-m68k/linux_logo.h: * include/asm-m68k/linux_logo.h: This is a linux logo
asm-m68k/machw.h:** linux/machw.h -- This header defines some macros and pointers for
asm-m68k/machw.h:#define VIDEOMEMMASK	(-4096*1024)
asm-m68k/mmu_context.h:	mm->context = virt_to_phys(mm->pgd);
asm-m68k/mmu_context.h:		0x80000000 | _PAGE_TABLE, mm->context
asm-m68k/mmu_context.h:	/* Switch the root pointer. For a 030-only kernel,
asm-m68k/mmu_context.h:	asm volatile ("movec %0,%%urp" : : "r" (mm->context));
asm-m68k/mmu_context.h:	next_mm->context = virt_to_phys(next_mm->pgd);
asm-m68k/mmu_context.h:	mm->context = SUN3_INVALID_CONTEXT;
asm-m68k/mmu_context.h:	if(mm->context == SUN3_INVALID_CONTEXT)
asm-m68k/mmu_context.h:		mm->context = get_free_context(mm);
asm-m68k/mmu_context.h:	if(mm->context != SUN3_INVALID_CONTEXT)
asm-m68k/mmu_context.h:		clear_context(mm->context);
asm-m68k/mmu_context.h:	sun3_put_context(mm->context);
asm-m68k/mmu_context.h:	activate_context(tsk->mm);
asm-m68k/amigaints.h:** amigaints.h -- Amiga Linux interrupt handling structs and prototypes
asm-m68k/amigaints.h:/* auto-vector interrupts */
asm-m68k/amigaints.h:#endif /* asm-m68k/amigaints.h */
asm-m68k/sun3xflop.h: * Derived partially from asm-sparc/floppy.h, which is:
asm-m68k/sun3xflop.h://	printk("doing pdma\n");// st %x\n", sun_fdc->status_82072);
asm-m68k/sun3xflop.h:		    lcount; lcount--, lptr++) {
asm-m68k/sun3xflop.h:		return ((error == 0) ? 0 : -1);
asm-m68k/sun3xflop.h:		return -1;
asm-m68k/atari_SCCserial.h:#define SCC_BAUD_BASE_TIMC	19200	/* 0.3072 MHz from TT-MFP, Timer C */
asm-m68k/atari_SCCserial.h: *   - CLK_RTxC: 1 or even (1, 2 and 4 are the direct modes, > 4 use
asm-m68k/atari_SCCserial.h: *   - CLK_TRxC: 1, 2 or 4 (no BRG, only direct modes possible)
asm-m68k/atari_SCCserial.h: *   - CLK_PCLK: >= 4 and even (no direct modes, only BRG)
asm-m68k/semaphore.h: * Interrupt-safe semaphores..
asm-m68k/semaphore.h:	CHECK_MAGIC(sem->__magic);
asm-m68k/semaphore.h:	CHECK_MAGIC(sem->__magic);
asm-m68k/semaphore.h:	CHECK_MAGIC(sem->__magic);
asm-m68k/semaphore.h:	CHECK_MAGIC(sem->__magic);
asm-m68k/semaphore.h:	return atomic_read(&sem->count);
asm-m68k/fcntl.h:/* open/fcntl - O_SYNC is only implemented on blocks devices and on files
asm-m68k/fcntl.h:#define O_DIRECT	0200000	/* direct disk access hint - currently ignored */
asm-m68k/fcntl.h:#define F_GETFL		3	/* get file->f_flags */
asm-m68k/fcntl.h:#define F_SETFL		4	/* set file->f_flags */
asm-m68k/entry.h: *	This allows access to the syscall arguments in registers d1-d5
asm-m68k/entry.h: *	 0(sp) - d1
asm-m68k/entry.h: *	 4(sp) - d2
asm-m68k/entry.h: *	 8(sp) - d3
asm-m68k/entry.h: *	 C(sp) - d4
asm-m68k/entry.h: *	10(sp) - d5
asm-m68k/entry.h: *	14(sp) - a0
asm-m68k/entry.h: *	18(sp) - a1
asm-m68k/entry.h: *	1C(sp) - a2
asm-m68k/entry.h: *	20(sp) - d0
asm-m68k/entry.h: *	24(sp) - orig_d0
asm-m68k/entry.h: *	28(sp) - stack adjustment
asm-m68k/entry.h: *	2C(sp) - sr
asm-m68k/entry.h: *	2E(sp) - pc
asm-m68k/entry.h: *	32(sp) - format & vector
asm-m68k/entry.h: * This defines the normal kernel pt-regs layout.
asm-m68k/entry.h: * regs a3-a6 and d6-d7 are preserved by C code
asm-m68k/entry.h: * a -1 in the orig_d0 field signifies
asm-m68k/entry.h:	clrl	%sp@-		| stk_adj
asm-m68k/entry.h:	pea	-1:w		| orig d0
asm-m68k/entry.h:	movel	%d0,%sp@-	| d0
asm-m68k/entry.h:	moveml	%d1-%d5/%a0-%a1/%curptr,%sp@-
asm-m68k/entry.h:	clrl	%sp@-		| stk_adj
asm-m68k/entry.h:	movel	%d0,%sp@-	| orig d0
asm-m68k/entry.h:	movel	%d0,%sp@-	| d0
asm-m68k/entry.h:	moveml	%d1-%d5/%a0-%a1/%curptr,%sp@-
asm-m68k/entry.h:	moveml	%sp@+,%a0-%a1/%curptr/%d1-%d5
asm-m68k/entry.h:	moveml	%a3-%a6/%d6-%d7,%sp@-
asm-m68k/entry.h:	moveml	%sp@+,%a3-%a6/%d6-%d7
asm-m68k/entry.h:	andw	#-KTHREAD_SIZE,\reg
asm-m68k/entry.h:	"clrl	%%sp@-;"    /* stk_adj */	\
asm-m68k/entry.h:	"pea	-1:w;"	    /* orig d0 = -1 */	\
asm-m68k/entry.h:	"movel	%%d0,%%sp@-;" /* d0 */		\
asm-m68k/entry.h:	"moveml	%%d1-%%d5/%%a0-%%a2,%%sp@-"
asm-m68k/entry.h:	"andw	#-"STR(KTHREAD_SIZE)","#tmp"\n\t" \
asm-m68k/atari_stram.h: * Functions for Atari ST-RAM management
asm-m68k/errno.h:#define	EXDEV		18	/* Cross-device link */
asm-m68k/errno.h:#define	EROFS		30	/* Read-only file system */
asm-m68k/errno.h:#define	ENOTSOCK	88	/* Socket operation on non-socket */
asm-m68k/sun3-head.h:/* $Id: ack,v 1.1.1.1 2006-10-13 02:42:37 steven Exp $ */
asm-m68k/sun3_pgtable.h: * `pgtable.h'; this should only be included from the generic file. --m
asm-m68k/sun3_pgtable.h:/* Use these fake page-protections on PMDs. */
asm-m68k/sun3_pgtable.h:#define pte_pagenr(pte)		((__pte_page(pte) - PAGE_OFFSET) >> PAGE_SHIFT)
asm-m68k/sun3_pgtable.h:((mm)->pgd + pgd_index(address))
asm-m68k/sun3_pgtable.h:/* Find an entry in the second-level pagetable. */
asm-m68k/sun3_pgtable.h:/* Find an entry in the third-level pagetable. */
asm-m68k/sun3_pgtable.h:((pte_t *) __pmd_page (*pmd) + ((address >> PAGE_SHIFT) & (PTRS_PER_PTE-1)))
asm-m68k/sun3_pgtable.h:	/* Don't think this is required on sun3. --m */
asm-m68k/sun3_pgtable.h:	/* Don't think this is required on sun3. --m */
asm-m68k/atariints.h:** atariints.h -- Atari Linux interrupt handling structs and prototypes
asm-m68k/atariints.h:#define NUM_ATARI_SOURCES   (VME_SOURCE_BASE+VME_MAX_SOURCES-STMFP_SOURCE_BASE)
asm-m68k/atariints.h:#define IRQ_VECTOR_TO_SOURCE(v)	((v) - ((v) < 0x20 ? 0x18 : (0x40-8)))
asm-m68k/atariints.h:#define IRQ_SOURCE_TO_VECTOR(i)	((i) + ((i) < 8 ? 0x18 : (0x40-8)))
asm-m68k/atariints.h:/* auto-vector interrupts */
asm-m68k/atariints.h:/* ST-MFP interrupts */
asm-m68k/atariints.h:/* TT-MFP interrupts */
asm-m68k/atariints.h:		  ((irq & 8) >> 2) + (((irq-8) & 16) << 3);
asm-m68k/atariints.h:		  ((irq & 8) >> 2) + (((irq-8) & 16) << 3);
asm-m68k/atariints.h:		  ((irq & 8) >> 2) + (((irq-8) & 16) << 3);
asm-m68k/sun3mmu.h:#define SUN3_PMEG_MASK		 (SUN3_PMEG_SIZE - 1)
asm-m68k/sun3mmu.h:#define SUN3_PTE_MASK		 (SUN3_PTE_SIZE - 1)
asm-m68k/sun3mmu.h:#define AC_CONTEXT    0x30000000    /* 34c current mmu-context               */
asm-m68k/sun3mmu.h:#define AC_VME_VECTOR 0xE0000000    /* 4   For non-Autovector VME, byte      */
asm-m68k/sun3mmu.h:/* Bits within bus-error register. */
asm-m68k/softirq.h:#define cpu_bh_enable(cpu)	do { barrier(); local_bh_count(cpu)--; } while (0)
asm-m68k/timex.h: * linux/include/asm-m68k/timex.h
asm-m68k/timex.h:#define FINETUNE ((((((long)LATCH * HZ - CLOCK_TICK_RATE) << SHIFT_HZ) * \
asm-m68k/timex.h:		<< (SHIFT_SCALE-SHIFT_HZ)) / HZ)
asm-m68k/atarihw.h:** linux/atarihw.h -- This header defines some macros and pointers for
asm-m68k/atarihw.h:** 1996-09-13 lars brinkhoff <f93labr@dd.chalmers.se>:
asm-m68k/atarihw.h: * Define several Hardware-Chips for indication so that for the ATARI we do
asm-m68k/atarihw.h:    ATARIHW_DECLARE(STND_SHIFTER);	/* ST-Shifter - no base low ! */
asm-m68k/atarihw.h:    ATARIHW_DECLARE(EXTD_SHIFTER);	/* STe-Shifter - 24 bit address */
asm-m68k/atarihw.h:    ATARIHW_DECLARE(TT_SHIFTER);	/* TT-Shifter */
asm-m68k/atarihw.h:    ATARIHW_DECLARE(VIDEL_SHIFTER);	/* Falcon-Shifter */
asm-m68k/atarihw.h:    ATARIHW_DECLARE(PCM_8BIT);		/* PCM-Sound in STe-ATARI */
asm-m68k/atarihw.h:    ATARIHW_DECLARE(ST_SCSI);		/* NCR5380 via ST-DMA (Falcon) */
asm-m68k/atarihw.h:    ATARIHW_DECLARE(ST_MFP);		/* The ST-MFP (there should be no Atari
asm-m68k/atarihw.h:    ATARIHW_DECLARE(STND_DMA);		/* 24 Bit limited ST-DMA */
asm-m68k/atarihw.h:    ATARIHW_DECLARE(EXTD_DMA);		/* 32 Bit ST-DMA */
asm-m68k/atarihw.h:/* values for shifter_tt->tt_shiftmode */
asm-m68k/atarihw.h:  u_char dma_vhi;	/* Some extended ST-DMAs can handle 32 bit addresses */
asm-m68k/atarihw.h:    (0x0c0 | ((dB) < -80 ? 0 : (dB) > 0 ? 40 : (((dB) + 80) / 2)))
asm-m68k/atarihw.h:    (0x140 | ((dB) < -40 ? 0 : (dB) > 0 ? 20 : (((dB) + 40) / 2)))
asm-m68k/atarihw.h:    (0x100 | ((dB) < -40 ? 0 : (dB) > 0 ? 20 : (((dB) + 40) / 2)))
asm-m68k/atarihw.h:    (0x080 | ((dB) < -12 ? 0 : (dB) > 12 ? 12 : (((dB) / 2) + 6)))
asm-m68k/atarihw.h:    (0x040 | ((dB) < -12 ? 0 : (dB) > 12 ? 12 : (((dB) / 2) + 6)))
asm-m68k/atarikb.h:** atarikb.h -- This header contains the prototypes of functions of
asm-m68k/bugs.h: *  include/asm-m68k/bugs.h
asm-m68k/bugs.h: * This is included by init/main.c to check for architecture-dependent bugs.
asm-m68k/namei.h: * linux/include/asm-m68k/namei.h
asm-m68k/namei.h: * Look at asm-sparc/namei.h for details.
asm-m68k/vuid_event.h:#include <asm-sparc/vuid_event.h>
asm-m68k/dvma.h: * include/asm-m68k/dma.h
asm-m68k/dvma.h:#define DVMA_PAGE_MASK	(~(DVMA_PAGE_SIZE-1))
asm-m68k/dvma.h:#define DVMA_PAGE_ALIGN(addr)	(((addr)+DVMA_PAGE_SIZE-1)&DVMA_PAGE_MASK)
asm-m68k/dvma.h:#define DVMA_SIZE (DVMA_END-DVMA_START)
asm-m68k/dvma.h:/* empirical kludge -- dvma regions only seem to work right on 0x10000 
asm-m68k/dvma.h:#define DVMA_ALIGN(addr) (((addr)+DVMA_REGION_SIZE-1) & \
asm-m68k/dvma.h:                         ~(DVMA_REGION_SIZE-1))
asm-m68k/dvma.h:/* virt <-> phys conversions */
asm-m68k/dvma.h:#define DVMA_SIZE (DVMA_END-DVMA_START)
asm-m68k/dvma.h:#define IOMMU_ENTRIES              (IOMMU_TOTAL_ENTRIES - 0x80)
asm-m68k/dvma.h:#define DMA_ISBROKEN(dma)    ((dma)->revision == dvmarev1)
asm-m68k/dvma.h:#define DMA_ISESC1(dma)      ((dma)->revision == dvmaesc1)
asm-m68k/dvma.h:#define DMA_BRST0        0x00080000        /* SCSI: no bursts (non-HME gate arrays) */
asm-m68k/dvma.h:#define DMA_EN_ENETAUI   DMA_3CLKS         /* Put lance into AUI-cable mode */
asm-m68k/dvma.h:/* Values describing the burst-size property from the PROM */
asm-m68k/dvma.h:#define DMA_MAXEND(addr) (0x01000000UL-(((unsigned long)(addr))&0x00ffffffUL))
asm-m68k/dvma.h:#define DMA_ERROR_P(regs)  ((((regs)->cond_reg) & DMA_HNDL_ERROR))
asm-m68k/dvma.h:#define DMA_IRQ_P(regs)    ((((regs)->cond_reg) & (DMA_HNDL_INTR | DMA_HNDL_ERROR)))
asm-m68k/dvma.h:#define DMA_WRITE_P(regs)  ((((regs)->cond_reg) & DMA_ST_WRITE))
asm-m68k/dvma.h:#define DMA_OFF(regs)      ((((regs)->cond_reg) &= (~DMA_ENABLE)))
asm-m68k/dvma.h:#define DMA_INTSOFF(regs)  ((((regs)->cond_reg) &= (~DMA_INT_ENAB)))
asm-m68k/dvma.h:#define DMA_INTSON(regs)   ((((regs)->cond_reg) |= (DMA_INT_ENAB)))
asm-m68k/dvma.h:#define DMA_PUNTFIFO(regs) ((((regs)->cond_reg) |= DMA_FIFO_INV))
asm-m68k/dvma.h:#define DMA_SETSTART(regs, addr)  ((((regs)->st_addr) = (char *) addr))
asm-m68k/dvma.h:        ((((regs)->cond_reg |= (DMA_ST_WRITE|DMA_ENABLE|DMA_INT_ENAB))))
asm-m68k/dvma.h:        ((((regs)->cond_reg |= ((DMA_ENABLE|DMA_INT_ENAB)&(~DMA_ST_WRITE)))))
asm-m68k/dvma.h:	struct sparc_dma_registers *regs = dma->regs;                      \
asm-m68k/dvma.h:	regs->cond_reg |= (DMA_RST_SCSI);     /* assert */                 \
asm-m68k/dvma.h:	regs->cond_reg &= ~(DMA_RST_SCSI);    /* de-assert */              \
asm-m68k/dvma.h:	sparc_dma_enable_interrupts(regs);    /* Re-enable interrupts */   \
asm-m68k/dvma.h:	if(dma->revision>dvmarev1) regs->cond_reg |= DMA_3CLKS;            \
asm-m68k/dvma.h:	dma->running = 0;                                                  \
asm-m68k/fbio.h:#include <asm-sparc/fbio.h>
asm-m68k/motorola_pgtable.h:#define _PAGE_NOCACHE030 0x040	/* 68030 no-cache mode */
asm-m68k/motorola_pgtable.h:#define _PAGE_NOCACHE	0x060	/* 68040 cache mode, non-serialized */
asm-m68k/motorola_pgtable.h:#define _PAGE_NOCACHE_S	0x040	/* 68040 no-cache mode, serialized */
asm-m68k/motorola_pgtable.h:#define _PAGE_CACHE040W	0x000	/* 68040 cache mode, cachable, write-through */
asm-m68k/motorola_pgtable.h:	unsigned long *ptr = pmdp->pmd;
asm-m68k/motorola_pgtable.h:	while (--i >= 0) {
asm-m68k/motorola_pgtable.h:#define pte_pagenr(pte)		((__pte_page(pte) - PAGE_OFFSET) >> PAGE_SHIFT)
asm-m68k/motorola_pgtable.h:	unsigned long *__ptr = pmdp->pmd;	\
asm-m68k/motorola_pgtable.h:	while (--__i >= 0)			\
asm-m68k/motorola_pgtable.h:/* to find an entry in a page-table-directory */
asm-m68k/motorola_pgtable.h:	return mm->pgd + pgd_index(address);
asm-m68k/motorola_pgtable.h:/* Find an entry in the second-level page table.. */
asm-m68k/motorola_pgtable.h:	return (pmd_t *)__pgd_page(*dir) + ((address >> PMD_SHIFT) & (PTRS_PER_PMD-1));
asm-m68k/motorola_pgtable.h:/* Find an entry in the third-level page table.. */ 
asm-m68k/motorola_pgtable.h:	return (pte_t *)__pmd_page(*pmdp) + ((address >> PAGE_SHIFT) & (PTRS_PER_PTE - 1));
asm-m68k/motorola_pgtable.h: * used to allocate a kernel page table - this turns on ASN bits
asm-m68k/motorola_pgtable.h: * cache setting for the page has been changed. -jskov
asm-m68k/idprom.h:#include <asm-sparc/idprom.h>
asm-m68k/segment.h:/* Address spaces (FC0-FC2) */
asm-m68k/uaccess.h:	return access_ok(type,addr,size)?0:-EFAULT;
asm-m68k/uaccess.h: * These are the main single-value transfer routines.  They automatically
asm-m68k/uaccess.h:     : "m"(*(ptr)), "r"(x), "i"(-EFAULT), "0"(0))
asm-m68k/uaccess.h:     : "m"(*(ptr)), "i" (-EFAULT), "0"(0))
asm-m68k/uaccess.h:	 : "i"(-EFAULT), "0"(count), "1"(dst), "2"(src), "3"(count)
asm-m68k/uaccess.h:	res = -(long)src;
asm-m68k/traps.h:#define MMU_WP	     (0x0800)    /* write-protected */
asm-m68k/kbio.h:#include <asm-sparc/kbio.h>
asm-m68k/sun3ints.h: * sun3ints.h -- Linux/Sun3 interrupt handling code definitions
asm-m68k/sun3ints.h:/* master list of VME vectors -- don't fuck with this */
asm-m68k/semaphore-helper.h: * SMP- and interrupt-safe semaphores helper functions.
asm-m68k/semaphore-helper.h:	atomic_inc(&sem->waking);
asm-m68k/semaphore-helper.h:	if (atomic_read(&sem->waking) > 0) {
asm-m68k/semaphore-helper.h:		atomic_dec(&sem->waking);
asm-m68k/semaphore-helper.h:	   : "m" (sem->waking), "0" (0), "1" (sem->waking));
asm-m68k/semaphore-helper.h: *	-EINTR	interrupted
asm-m68k/semaphore-helper.h:	if (atomic_read(&sem->waking) > 0) {
asm-m68k/semaphore-helper.h:		atomic_dec(&sem->waking);
asm-m68k/semaphore-helper.h:		atomic_inc(&sem->count);
asm-m68k/semaphore-helper.h:		ret = -EINTR;
asm-m68k/semaphore-helper.h:	   : "m" (sem->waking), "i" (&&next), "0" (0), "1" (sem->waking));
asm-m68k/semaphore-helper.h:		atomic_inc(&sem->count);
asm-m68k/semaphore-helper.h:		ret = -EINTR;
asm-m68k/semaphore-helper.h:	if (atomic_read(&sem->waking) > 0) {
asm-m68k/semaphore-helper.h:		atomic_dec(&sem->waking);
asm-m68k/semaphore-helper.h:		atomic_inc(&sem->count);
asm-m68k/semaphore-helper.h:	   : "m" (sem->waking), "0" (1), "1" (sem->waking));
asm-m68k/semaphore-helper.h:		atomic_inc(&sem->count);
asm-m68k/contregs.h:#include <asm-sparc/contregs.h>
asm-m68k/mman.h:#define MAP_GROWSDOWN	0x0100		/* stack-like segment */
asm-m68k/mman.h:#define MADV_NORMAL	0x0		/* default page-in behavior */
asm-m68k/mman.h:#define MADV_RANDOM	0x1		/* page-in minimum required */
asm-m68k/mman.h:#define MADV_SEQUENTIAL	0x2		/* read-ahead aggressively */
asm-m68k/mman.h:#define MADV_WILLNEED	0x3		/* pre-fault pages */
asm-m68k/posix_types.h: * This file is generally used by user-level software, so you need to
asm-m68k/posix_types.h:#define	__FD_SET(d, set)	((set)->fds_bits[__FDELT(d)] |= __FDMASK(d))
asm-m68k/posix_types.h:#define	__FD_CLR(d, set)	((set)->fds_bits[__FDELT(d)] &= ~__FDMASK(d))
asm-m68k/posix_types.h:#define	__FD_ISSET(d, set)	((set)->fds_bits[__FDELT(d)] & __FDMASK(d))
asm-m68k/scatterlist.h:	__u32 dvma_address; /* A place to hang host-specific addresses at. */
asm-m68k/smplock.h:	if (task->lock_depth >= 0) \
asm-m68k/smplock.h: * Re-acquire the kernel lock
asm-m68k/smplock.h:	if (task->lock_depth >= 0) \
asm-m68k/smplock.h:	if (!++current->lock_depth)
asm-m68k/smplock.h:	if (--current->lock_depth < 0)
asm-m68k/raw_io.h: * linux/include/asm-m68k/raw_io.h 
asm-m68k/raw_io.h: * 10/20/00 RZ: - created from bits of io.h and ide.h to cleanup namespace
asm-m68k/raw_io.h:		tmp = (nr & 15) - 1;
asm-m68k/raw_io.h:		tmp = (nr >> 4) - 1;
asm-m68k/raw_io.h:		tmp = (nr & 15) - 1;
asm-m68k/raw_io.h:		tmp = (nr >> 4) - 1;
asm-m68k/raw_io.h:		tmp = (nr & 15) - 1;
asm-m68k/raw_io.h:		tmp = (nr >> 4) - 1;
asm-m68k/raw_io.h:		tmp = (nr & 15) - 1;
asm-m68k/raw_io.h:		tmp = (nr >> 4) - 1;
asm-m68k/page.h:#define PAGE_MASK	(~(PAGE_SIZE-1))
asm-m68k/page.h:		       : "0" (to), "1" (from) , "2" (PAGE_SIZE / 32 - 1)
asm-m68k/page.h:			       "1" ((PAGE_SIZE - 16) / 16 - 1));
asm-m68k/page.h: * These are used to make use of C type-checking..
asm-m68k/page.h:#define pmd_val(x)	((&x)->pmd[0])
asm-m68k/page.h:#define PAGE_ALIGN(addr)	(((addr)+PAGE_SIZE-1)&PAGE_MASK)
asm-m68k/page.h:	size = (size-1) >> (PAGE_SHIFT-1);
asm-m68k/page.h:	order = -1;
asm-m68k/page.h:#define __va(paddr)		((void *)((unsigned long)(paddr)-m68k_memoffset))
asm-m68k/page.h:/* This #define is a horrible hack to suppress lots of warnings. --m */
asm-m68k/page.h:        return (x-PAGE_OFFSET);
asm-m68k/page.h:        return (void *)(x-0x2000000);
asm-m68k/page.h:#define MAP_NR(addr)		(((unsigned long)(addr)-PAGE_OFFSET) >> PAGE_SHIFT)
asm-m68k/page.h:#define virt_to_page(kaddr)	(mem_map + (((unsigned long)(kaddr)-PAGE_OFFSET) >> PAGE_SHIFT))
asm-m68k/page.h:#define VALID_PAGE(page)	((page - mem_map) < max_mapnr)
asm-m68k/dsp56k.h: * linux/include/asm-m68k/dsp56k.h - defines and declarations for
asm-m68k/dsp56k.h:#define DSP56K_SET_TX_WSIZE	2    /* Host transmit word size (1-4)   */
asm-m68k/dsp56k.h:#define DSP56K_SET_RX_WSIZE	3    /* Host receive word size (1-4)    */
asm-m68k/dsp56k.h:#define DSP56K_HOST_CMD         5    /* Trig Host Command (0-31)        */
asm-m68k/hdreg.h: *  linux/include/asm-m68k/hdreg.h
asm-m68k/hdreg.h: *  Copyright (C) 1994-1996  Linus Torvalds & authors
asm-m68k/types.h: * application is Linux specific so (user-) name space pollution is
asm-m68k/types.h:/* DMA addresses are always 32-bits wide */
asm-m68k/sbus.h:/* sbus IO functions stolen from include/asm-sparc/io.h for the serial driver */
asm-m68k/sbus.h:/* No SBUS on the Sun3, kludge -- sam */
asm-m68k/sembuf.h: * - 64-bit time_t to solve y2038 problem
asm-m68k/sembuf.h: * - 2 miscellaneous 32-bit values
asm-m68k/system.h: * also clears the TS-flag if the task we switched to has used the
asm-m68k/system.h: * math co-processor latest.
asm-m68k/system.h: * automatically by SAVE_SWITCH_STACK in resume(), ie. d0-d5 and
asm-m68k/system.h: * a0-a1. Some of these are used by schedule() and its predecessors
asm-m68k/system.h: * 02/17/96 - Jes Sorensen (jds@kom.auc.dk)
asm-m68k/stat.h:	unsigned long	st_blocks;	/* Number 512-byte blocks allocated. */
asm-m68k/checksum.h: * and adds in "sum" (32-bit)
asm-m68k/checksum.h: * returns a 32-bit number suitable for feeding into itself
asm-m68k/checksum.h: * it's best to have buff aligned on a 32-bit boundary
asm-m68k/checksum.h: * here even more important to align src and dst on a 32-bit (or even
asm-m68k/checksum.h: * better 64-bit) boundary
asm-m68k/checksum.h: * here even more important to align src and dst on a 32-bit (or even
asm-m68k/checksum.h: * better 64-bit) boundary
asm-m68k/checksum.h: * computes the checksum of the TCP/UDP pseudo-header
asm-m68k/checksum.h: * returns a 16-bit checksum, already complemented
asm-m68k/checksum.h: * this routine is used for miscellaneous IP-like checksums, mainly
asm-m68k/termios.h:#define N_IRDA		11	/* Linux IrDa - http://irda.sourceforge.net/ */
asm-m68k/termios.h:#define N_SMSBLOCK	12	/* SMS block mode - for talking to GSM data cards about SMS messages */
asm-m68k/termios.h:	get_user(tmp, &(termio)->c_iflag); \
asm-m68k/termios.h:	(termios)->c_iflag = (0xffff0000 & ((termios)->c_iflag)) | tmp; \
asm-m68k/termios.h:	get_user(tmp, &(termio)->c_oflag); \
asm-m68k/termios.h:	(termios)->c_oflag = (0xffff0000 & ((termios)->c_oflag)) | tmp; \
asm-m68k/termios.h:	get_user(tmp, &(termio)->c_cflag); \
asm-m68k/termios.h:	(termios)->c_cflag = (0xffff0000 & ((termios)->c_cflag)) | tmp; \
asm-m68k/termios.h:	get_user(tmp, &(termio)->c_lflag); \
asm-m68k/termios.h:	(termios)->c_lflag = (0xffff0000 & ((termios)->c_lflag)) | tmp; \
asm-m68k/termios.h:	get_user((termios)->c_line, &(termio)->c_line); \
asm-m68k/termios.h:	copy_from_user((termios)->c_cc, (termio)->c_cc, NCC); \
asm-m68k/termios.h:	put_user((termios)->c_iflag, &(termio)->c_iflag); \
asm-m68k/termios.h:	put_user((termios)->c_oflag, &(termio)->c_oflag); \
asm-m68k/termios.h:	put_user((termios)->c_cflag, &(termio)->c_cflag); \
asm-m68k/termios.h:	put_user((termios)->c_lflag, &(termio)->c_lflag); \
asm-m68k/termios.h:	put_user((termios)->c_line,  &(termio)->c_line); \
asm-m68k/termios.h:	copy_to_user((termio)->c_cc, (termios)->c_cc, NCC); \
asm-m68k/machines.h: * ---------------
asm-m68k/machines.h: * ---------------
asm-m68k/machines.h:/* Sun4c machines                Full Name              - PROM NAME */
asm-m68k/machines.h:#define SM_4C_SS1     0x01    /* Sun4c SparcStation 1   - Sun 4/60  */
asm-m68k/machines.h:#define SM_4C_IPC     0x02    /* Sun4c SparcStation IPC - Sun 4/40  */
asm-m68k/machines.h:#define SM_4C_SS1PLUS 0x03    /* Sun4c SparcStation 1+  - Sun 4/65  */
asm-m68k/machines.h:#define SM_4C_SLC     0x04    /* Sun4c SparcStation SLC - Sun 4/20  */
asm-m68k/machines.h:#define SM_4C_SS2     0x05    /* Sun4c SparcStation 2   - Sun 4/75  */
asm-m68k/machines.h:#define SM_4C_ELC     0x06    /* Sun4c SparcStation ELC - Sun 4/25  */
asm-m68k/machines.h:#define SM_4C_IPX     0x07    /* Sun4c SparcStation IPX - Sun 4/50  */
asm-m68k/machines.h:/* Sun4d machines -- N/A */
asm-m68k/machines.h:/* Sun4e machines -- N/A */
asm-m68k/machines.h:/* Sun4u machines -- N/A */
asm-m68k/user.h:   linux we use the 'trad-core' bfd).  There are quite a number of
asm-m68k/user.h:   DATA: The data area is stored.  We use current->end_text to
asm-m68k/user.h:   current->brk to pick up all of the user variables, plus any memory
asm-m68k/user.h:   is demand-zero or if a page is totally unused, we just cover the entire
asm-m68k/user.h:   current->start_stack, so we round each of these off in order to be able
asm-m68k/user.h:	unsigned long  fpregs[8*3];	/* fp0-fp7 registers */
asm-m68k/user.h:/* When the kernel dumps core, it starts by dumping the user struct -
asm-m68k/user.h:  int u_fpvalid;		/* True if math co-processor being used. */
asm-m68k/user.h:  struct user_m68kfp_struct m68kfp; /* Math Co-processor registers. */
asm-m68k/user.h:  struct user_m68kfp_struct* u_fpstate;	/* Math Co-processor pointer. */
asm-m68k/hwtest.h: *  -- PMM <pmaydell@chiark.greenend.org.uk> 05/1998
asm-m68k/mac_mouse.h: * linux/include/asm-m68k/mac_mouse.h
asm-m68k/mac_mouse.h: * 27-10-97 Michael Schmitz
asm-m68k/serial.h: * include/asm-m68k/serial.h
asm-m68k/serial.h: * it's an almost exact copy of ../asm-alpha/serial.h 
asm-m68k/pgtable.h:/* PMD_SHIFT determines the size of the area a second-level page table can map */
asm-m68k/pgtable.h:#define PMD_MASK	(~(PMD_SIZE-1))
asm-m68k/pgtable.h:/* PGDIR_SHIFT determines what a third-level page table entry can map */
asm-m68k/pgtable.h:#define PGDIR_MASK	(~(PGDIR_SIZE-1))
asm-m68k/pgtable.h: * entries per page directory level: the m68k is configured as three-level,
asm-m68k/pgtable.h: * any out-of-bounds memory accesses will hopefully be caught.
asm-m68k/pgtable.h:#define VMALLOC_START (((unsigned long) high_memory + VMALLOC_OFFSET) & ~(VMALLOC_OFFSET-1))
asm-m68k/pgtable.h: * BAD_PAGETABLE is used when we need a bogus page-table, while
asm-m68k/pgtable.h: * for zero-mapped memory areas etc..
asm-m68k/pgtable.h:#define PTR_MASK			(~(sizeof(void*)-1))
asm-m68k/pgtable.h:/* 64-bit machines, beware!  SRB. */
asm-m68k/pgtable.h:/* Encode and de-code a swap entry (must be !pte_none(e) && !pte_present(e)) */
asm-m68k/pgtable.h:/* MMU-specific headers */
asm-m68k/pgtable.h:#include <asm-generic/pgtable.h>
asm-m68k/param.h:#define NOGROUP		(-1)
asm-m68k/sun3_pgalloc.h:/* sun3_pgalloc.h --
asm-m68k/sun3_pgalloc.h://todo: should implement for at least ptes. --m
asm-m68k/sun3_pgalloc.h:/* FIXME - when we get this compiling */
asm-m68k/sun3_pgalloc.h:        address = (address >> PAGE_SHIFT) & (PTRS_PER_PTE - 1);
asm-m68k/sun3_pgalloc.h: * allocating and freeing a pmd is trivial: the 1-entry pmd is
asm-m68k/sun3_pgalloc.h: * allocating and freeing a pmd is trivial: the 1-entry pmd is
asm-m68k/sun3_pgalloc.h:     sun3_put_context(mm->context);
asm-m68k/sun3_pgalloc.h:	sun3_put_context(vma->vm_mm->context);
asm-m68k/sun3_pgalloc.h:	sun3_put_context(mm->context);
asm-m68k/sun3_pgalloc.h:		if(pmeg_ctx[seg] == mm->context) {
asm-m68k/sun3_pgalloc.h:	sun3_put_segmap (addr & ~(SUN3_PMEG_SIZE - 1), SUN3_INVALID_PMEG);
asm-m68k/oplib.h: * and usage utility functions.  Only prom-lib should use these,
asm-m68k/oplib.h: * of the string is different on V0 vs. V2->higher proms.  The caller must
asm-m68k/oplib.h: * These lists are returned pre-sorted, this should make your life easier
asm-m68k/oplib.h:/* Enter the prom, with no chance of continuation for the stand-alone
asm-m68k/oplib.h: * XXX The arguments are different on V0 vs. V2->higher proms, grrr! XXX
asm-m68k/oplib.h:/* Non-blocking get character from console. */
asm-m68k/oplib.h:/* Non-blocking put character to console. */
asm-m68k/oplib.h:/* Re-Start the CPU with the passed device tree node. */
asm-m68k/oplib.h:/* Sun4/sun4c specific memory-management startup hook. */
asm-m68k/oplib.h: * Returns -1 on error (ie. no such property at this node).
asm-m68k/oplib.h: * the number of bytes the prom put into your buffer or -1 on error.
asm-m68k/bootinfo.h:** asm/bootinfo.h -- Definition of the Linux/m68k boot information structure
asm-m68k/bootinfo.h:     *  Amiga-specific tags
asm-m68k/bootinfo.h:     *  Atari-specific tags
asm-m68k/bootinfo.h:     *  VME-specific tags
asm-m68k/bootinfo.h:#define BI_VME_TYPE		0x8000	/* VME sub-architecture (u_long) */
asm-m68k/bootinfo.h:     *  Macintosh-specific tags (all u_long)
asm-m68k/bootinfo.h:     *  Macintosh hardware profile data - unused, see macintosh.h for 
asm-m68k/bootinfo.h:     *  Apollo-specific tags
asm-m68k/bootinfo.h:     * together :-)
asm-m68k/bootinfo.h:     * appropriate machine. If a change is backward-compatible, the minor
asm-m68k/bootinfo.h:     * should be stepped. "Backwards-compatible" means that booting will work,
asm-m68k/cache.h: * include/asm-m68k/cache.h
asm-m68k/mac_iop.h:#define	IOP_BYPASS	0x01	/* bypass-mode hardware access */
asm-m68k/mac_iop.h:/* IOP reference numbers, used by the globally-visible iop_xxx functions */
asm-m68k/mac_iop.h:    /* Bypass-mode hardware access registers */
asm-m68k/mac_iop.h:	    __u8 wcrc;		/* write 2-byte crc to disk */
asm-m68k/siginfo.h:/* This is copied from asm-alpha/siginfo.h.  */
asm-m68k/siginfo.h:#define SI_PAD_SIZE	((SI_MAX_SIZE/sizeof(int)) - 3)
asm-m68k/siginfo.h: * Digital reserves positive values for kernel-generated signals.
asm-m68k/siginfo.h:#define SI_QUEUE	-1		/* sent by sigqueue */
asm-m68k/siginfo.h:#define SI_TIMER __SI_CODE(__SI_TIMER,-2) /* sent by timer expiration */
asm-m68k/siginfo.h:#define SI_MESGQ	-3		/* sent by real time mesq state change */
asm-m68k/siginfo.h:#define SI_ASYNCIO	-4		/* sent by AIO completion */
asm-m68k/siginfo.h:#define SI_SIGIO	-5		/* sent by queued SIGIO */
asm-m68k/siginfo.h:#define SI_TKILL	-6		/* sent by tkill system call */
asm-m68k/siginfo.h:#define SI_FROMUSER(siptr)	((siptr)->si_code <= 0)
asm-m68k/siginfo.h:#define SI_FROMKERNEL(siptr)	((siptr)->si_code > 0)
asm-m68k/siginfo.h:#define BUS_ADRERR	(__SI_FAULT|2)	/* non-existant physical address */
asm-m68k/siginfo.h:#define SIGEV_PAD_SIZE	((SIGEV_MAX_SIZE/sizeof(int)) - 3)
asm-m68k/siginfo.h:	if (from->si_code < 0)
asm-m68k/siginfo.h:		memcpy(to, from, 3*sizeof(int) + sizeof(from->_sifields._sigchld));
asm-m68k/floppy.h:/* vdma globals adapted from asm-i386/floppy.h */
asm-m68k/floppy.h:	return -ENXIO;
asm-m68k/floppy.h:/* No 64k boundary crossing problems on Q40 - no DMA at all */
asm-m68k/floppy.h:#define DMA_MODE_READ  0x44    /* i386 look-alike */
asm-m68k/floppy.h:    return -1;
asm-m68k/floppy.h:		    lcount; lcount--, lptr++) {
asm-m68k/mac_oss.h: * Interrupt level offsets for mac_oss->irq_level
asm-m68k/mac_oss.h: * Pending interrupt bits in mac_oss->irq_pending
asm-m68k/mac_oss.h: * OSS Interrupt levels for various sub-systems
asm-m68k/mac_oss.h: * things on their own levels to avoid having to do double-dispatches. Second,
asm-m68k/mac_oss.h:    __u8  irq_level[0x10];	/* [0x000-0x00f] Interrupt levels */
asm-m68k/mac_oss.h:    __u8  padding0[0x1F2];	/* [0x010-0x201] IO space filler */
asm-m68k/mac_oss.h:    __u16 irq_pending;		/* [0x202-0x203] pending interrupts bits */
asm-m68k/mac_oss.h:    __u8  rom_ctrl;		/* [0x204-0x204] ROM cntl reg (for poweroff) */
asm-m68k/mac_oss.h:    __u8  padding1[0x2];	/* [0x205-0x206] currently unused by A/UX */
asm-m68k/mac_oss.h:    __u8  ack_60hz;		/* [0x207-0x207] 60 Hz ack. */
asm-m68k/mac_psc.h: * The first seven DMA channels appear to be "one-shot" and are actually
asm-m68k/mac_psc.h: * The one-shot channels are grouped together and are:
asm-m68k/mac_psc.h: * machine with easy-to-find patterns and looking for them in the DMA
asm-m68k/mac_psc.h: * 1999-05-25 (jmt)
asm-m68k/mac_psc.h: * One-shot DMA control registers
asm-m68k/mac_psc.h: * Free-running DMA registers. The only part known for sure are the bits in
asm-m68k/mac_psc.h: * These registers seem to be mirrored every thirty-two bytes up until offset
asm-m68k/mac_psc.h:				 * [ 16-bit ]
asm-m68k/mac_psc.h:				 * bit 6  : Set to one to enable pass-thru
asm-m68k/mac_psc.h: * 0x0202 - 0x0203 is unused. Writing there
asm-m68k/mac_psc.h:				 * [ 32-bit ]
asm-m68k/mac_psc.h:				 * bits 12-15 : input source volume, 0 - F
asm-m68k/mac_psc.h:				 * bits 16-19 : unknown, always 0x5
asm-m68k/mac_psc.h:				 * bits 20-23 : input source selection:
asm-m68k/mac_psc.h:				 * [ 32-bit ]
asm-m68k/mac_psc.h:				 * Appears to be a read-only status register.
asm-m68k/mac_psc.h:				 * [ 16-bit ]
asm-m68k/mac_psc.h:				 * Unknown 16-bit value, always 0x0000.
asm-m68k/mac_psc.h:				 * [ 16-bit ]
asm-m68k/mac_psc.h:				 * [ 32-bit ]
asm-m68k/mac_psc.h:				 * [ 32-bit ]
asm-m68k/mac_psc.h:				 * [ 16-bit ]
asm-m68k/mac_psc.h:				 * Length of both buffers in eight-byte units.
asm-m68k/mac_psc.h:				 * [ 16-bit ]
asm-m68k/mac_psc.h:				 * [ 16-bit ]
asm-m68k/mac_psc.h:				 * Appears to e a read-only status register.
asm-m68k/mac_psc.h:				 * [ 16-bit ]
asm-m68k/atari_acsi.h:/* The ACSI buffer is guarantueed to reside in ST-RAM and may be used by other
asm-m68k/atari_acsi.h: * the ST-DMA is locked. */
asm-m68k/atari_acsi.h: * with one move.l -- Atari recommends this...
asm-m68k/amigayle.h:** asm-m68k/amigayle.h -- This header defines the registers of the gayle chip
asm-m68k/amigayle.h:#define GAYLE_ODD		(GAYLE_IO_8BITODD-GAYLE_IO-1)
asm-m68k/amigayle.h:	u_char pad0[0x1000-1];
asm-m68k/amigayle.h:	u_char pad1[0x1000-1];
asm-m68k/amigayle.h:	u_char pad2[0x1000-1];
asm-m68k/amigayle.h:	u_char pad3[0x1000-1];
asm-m68k/amigayle.h:   (bit 0-1 for program voltage, bit 2-3 for access speed */
asm-m68k/amigayle.h:#endif /* asm-m68k/amigayle.h */
asm-m68k/mac_via.h: *	via them as are assorted bits and bobs - eg rtc, adb. The picture
asm-m68k/mac_via.h:				 * state-control line SEL" on all but IIfx
asm-m68k/mac_via.h:/* Macintosh Family Hardware sez: bits 0-2 of VIA1A are volume control
asm-m68k/mac_via.h: * On IIci,IIfx, bits 1-2 are the rest of the CPU ID:
asm-m68k/mac_via.h: * CHRP sez: VIA1A bits 0-2 and 5 are 'unused': if programmed as
asm-m68k/mac_via.h:#define VIA1B_vRTCClk	0x02    /* Real time clock serial-clock line. */
asm-m68k/mac_via.h:#define VIA1B_vRTCData	0x01    /* Real time clock serial-data line. */
asm-m68k/mac_via.h: * correspond to a VIA work-alike named 'EVR'. */
asm-m68k/mac_via.h: *      defines the 'Video IRQ' as 0x40 for the 'EVR' VIA work-alike.
asm-m68k/mac_via.h:#define VIA2B_vMode32	0x08	/* 24/32bit switch - doubles as cache flush
asm-m68k/mac_via.h: * of the alternate video page for page-flipping animation. Since there
asm-m68k/mac_via.h: *	6522 registers - see databook.
asm-m68k/mac_via.h: * decode the bottom eight -- so vBufB | rBufB will always get you BufB */
asm-m68k/mac_via.h: * Perhaps some sort of 'compatibility mode' is built-in? [21-May-1999]
asm-m68k/mac_via.h:	char val = (bpp==1)?0:(bpp==2)?1:(bpp==4)?2:(bpp==8)?3:-1;
asm-m68k/mac_via.h:	if (!rbv_present || val<0) return -1;
asm-m68k/sockios.h:/* Socket-level I/O control calls. */
asm-m68k/motorola_pgalloc.h:		quicklists.pgtable_cache_sz -= 8;
asm-m68k/motorola_pgalloc.h:		quicklists.pgtable_cache_sz--;
asm-m68k/motorola_pgalloc.h: * flush all user-space atc entries.
asm-m68k/motorola_pgalloc.h: * flush all atc entries (both kernel and user-space entries).
asm-m68k/motorola_pgalloc.h:	if (mm == current->active_mm)
asm-m68k/motorola_pgalloc.h:	if (vma->vm_mm == current->active_mm) {
asm-m68k/motorola_pgalloc.h:	if (mm == current->active_mm)
asm-m68k/mvme16xhw.h:/* Board ID data structure - pointer to this retrieved from Bug by head.S */
asm-m68k/keyboard.h: *  linux/include/asm-m68k/keyboard.h
asm-m68k/keyboard.h:    return -EOPNOTSUPP;
asm-m68k/keyboard.h:    return scancode > 127 ? -EINVAL : scancode;
asm-m68k/ioctl.h: * NOTE: This limits the max parameter size to 16kB -1 !
asm-m68k/ioctl.h:#define _IOC_NRMASK	((1 << _IOC_NRBITS)-1)
asm-m68k/ioctl.h:#define _IOC_TYPEMASK	((1 << _IOC_TYPEBITS)-1)
asm-m68k/ioctl.h:#define _IOC_SIZEMASK	((1 << _IOC_SIZEBITS)-1)
asm-m68k/ioctl.h:#define _IOC_DIRMASK	((1 << _IOC_DIRBITS)-1)
asm-m68k/string.h:			if (--count == 0) {
asm-m68k/string.h:  return(sc - s);
asm-m68k/string.h:        "2:\tsubb %1@-,%2\n\t"  /* *cs - *ct */
asm-m68k/string.h:        "3:\tsubb %1@-,%3\n\t"          /* *cs - *ct */
asm-m68k/string.h: * 680[46]0 doesn't really care due to their copy-back caches.
asm-m68k/string.h: *						10/09/96 - Jes Sorensen
asm-m68k/string.h:      count--;
asm-m68k/string.h:      count -= 2;
asm-m68k/string.h:      temp--;
asm-m68k/string.h:      while (temp--);
asm-m68k/string.h: * copy-back cache.
asm-m68k/string.h: * instruction. My tests showed that this implementation is 35-45%
asm-m68k/string.h: * caveat is that the destination address must be 16-byte aligned.
asm-m68k/string.h: *                                            01/09/96 - Jes Sorensen
asm-m68k/string.h:			       : "a" (sp), "0" (s), "1" ((count - 16) / 16 - 1)
asm-m68k/string.h:		       : "d" (data), "0" (s), "1" (count / 32 - 1)
asm-m68k/string.h: * __builtin_memcpy() does not handle page-sized memcpys very well,
asm-m68k/string.h: * thus following the same assumptions as for page-sized memsets, this
asm-m68k/string.h: * function copies page-sized areas using an unrolled loop, without
asm-m68k/string.h: * as it writes through the data-cache, invalidating the cache-lines
asm-m68k/string.h: * touched. In this way we do not use up the entire data-cache (well,
asm-m68k/string.h: * both source and destination must be 16-byte aligned, if not we fall
asm-m68k/string.h: * back to the generic memcpy function.  - Jes
asm-m68k/string.h:		       : "0" (to), "1" (from) , "2" (count / 32 - 1)
asm-m68k/string.h:		       : "0" (to), "1" (from) , "2" (count / 32 - 1)
asm-m68k/string.h:	  n--;
asm-m68k/string.h:	  n -= 2;
asm-m68k/string.h:	  temp--;
asm-m68k/string.h:	  while (temp--);
asm-m68k/string.h:	  *--cdest = *--csrc;
asm-m68k/string.h:	  n--;
asm-m68k/string.h:	  *--sdest = *--ssrc;
asm-m68k/string.h:	  n -= 2;
asm-m68k/string.h:	  temp--;
asm-m68k/string.h:	    *--ldest = *--lsrc;
asm-m68k/string.h:	  while (temp--);
asm-m68k/string.h:	  *--sdest = *--ssrc;
asm-m68k/string.h:	  *--cdest = *--csrc;
asm-m68k/string.h:	/* Someone else can optimize this, I don't care - tonym@mac.linux-m68k.org */
asm-m68k/string.h:	for(;count>0;count--,ret++)
asm-m68k/ioctls.h:#define TIOCGPTN	_IOR('T',0x30, unsigned int) /* Get Pty Number (of pty-mux device) */
asm-m68k/msgbuf.h: * - 64-bit time_t to solve y2038 problem
asm-m68k/msgbuf.h: * - 2 miscellaneous 32-bit values
asm-m68k/openprom.h:#define LINUX_OPPROM_ENDVM      0x0ff10000    /* I think this is right - tm */
asm-m68k/openprom.h:#define KADB_DEBUGGER_BEGVM     0xffc00000    /* Where kern debugger is in virt-mem */
asm-m68k/openprom.h:	 * Non-maskable interrupt  (nmi) information
asm-m68k/openprom.h:	/* Non-blocking variants. */
asm-m68k/openprom.h:	/* Evaluate a forth string, not different proto for V0 and V2->up. */
asm-m68k/openprom.h:	 * crashes the machine, have to test this. :-)
asm-m68k/openprom.h:	/* v3_cpustart() will start the cpu 'whichcpu' in mmu-context
asm-m68k/socket.h:/* Security levels - as per NRL IPv6 - don't actually do anything */
asm-m68k/socket.h:/* Nast libc5 fixup - bletch */
asm-m68k/socket.h:#define SOCK_RDM	4		/* reliably-delivered message	*/
asm-m68k/macintosh.h: *	Floppy driver magic hook - probably shouldnt be here
asm-m68k/macints.h:** macints.h -- Macintosh Linux interrupt handling structs and prototypes
asm-m68k/macints.h: * has eight indexes (base -> base+7).
asm-m68k/macints.h:/* auto-vector interrupts */
asm-m68k/macints.h:#define IRQ2SLOT(x)	  (x - 47)
asm-mips/ack:addrspace.h: *  32-bit MIPS address spaces
asm-mips/ack:addrspace.h: * 64-bit address conversions
asm-mips/ack:arc/types.h:/* The pointer types.  Note that we're using a 64-bit compiler but all
asm-mips/ack:arc/types.h:   pointer in the ARC structures are only 32-bit, so we need some disgusting
asm-mips/ack:arc/types.h:/* The pointer types.  We're 64-bit and the firmware is also 64-bit, so
asm-mips/ack:asm.h: * away by gas in -O mode. These nops are however required to fill delay
asm-mips/ack:asm.h: * LEAF - declare leaf routine
asm-mips/ack:asm.h: * NESTED - declare nested routine entry point
asm-mips/ack:asm.h: * END - mark end of function
asm-mips/ack:asm.h:		.size	function,.-function
asm-mips/ack:asm.h: * EXPORT - export definition of symbol
asm-mips/ack:asm.h: * FEXPORT - export definition of a function symbol
asm-mips/ack:asm.h: * ABS - export absolute symbol
asm-mips/ack:asm.h: * Macros to handle different pointer/register sizes for 32/64-bit code
asm-mips/ack:atomic.h: * atomic_read - read atomic variable
asm-mips/ack:atomic.h:#define atomic_read(v)	((v)->counter)
asm-mips/ack:atomic.h: * atomic_set - set atomic variable
asm-mips/ack:atomic.h:#define atomic_set(v,i)	((v)->counter = (i))
asm-mips/ack:atomic.h: * atomic_add - add integer to atomic variable
asm-mips/ack:atomic.h:	v->counter += i;
asm-mips/ack:atomic.h: * atomic_sub - subtract the atomic variable
asm-mips/ack:atomic.h:	v->counter -= i;
asm-mips/ack:atomic.h:	temp = v->counter;
asm-mips/ack:atomic.h:	v->counter = temp;
asm-mips/ack:atomic.h:	temp = v->counter;
asm-mips/ack:atomic.h:	temp -= i;
asm-mips/ack:atomic.h:	v->counter = temp;
asm-mips/ack:atomic.h: * atomic_add - add integer to atomic variable
asm-mips/ack:atomic.h:		: "=&r" (temp), "=m" (v->counter)
asm-mips/ack:atomic.h:		: "Ir" (i), "m" (v->counter));
asm-mips/ack:atomic.h: * atomic_sub - subtract the atomic variable
asm-mips/ack:atomic.h:		: "=&r" (temp), "=m" (v->counter)
asm-mips/ack:atomic.h:		: "Ir" (i), "m" (v->counter));
asm-mips/ack:atomic.h:		: "=&r" (result), "=&r" (temp), "=m" (v->counter)
asm-mips/ack:atomic.h:		: "Ir" (i), "m" (v->counter)
asm-mips/ack:atomic.h:		: "=&r" (result), "=&r" (temp), "=m" (v->counter)
asm-mips/ack:atomic.h:		: "Ir" (i), "m" (v->counter)
asm-mips/ack:atomic.h: * atomic_sub_and_test - subtract value from variable and test result
asm-mips/ack:atomic.h: * atomic_inc_and_test - increment and test
asm-mips/ack:atomic.h: * atomic_dec_and_test - decrement by 1 and test
asm-mips/ack:atomic.h: * atomic_inc - increment atomic variable
asm-mips/ack:atomic.h: * atomic_dec - decrement and test
asm-mips/ack:atomic.h: * atomic_add_negative - add and test if negative
asm-mips/ack:au1000_dma.h:	au_writel(DMA_BE0, chan->io + DMA_MODE_SET);
asm-mips/ack:au1000_dma.h:	au_writel(DMA_BE1, chan->io + DMA_MODE_SET);
asm-mips/ack:au1000_dma.h:	au_writel(DMA_BE0 | DMA_BE1, chan->io + DMA_MODE_SET);
asm-mips/ack:au1000_dma.h:	au_writel(DMA_GO, chan->io + DMA_MODE_SET);
asm-mips/ack:au1000_dma.h:	au_writel(DMA_GO, chan->io + DMA_MODE_CLEAR);
asm-mips/ack:au1000_dma.h:		if (au_readl(chan->io + DMA_MODE_READ) & DMA_HALT)
asm-mips/ack:au1000_dma.h:	au_writel(~DMA_GO, chan->io + DMA_MODE_CLEAR);
asm-mips/ack:au1000_dma.h:	return (au_readl(chan->io + DMA_MODE_READ) & DMA_HALT) ? 1 : 0;
asm-mips/ack:au1000_dma.h:	au_writel(PHYSADDR(chan->fifo_addr),
asm-mips/ack:au1000_dma.h:		  chan->io + DMA_PERIPHERAL_ADDR);
asm-mips/ack:au1000_dma.h:	mode = chan->mode | (chan->dev_id << DMA_DID_BIT);
asm-mips/ack:au1000_dma.h:	if (chan->irq)
asm-mips/ack:au1000_dma.h:	au_writel(~mode, chan->io + DMA_MODE_CLEAR);
asm-mips/ack:au1000_dma.h:	au_writel(mode, chan->io + DMA_MODE_SET);
asm-mips/ack:au1000_dma.h:	chan->mode &= ~(DMA_BE | DMA_DR | DMA_TS8 | DMA_DW_MASK | DMA_NC);
asm-mips/ack:au1000_dma.h:	chan->mode |= mode;
asm-mips/ack:au1000_dma.h:	return chan->mode;
asm-mips/ack:au1000_dma.h:		return -1;
asm-mips/ack:au1000_dma.h:	return (au_readl(chan->io + DMA_MODE_READ) & DMA_AB) ? 1 : 0;
asm-mips/ack:au1000_dma.h: * set the device FIFO address for a specific DMA channel - only
asm-mips/ack:au1000_dma.h:	if (chan->mode & DMA_DS)	/* second bank of device ids */
asm-mips/ack:au1000_dma.h:	if (chan->dev_id != DMA_ID_GP04 && chan->dev_id != DMA_ID_GP05)
asm-mips/ack:au1000_dma.h:	au_writel(PHYSADDR(a), chan->io + DMA_PERIPHERAL_ADDR);
asm-mips/ack:au1000_dma.h:	au_writel(DMA_D0, chan->io + DMA_MODE_CLEAR);
asm-mips/ack:au1000_dma.h:	au_writel(DMA_D1, chan->io + DMA_MODE_CLEAR);
asm-mips/ack:au1000_dma.h: * This does nothing - not applicable to Au1000 DMA.
asm-mips/ack:au1000_dma.h:	au_writel(a, chan->io + DMA_BUFFER0_START);
asm-mips/ack:au1000_dma.h:	au_writel(a, chan->io + DMA_BUFFER1_START);
asm-mips/ack:au1000_dma.h:	au_writel(count, chan->io + DMA_BUFFER0_COUNT);
asm-mips/ack:au1000_dma.h:	au_writel(count, chan->io + DMA_BUFFER1_COUNT);
asm-mips/ack:au1000_dma.h:	au_writel(count, chan->io + DMA_BUFFER0_COUNT);
asm-mips/ack:au1000_dma.h:	au_writel(count, chan->io + DMA_BUFFER1_COUNT);
asm-mips/ack:au1000_dma.h: * Returns -1 if neither or both done bits set.
asm-mips/ack:au1000_dma.h:    return au_readl(chan->io + DMA_MODE_READ) & (DMA_D0 | DMA_D1);
asm-mips/ack:au1000_dma.h:		return -1;
asm-mips/ack:au1000_dma.h:	return chan->irq;
asm-mips/ack:au1000_dma.h:	curBufCntReg = (au_readl(chan->io + DMA_MODE_READ) & DMA_AB) ?
asm-mips/ack:au1000_dma.h:	count = au_readl(chan->io + curBufCntReg) & DMA_COUNT_MASK;
asm-mips/ack:au1000_dma.h:	if ((chan->mode & DMA_DW_MASK) == DMA_DW16)
asm-mips/ack:au1000_dma.h:	else if ((chan->mode & DMA_DW_MASK) == DMA_DW32)
asm-mips/ack:au1000_gpio.h:#define NOT_AVAIL		(-1)
asm-mips/ack:au1000_gpio.h:#define MINOR_TO_GPIOPIN(minor)		((minor < AU1X00_MAX_PRIMARY_GPIO) ? minor : (minor - AU1X00_MAX_PRIMARY_GPIO))
asm-mips/ack:au1000_gpio.h: * GPIO0-GPIO31, minor=0-31.
asm-mips/ack:au1000_gpio.h: * GPIO200-GPIO215, minor=32-47.
asm-mips/ack:au1000_gpio.h:	int data;	// Pin output when itized (0/1), or at the term. 0/1/-1 (tristate).
asm-mips/ack:au1000.h: * Taken from PPC tree.  -- Dan
asm-mips/ack:au1000.h:	return 31 - lz;
asm-mips/ack:au1000.h:	return __ilog2(x & -x);
asm-mips/ack:au1000.h:	return __ilog2(x & -x) + 1;
asm-mips/ack:au1000.h:/* UARTS 0-3 */
asm-mips/ack:au1000.h:#define UART_LSR_THRE	0x20	/* Transmit-hold-register empty */
asm-mips/ack:au1000.h:#define SSI_CONFIG_ALEN_N(N)		((N-1)<<20)
asm-mips/ack:au1000.h:#define SSI_CONFIG_DLEN_N(N)		((N-1)<<16)
asm-mips/ack:au1000.h:  /* FIXME - double check this from asm-ppc/pci-bridge.h */
asm-mips/ack:au1000.h:  ({ long _ctl_ = -1;                                 \
asm-mips/ack:au1000.h:	       _ctl_ = pci_irq_table[idsel - min_idsel][pin-1];               \
asm-mips/ack:au1000_pcmcia.h: *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm-mips/ack:au1000_pcmcia.h: * These really belong in a board-specific header file...
asm-mips/ack:au1000_usbdev.h: *	Au1000 USB Device-Side Driver
asm-mips/ack:au1100_mmc.h: * From "AMD Alchemy Solutions Au1100 Processor Data Book - Preliminary"
asm-mips/ack:au1100_mmc.h:/* support routines required on a platform-specific basis */
asm-mips/ack:au1xxx_dbdma.h:/* Specifics for the Au1xxx Descriptor-Based DMA Controllers, first
asm-mips/ack:au1xxx_dbdma.h:	u32	ddma_desptr;	/* 32-byte aligned pointer to descriptor */
asm-mips/ack:au1xxx_dbdma.h:#define DDMA_CFG_DFN	(1 << 3)	/* Descriptor fetch non-coherent */
asm-mips/ack:au1xxx_dbdma.h: * Must be 32-byte aligned.
asm-mips/ack:au1xxx_dbdma.h:#define DSCR_CMD0_MEM		(1 << 30)	/* mem-mem transfer */
asm-mips/ack:au1xxx_dbdma.h:#define DSCR_CMD0_SN		(0x1 << 12)	/* Source non-coherent */
asm-mips/ack:au1xxx_dbdma.h:#define DSCR_CMD0_DN		(0x1 << 11)	/* Destination non-coherent */
asm-mips/ack:au1xxx_dbdma.h:/* Source1, 1-dimensional stride.
asm-mips/ack:au1xxx_dbdma.h:/* Dest1, 1-dimensional stride.
asm-mips/ack:au1xxx_dbdma.h: 	Some compatibilty macros --
asm-mips/ack:au1xxx_psc.h:/* Enable slots 3-12.
asm-mips/ack:au1xxx_psc.h:#define PSC_AC97CFG_TXSLOT_ENA(x)	(1 << (((x) - 3) + 11))
asm-mips/ack:au1xxx_psc.h:#define PSC_AC97CFG_RXSLOT_ENA(x)	(1 << (((x) - 3) + 1))
asm-mips/ack:au1xxx_psc.h:#define PSC_AC97CFG_SET_LEN(x)	(((((x)-2)/2) & 0xf) << 21)
asm-mips/ack:au1xxx_psc.h:#define PSC_I2SCFG_SET_WS(x)	(((((x) / 2) - 1) & 0x7f) << 16)
asm-mips/ack:au1xxx_psc.h:#define PSC_I2SCFG_SET_LEN(x)	((((x) - 1) & 0x1f) << 4)
asm-mips/ack:au1xxx_psc.h:#define PSC_SPICFG_SET_LEN(x)	(((x-1) & 0x1f) << 4)
asm-mips/ack:baget/vac.h:#define    VAC_CTRL_RECOVERY_IOSELI(x) ((((x)-1)&7)<<8)
asm-mips/ack:baget/vac.h:#define    VAC_CTRL_DELAY_DSACKI(x)    ((((x)-1)&7)<<13)
asm-mips/ack:baget/vic.h:#define    VIC_LOCAL_TIM_PAS_ASSERT(x)   (((x)-2)&0xf)
asm-mips/ack:baget/vic.h:#define    VIC_LOCAT_TIM_DS_DEASSERT(x)  ((((x)-1)&1)<<4)
asm-mips/ack:baget/vic.h:#define    VIC_LOCAL_TIM_PAS_DEASSERT(x) ((((x)-1)&0x7)<<5)
asm-mips/ack:baget/baget.h:#define BAGET_A24M_BASE       0xFC000000      /* VME-master A24 base address  */
asm-mips/ack:baget/baget.h:#define BAGET_A24S_BASE       0x00000000      /* VME-slave A24 base address   */
asm-mips/ack:baget/baget.h:#define BAGET_A24S_MASK       0x00c00000      /* VME-slave A24 address mask   */
asm-mips/ack:baget/baget.h:#define BAGET_IRQ_MASK(x)       ((NR_IRQS-1) & (x))
asm-mips/ack:bcache.h:/* Some R4000 / R4400 / R4600 / R5000 machines may have a non-dma-coherent,
asm-mips/ack:bcache.h:	bcops->bc_enable();
asm-mips/ack:bcache.h:	bcops->bc_disable();
asm-mips/ack:bcache.h:	bcops->bc_wback_inv(page, size);
asm-mips/ack:bcache.h:	bcops->bc_inv(page, size);
asm-mips/ack:bitops.h: * Copyright (c) 1994 - 1997, 1999, 2000  Ralf Baechle (ralf@gnu.org)
asm-mips/ack:bitops.h: * set_bit - Atomically set a bit in memory
asm-mips/ack:bitops.h: * restricted to acting on a single-word quantity.
asm-mips/ack:bitops.h: * __set_bit - Set a bit in memory
asm-mips/ack:bitops.h: * Unlike set_bit(), this function is non-atomic and may be reordered.
asm-mips/ack:bitops.h: * clear_bit - Clears a bit in memory
asm-mips/ack:bitops.h: * change_bit - Toggle a bit in memory
asm-mips/ack:bitops.h: * restricted to acting on a single-word quantity.
asm-mips/ack:bitops.h: * __change_bit - Toggle a bit in memory
asm-mips/ack:bitops.h: * Unlike change_bit(), this function is non-atomic and may be reordered.
asm-mips/ack:bitops.h: * test_and_set_bit - Set a bit and return its old value
asm-mips/ack:bitops.h: * __test_and_set_bit - Set a bit and return its old value
asm-mips/ack:bitops.h: * This operation is non-atomic and can be reordered.
asm-mips/ack:bitops.h: * test_and_clear_bit - Clear a bit and return its old value
asm-mips/ack:bitops.h: * __test_and_clear_bit - Clear a bit and return its old value
asm-mips/ack:bitops.h: * This operation is non-atomic and can be reordered.
asm-mips/ack:bitops.h: * test_and_change_bit - Change a bit and return its new value
asm-mips/ack:bitops.h: * __test_and_change_bit - Change a bit and return its old value
asm-mips/ack:bitops.h: * This operation is non-atomic and can be reordered.
asm-mips/ack:bitops.h: * set_bit - Atomically set a bit in memory
asm-mips/ack:bitops.h: * restricted to acting on a single-word quantity.
asm-mips/ack:bitops.h: * __set_bit - Set a bit in memory
asm-mips/ack:bitops.h: * Unlike set_bit(), this function is non-atomic and may be reordered.
asm-mips/ack:bitops.h: * clear_bit - Clears a bit in memory
asm-mips/ack:bitops.h: * change_bit - Toggle a bit in memory
asm-mips/ack:bitops.h: * restricted to acting on a single-word quantity.
asm-mips/ack:bitops.h: * __change_bit - Toggle a bit in memory
asm-mips/ack:bitops.h: * Unlike change_bit(), this function is non-atomic and may be reordered.
asm-mips/ack:bitops.h: * test_and_set_bit - Set a bit and return its old value
asm-mips/ack:bitops.h: * __test_and_set_bit - Set a bit and return its old value
asm-mips/ack:bitops.h: * This operation is non-atomic and can be reordered.
asm-mips/ack:bitops.h: * test_and_clear_bit - Clear a bit and return its old value
asm-mips/ack:bitops.h: * __test_and_clear_bit - Clear a bit and return its old value
asm-mips/ack:bitops.h: * This operation is non-atomic and can be reordered.
asm-mips/ack:bitops.h: * test_and_change_bit - Change a bit and return its new value
asm-mips/ack:bitops.h: * __test_and_change_bit - Change a bit and return its old value
asm-mips/ack:bitops.h: * This operation is non-atomic and can be reordered.
asm-mips/ack:bitops.h: * test_bit - Determine whether a bit is set
asm-mips/ack:bitops.h: * ffz - find first zero in word.
asm-mips/ack:bitops.h: * ffs - find first bit set
asm-mips/ack:bitops.h: * find_next_zero_bit - find the first zero bit in a memory region
asm-mips/ack:bitops.h:	size -= result;
asm-mips/ack:bitops.h:		tmp |= ~0UL >> (32-offset);
asm-mips/ack:bitops.h:		size -= 32;
asm-mips/ack:bitops.h:		size -= 32;
asm-mips/ack:bitops.h:#if 0 /* Fool kernel-doc since it doesn't do macros yet */
asm-mips/ack:bitops.h: * find_first_zero_bit - find the first zero bit in a memory region
asm-mips/ack:bitops.h: * Returns the bit-number of the first zero bit, not the number of the byte
asm-mips/ack:bitops.h: * hweightN - returns the hamming weight of a N-bit word
asm-mips/ack:bitops.h:	size -= result;
asm-mips/ack:bitops.h:		tmp |= ~0U >> (32-offset); /* bug or feature ? */
asm-mips/ack:bitops.h:		size -= 32;
asm-mips/ack:bitops.h:		size -= 32;
asm-mips/ack:bootinfo.h:#define MACH_GROUP_TITAN       22 /* PMC-Sierra Titan 			    */
asm-mips/ack:bootinfo.h:#define MACH_ACER_PICA_61	0	/* Acer PICA-61 (PICA1)		*/
asm-mips/ack:bootinfo.h:#define MACH_OLIVETTI_M700      2	/* Olivetti M700-10 (-15 ??)    */
asm-mips/ack:bootinfo.h:#define MACH_NEC_DDB5074	0	/* NEC DDB Vrc-5074 */
asm-mips/ack:bootinfo.h:#define MACH_NEC_DDB5476	1	/* NEC DDB Vrc-5476 */
asm-mips/ack:bootinfo.h:#define MACH_NEC_DDB5477	2	/* NEC DDB Vrc-5477 */
asm-mips/ack:bootinfo.h:#define MACH_BAGET201		0	/* BT23-201 */
asm-mips/ack:bootinfo.h:#define MACH_BAGET202		1	/* BT23-202 */
asm-mips/ack:bootinfo.h:#define MACH_TOSHIBA_JMR3927	3	/* JMR-TX3927 CPU/IO board */
asm-mips/ack:bootinfo.h:#define MACH_PB1000		0	/* Au1000-based eval board */
asm-mips/ack:bootinfo.h:#define MACH_PB1100		1	/* Au1100-based eval board */
asm-mips/ack:bootinfo.h:#define MACH_PB1500		2	/* Au1500-based eval board */
asm-mips/ack:bootinfo.h:#define MACH_DB1000		3       /* Au1000-based eval board */
asm-mips/ack:bootinfo.h:#define MACH_DB1100		4       /* Au1100-based eval board */
asm-mips/ack:bootinfo.h:#define MACH_DB1500		5       /* Au1500-based eval board */
asm-mips/ack:bootinfo.h:#define MACH_XXS1500		6       /* Au1500-based eval board */
asm-mips/ack:bootinfo.h:#define MACH_MTX1		7	/* 4G MTX-1 Au1500-based board */
asm-mips/ack:bootinfo.h:#define MACH_PB1550     	9       /* Au1550-based eval board */
asm-mips/ack:bootinfo.h:#define MACH_PB1200     	10      /* Au1200-based eval board */
asm-mips/ack:bootinfo.h:#define MACH_DB1550     	11      /* Au1550-based eval board */
asm-mips/ack:bootinfo.h:#define MACH_DB1200     	12      /* Au1200-based eval board */
asm-mips/ack:bootinfo.h:#define MACH_VICTOR_MPC30X	3	/* Victor MP-C303/304 */
asm-mips/ack:bootinfo.h:#define MACH_CASIO_E55		5	/* CASIO CASSIOPEIA E-10/15/55/65 */
asm-mips/ack:bootinfo.h:#define	MACH_TITAN_YOSEMITE	1 	/* PMC-Sierra Yosemite */
asm-mips/ack:branch.h:	return regs->cp0_cause & CAUSEF_BD;
asm-mips/ack:branch.h:		return regs->cp0_epc;
asm-mips/ack:branch.h:	return regs->cp0_epc + 4;
asm-mips/ack:branch.h:		regs->cp0_epc += 4;
asm-mips/ack:break.h: * non-Linux/MIPS object files or make use of them in the future.
asm-mips/ack:break.h:#define BRK_BD_TAKEN	3	/* For bd slot emulation - not implemented */
asm-mips/ack:break.h:#define BRK_BD_NOTTAKEN	4	/* For bd slot emulation - not implemented */
asm-mips/ack:break.h:#define BRK_NORLD	10	/* No rld found - not used by Linux/MIPS */
asm-mips/ack:bugs.h: * This is included by init/main.c to check for architecture-dependent bugs.
asm-mips/ack:cachectl.h: * cachectl.h -- defines for MIPS cache control system calls
asm-mips/ack:cacheflush.h: *  - flush_cache_all() flushes entire cache
asm-mips/ack:cacheflush.h: *  - flush_cache_mm(mm) flushes the specified mm context's cache lines
asm-mips/ack:cacheflush.h: *  - flush_cache_page(mm, vmaddr) flushes a single page
asm-mips/ack:cacheflush.h: *  - flush_cache_range(mm, start, end) flushes a range of pages
asm-mips/ack:cacheflush.h: *  - flush_page_to_ram(page) write back kernel page to ram
asm-mips/ack:cacheflush.h: *  - flush_icache_range(start, end) flush a range of instructions
asm-mips/ack:cacheflush.h: *  - flush_cache_sigtramp() flush signal trampoline
asm-mips/ack:cacheflush.h: *  - flush_icache_all() flush the entire instruction cache
asm-mips/ack:cacheflush.h: *  - flush_data_cache_page() flushes a page from the data cache
asm-mips/ack:cacheops.h: * Cache Operations available on all MIPS processors with R4000-style caches
asm-mips/ack:cacheops.h: * R4000-specific cacheops
asm-mips/ack:cacheops.h: * R4000SC and R4400SC-specific cacheops
asm-mips/ack:cacheops.h: * R5000-specific cacheops
asm-mips/ack:cacheops.h: * RM7000-specific cacheops
asm-mips/ack:cacheops.h: * R1000-specific cacheops
asm-mips/ack:cacheops.h: * Cacheops 0x02, 0x06, 0x0a, 0x0c-0x0e, 0x16, 0x1a and 0x1e are unused.
asm-mips/ack:checksum.h: * and adds in "sum" (32-bit)
asm-mips/ack:checksum.h: * returns a 32-bit number suitable for feeding into itself
asm-mips/ack:checksum.h: * it's best to have buff aligned on a 32-bit boundary
asm-mips/ack:checksum.h:		*err_ptr = -EFAULT;
asm-mips/ack:checksum.h:		return -1;
asm-mips/ack:checksum.h: * computes the checksum of the TCP/UDP pseudo-header
asm-mips/ack:checksum.h: * returns a 16-bit checksum, already complemented
asm-mips/ack:checksum.h: * this routine is used for miscellaneous IP-like checksums, mainly
asm-mips/ack:cpu.h:  +----------------+----------------+----------------+----------------+
asm-mips/ack:cpu.h:  +----------------+----------------+----------------+----------------+
asm-mips/ack:cpu.h:   that bits 16-23 have been 0 for all MIPS processors before the MIPS32/64
asm-mips/ack:cpu.h: * +---------------------------------+----------------+----------------+
asm-mips/ack:cpu.h: * +---------------------------------+----------------+----------------+
asm-mips/ack:cpu.h: * Bit 15 encodes if an ISA level supports 64-bit operations.
asm-mips/ack:cpu.h:#define MIPS_CPU_SUBSET_CACHES	0x00020000 /* P-cache subset enforced */
asm-mips/ack:csb250.h: *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm-mips/ack:db1200.h: *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm-mips/ack:db1200.h: *    *example: IDE bis pos is  = 64 - 64
asm-mips/ack:db1200.h:                ETH bit pos is  = 65 - 64
asm-mips/ack:db1200.h:#define BOARD_CARD_INSERTED(SOCKET) bcsr->sig_status & (1<<(8+(2*SOCKET)))
asm-mips/ack:db1x00.h: *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm-mips/ack:db1x00.h:#define BOARD_CARD_INSERTED(SOCKET) !(bcsr->status & (1<<(4+SOCKET)))
asm-mips/ack:db1x00.h:#define BOARD_CARD_INSERTED(SOCKET) !(bcsr->status & (1<<(4+SOCKET)))
asm-mips/ack:ddb5074.h: *  include/asm-mips/ddb5074.h -- NEC DDB Vrc-5074 definitions
asm-mips/ack:ddb5xxx/ddb5074.h: *  include/asm-mips/ddb5074.h -- NEC DDB Vrc-5074 definitions
asm-mips/ack:ddb5xxx/ddb5476.h:#define	DDB_DCS5_SIZE		0x00200000	/* 2MB, 8-bit */
asm-mips/ack:ddb5xxx/ddb5476.h:#define	DDB_DCS4_SIZE		0x00200000	/* 2MB, 8-bit */
asm-mips/ack:ddb5xxx/ddb5476.h:#define DDB_BOOTCS_SIZE         0x00200000      /* 2 MB - doc says 4MB */
asm-mips/ack:ddb5xxx/ddb5476.h: *   . CPU itself - 8 sources
asm-mips/ack:ddb5xxx/ddb5476.h: *   . i8259 - 16 sources
asm-mips/ack:ddb5xxx/ddb5476.h: *   . vrc5476 - 16 sources
asm-mips/ack:ddb5xxx/ddb5476.h: *  All VRC5476 PCI interrupts are level-triggered (no ack needed).
asm-mips/ack:ddb5xxx/ddb5476.h: * vrc5476 irq defs, see page 52-64 of Vrc5074 system controller manual
asm-mips/ack:ddb5xxx/ddb5476.h:#define irq_to_nile4(n)         ((n)-NUM_I8259_IRQ)
asm-mips/ack:ddb5xxx/ddb5476.h: * low-level irq functions
asm-mips/ack:ddb5xxx/ddb5477.h: * include/asm-mips/ddb5xxx/ddb5477.h
asm-mips/ack:ddb5xxx/ddb5477.h:#undef  DDB_CPUSTAT		/* duplicate in Vrc-5477 */
asm-mips/ack:ddb5xxx/ddb5477.h:#define	DDB_PCICTL0_L	0x02e0	/* PCI0 Control-L */
asm-mips/ack:ddb5xxx/ddb5477.h:#define	DDB_PCICTL0_H	0x02e4	/* PCI0 Control-H */
asm-mips/ack:ddb5xxx/ddb5477.h:#define	DDB_PCIARB0_L	0x02e8	/* PCI0 Arbitration-L */
asm-mips/ack:ddb5xxx/ddb5477.h:#define	DDB_PCIARB0_H	0x02ec	/* PCI0 Arbitration-H */
asm-mips/ack:ddb5xxx/ddb5477.h:#define	DDB_PCICTL1_L	0x06e0	/* PCI1 Control-L */
asm-mips/ack:ddb5xxx/ddb5477.h:#define	DDB_PCICTL1_H	0x06e4	/* PCI1 Control-H */
asm-mips/ack:ddb5xxx/ddb5477.h:#define	DDB_PCIARB1_L	0x06e8	/* PCI1 Arbitration-L */
asm-mips/ack:ddb5xxx/ddb5477.h:#define	DDB_PCIARB1_H	0x06ec	/* PCI1 Arbitration-H */
asm-mips/ack:ddb5xxx/ddb5477.h:#define DDB_GIUFUNSEL	0x4040  /* select dual-func pins */
asm-mips/ack:ddb5xxx/ddb5477.h:/* the actual ram size is detected at run-time */
asm-mips/ack:ddb5xxx/ddb5477.h:#define	DDB_BOOTCS_SIZE		0x00200000	/* 2 MB - doc says 4MB */
asm-mips/ack:ddb5xxx/ddb5477.h:/* low-level routine for enabling vrc5477 irq, bypassing high-level */
asm-mips/ack:ddb5xxx/ddb5477.h: *   . CPU itself - 8 sources
asm-mips/ack:ddb5xxx/ddb5477.h: *   . i8259 - 16 sources
asm-mips/ack:ddb5xxx/ddb5477.h: *   . vrc5477 - 32 sources
asm-mips/ack:ddb5xxx/ddb5477.h: *  All VRC5477 PCI interrupts are level-triggered (no ack needed).
asm-mips/ack:ddb5xxx/ddb5477.h:#define VRC5477_IRQ_IOPCI_INTA	(16 + VRC5477_IRQ_BASE)      /* USB-H */
asm-mips/ack:ddb5xxx/ddb5477.h:#define VRC5477_IRQ_IOPCI_INTB	(17 + VRC5477_IRQ_BASE)      /* USB-P */
asm-mips/ack:ddb5xxx/ddb5477.h:#define	VRC5477_I8259_CASCADE	(VRC5477_IRQ_INTC - VRC5477_IRQ_BASE)
asm-mips/ack:ddb5xxx/ddb5xxx.h: * include/asm-mips/ddb5xxx/ddb5xxx.h
asm-mips/ack:ddb5xxx/ddb5xxx.h: *	uPD31577(VRC5477) VR5432-SDRAM/PCI Bridge (Luke)
asm-mips/ack:ddb5xxx/ddb5xxx.h:#define DDB_DCS2	0x0010	/* Device Chip-Select 2 [R/W] */
asm-mips/ack:ddb5xxx/ddb5xxx.h:#define DDB_DCS3	0x0018	/* Device Chip-Select 3 [R/W] */
asm-mips/ack:ddb5xxx/ddb5xxx.h:#define DDB_DCS4	0x0020	/* Device Chip-Select 4 [R/W] */
asm-mips/ack:ddb5xxx/ddb5xxx.h:#define DDB_DCS5	0x0028	/* Device Chip-Select 5 [R/W] */
asm-mips/ack:ddb5xxx/ddb5xxx.h:#define DDB_DCS6	0x0030	/* Device Chip-Select 6 [R/W] */
asm-mips/ack:ddb5xxx/ddb5xxx.h:#define DDB_DCS7	0x0038	/* Device Chip-Select 7 [R/W] */
asm-mips/ack:ddb5xxx/ddb5xxx.h:#define DDB_DCS8	0x0040	/* Device Chip-Select 8 [R/W] */
asm-mips/ack:ddb5xxx/ddb5xxx.h:#define DDB_BOOTCS	0x0078	/* Boot ROM Chip-Select [R/W] */
asm-mips/ack:ddb5xxx/ddb5xxx.h: *  Memory-Interface Registers
asm-mips/ack:ddb5xxx/ddb5xxx.h: *  PCI-Bus Registers
asm-mips/ack:ddb5xxx/ddb5xxx.h: *  Local-Bus Registers
asm-mips/ack:ddb5xxx/ddb5xxx.h:#define DDB_LCST2	0x0110	/* Local Bus Chip-Select Timing 2 [R/W] */
asm-mips/ack:ddb5xxx/ddb5xxx.h:#define DDB_LCST3	0x0118	/* Local Bus Chip-Select Timing 3 [R/W] */
asm-mips/ack:ddb5xxx/ddb5xxx.h:#define DDB_LCST4	0x0120	/* Local Bus Chip-Select Timing 4 [R/W] */
asm-mips/ack:ddb5xxx/ddb5xxx.h:#define DDB_LCST5	0x0128	/* Local Bus Chip-Select Timing 5 [R/W] */
asm-mips/ack:ddb5xxx/ddb5xxx.h:#define DDB_LCST6	0x0130	/* Local Bus Chip-Select Timing 6 [R/W] */
asm-mips/ack:ddb5xxx/ddb5xxx.h:#define DDB_LCST7	0x0138	/* Local Bus Chip-Select Timing 7 [R/W] */
asm-mips/ack:ddb5xxx/ddb5xxx.h:#define DDB_LCST8	0x0140	/* Local Bus Chip-Select Timing 8 [R/W] */
asm-mips/ack:ddb5xxx/ddb5xxx.h:#define DDB_DCSFN	0x0150	/* Device Chip-Select Muxing and Output */
asm-mips/ack:ddb5xxx/ddb5xxx.h:#define DDB_DCSIO	0x0158	/* Device Chip-Selects As I/O Bits [R/W] */
asm-mips/ack:ddb5xxx/ddb5xxx.h:#define DDB_BCST	0x0178	/* Local Boot Chip-Select Timing [R/W] */
asm-mips/ack:ddb5xxx/ddb5xxx.h:#define DDB_T1CTRL	0x01D0	/* CPU-Bus Read Time-Out Control [R/W] */
asm-mips/ack:ddb5xxx/ddb5xxx.h:#define DDB_T1CNTR	0x01D8	/* CPU-Bus Read Time-Out Counter [R/W] */
asm-mips/ack:ddb5xxx/ddb5xxx.h:#define DDB_T2CTRL	0x01E0	/* General-Purpose Timer Control [R/W] */
asm-mips/ack:ddb5xxx/ddb5xxx.h:#define DDB_T2CNTR	0x01E8	/* General-Purpose Timer Counter [R/W] */
asm-mips/ack:ddb5xxx/ddb5xxx.h:#define DDB_SSVID	0x022C	/* PCI Sub-System Vendor ID [R/W] */
asm-mips/ack:ddb5xxx/ddb5xxx.h:#define DDB_SSID	0x022E	/* PCI Sub-System ID [R/W] */
asm-mips/ack:debug.h: * Debug macros for run-time debugging.  Turned on/off with 
asm-mips/ack:debug.h: * run-time macros for catching spurious errors.  Eable CONFIG_RUNTIME_DEBUG in
asm-mips/ack:debug.h: * Use them as run-time debugging aid.  NEVER USE THEM AS ERROR HANDLING CODE!!!
asm-mips/ack:dec/tc.h: * of the first card not in use or -ENODEV
asm-mips/ack:dec/kn230.h: *	include/asm-mips/dec/kn230.h
asm-mips/ack:dec/ecc.h: *	include/asm-mips/dec/ecc.h
asm-mips/ack:dec/ecc.h: * The register is r/wc -- any write clears it.
asm-mips/ack:dec/ecc.h: * from the last memory read.  The register is r/wc -- any write clears it.
asm-mips/ack:dec/kn02ba.h: *	include/asm-mips/dec/kn02ba.h
asm-mips/ack:dec/kn02ba.h: *	DECstation 5000/1xx (3min or KN02-BA) definitions.
asm-mips/ack:dec/kn02ba.h: * I/O ASIC interrupt bits.  Star marks denote non-IRQ status bits.
asm-mips/ack:dec/kn02ca.h: *	include/asm-mips/dec/kn02ca.h
asm-mips/ack:dec/kn02ca.h: *	Personal DECstation 5000/xx (Maxine or KN02-CA) definitions.
asm-mips/ack:dec/kn02ca.h: * I/O ASIC interrupt bits.  Star marks denote non-IRQ status bits.
asm-mips/ack:dec/kn02ca.h:#define KN02CA_IO_INR_POWERON	13	/* (*) ACCESS.Bus/power-on reset */
asm-mips/ack:dec/kn02xa.h: * The rest is defined in system-specific headers.
asm-mips/ack:dec/kn02xa.h: * The rest is defined in system-specific headers.
asm-mips/ack:dec/interrupts.h: * with the machine-specific interrupt routines.
asm-mips/ack:dec/interrupts.h:#define DEC_IRQ_TC5		DEC_IRQ_ASC	/* virtual PMAZ-AA */
asm-mips/ack:dec/interrupts.h:#define DEC_IRQ_TC6		DEC_IRQ_LANCE	/* virtual PMAD-AA */
asm-mips/ack:dec/ioasic_addrs.h:#define IO_REG_SCSI_SCR		0x1b0	/* SCSI Partial-Word DMA Control */
asm-mips/ack:dec/ioasic_addrs.h:#define IO_REG_FCTR		0x1e0	/* Free-Running Counter */
asm-mips/ack:dec/ioasic_addrs.h: * The lower 16 bits are system-specific.  Bits 15,11:8 are common and
asm-mips/ack:dec/ioasic_addrs.h: * defined here.  The rest is defined in system-specific headers.
asm-mips/ack:dec/kn01.h:#define KN01_CSR_STATUS		(1<<14)	/* self-test result status output */
asm-mips/ack:dec/kn03.h: * I/O ASIC interrupt bits.  Star marks denote non-IRQ status bits.
asm-mips/ack:dec/kn05.h: *	include/asm-mips/dec/kn05.h
asm-mips/ack:dec/kn05.h: * The register appears read-only.
asm-mips/ack:dec/rtc-dec.h: *	include/asm-mips/dec/rtc-dec.h
asm-mips/ack:dec/tcmodule.h: * EK-TCAAD-FS-004
asm-mips/ack:dec/serial.h: *	include/asm-mips/dec/serial.h
asm-mips/ack:dec/ioasic.h: *	include/asm-mips/dec/ioasic.h
asm-mips/ack:dec/tcinfo.h: * EK-TCAAD-FS-004
asm-mips/ack:dec/ioasic_ints.h: * The lower 16 bits are system-specific and thus defined in
asm-mips/ack:dec/ioasic_ints.h: * system-specific headers.
asm-mips/ack:delay.h: * Copyright (C) 1995 - 1998, 2001 by Ralf Baechle
asm-mips/ack:div64.h:		" addiu	%4, %4, -1\n\t" \
asm-mips/ack:dma.h: *  controller 1: channels 0-3, byte operations, ports 00-1F
asm-mips/ack:dma.h: *  controller 2: channels 4-7, word operations, ports C0-DF
asm-mips/ack:dma.h: *  - ALL registers are 8 bits only, regardless of transfer size
asm-mips/ack:dma.h: *  - channel 4 is not used - cascades 1 into 2.
asm-mips/ack:dma.h: *  - channels 0-3 are byte - addresses/counts are for physical bytes
asm-mips/ack:dma.h: *  - channels 5-7 are word - addresses/counts are for physical words
asm-mips/ack:dma.h: *  - transfers must not cross physical 64K (0-3) or 128K (5-7) boundaries
asm-mips/ack:dma.h: *  - transfer count loaded to registers is 1 less than actual count
asm-mips/ack:dma.h: *  - controller 2 offsets are all even (2x offsets for controller 1)
asm-mips/ack:dma.h: *  - page registers for 5-7 don't use data bit 0, represent 128K pages
asm-mips/ack:dma.h: *  - page registers for 0-3 use bit 0, represent 64K pages
asm-mips/ack:dma.h: *  Address mapping for channels 0-3:
asm-mips/ack:dma.h: *  Address mapping for channels 5-7:
asm-mips/ack:dma.h: * Again, channels 5-7 transfer _physical_ words (16 bits), so addresses
asm-mips/ack:dma.h: * and counts _must_ be word-aligned (the lowest address bit is _ignored_ at
asm-mips/ack:dma.h: * the hardware level, so odd-byte transfers aren't possible).
asm-mips/ack:dma.h: * count - 1 : 64K => 0xFFFF, 1 => 0x0000.  Thus, count is always 1 or more,
asm-mips/ack:dma.h: * and up to 128K bytes may be transferred on channels 5-7 in one operation.
asm-mips/ack:dma.h:#define DMA1_MASK_REG		0x0A	/* single-channel mask (w) */
asm-mips/ack:dma.h:#define DMA1_CLEAR_FF_REG	0x0C	/* clear pointer flip-flop (w) */
asm-mips/ack:dma.h:#define DMA1_MASK_ALL_REG       0x0F    /* all-channels mask (w) */
asm-mips/ack:dma.h:#define DMA2_MASK_REG		0xD4	/* single-channel mask (w) */
asm-mips/ack:dma.h:#define DMA2_CLEAR_FF_REG	0xD8	/* clear pointer flip-flop (w) */
asm-mips/ack:dma.h:#define DMA2_MASK_ALL_REG       0xDE    /* all-channels mask (w) */
asm-mips/ack:dma.h:#define DMA_MODE_CASCADE 0xC0   /* pass thru DREQ->HRQ, DACK<-HLDA only */
asm-mips/ack:dma.h: * After that, keep track of it. :-)
asm-mips/ack:dma.h: * --- In order to do that, the DMA routines below should ---
asm-mips/ack:dma.h: * --- only be used while holding the DMA lock ! ---
asm-mips/ack:dma.h: * Assumes dma flip-flop is clear.
asm-mips/ack:dma.h: * NOTE 2: "count" represents _bytes_ and must be even for channels 5-7.
asm-mips/ack:dma.h:        count--;
asm-mips/ack:dma.h: * Assumes DMA flip-flop is clear.
asm-mips/ack:dma.h:	/* using short to get 16-bit wrap around */
asm-mips/ack:ds1286.h: * mc146818rtc.h - register definitions for the Real-Time-Clock / CMOS RAM
asm-mips/ack:ds1286.h: * Copyright Torsten Duwe <duwe@informatik.uni-erlangen.de> 1993
asm-mips/ack:elf.h:#define EF_MIPS_ARCH_1      0x00000000  /* -mips1 code.  */
asm-mips/ack:elf.h:#define EF_MIPS_ARCH_2      0x10000000  /* -mips2 code.  */
asm-mips/ack:elf.h:#define EF_MIPS_ARCH_3      0x20000000  /* -mips3 code.  */
asm-mips/ack:elf.h:#define EF_MIPS_ARCH_4      0x30000000  /* -mips4 code.  */
asm-mips/ack:elf.h:#define EF_MIPS_ARCH_5      0x40000000  /* -mips5 code.  */
asm-mips/ack:elf.h:	if (__h->e_machine != EM_MIPS)					\
asm-mips/ack:elf.h:	if (__h->e_ident[EI_CLASS] != ELFCLASS32)			\
asm-mips/ack:elf.h:	if ((__h->e_flags & EF_MIPS_ABI2) != 0)				\
asm-mips/ack:elf.h:	if (((__h->e_flags & EF_MIPS_ABI) != 0) &&			\
asm-mips/ack:elf.h:	    ((__h->e_flags & EF_MIPS_ABI) != EF_MIPS_ABI_O32))		\
asm-mips/ack:elf.h:#define irix_elf_check_arch(hdr)	((hdr)->e_machine == EM_MIPS)
asm-mips/ack:elf.h: * See comments in asm-alpha/elf.h, this is the same thing
asm-mips/ack:elf.h:	_r->regs[1] = _r->regs[2] = _r->regs[3] = _r->regs[4] = 0;	\
asm-mips/ack:elf.h:	_r->regs[5] = _r->regs[6] = _r->regs[7] = _r->regs[8] = 0;	\
asm-mips/ack:elf.h:	_r->regs[9] = _r->regs[10] = _r->regs[11] = _r->regs[12] = 0;	\
asm-mips/ack:elf.h:	_r->regs[13] = _r->regs[14] = _r->regs[15] = _r->regs[16] = 0;	\
asm-mips/ack:elf.h:	_r->regs[17] = _r->regs[18] = _r->regs[19] = _r->regs[20] = 0;	\
asm-mips/ack:elf.h:	_r->regs[21] = _r->regs[22] = _r->regs[23] = _r->regs[24] = 0;	\
asm-mips/ack:elf.h:	_r->regs[25] = _r->regs[26] = _r->regs[27] = _r->regs[28] = 0;	\
asm-mips/ack:elf.h:	_r->regs[30] = _r->regs[31] = 0;				\
asm-mips/ack:errno.h:#define	EXDEV		18	/* Cross-device link */
asm-mips/ack:errno.h:#define	EROFS		30	/* Read-only file system */
asm-mips/ack:errno.h:#define	ENOTSOCK	95	/* Socket operation on non-socket */
asm-mips/ack:fcntl.h:/* open/fcntl - O_SYNC is only implemented on blocks devices and on files
asm-mips/ack:fcntl.h:#define F_GETFL		3	/* get file->f_flags */
asm-mips/ack:fcntl.h:#define F_SETFL		4	/* set file->f_flags */
asm-mips/ack:ficmmp.h: *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm-mips/ack:ficmmp.h:#define AU1XXX_ATA_MEM_SIZE		(AU1XXX_ATA_END - AU1XXX_ATA_BASE +1)
asm-mips/ack:fixmap.h: * fixmap.h: compile-time virtual memory allocation
asm-mips/ack:fixmap.h: * Here we define all the compile-time 'special' virtual
asm-mips/ack:fixmap.h: * Also this lets us do fail-safe vmalloc(), we
asm-mips/ack:fixmap.h: * vmalloc()-ed addresses never overlap.
asm-mips/ack:fixmap.h: * these 'compile-time allocated' memory buffers are
asm-mips/ack:fixmap.h: * fixed-size 4k pages. (or larger if used with an increment
asm-mips/ack:fixmap.h: * fix-mapped?
asm-mips/ack:fixmap.h:	FIX_KMAP_END = FIX_KMAP_BEGIN+(KM_TYPE_NR*NR_CPUS)-1,
asm-mips/ack:fixmap.h:#define FIXADDR_START	(FIXADDR_TOP - FIXADDR_SIZE)
asm-mips/ack:fixmap.h:#define __fix_to_virt(x)	(FIXADDR_TOP - ((x) << PAGE_SHIFT))
asm-mips/ack:fixmap.h: * directly without tranlation, we catch the bug with a NULL-deference
asm-mips/ack:fixmap.h:	 * out-of-range indices).
asm-mips/ack:floppy.h: * Copyright (C) 1995 - 2000 Ralf Baechle
asm-mips/ack:floppy.h:#define fd_inb(port)		fd_ops->fd_inb(port)
asm-mips/ack:floppy.h:#define fd_outb(value,port)	fd_ops->fd_outb(value,port)
asm-mips/ack:floppy.h:#define fd_enable_dma()		fd_ops->fd_enable_dma(FLOPPY_DMA)
asm-mips/ack:floppy.h:#define fd_disable_dma()	fd_ops->fd_disable_dma(FLOPPY_DMA)
asm-mips/ack:floppy.h:#define fd_request_dma()	fd_ops->fd_request_dma(FLOPPY_DMA)
asm-mips/ack:floppy.h:#define fd_free_dma()		fd_ops->fd_free_dma(FLOPPY_DMA)
asm-mips/ack:floppy.h:#define fd_clear_dma_ff()	fd_ops->fd_clear_dma_ff(FLOPPY_DMA)
asm-mips/ack:floppy.h:#define fd_set_dma_mode(mode)	fd_ops->fd_set_dma_mode(FLOPPY_DMA, mode)
asm-mips/ack:floppy.h:#define fd_set_dma_addr(addr)	fd_ops->fd_set_dma_addr(FLOPPY_DMA, \
asm-mips/ack:floppy.h:#define fd_set_dma_count(count)	fd_ops->fd_set_dma_count(FLOPPY_DMA,count)
asm-mips/ack:floppy.h:#define fd_get_dma_residue()	fd_ops->fd_get_dma_residue(FLOPPY_DMA)
asm-mips/ack:floppy.h:#define fd_enable_irq()		fd_ops->fd_enable_irq(FLOPPY_IRQ)
asm-mips/ack:floppy.h:#define fd_disable_irq()	fd_ops->fd_disable_irq(FLOPPY_IRQ)
asm-mips/ack:floppy.h:#define fd_dma_mem_alloc(size)	fd_ops->fd_dma_mem_alloc(size)
asm-mips/ack:floppy.h:#define fd_dma_mem_free(mem,size) fd_ops->fd_dma_mem_free(mem,size)
asm-mips/ack:floppy.h:#define fd_drive_type(n)	fd_ops->fd_drive_type(n)
asm-mips/ack:floppy.h:#define FDC1			fd_ops->fd_getfdaddr1();
asm-mips/ack:floppy.h:#define CROSS_64KB(a,s) ((unsigned long)(a)/K_64 != ((unsigned long)(a) + (s) - 1) / K_64)
asm-mips/ack:fpregdef.h: * These definitions only cover the R3000-ish 16/32 register model.
asm-mips/ack:fpu_emulator.h: *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm-mips/ack:fpu.h:#define clear_fpu_owner() do { current->flags &= ~PF_USEDFPU; } while(0)
asm-mips/ack:fpu.h:	return cpu_has_fpu && ((current->flags & PF_USEDFPU) != 0); 
asm-mips/ack:fpu.h:		current->flags |= PF_USEDFPU;
asm-mips/ack:fpu.h:		current->flags &= ~PF_USEDFPU;
asm-mips/ack:fpu.h:		return (unsigned long long *)&tsk->thread.fpu.hard.fp_regs[0];
asm-mips/ack:fpu.h:		return (unsigned long long *)tsk->thread.fpu.soft.regs;
asm-mips/ack:galileo-boards/gt96100.h: *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm-mips/ack:galileo-boards/gt96100.h:/* TDPR0 - Transmit Dual Port RAM. block size 0xff */
asm-mips/ack:galileo-boards/gt96100.h:/* RDPR0 - Receive Dual Port RAM. block size 0xff */
asm-mips/ack:gdb-stub.h: * Derived from the stack layout described in asm-mips/stackframe.h
asm-mips/ack:gdb-stub.h:#define GDB_FR_SIZE		((((GDB_FR_CP0_PRID) + 4) + (PTRSIZE-1)) & ~(PTRSIZE-1))
asm-mips/ack:gdb-stub.h: * This is the same as above, but for the high-level
asm-mips/ack:gfx.h: * This is the user-visible SGI GFX interface.
asm-mips/ack:gfx.h: * any kernel-only bits on it.
asm-mips/ack:gt64120/gt64120.h: *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm-mips/ack:gt64120/gt64120.h:#define MSK(n)                    ((1 << (n)) - 1)
asm-mips/ack:gt64120/gt64120.h: *   GT_WRITE(ofs, data)           - read/write GT64120 registers in 32bit
asm-mips/ack:gt64120/gt64120.h: *   TIMER 	- gt64120 timer irq, temporary solution until
asm-mips/ack:gt64120/gt64120.h:#include <asm/gt64120/mips-boards/gt64120_dep.h>
asm-mips/ack:gt64120/gt64120.h:#include <asm/gt64120/mips-boards/gt64120_dep.h>
asm-mips/ack:gt64120/gt64120.h: * bytes when running bigendian.  We also provide non-swapping versions.
asm-mips/ack:gt64120/gt64120.h: * Board-dependent functions, which must be defined in
asm-mips/ack:hardirq.h:#define irq_exit(cpu, irq)	(local_irq_count(cpu)--)
asm-mips/ack:hardirq.h:	--local_irq_count(cpu);
asm-mips/ack:hazards.h: * mtc0->mfc0 hazard
asm-mips/ack:hazards.h: * mtc0->mfc0 hazard
asm-mips/ack:hazards.h: * R10000 rocks - all hazards handled in hardware, so this becomes a nobrainer.
asm-mips/ack:hazards.h: * care about the irq_enable_hazard - sooner or later the hardware will
asm-mips/ack:hdreg.h: *  Copyright (C) 1994-1996  Linus Torvalds & authors
asm-mips/ack:highmem.h: * Redesigned the x86 32-bit VM architecture to deal with
asm-mips/ack:highmem.h:#define LAST_PKMAP_MASK (LAST_PKMAP-1)
asm-mips/ack:highmem.h:#define PKMAP_NR(virt)  ((virt-PKMAP_BASE) >> PAGE_SHIFT)
asm-mips/ack:highmem.h: * The use of kmap_atomic/kunmap_atomic is discouraged - kmap/kunmap
asm-mips/ack:highmem.h:	set_pte(kmap_pte-idx, mk_pte(page, kmap_prot));
asm-mips/ack:i8259.h: *	include/asm-mips/i8259.h
asm-mips/ack:ide.h: * Copyright (C) 1994-1996  Linus Torvalds & authors
asm-mips/ack:ide.h:	return ide_ops->ide_default_irq(base);
asm-mips/ack:ide.h:	return ide_ops->ide_default_io_base(index);
asm-mips/ack:ide.h:	ide_ops->ide_init_hwif_ports(hw, data_port, ctrl_port, irq);
asm-mips/ack:ide.h:#define ide_ack_intr(hwif)	((hwif)->hw.ack_intr ? (hwif)->hw.ack_intr(hwif) : 1)
asm-mips/ack:ide.h:/* MIPS port and memory-mapped I/O string operations.  */
asm-mips/ack:ide.h:	while (count--) {
asm-mips/ack:ide.h:	while (count--) {
asm-mips/ack:ide.h:	while (count--) {
asm-mips/ack:ide.h:	while (count--) {
asm-mips/ack:init.h:#error "<asm/init.h> should never be used - use <linux/init.h> instead"
asm-mips/ack:inst.h:	 * The others (0x14 - 0x1f) are unused.
asm-mips/ack:inst.h: * Damn ...  bitfields depend from byteorder :-(
asm-mips/ack:ioctl.h:#define _IOC_NRMASK	((1 << _IOC_NRBITS)-1)
asm-mips/ack:ioctl.h:#define _IOC_TYPEMASK	((1 << _IOC_TYPEBITS)-1)
asm-mips/ack:ioctl.h:#define _IOC_SIZEMASK	((1 << _IOC_SIZEBITS)-1)
asm-mips/ack:ioctl.h:#define _IOC_DIRMASK	((1 << _IOC_DIRBITS)-1)
asm-mips/ack:ioctls.h:						/* 127-124 compat */
asm-mips/ack:ioctls.h:#define TIOCGPTN	_IOR('T',0x30, unsigned int) /* Get Pty Number (of pty-mux device) */
asm-mips/ack:io.h: * Copyright (C) 1994 - 2000 Ralf Baechle
asm-mips/ack:io.h:#include <asm/pgtable-bits.h>
asm-mips/ack:io.h:#define bus_to_baddr(bus, addr)	(bus_to_baddr[(bus)->number] + (addr))
asm-mips/ack:io.h:#define baddr_to_bus(bus, addr)	((addr) - bus_to_baddr[(bus)->number])
asm-mips/ack:io.h: * IP22 seems braindead enough to swap 16-bits values in hardware, but not
asm-mips/ack:io.h: * 32-bits.  Go figure... Can't tell without documentation.
asm-mips/ack:io.h: * We only do the swapping to keep the kernel config bits of bi-endian
asm-mips/ack:io.h:#define page_to_phys(page)	((u64)(page - mem_map) << PAGE_SHIFT)
asm-mips/ack:io.h:#define page_to_phys(page)	((page - mem_map) << PAGE_SHIFT)
asm-mips/ack:io.h: *     ioremap         -       map bus memory into CPU space
asm-mips/ack:io.h: *     ioremap_nocache         -       map bus memory into CPU space
asm-mips/ack:io.h: * 24-31 on SNI.
asm-mips/ack:io.h: * to PAGE_OFFSET is pure coincidence - it does not mean ISA values
asm-mips/ack:io.h: * used as the IO-area pointer (it can be iounmapped as well, so the
asm-mips/ack:io.h:#define eth_io_copy_and_sum(skb,src,len,unused) memcpy_fromio((skb)->data,(src),(len))
asm-mips/ack:io.h: *     check_signature         -       find BIOS signatures
asm-mips/ack:io.h:		length--;
asm-mips/ack:io.h: *     isa_check_signature             -       find BIOS signatures
asm-mips/ack:io.h:		length--;
asm-mips/ack:io.h: *     virt_to_phys    -       map virtual addresses to physical
asm-mips/ack:io.h:	return (unsigned long)address - PAGE_OFFSET;
asm-mips/ack:io.h: *     phys_to_virt    -       map physical address to virtual
asm-mips/ack:io.h:	return (unsigned long)address - PAGE_OFFSET;
asm-mips/ack:io.h:	while (count--) {
asm-mips/ack:io.h:	while (count--) {
asm-mips/ack:io.h:	while (count--) {
asm-mips/ack:io.h:	while (count--) {
asm-mips/ack:io.h:	while (count--) {
asm-mips/ack:io.h:	while (count--) {
asm-mips/ack:io.h: * The caches on some architectures aren't dma-coherent and have need to
asm-mips/ack:io.h: *  - dma_cache_wback_inv(start, size) makes caches and coherent by
asm-mips/ack:io.h: *  - dma_cache_wback(start, size) makes caches and coherent by
asm-mips/ack:io.h: *  - dma_cache_inv(start, size) invalidates the affected parts of the
asm-mips/ack:ipcbuf.h: * - 32-bit seq
asm-mips/ack:ipcbuf.h: * - 2 miscellaneous 64-bit values
asm-mips/ack:irq_cpu.h: *	include/asm-mips/irq_cpu.h
asm-mips/ack:it8172/it8172_int.h: * and the non-maskable ints from 48 to 53.
asm-mips/ack:it8172/it8172_int.h:/* 12 - 15 reserved */
asm-mips/ack:it8172/it8172_int.h:#define MIPS_CPU_TIMER_IRQ       (NR_IRQS-1)
asm-mips/ack:jazzdma.h: * Helpfile for jazzdma.c -- Mips Jazz R4030 DMA controller support
asm-mips/ack:jazzdma.h:#define VDMA_OFFSET(a)          ((unsigned int)(a) & (VDMA_PAGESIZE-1))
asm-mips/ack:jazz.h: * Copyright (C) 1995 - 1998 by Andreas Busse and Ralf Baechle
asm-mips/ack:jazz.h: * 0xf0000000 - Rev1
asm-mips/ack:jazz.h: * 0xf0000001 - Rev2
asm-mips/ack:jazz.h: * 0xf0000002 - Rev3
asm-mips/ack:jazz.h: *      ---------
asm-mips/ack:jazz.h: *      ---------
asm-mips/ack:jazz.h: *      --------- . (0)
asm-mips/ack:jazz.h: * Note: Channels 4...7 are not used with respect to the Acer PICA-61
asm-mips/ack:jmr3927/irq.h: *  linux/include/asm-mips/tx3927/irq.h
asm-mips/ack:jmr3927/irq.h:	sp->next = tb_irq_spaces;
asm-mips/ack:jmr3927/pci.h: * include/asm-mips/jmr3927/pci.h
asm-mips/ack:jmr3927/pci.h: * Based on include/asm-mips/ddb5xxx/pci.h
asm-mips/ack:jmr3927/pci.h: * Each pci channel is a top-level PCI bus seem by CPU.  A machine  with
asm-mips/ack:jmr3927/tx3927.h:#define TX3927_PCIC_IDSEL_AD_TO_SLOT(ad)	((ad) - 11)
asm-mips/ack:jmr3927/ds1742rtc.h: * ds1742rtc.h - register definitions for the Real-Time-Clock / CMOS RAM
asm-mips/ack:jmr3927/ds1742rtc.h: *   Based on include/asm-mips/ds1643rtc.h.
asm-mips/ack:jmr3927/ds1742rtc.h: * Copyright (C) 1999-2001 Toshiba Corporation
asm-mips/ack:jmr3927/jmr3927.h: * Defines for the TJSYS JMR-TX3927/JMI-3927IO2/JMY-1394IF.
asm-mips/ack:jmr3927/jmr3927.h: * Copyright (C) 2000-2001 Toshiba Corporation
asm-mips/ack:jmr3927/jmr3927.h:	romcr3 = tx3927_romcptr->cr[3];
asm-mips/ack:jmr3927/jmr3927.h:	tx3927_romcptr->cr[3] &= 0xffffefff;	/* do not wait infinitely */
asm-mips/ack:jmr3927/jmr3927.h:	tx3927_romcptr->cr[3] = romcr3;
asm-mips/ack:jmr3927/jmr3927.h:#define jmr3927_led_set(n/*0-16*/)	jmr3927_ioc_reg_out(~(n), JMR3927_IOC_LED_ADDR)
asm-mips/ack:jmr3927/jmr3927.h:#define jmr3927_io_led_set(n/*0-3*/)	jmr3927_isac_reg_out((n), JMR3927_ISAC_LED_ADDR)
asm-mips/ack:jmr3927/jmr3927.h:#define jmr3927_led_and_set(n/*0-16*/)	jmr3927_ioc_reg_out((~(n)) & jmr3927_ioc_reg_in(JMR3927_IOC_LED_ADDR), JMR3927_IOC_LED_ADDR)
asm-mips/ack:jmr3927/jmr3927.h:#define jmr3927_dipsw1()	((tx3927_pioptr->din & (1 << 11)) == 0)
asm-mips/ack:jmr3927/jmr3927.h:#define jmr3927_dipsw2()	((tx3927_pioptr->din & (1 << 10)) == 0)
asm-mips/ack:jmr3927/jmr3927.h:/* use Pre-scaler T0 (1/2) */
asm-mips/ack:jmr3927/jmr3927.h:#define JMR3927_NR_IRQ_IRC	16	/* On-Chip IRC */
asm-mips/ack:jmr3927/jmr3927.h:/* RTL8019AS 10M Ether (JMI-3927IO2:JPW2:1-2 Short) */
asm-mips/ack:jmr3927/jmr3927.h:/* TC35815 100M Ether (JMR-TX3912:JPW4:2-3 Short) */
asm-mips/ack:jmr3927/jmr3927.h:#define JMR3927_ETHER1_PORT	(JMR3927_ISAIO_BASE - JMR3927_PORT_BASE + 0x280)
asm-mips/ack:jmr3927/jmr3927.h:#define JMR3927_KBD_PORT	(JMR3927_ISAIO_BASE - JMR3927_PORT_BASE + 0x00800060)
asm-mips/ack:jmr3927/jmr3927.h:#define JMR3927_IDE_PORT	(JMR3927_ISAIO_BASE - JMR3927_PORT_BASE + 0x001001f0)
asm-mips/ack:keyboard.h: * Copyright (C) 1994 - 1999 Ralf Baechle
asm-mips/ack:keyboard.h:#define kbd_request_region() kbd_ops->kbd_request_region()
asm-mips/ack:keyboard.h:#define kbd_request_irq(handler) kbd_ops->kbd_request_irq(handler)
asm-mips/ack:keyboard.h:#define aux_request_irq(hand, dev_id) kbd_ops->aux_request_irq(hand)
asm-mips/ack:keyboard.h:#define aux_free_irq(dev_id) kbd_ops->aux_free_irq()
asm-mips/ack:keyboard.h:#define kbd_read_input() kbd_ops->kbd_read_input()
asm-mips/ack:keyboard.h:#define kbd_write_output(val) kbd_ops->kbd_write_output(val)
asm-mips/ack:keyboard.h:#define kbd_write_command(val) kbd_ops->kbd_write_command(val)
asm-mips/ack:keyboard.h:#define kbd_read_status() kbd_ops->kbd_read_status()
asm-mips/ack:lasat/lasat.h: *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm-mips/ack:lasat/lasat.h:/* Configuration descriptor encoding - see the doc for details */
asm-mips/ack:linux_logo_dec.h: * include/asm-mips/linux_logo_dec.h: This is a linux logo
asm-mips/ack:linux_logo_dec.h: * Copyright (C) 2001 Jan-Benedict Glaw <jbglaw@lug-owl.de>
asm-mips/ack:linux_logo.h: * include/asm-mips/linux_logo.h: This is a linux logo
asm-mips/ack:linux_logo_sgi.h: * include/asm-mips/linux_logo_sgi.h: This is a linux logo
asm-mips/ack:linux_logo_sgi.h: * Copyright (C) 2001 Jan-Benedict Glaw <jbglaw@lug-owl.de>
asm-mips/ack:mc146818rtc.h:rtc_ops->rtc_read_data(addr); \
asm-mips/ack:mc146818rtc.h:rtc_ops->rtc_write_data(val, addr); \
asm-mips/ack:mc146818rtc.h:rtc_ops->rtc_bcd_mode()
asm-mips/ack:mc146818rtc.h:#include <asm/dec/rtc-dec.h>
asm-mips/ack:mips-boards/msc01_pci.h:#define MSC01_PCI_HEAD11_OFS		0x2058  /* SubSystem ID, -VendorID */
asm-mips/ack:mips-boards/msc01_pci.h: * FIXME - are these macros specific to Malta and co or to the MSC?  If the
asm-mips/ack:mips-boards/atlasint.h: *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm-mips/ack:mips-boards/atlasint.h: * Atlas registers are memory mapped on 64-bit aligned boundaries and
asm-mips/ack:mips-boards/malta.h: *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm-mips/ack:mips-boards/malta.h: * Defines of the Malta board specific address-MAP, registers, etc.
asm-mips/ack:mips-boards/malta.h: * Malta RTC-device indirect register access.
asm-mips/ack:mips-boards/saa9730_uart.h: *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm-mips/ack:mips-boards/generic.h: * 59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm-mips/ack:mips-boards/generic.h: * Defines of the MIPS boards specific address-MAP, registers, etc.
asm-mips/ack:mips-boards/generic.h:#include <asm/mips-boards/bonito64.h>
asm-mips/ack:mips-boards/seadint.h: *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm-mips/ack:mips-boards/prom.h: *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm-mips/ack:mips-boards/sead.h: *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm-mips/ack:mips-boards/sead.h: * Defines of the SEAD board specific address-MAP, registers, etc.
asm-mips/ack:mips-boards/maltaint.h: *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm-mips/ack:mips-boards/bonito64.h:#define BONITO_BOOT_TOP 		(BONITO_BOOT_BASE+BONITO_BOOT_SIZE-1)
asm-mips/ack:mips-boards/bonito64.h:#define BONITO_FLASH_TOP		(BONITO_FLASH_BASE+BONITO_FLASH_SIZE-1)
asm-mips/ack:mips-boards/bonito64.h:#define BONITO_SOCKET_TOP		(BONITO_SOCKET_BASE+BONITO_SOCKET_SIZE-1)
asm-mips/ack:mips-boards/bonito64.h:#define BONITO_REG_TOP			(BONITO_REG_BASE+BONITO_REG_SIZE-1)
asm-mips/ack:mips-boards/bonito64.h:#define BONITO_DEV_TOP			(BONITO_DEV_BASE+BONITO_DEV_SIZE-1)
asm-mips/ack:mips-boards/bonito64.h:#define BONITO_PCILO_TOP		(BONITO_PCILO_BASE+BONITO_PCILO_SIZE-1)
asm-mips/ack:mips-boards/bonito64.h:#define BONITO_PCIHI_TOP		(BONITO_PCIHI_BASE+BONITO_PCIHI_SIZE-1)
asm-mips/ack:mips-boards/bonito64.h:#define BONITO_PCIIO_TOP		(BONITO_PCIIO_BASE+BONITO_PCIIO_SIZE-1)
asm-mips/ack:mips-boards/bonito64.h:#define BONITO_PCICFG_TOP		(BONITO_PCICFG_BASE+BONITO_PCICFG_SIZE-1)
asm-mips/ack:mips-boards/bonito64.h:/* Added by RPF 11-9-00 */
asm-mips/ack:mips-boards/bonito64.h:/* --- */
asm-mips/ack:mips-boards/bonito64.h:/* GPIO Regs - r/w */
asm-mips/ack:mips-boards/bonito64.h:/* ICU Configuration Regs - r/w */
asm-mips/ack:mips-boards/bonito64.h:/* ICU Enable Regs - IntEn & IntISR are r/o. */
asm-mips/ack:mips-boards/bonito64.h:/* DRAM - sdCfg */
asm-mips/ack:mips-boards/bonito64.h:/* Changed by RPF 11-9-00 */
asm-mips/ack:mips-boards/bonito64.h:/* --- */
asm-mips/ack:mips-boards/bonito64.h:/* Added by RPF 11-9-00 */
asm-mips/ack:mips-boards/bonito64.h:/* --- */
asm-mips/ack:mips-boards/bonito64.h:/* PCI Cache - pciCacheCtrl */
asm-mips/ack:mips-boards/bonito64.h:/* Added by RPF 11-9-00 */
asm-mips/ack:mips-boards/bonito64.h:/* --- */
asm-mips/ack:mips-boards/bonito64.h:#define BONITO_PCIMAP_WINOFFSET(ADDR)	((ADDR) & (BONITO_PCIMAP_WINSIZE - 1))
asm-mips/ack:mips-boards/bonito64.h:#define BONITO_PCIMEMBASECFGSIZE(WIN,SIZE)	(((~((SIZE)-1))>>(BONITO_PCIMEMBASECFG_ASHIFT-BONITO_PCIMEMBASECFG_MEMBASE##WIN##_MASK_SHIFT)) & BONITO_PCIMEMBASECFG_MEMBASE##WIN##_MASK)
asm-mips/ack:mips-boards/bonito64.h:#define BONITO_PCIMEMBASECFGBASE(WIN,BASE)	(((BASE)>>(BONITO_PCIMEMBASECFG_ASHIFT-BONITO_PCIMEMBASECFG_MEMBASE##WIN##_TRANS_SHIFT)) & BONITO_PCIMEMBASECFG_MEMBASE##WIN##_TRANS)
asm-mips/ack:mips-boards/bonito64.h:#define BONITO_PCIMEMBASECFG_SIZE(WIN,CFG)  (((((~(CFG)) & BONITO_PCIMEMBASECFG_MEMBASE##WIN##_MASK)) << (BONITO_PCIMEMBASECFG_ASHIFT - BONITO_PCIMEMBASECFG_MEMBASE##WIN##_MASK_SHIFT)) | BONITO_PCIMEMBASECFG_AMASK)
asm-mips/ack:mips-boards/atlas.h: *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm-mips/ack:mips-boards/atlas.h: * Defines of the Atlas board specific address-MAP, registers, etc.
asm-mips/ack:mips-boards/atlas.h: * Atlas RTC-device indirect register access.
asm-mips/ack:mips-boards/piix4.h: *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm-mips/ack:mipsregs.h:#define FPU_CSR_RD      0x3     /* towards -Infinity */
asm-mips/ack:mipsregs.h: * physical address space running the 32-bit kernel.  That's none atm :-)
asm-mips/ack:mman.h:/* These are linux-specific */
asm-mips/ack:mman.h:#define MAP_GROWSDOWN	0x1000		/* stack-like segment */
asm-mips/ack:mman.h:#define MADV_NORMAL	0x0		/* default page-in behavior */
asm-mips/ack:mman.h:#define MADV_RANDOM	0x1		/* page-in minimum required */
asm-mips/ack:mman.h:#define MADV_SEQUENTIAL	0x2		/* read-ahead aggressively */
asm-mips/ack:mman.h:#define MADV_WILLNEED	0x3		/* pre-fault pages */
asm-mips/ack:mmu_context.h: * use the processor id via current->processor, where current is stored
asm-mips/ack:mmu_context.h:#define cpu_context(cpu, mm)	((mm)->context[cpu])
asm-mips/ack:mmu_context.h:#define ASID_VERSION_MASK  ((unsigned long)~(ASID_MASK|(ASID_MASK-1)))
asm-mips/ack:mmu_context.h:	TLBMISS_HANDLER_SETUP_PGD(next->pgd);
asm-mips/ack:mmu_context.h:	 * Mark current->active_mm as not "active" anymore.
asm-mips/ack:mmu_context.h:	clear_bit(cpu, &prev->cpu_vm_mask);
asm-mips/ack:mmu_context.h:	set_bit(cpu, &next->cpu_vm_mask);
asm-mips/ack:mmu_context.h: * After we have set current->mm to a new value, this activates
asm-mips/ack:mmu_context.h:	TLBMISS_HANDLER_SETUP_PGD(next->pgd);
asm-mips/ack:mmu_context.h:	clear_bit(cpu, &prev->cpu_vm_mask);
asm-mips/ack:mmu_context.h:	set_bit(cpu, &next->cpu_vm_mask);
asm-mips/ack:mmu_context.h:	if (test_bit(cpu, &mm->cpu_vm_mask))  {
asm-mips/ack:module.h: * modutils/obj/obj-mips.c
asm-mips/ack:module.h:	archdata = (struct archdata *)(mod->archdata_start);
asm-mips/ack:module.h:	if (archdata->dbe_table_start > archdata->dbe_table_end ||
asm-mips/ack:module.h:	    (archdata->dbe_table_start &&
asm-mips/ack:module.h:	     !((unsigned long)archdata->dbe_table_start >=
asm-mips/ack:module.h:	       ((unsigned long)mod + mod->size_of_struct) &&
asm-mips/ack:module.h:	       ((unsigned long)archdata->dbe_table_end <
asm-mips/ack:module.h:	        (unsigned long)mod + mod->size))) ||
asm-mips/ack:module.h:            (((unsigned long)archdata->dbe_table_start -
asm-mips/ack:module.h:	      (unsigned long)archdata->dbe_table_end) %
asm-mips/ack:module.h:			"module_arch_init: archdata->dbe_table_* invalid.\n");
asm-mips/ack:module.h:	mod->archdata_start = (char *)&archdata;
asm-mips/ack:module.h:	mod->archdata_end = mod->archdata_start + sizeof(archdata);
asm-mips/ack:msgbuf.h: * - extension of time_t to 64-bit on 32-bitsystem to solve the y2038 problem
asm-mips/ack:msgbuf.h: * - 2 miscellaneous unsigned long values
asm-mips/ack:mv64340_dep.h: * include/asm-mips/mv64340-dep.h
asm-mips/ack:mv64340_dep.h: *     Board-dependent definitions for MV-64340 chip.
asm-mips/ack:mv64340.h:* mv64340.h - MV-64340 Internal registers definition file.
asm-mips/ack:namei.h: * linux/include/asm-mips/namei.h
asm-mips/ack:namei.h:	if (current->personality != PER_IRIX32)
asm-mips/ack:ng1hw.h:#define REX3WAIT(rex3)  while ((rex3)->p1.set.status & GFXBUSY)
asm-mips/ack:ng1hw.h:#define BFIFOWAIT(rex3)  while ((rex3)->p1.set.status & BACKBUSY)
asm-mips/ack:nile4.h: *  asm-mips/nile4.h -- NEC Vrc-5074 Nile 4 definitions
asm-mips/ack:nile4.h:#define NILE4_DCS2	0x0010	/* Device Chip-Select 2 [R/W] */
asm-mips/ack:nile4.h:#define NILE4_DCS3	0x0018	/* Device Chip-Select 3 [R/W] */
asm-mips/ack:nile4.h:#define NILE4_DCS4	0x0020	/* Device Chip-Select 4 [R/W] */
asm-mips/ack:nile4.h:#define NILE4_DCS5	0x0028	/* Device Chip-Select 5 [R/W] */
asm-mips/ack:nile4.h:#define NILE4_DCS6	0x0030	/* Device Chip-Select 6 [R/W] */
asm-mips/ack:nile4.h:#define NILE4_DCS7	0x0038	/* Device Chip-Select 7 [R/W] */
asm-mips/ack:nile4.h:#define NILE4_DCS8	0x0040	/* Device Chip-Select 8 [R/W] */
asm-mips/ack:nile4.h:#define NILE4_BOOTCS	0x0078	/* Boot ROM Chip-Select [R/W] */
asm-mips/ack:nile4.h:     *  Memory-Interface Registers
asm-mips/ack:nile4.h:     *  PCI-Bus Registers
asm-mips/ack:nile4.h:     *  Local-Bus Registers
asm-mips/ack:nile4.h:#define NILE4_LCST2	0x0110	/* Local Bus Chip-Select Timing 2 [R/W] */
asm-mips/ack:nile4.h:#define NILE4_LCST3	0x0118	/* Local Bus Chip-Select Timing 3 [R/W] */
asm-mips/ack:nile4.h:#define NILE4_LCST4	0x0120	/* Local Bus Chip-Select Timing 4 [R/W] */
asm-mips/ack:nile4.h:#define NILE4_LCST5	0x0128	/* Local Bus Chip-Select Timing 5 [R/W] */
asm-mips/ack:nile4.h:#define NILE4_LCST6	0x0130	/* Local Bus Chip-Select Timing 6 [R/W] */
asm-mips/ack:nile4.h:#define NILE4_LCST7	0x0138	/* Local Bus Chip-Select Timing 7 [R/W] */
asm-mips/ack:nile4.h:#define NILE4_LCST8	0x0140	/* Local Bus Chip-Select Timing 8 [R/W] */
asm-mips/ack:nile4.h:#define NILE4_DCSFN	0x0150	/* Device Chip-Select Muxing and Output */
asm-mips/ack:nile4.h:#define NILE4_DCSIO	0x0158	/* Device Chip-Selects As I/O Bits [R/W] */
asm-mips/ack:nile4.h:#define NILE4_BCST	0x0178	/* Local Boot Chip-Select Timing [R/W] */
asm-mips/ack:nile4.h:#define NILE4_T1CTRL	0x01D0	/* CPU-Bus Read Time-Out Control [R/W] */
asm-mips/ack:nile4.h:#define NILE4_T1CNTR	0x01D8	/* CPU-Bus Read Time-Out Counter [R/W] */
asm-mips/ack:nile4.h:#define NILE4_T2CTRL	0x01E0	/* General-Purpose Timer Control [R/W] */
asm-mips/ack:nile4.h:#define NILE4_T2CNTR	0x01E8	/* General-Purpose Timer Counter [R/W] */
asm-mips/ack:nile4.h:#define NILE4_SSVID	0x022C	/* PCI Sub-System Vendor ID [R/W] */
asm-mips/ack:nile4.h:#define NILE4_SSID	0x022E	/* PCI Sub-System ID [R/W] */
asm-mips/ack:nile4.h:     *  Serial-Port Registers
asm-mips/ack:nile4.h:#define NILE4_INT_CPCE	0	/* CPU-Interface Parity-Error Interrupt */
asm-mips/ack:nile4.h:#define NILE4_INT_CNTD	1	/* CPU No-Target Decode Interrupt */
asm-mips/ack:nile4.h:#define NILE4_INT_MCE	2	/* Memory-Check Error Interrupt */
asm-mips/ack:nile4.h:#define NILE4_INT_GPT	6	/* General-Purpose Timer Interrupt */
asm-mips/ack:nile4.h:#define NILE4_INT_LBRTD	7	/* Local-Bus Ready Timer Interrupt */
asm-mips/ack:nile4.h:#define irq_to_nile4(n)		((n)-NUM_I8259_INTERRUPTS)
asm-mips/ack:paccess.h: * by sending a DBE error like accessing possibly non-existant memory or
asm-mips/ack:paccess.h:	".word\t1b-4,3b\n\t" \
asm-mips/ack:paccess.h:	:"o" (__mp(__gu_addr)), "i" (-EFAULT)); })
asm-mips/ack:paccess.h:	".word\t1b-4,3b\n\t" \
asm-mips/ack:paccess.h:	:"r" (__pu_val), "o" (__mp(__pu_addr)), "i" (-EFAULT)); })
asm-mips/ack:page.h: * Copyright (C) 1994 - 1999, 2003 by Ralf Baechle
asm-mips/ack:page.h:#define PAGE_MASK	(~(PAGE_SIZE-1))
asm-mips/ack:page.h: * These are used to make use of C type-checking..
asm-mips/ack:page.h:	size = (size-1) >> (PAGE_SHIFT-1);
asm-mips/ack:page.h:	order = -1;
asm-mips/ack:page.h:#define PAGE_ALIGN(addr)	(((addr) + PAGE_SIZE - 1) & PAGE_MASK)
asm-mips/ack:page.h:#define __pa(x)		((unsigned long) (x) - PAGE_OFFSET)
asm-mips/ack:page.h:#define VALID_PAGE(page)	((page - mem_map) < max_mapnr)
asm-mips/ack:page.h:#define UNCAC_ADDR(addr)	((addr) - PAGE_OFFSET + UNCAC_BASE)
asm-mips/ack:page.h:#define CAC_ADDR(addr)		((addr) - UNCAC_BASE + PAGE_OFFSET)
asm-mips/ack:param.h:    * Ye olde division-by-multiplication trick.
asm-mips/ack:param.h:#  define QUOTIENT ((1UL << (32 - LOG_2_HZ)) * 100)
asm-mips/ack:param.h:   unless you know what you're doing - changing breaks binary compatibility.  */
asm-mips/ack:param.h:#define NOGROUP		(-1)
asm-mips/ack:pb1000.h: *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm-mips/ack:pb1000.h:/* VPPEN1 - VPPEN0 */
asm-mips/ack:pb1000.h:/* VCCEN1 - VCCEN0 */
asm-mips/ack:pb1100.h: *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm-mips/ack:pb1200.h: *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm-mips/ack:pb1200.h: *    *example: IDE bis pos is  = 64 - 64
asm-mips/ack:pb1200.h:                ETH bit pos is  = 65 - 64
asm-mips/ack:pb1200.h:#define BOARD_CARD_INSERTED(SOCKET) bcsr->sig_status & (1<<(8+(2*SOCKET)))
asm-mips/ack:pb1500.h: *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm-mips/ack:pb1550.h: *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm-mips/ack:pb1550.h:#define DAUGHTER_CARD_MEM_SIZE		(0xADFFFFFF - DAUGHTER_CARD_BASE + 1)
asm-mips/ack:pci_channel.h: * Each pci channel is a top-level PCI bus seem by CPU.  A machine  with
asm-mips/ack:pci.h:   already-configured bus numbers - to be used for buggy BIOSes
asm-mips/ack:pci.h: * NULL for PCI-like buses (ISA, EISA).
asm-mips/ack:pci.h: * Returns non-NULL cpu-view pointer to the buffer if successful and
asm-mips/ack:pci.h: * The 32-bit bus address to use is returned.
asm-mips/ack:pci.h:	return bus_to_baddr(hwdev->bus, __pa(ptr));
asm-mips/ack:pci.h:		addr = baddr_to_bus(hwdev->bus, dma_addr) + PAGE_OFFSET;
asm-mips/ack:pci.h:	return bus_to_baddr(hwdev->bus, page_to_phys(page) + offset);
asm-mips/ack:pci.h:		addr = baddr_to_bus(hwdev->bus, dma_address) + PAGE_OFFSET;
asm-mips/ack:pci.h: * mode for DMA.  This is the scather-gather version of the
asm-mips/ack:pci.h:		if (sg->address && sg->page)
asm-mips/ack:pci.h:		else if (!sg->address && !sg->page)
asm-mips/ack:pci.h:		if (sg->address) {
asm-mips/ack:pci.h:			dma_cache_wback_inv((unsigned long)sg->address,
asm-mips/ack:pci.h:			                    sg->length);
asm-mips/ack:pci.h:			sg->dma_address = bus_to_baddr(hwdev->bus, __pa(sg->address));
asm-mips/ack:pci.h:			sg->dma_address = page_to_bus(sg->page) +
asm-mips/ack:pci.h:			                  sg->offset;
asm-mips/ack:pci.h:				(page_address(sg->page) + sg->offset),
asm-mips/ack:pci.h:				sg->length);
asm-mips/ack:pci.h:		if (sg->address && sg->page)
asm-mips/ack:pci.h:		else if (!sg->address && !sg->page)
asm-mips/ack:pci.h:		if (!sg->address)
asm-mips/ack:pci.h:		dma_cache_wback_inv((unsigned long)sg->address, sg->length);
asm-mips/ack:pci.h:	addr = baddr_to_bus(hwdev->bus, dma_handle) + PAGE_OFFSET;
asm-mips/ack:pci.h: * The same as pci_dma_sync_single but for a scatter-gather list,
asm-mips/ack:pci.h:		dma_cache_wback_inv((unsigned long)sg->address, sg->length);
asm-mips/ack:pci.h: * only drive the low 24-bits during PCI bus mastering, then
asm-mips/ack:pci.h:	return (dma64_addr_t) bus_to_baddr(pdev->bus, addr);
asm-mips/ack:pci.h:	unsigned long poff = baddr_to_bus(pdev->bus, dma_addr) >> PAGE_SHIFT;
asm-mips/ack:pci.h:	addr = baddr_to_bus(pdev->bus, dma_addr) + PAGE_OFFSET;
asm-mips/ack:pci.h:#define sg_dma_address(sg)	((sg)->dma_address)
asm-mips/ack:pci.h:#define sg_dma_len(sg)		((sg)->length)
asm-mips/ack:pgalloc.h: * Copyright (C) 1994 - 2001 by Ralf Baechle
asm-mips/ack:pgalloc.h: *  - flush_tlb_all() flushes all processes TLB entries
asm-mips/ack:pgalloc.h: *  - flush_tlb_mm(mm) flushes the specified mm context TLB entries
asm-mips/ack:pgalloc.h: *  - flush_tlb_page(mm, vmaddr) flushes a single page
asm-mips/ack:pgalloc.h: *  - flush_tlb_range(mm, start, end) flushes a range of pages
asm-mips/ack:pgalloc.h: *  - flush_tlb_pgtables(mm, start, end) flushes a range of page tables
asm-mips/ack:pgalloc.h: *  - flush_tlb_one(page) flushes a single kernel page
asm-mips/ack:pgalloc.h:			(PTRS_PER_PGD - USER_PTRS_PER_PGD) * sizeof(pgd_t));
asm-mips/ack:pgalloc.h:		pgtable_cache_size--;
asm-mips/ack:pgalloc.h:		pgtable_cache_size--;
asm-mips/ack:pgalloc.h:		pgtable_cache_size--;
asm-mips/ack:pgalloc.h: * allocating and freeing a pmd is trivial: the 1-entry pmd is
asm-mips/ack:pgtable-32.h: * traditional mips two-level paging structure:
asm-mips/ack:pgtable-32.h:#define PMD_SHIFT       (2 * PAGE_SHIFT - PTE_T_LOG2)
asm-mips/ack:pgtable-32.h:        pte_val(__pte) = ((phys_t)(page - mem_map) << (PAGE_SHIFT + 2)) | \
asm-mips/ack:pgtable-32.h:	pte_val(__pte) = ((phys_t)(page - mem_map) << PAGE_SHIFT) | \
asm-mips/ack:pgtable-64.h:#define mk_pte(page, pgprot) __mk_pte((page) - mem_map, (pgprot))
asm-mips/ack:pgtable-64.h: * value and then use set_pte to update it.  -ben
asm-mips/ack:pgtable-64.h:	ptep->pte_high = pte.pte_high;
asm-mips/ack:pgtable-64.h:	ptep->pte_low = pte.pte_low;
asm-mips/ack:pgtable-64.h:			buddy->pte_low |= _PAGE_GLOBAL;
asm-mips/ack:pgtable-bits.h: * Copyright (C) 1994 - 2002 by Ralf Baechle
asm-mips/ack:pgtable-bits.h:/* bobtseng --, 2005.12.16 */
asm-mips/ack:pgtable.h:	test_bit(PG_dcache_dirty, &(page)->flags)
asm-mips/ack:pgtable.h:	set_bit(PG_dcache_dirty, &(page)->flags)
asm-mips/ack:pgtable.h:	clear_bit(PG_dcache_dirty, &(page)->flags)
asm-mips/ack:pgtable.h: * - add_wired_entry() add a fixed TLB entry, and move wired register
asm-mips/ack:pgtable.h: * - add_temporary_entry() add a temporary TLB entry. We use TLB entries
asm-mips/ack:pgtable.h:/* Basically we have the same two-level (which is the logical three level
asm-mips/ack:pgtable.h:/* PMD_SHIFT determines the size of the area a second-level page table can map */
asm-mips/ack:pgtable.h:#define PMD_MASK	(~(PMD_SIZE-1))
asm-mips/ack:pgtable.h:/* PGDIR_SHIFT determines what a third-level page table entry can map */
asm-mips/ack:pgtable.h:#define PGDIR_MASK	(~(PGDIR_SIZE-1))
asm-mips/ack:pgtable.h:# define VMALLOC_END	(PKMAP_BASE-2*PAGE_SIZE)
asm-mips/ack:pgtable.h:# define VMALLOC_END	(FIXADDR_START-2*PAGE_SIZE)
asm-mips/ack:pgtable.h:#include <asm/pgtable-bits.h>
asm-mips/ack:pgtable.h:#include <asm/pgtable-64.h>
asm-mips/ack:pgtable.h:#include <asm/pgtable-32.h>
asm-mips/ack:pgtable.h: * The "pgd_xxx()" functions here are trivial for a folded two-level
asm-mips/ack:pgtable.h:	(((address) >> PMD_SHIFT) & (PTRS_PER_PMD-1))
asm-mips/ack:pgtable.h:/* to find an entry in a kernel page-table-directory */
asm-mips/ack:pgtable.h:/* to find an entry in a page-table-directory */
asm-mips/ack:pgtable.h:	return mm->pgd + pgd_index(address);
asm-mips/ack:pgtable.h:/* Find an entry in the second-level page table.. */
asm-mips/ack:pgtable.h:/* Find an entry in the third-level page table.. */
asm-mips/ack:pgtable.h:	       ((address >> PAGE_SHIFT) & (PTRS_PER_PTE - 1));
asm-mips/ack:pgtable.h:#include <asm-generic/pgtable.h>
asm-mips/ack:poll.h:/* XXX This one seems to be more-or-less nonstandard.  */
asm-mips/ack:posix_types.h: * This file is generally used by user-level software, so you need to
asm-mips/ack:posix_types.h:	__fdsetp->fds_bits[__tmp] |= (1UL<<__rem);
asm-mips/ack:posix_types.h:	__fdsetp->fds_bits[__tmp] &= ~(1UL<<__rem);
asm-mips/ack:posix_types.h:	return (__p->fds_bits[__tmp] & (1UL<<__rem)) != 0;
asm-mips/ack:posix_types.h: * for a 256-bit fd_set)
asm-mips/ack:posix_types.h:	unsigned long *__tmp = __p->fds_bits;
asm-mips/ack:posix_types.h:		__i--;
asm-mips/ack:processor.h:#define MIPS_CACHE_IC_F_DC	0x00000008	/* Ic can refill from D-cache */
asm-mips/ack:processor.h:	struct cache_desc icache;	/* Primary I-cache */
asm-mips/ack:processor.h: * Size of io_bitmap in longwords: 32 is ports 0-0x3ff.
asm-mips/ack:processor.h: * the FPU emulator for now.  See asm-mips/fpu_emulator.h.
asm-mips/ack:processor.h:	if (t->reg31 == (unsigned long) ret_from_fork)
asm-mips/ack:processor.h:		return t->reg31;
asm-mips/ack:processor.h:	return ((unsigned long *)t->reg29)[schedule_frame.pc_offset];
asm-mips/ack:processor.h:#define __PT_REG(reg) ((long)&((struct pt_regs *)0)->reg - sizeof(struct pt_regs))
asm-mips/ack:processor.h:#define __KSTK_TOS(tsk) ((unsigned long)(tsk) + KERNEL_STACK_SIZE - 32)
asm-mips/ack:processor.h:#define THREAD_MASK		(THREAD_SIZE - 1UL)
asm-mips/ack:processor.h:#define get_task_struct(tsk)      atomic_inc(&virt_to_page(tsk)->count)
asm-mips/ack:processor.h: * (MIPS, Alpha) or is unuseable with -fomit-frame-pointer (i386).
asm-mips/ack:processor.h: * __builtin_return_address works only for non-leaf functions.  We avoid the
asm-mips/ack:ptrace.h:/* 0 - 31 are integer registers, 32 - 63 are fp registers.  */
asm-mips/ack:ptrace.h:        ".size\t" #symbol",. - " #symbol)
asm-mips/ack:ptrace.h:#define user_mode(regs) (((regs)->cp0_status & KU_MASK) == KU_USER)
asm-mips/ack:ptrace.h:#define instruction_pointer(regs) ((regs)->cp0_epc)
asm-mips/ack:r4kcache.h: * Copyright (C) 1997 - 2002 Ralf Baechle (ralf@gnu.org)
asm-mips/ack:r4kcache.h: * Copyright (C) 2004 Ralf Baechle (ralf@linux-mips.org)
asm-mips/ack:r4kcache.h: * R10000 / R12000 hazard - these processors don't support the Hit_Writeback_D
asm-mips/ack:r4kcache.h: * cacheop so we use Hit_Writeback_Inv_D which is supported by all R4000-style
asm-mips/ack:r4kcache.h: * This one is RM7000-specific
asm-mips/ack:regdef.h: * include/asm-mips/regdefs.h
asm-mips/ack:regdef.h:#define AT      $1      /* assembler temp  - uppercase because of ".set at" */
asm-mips/ack:reg.h: * This defines/structures correspond to the register layout on stack -
asm-mips/ack:reg.h: * include/asm-mips/stackframe.h
asm-mips/ack:resource.h:#define RLIMIT_MEMLOCK 9		/* max locked-in-memory address space */
asm-mips/ack:riscos-syscall.h: * The syscalls 0 - 3999 are reserved for a down to the root syscall
asm-mips/ack:rt2880/surfboard.h: *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm-mips/ack:rt2880/surfboardint.bob: *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm-mips/ack:rt2880/surfboardint.bob: * Surfboard registers are memory mapped on 32-bit aligned boundaries and
asm-mips/ack:rt2880/surfboardint.bob:/* bobtseng added --, 2006.3.6. */
asm-mips/ack:rt2880/surfboardint.org: *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm-mips/ack:rt2880/surfboardint.org: * Surfboard registers are memory mapped on 32-bit aligned boundaries and
asm-mips/ack:rt2880/generic.h: * 59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm-mips/ack:rt2880/generic.h: * Defines of the Palmchip boards specific address-MAP, registers, etc.
asm-mips/ack:rt2880/generic.h: * Power-off register
asm-mips/ack:rt2880/prom.h: *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm-mips/ack:rt2880/surfboardint.h: *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm-mips/ack:rt2880/surfboardint.h: * Surfboard registers are memory mapped on 32-bit aligned boundaries and
asm-mips/ack:rt2880/surfboardint.h:/* bobtseng added --, 2006.3.6. */
asm-mips/ack:semaphore.h:	atomic_set(&sem->count, val);
asm-mips/ack:semaphore.h:	atomic_set(&sem->waking, 0);
asm-mips/ack:semaphore.h:	init_waitqueue_head(&sem->wait);
asm-mips/ack:semaphore.h:	sem->__magic = (long)&sem->__magic;
asm-mips/ack:semaphore.h: * sem->count and sem->waking atomic.
asm-mips/ack:semaphore.h:	CHECK_MAGIC(sem->__magic);
asm-mips/ack:semaphore.h:	count = atomic_dec_return(&sem->count);
asm-mips/ack:semaphore.h: * it, return zero.  If we were interrupted, returns -EINTR
asm-mips/ack:semaphore.h:	CHECK_MAGIC(sem->__magic);
asm-mips/ack:semaphore.h:	count = atomic_dec_return(&sem->count);
asm-mips/ack:semaphore.h: * Here, we do this by using lld/scd on the pair of 32-bit words.
asm-mips/ack:semaphore.h: *   Decrement(sem->count)
asm-mips/ack:semaphore.h: *   If(sem->count >=0) {
asm-mips/ack:semaphore.h: *	If(sem->waking <= 0) {		// if no wakeup pending
asm-mips/ack:semaphore.h: *	   Increment(sem->count)	// undo decrement
asm-mips/ack:semaphore.h: *	   Decrement(sem->waking)	// otherwise "steal" wakeup
asm-mips/ack:semaphore.h:	CHECK_MAGIC(sem->__magic);
asm-mips/ack:semaphore.h:	"	dli	%3, 0x0000000100000000	# count -= 1		\n"
asm-mips/ack:semaphore.h:	"	blez	%2, 1f			# if waking < 0 -> 1f	\n"
asm-mips/ack:semaphore.h:	"	daddiu	%1, %1, -1		# waking -= 1		\n"
asm-mips/ack:semaphore.h:	CHECK_MAGIC(sem->__magic);
asm-mips/ack:semaphore.h:	"	dsll32 %1, %1, 0	# zero-extend %1	\n"
asm-mips/ack:semaphore.h: * Non-blockingly attempt to down() a semaphore.
asm-mips/ack:semaphore.h:	CHECK_MAGIC(sem->__magic);
asm-mips/ack:semaphore.h:	count = atomic_read(&sem->count) - 1;
asm-mips/ack:semaphore.h:	atomic_set(&sem->count, count);
asm-mips/ack:semaphore.h:		waking = atomic_read(&sem->waking);
asm-mips/ack:semaphore.h:			atomic_set(&sem->count, count + 1);
asm-mips/ack:semaphore.h:			atomic_set(&sem->waking, waking - 1);
asm-mips/ack:semaphore.h:	CHECK_MAGIC(sem->__magic);
asm-mips/ack:semaphore.h:	count = atomic_read(&sem->count) + 1;
asm-mips/ack:semaphore.h:	waking = atomic_read(&sem->waking);
asm-mips/ack:semaphore.h:	atomic_set(&sem->count, count);
asm-mips/ack:semaphore.h:	atomic_set(&sem->waking, waking);
asm-mips/ack:semaphore.h:	return atomic_read(&sem->count);
asm-mips/ack:sembuf.h: * - 2 miscellaneous 64-bit values
asm-mips/ack:serial.h:#include <asm/mips-boards/atlas.h>
asm-mips/ack:serial.h:#include <asm/mips-boards/atlasint.h>
asm-mips/ack:serial.h:#include <asm/mips-boards/sead.h>
asm-mips/ack:serial.h:#include <asm/mips-boards/seadint.h>
asm-mips/ack:serial.h:#include <asm/galileo-boards/ev96100int.h>
asm-mips/ack:serial.h: * Also look in ip27-pci.c:pci_fixuop_ioc3() for some comments on working
asm-mips/ack:sfp-machine.h:#define _FP_NANFRAC_S		((_FP_QNANBIT_S << 1) - 1)
asm-mips/ack:sfp-machine.h:#define _FP_NANFRAC_D		((_FP_QNANBIT_D << 1) - 1), -1
asm-mips/ack:sfp-machine.h:#define _FP_NANFRAC_Q		((_FP_QNANBIT_Q << 1) - 1), -1, -1, -1
asm-mips/ack:sgi/mc.h:#define SGIMC_CCTRL0_LENDIAN	0x00020000 /* Put MC in little-endian mode */
asm-mips/ack:sgi/mc.h:#define SGIMC_EEPROM_SDATAO	0x00000008 /* Serial EEPROM data-out */
asm-mips/ack:sgi/mc.h:#define SGIMC_EEPROM_SDATAI	0x00000010 /* Serial EEPROM data-in */
asm-mips/ack:sgi/mc.h:#define SGIMC_GIOPAR_HPC64	0x00000001 /* HPC talks to GIO using 64-bits */
asm-mips/ack:sgi/mc.h:#define SGIMC_GIOPAR_GFX64	0x00000002 /* GFX talks to GIO using 64-bits */
asm-mips/ack:sgi/mc.h:#define SGIMC_GIOPAR_EXP064	0x00000004 /* EXP(slot0) talks using 64-bits */
asm-mips/ack:sgi/mc.h:#define SGIMC_GIOPAR_EXP164	0x00000008 /* EXP(slot1) talks using 64-bits */
asm-mips/ack:sgi/mc.h:#define SGIMC_GIOPAR_EISA64	0x00000010 /* EISA bus talks 64-bits to GIO */
asm-mips/ack:sgi/mc.h:#define SGIMC_GIOPAR_HPC264	0x00000020 /* 2nd HPX talks 64-bits to GIO */
asm-mips/ack:sgi/mc.h:	volatile u32 syssembit;		/* Uni-bit system semaphore */
asm-mips/ack:sgi/mc.h:	u32 _unused36[0x1000/4-2*4];
asm-mips/ack:sgi/gio.h: * -----   --------- ----------------------- -----
asm-mips/ack:sgi/gio.h: *   0     GFX       0x1f000000 - 0x1f3fffff   4MB
asm-mips/ack:sgi/gio.h: *   1     EXP0      0x1f400000 - 0x1f5fffff   2MB
asm-mips/ack:sgi/gio.h: *   2     EXP1      0x1f600000 - 0x1f9fffff   4MB
asm-mips/ack:sgi/gio.h: * There are un-slotted devices, HPC, I/O and misc devices, which are grouped
asm-mips/ack:sgi/gio.h: *   -     MISC      0x1fb00000 - 0x1fbfffff   1MB
asm-mips/ack:sgi/gio.h: *   -     RESERVED  0x18000000 - 0x1effffff 112MB
asm-mips/ack:sgi/gio.h: * 32-bit IDs are divided into
asm-mips/ack:sgi/gio.h: *	bit 16		0=GIO32 and GIO32-bis, 1=GIO64.
asm-mips/ack:sgi/gio.h: * 8-bit IDs
asm-mips/ack:sgi/gio.h: *	0x0e		E-Plex 8-port Ethernet
asm-mips/ack:sgi/gio.h: * [*] Device provide 32-bit ID.
asm-mips/ack:sgi/ioc.h: * All registers are 8-bit wide alligned on 32-bit boundary. Bad things
asm-mips/ack:sgi/ioc.h:#define SGINT_TCWORD_MOS	0x02	/* One-shot IRQ mode. */
asm-mips/ack:sgi/pi1.h:#define PI1_STAT_DEVID		0x03	/* bits 0-1 */
asm-mips/ack:sgi/pi1.h:#define PI1_DMACTRL_STDMODE	0x00    /* bits 2-3 */
asm-mips/ack:sgi/pi1.h:#define PI1_DMACTRL_SGIMODE	0x04    /* bits 2-3 */
asm-mips/ack:sgi/pi1.h:#define PI1_DMACTRL_RICOHMODE	0x08    /* bits 2-3 */
asm-mips/ack:sgi/pi1.h:#define PI1_DMACTRL_HPMODE	0x0c    /* bits 2-3 */
asm-mips/ack:sgi/hpc3.h:	u32 _unused0[0x1000/4 - 2];	/* padding */
asm-mips/ack:sgi/hpc3.h:#define HPC3_PDMACTRL_HW	0x0000ff00 /* DMA High-water mark */
asm-mips/ack:sgi/hpc3.h:	u32 _unused1[0x1000/4 - 1];	/* padding */
asm-mips/ack:sgi/hpc3.h:	u32 _unused0[0x1000/4 - 2];	/* padding */
asm-mips/ack:sgi/hpc3.h:#define HPC3_SDCFG_HW   0x01000 /* Enable 16-bit halfword DMA accesses to scsi */
asm-mips/ack:sgi/hpc3.h:#define HPC3_SPCFG_HW   0x1000 /* Enable 16-bit halfword PIO accesses to scsi */
asm-mips/ack:sgi/hpc3.h:	u32 _unused1[0x1000/4 - 6];	/* padding */
asm-mips/ack:sgi/hpc3.h:	u32 _unused0[0x1000/4 - 2];	/* padding */
asm-mips/ack:sgi/hpc3.h:	u32 _unused2[0x1000/4 - 8];	/* padding */
asm-mips/ack:sgi/hpc3.h:	u32 _unused3[0x1000/4 - 2];	/* padding */
asm-mips/ack:sgi/hpc3.h:	u32 _unused4[0x1000/4 - 4];	/* padding */
asm-mips/ack:sgi/hpc3.h:	 * you it was a peculiar bug. ;-)
asm-mips/ack:sgi/hpc3.h:#define HPC3_ISTAT_PBIMASK	0x0ff	/* irq bits for pbus devs 0 --> 7 */
asm-mips/ack:sgi/hpc3.h:	u32 _unused1[0x14000/4 - 5];	/* padding */
asm-mips/ack:sgi/hpc3.h:	/* Now direct PIO per-HPC3 peripheral access to external regs. */
asm-mips/ack:sgi/hpc3.h:	/* Per-peripheral device external registers and DMA/PIO control. */
asm-mips/ack:sgi/hpc3.h:	/* Enable 16-bit DMA access mode */
asm-mips/ack:sgi/hpc3.h:	/* Enable 16-bit PIO accesses */
asm-mips/ack:sgi/hpc3.h:	u32 _unused5[0x0800/4 - 1];
asm-mips/ack:sgi/hpc3.h:	u32 _unused6[0x0800/4 - 1];
asm-mips/ack:sgi/hpc3.h:	u32 _unused7[0x1000/4 - 1];
asm-mips/ack:sgi/hpc3.h:	volatile u32 bbram[8192-50-14];	/* Battery backed ram */
asm-mips/ack:sgi/ip22.h: * HAL2 driver). This will prevent many complications, trust me ;-)
asm-mips/ack:sgi/ip22.h:#define SGI_GIO_0_IRQ	SGI_FIFO_IRQ		/* GIO-0 */
asm-mips/ack:sgi/ip22.h:#define SGI_GIO_1_IRQ	SGINT_LOCAL0 + 6	/* GE / GIO-1 / 2nd-HPC */
asm-mips/ack:sgi/ip22.h:#define SGI_GIO_2_IRQ	SGINT_LOCAL1 + 7	/* Vert retrace / GIO-2 */
asm-mips/ack:sgi/ip22.h:#define ip22_is_fullhouse()	(sgioc->sysid & SGIOC_SYSID_FULLHOUSE)
asm-mips/ack:sgialib.h:/* A 32-bit ARC PROM pass arguments and environment as 32-bit pointer.
asm-mips/ack:sgialib.h:/* Simple char-by-char console I/O. */
asm-mips/ack:sgialib.h:/* Running stand-along programs. */
asm-mips/ack:sgiarcs.h:#define ROMVECTOR ((struct linux_romvec *) (long)(PROMBLOCK)->romvec)
asm-mips/ack:sgiarcs.h:#define SGIPROM_ROFILE    0x01  /* read-only file */
asm-mips/ack:sgiarcs.h: * Macros for calling a 32-bit ARC implementation from 64-bit code
asm-mips/ack:sgiarcs.h:	long __vec = (long) romvec->dest;				\
asm-mips/ack:sgiarcs.h:	long __vec = (long) romvec->dest;				\
asm-mips/ack:sgiarcs.h:	long __vec = (long) romvec->dest;				\
asm-mips/ack:sgiarcs.h:	long __vec = (long) romvec->dest;				\
asm-mips/ack:sgiarcs.h:	long __vec = (long) romvec->dest;				\
asm-mips/ack:sgiarcs.h:	long __vec = (long) romvec->dest;				\
asm-mips/ack:sgiarcs.h:	long (*__vec)(void) = (void *) romvec->dest;			\
asm-mips/ack:sgiarcs.h:	long (*__vec)(long) = (void *) romvec->dest;			\
asm-mips/ack:sgiarcs.h:	long (*__vec)(long, long) = (void *) romvec->dest;		\
asm-mips/ack:sgiarcs.h:	long (*__vec)(long, long, long)	= (void *) romvec->dest;	\
asm-mips/ack:sgiarcs.h:	long (*__vec)(long, long, long, long) = (void *) romvec->dest;	\
asm-mips/ack:sgiarcs.h:	__vec = (void *) romvec->dest;					\
asm-mips/ack:sgiarcs.h:#endif /* both kernel and ARC either 32-bit or 64-bit */
asm-mips/ack:shmbuf.h: * - 2 miscellaneous 32-bit values
asm-mips/ack:shmiq.h:        volatile unsigned int flags; /* place for out-of-band data */
asm-mips/ack:shmiq.h:/* -------------------- iDev stuff -------------------- */
asm-mips/ack:shmiq.h:/* These are only interpreted by SHMIQ-attacheable devices and are internal
asm-mips/ack:sibyte/sb1250_dma.h:    *  MA 02111-1307 USA
asm-mips/ack:sibyte/sb1250_dma.h: * Ethernet and Serial DMA Configuration Register 0  (Table 7-4)
asm-mips/ack:sibyte/sb1250_dma.h: * Ethernet and Serial DMA Configuration Register 1 (Table 7-5)
asm-mips/ack:sibyte/sb1250_dma.h: * Ethernet and Serial DMA Descriptor base address (Table 7-6)
asm-mips/ack:sibyte/sb1250_dma.h: * ASIC Mode Base Address (Table 7-7)
asm-mips/ack:sibyte/sb1250_dma.h: * DMA Descriptor Count Registers (Table 7-8)
asm-mips/ack:sibyte/sb1250_dma.h: * Current Descriptor Address Register (Table 7-11)
asm-mips/ack:sibyte/sb1250_dma.h: * Descriptor doubleword "A"  (Table 7-12)
asm-mips/ack:sibyte/sb1250_dma.h: * Descriptor doubleword "B"  (Table 7-13)
asm-mips/ack:sibyte/sb1250_dma.h: * Ethernet Descriptor Status Bits (Table 7-15)
asm-mips/ack:sibyte/sb1250_dma.h: * Ethernet Transmit Status Bits (Table 7-16)
asm-mips/ack:sibyte/sb1250_dma.h: * Ethernet Transmit Options (Table 7-17)
asm-mips/ack:sibyte/sb1250_dma.h: * Serial Receive Options (Table 7-18)
asm-mips/ack:sibyte/sb1250_dma.h: * Serial Transmit Status Bits (Table 7-20)
asm-mips/ack:sibyte/sb1250_dma.h: * Serial Transmit Options (Table 7-21)
asm-mips/ack:sibyte/sb1250_dma.h: * Data Mover Descriptor Base Address Register (Table 7-22)
asm-mips/ack:sibyte/sb1250_dma.h: * Data Mover Descriptor Count Register (Table 7-25)
asm-mips/ack:sibyte/sb1250_dma.h: * Data Mover Current Descriptor Address (Table 7-24)
asm-mips/ack:sibyte/sb1250_dma.h: * Data Mover Descriptor Doubleword "A"  (Table 7-26)
asm-mips/ack:sibyte/sb1250_dma.h: * Data Mover Descriptor Doubleword "B"  (Table 7-25)
asm-mips/ack:sibyte/sb1250_l2c.h:    *  MA 02111-1307 USA
asm-mips/ack:sibyte/sb1250_l2c.h: * Level 2 Cache Tag register (Table 5-3)
asm-mips/ack:sibyte/sb1250_l2c.h: * Format of level 2 cache management address (table 5-2)
asm-mips/ack:sibyte/sb1250_int.h:    *  MA 02111-1307 USA
asm-mips/ack:sibyte/sb1250_int.h: * Interrupt sources (Table 4-8, UM 0.2)
asm-mips/ack:sibyte/sb1250_int.h: * LDT Interrupt Set Register (table 4-5)
asm-mips/ack:sibyte/sb1250_int.h: * Vector format (Table 4-6)
asm-mips/ack:sibyte/sb1250_ldt.h:    *  MA 02111-1307 USA
asm-mips/ack:sibyte/sb1250_ldt.h: * LDT Command Register (Table 8-13)
asm-mips/ack:sibyte/sb1250_ldt.h: * LDT Status Register (Table 8-14).  Note that these constants
asm-mips/ack:sibyte/sb1250_ldt.h: * together (32-bit read at offset 0x04)
asm-mips/ack:sibyte/sb1250_ldt.h: * register (Table 8-15), offset 0x1C
asm-mips/ack:sibyte/sb1250_ldt.h: * Bridge Control Register (Table 8-16).  Note that these 
asm-mips/ack:sibyte/sb1250_ldt.h: * constants assume you've read the register as a 32-bit 
asm-mips/ack:sibyte/sb1250_ldt.h: * LDT Command Register (Table 8-17).  Note that these constants
asm-mips/ack:sibyte/sb1250_ldt.h: * 32-bit read at offset 0x40
asm-mips/ack:sibyte/sb1250_ldt.h: * LDT link control register (Table 8-18), and (Table 8-19)
asm-mips/ack:sibyte/sb1250_ldt.h: * LDT Link frequency register  (Table 8-20) offset 0x48
asm-mips/ack:sibyte/sb1250_ldt.h: * LDT SRI Command Register (Table 8-21).  Note that these constants
asm-mips/ack:sibyte/sb1250_ldt.h: * 32-bit read at offset 0x50
asm-mips/ack:sibyte/sb1250_ldt.h: * LDT Error control and status register (Table 8-22) (Table 8-23)
asm-mips/ack:sibyte/sb1250_ldt.h: * SRI Control register (Table 8-24, 8-25)  Offset 0x6C
asm-mips/ack:sibyte/sb1250_ldt.h: * LDT SRI Transmit Buffer Count register (Table 8-26)
asm-mips/ack:sibyte/sb1250_mac.h:    *  MA 02111-1307 USA
asm-mips/ack:sibyte/sb1250_mac.h: * MAC Configuration Register (Table 9-13)
asm-mips/ack:sibyte/sb1250_mac.h: * MAC Fifo Threshhold registers (Table 9-14)
asm-mips/ack:sibyte/sb1250_mac.h: * MAC Frame Configuration Registers (Table 9-15)
asm-mips/ack:sibyte/sb1250_mac.h: * MAC VLAN Tag Registers (Table 9-16)
asm-mips/ack:sibyte/sb1250_mac.h: * MAC Status Registers (Table 9-17)
asm-mips/ack:sibyte/sb1250_mac.h: * Also used for the MAC Interrupt Mask Register (Table 9-18)
asm-mips/ack:sibyte/sb1250_mac.h: *  and pass just the six bits to a DMA-channel-specific ISR
asm-mips/ack:sibyte/sb1250_mac.h: * MAC Fifo Pointer Registers (Table 9-19)    [Debug register]
asm-mips/ack:sibyte/sb1250_mac.h: * MAC Fifo End Of Packet Count Registers (Table 9-20)  [Debug register]
asm-mips/ack:sibyte/sb1250_mac.h: * MAC Recieve Address Filter Exact Match Registers (Table 9-21)
asm-mips/ack:sibyte/sb1250_mac.h: * MAC Recieve Address Filter Hash Match Registers (Table 9-22)
asm-mips/ack:sibyte/sb1250_mac.h: * MAC Transmit Source Address Registers (Table 9-23)
asm-mips/ack:sibyte/sb1250_mac.h: * MAC Receive Address Filter Control Registers (Table 9-24)
asm-mips/ack:sibyte/sb1250_mac.h: * MAC Receive Channel Select Registers (Table 9-25)
asm-mips/ack:sibyte/sb1250_mac.h: * MAC MII Management Interface Registers (Table 9-26)
asm-mips/ack:sibyte/sb1250_scd.h:    *  MA 02111-1307 USA
asm-mips/ack:sibyte/sb1250_scd.h: * System Revision Register (Table 4-1)
asm-mips/ack:sibyte/sb1250_scd.h: * System Config Register (Table 4-2)
asm-mips/ack:sibyte/sb1250_scd.h: * Mailbox Registers (Table 4-3)
asm-mips/ack:sibyte/sb1250_scd.h: * Watchdog Registers (Table 4-8) (Table 4-9) (Table 4-10)
asm-mips/ack:sibyte/sb1250_scd.h: * Timer Registers (Table 4-11) (Table 4-12) (Table 4-13)
asm-mips/ack:sibyte/trace_prof.h: * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
asm-mips/ack:sibyte/trace_prof.h: * Routines for using 40-bit SCD cycle counter
asm-mips/ack:sibyte/trace_prof.h: * zclk_timer_init(0) at least every 2^40 - 1 ZCLKs.
asm-mips/ack:sibyte/sb1250_syncser.h:    *  MA 02111-1307 USA
asm-mips/ack:sibyte/sb1250.h: * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
asm-mips/ack:sibyte/sb1250_mc.h:    *  MA 02111-1307 USA
asm-mips/ack:sibyte/sb1250_mc.h: * Memory Channel Config Register (table 6-14)
asm-mips/ack:sibyte/sb1250_mc.h: * Memory clock config register (Table 6-15)
asm-mips/ack:sibyte/sb1250_mc.h: * DRAM Command Register (Table 6-13)
asm-mips/ack:sibyte/sb1250_mc.h: * DRAM Mode Register (Table 6-14)
asm-mips/ack:sibyte/sb1250_mc.h: * SDRAM Timing Register  (Table 6-15)
asm-mips/ack:sibyte/sb1250_mc.h: * Chip Select Start Address Register (Table 6-17)
asm-mips/ack:sibyte/sb1250_mc.h: * Chip Select End Address Register (Table 6-18)
asm-mips/ack:sibyte/sb1250_mc.h: * Chip Select Interleave Register (Table 6-19)
asm-mips/ack:sibyte/sb1250_mc.h: * Row Address Bits Register (Table 6-20)
asm-mips/ack:sibyte/sb1250_mc.h: * Column Address Bits Register (Table 6-21)
asm-mips/ack:sibyte/sb1250_mc.h: * Bank Address Address Bits Register (Table 6-22)
asm-mips/ack:sibyte/sb1250_mc.h: * Chip Select Attribute Register (Table 6-23)
asm-mips/ack:sibyte/sb1250_mc.h: * ECC Test ECC Register (Table 6-25)
asm-mips/ack:sibyte/swarm.h: * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
asm-mips/ack:sibyte/carmel.h: * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
asm-mips/ack:sibyte/sb1250_smbus.h:    *  MA 02111-1307 USA
asm-mips/ack:sibyte/sb1250_smbus.h: * SMBus Clock Frequency Register (Table 14-2)
asm-mips/ack:sibyte/sb1250_smbus.h: * SMBus control register (Table 14-4)
asm-mips/ack:sibyte/sb1250_smbus.h: * SMBus status registers (Table 14-5)
asm-mips/ack:sibyte/sb1250_smbus.h: * SMBus Start/Command registers (Table 14-9)
asm-mips/ack:sibyte/sb1250_smbus.h: * SMBus Data Register (Table 14-6) and SMBus Extra Register (Table 14-7)
asm-mips/ack:sibyte/sb1250_smbus.h: * SMBus Packet Error Check register (Table 14-8)
asm-mips/ack:sibyte/sentosa.h: * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
asm-mips/ack:sibyte/64bit.h: * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
asm-mips/ack:sibyte/64bit.h: * This is annoying...we can't actually write the 64-bit IO register properly
asm-mips/ack:sibyte/64bit.h: * without having access to 64-bit registers...  which doesn't work by default
asm-mips/ack:sibyte/64bit.h: * driver code for the 32-bit and 64-bit trees
asm-mips/ack:sibyte/64bit.h: * Avoid interrupt mucking, just adjust the address for 4-byte access.
asm-mips/ack:sibyte/64bit.h: * Assume the addresses are 8-byte aligned.
asm-mips/ack:sibyte/sb1250_defs.h:    *  MA 02111-1307 USA
asm-mips/ack:sibyte/sb1250_defs.h: * 'long long' (64-bit integer) support.
asm-mips/ack:sibyte/sb1250_defs.h:    ((SIBYTE_HDR_FMASK(chip, pass) - 1) & SIBYTE_HDR_FMASK_ALLREVS(chip))
asm-mips/ack:sibyte/sb1250_defs.h:     | (SIBYTE_HDR_FMASK(chip, pass) - 1)) & SIBYTE_HDR_FMASK_ALLREVS(chip))
asm-mips/ack:sibyte/sb1250_defs.h:    *                  For multi-bit fields, all bits in the field will
asm-mips/ack:sibyte/sb1250_defs.h:    *  K_xxx           "Code" constant (value for data in a multi-bit
asm-mips/ack:sibyte/sb1250_defs.h:    *  G_xxx(X)        GET value.  This macro obtains a multi-bit field
asm-mips/ack:sibyte/sb1250_defs.h: * Cast to 64-bit number.  Presumably the syntax is different in 
asm-mips/ack:sibyte/sb1250_defs.h:#define _SB_MAKEMASK(v,n) (_SB_MAKE64((_SB_MAKE64(1)<<(v))-1) << _SB_MAKE64(n))
asm-mips/ack:sibyte/sb1250_defs.h:#define _SB_MAKEMASK_32(v,n) (_SB_MAKE32((_SB_MAKE32(1)<<(v))-1) << _SB_MAKE32(n))
asm-mips/ack:sibyte/sb1250_defs.h: * Macros to read/write on-chip registers
asm-mips/ack:sibyte/sb1250_genbus.h:    *  MA 02111-1307 USA
asm-mips/ack:sibyte/sb1250_genbus.h: * Generic Bus Region Configuration Registers (Table 11-4)
asm-mips/ack:sibyte/sb1250_genbus.h: * Generic Bus Region Size register (Table 11-5)
asm-mips/ack:sibyte/sb1250_genbus.h: * Generic Bus Region Address (Table 11-6)
asm-mips/ack:sibyte/sb1250_genbus.h: * Generic Bus Region 0 Timing Registers (Table 11-7)
asm-mips/ack:sibyte/sb1250_genbus.h: * Generic Bus Timing 1 Registers (Table 11-8)
asm-mips/ack:sibyte/sb1250_genbus.h: * Generic Bus Interrupt Status Register (Table 11-9)
asm-mips/ack:sibyte/sb1250_genbus.h: * PCMCIA configuration register (Table 12-6)
asm-mips/ack:sibyte/sb1250_genbus.h: * PCMCIA status register (Table 12-7)
asm-mips/ack:sibyte/sb1250_genbus.h: * GPIO Interrupt Type Register (table 13-3)
asm-mips/ack:sibyte/board.h: * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
asm-mips/ack:sibyte/sb1250_regs.h:    *  This module contains the addresses of the on-chip peripherals
asm-mips/ack:sibyte/sb1250_regs.h:    *  MA 02111-1307 USA
asm-mips/ack:sibyte/sb1250_regs.h:/* Backward-compatibility definitions.  */
asm-mips/ack:sibyte/sb1250_uart.h:    *  MA 02111-1307 USA
asm-mips/ack:sibyte/sb1250_uart.h: * DUART Mode Register #1 (Table 10-3)
asm-mips/ack:sibyte/sb1250_uart.h: * DUART Mode Register #2 (Table 10-4)
asm-mips/ack:sibyte/sb1250_uart.h: * DUART Command Register (Table 10-5)
asm-mips/ack:sibyte/sb1250_uart.h: * DUART Status Register (Table 10-6)
asm-mips/ack:sibyte/sb1250_uart.h: * READ-ONLY
asm-mips/ack:sibyte/sb1250_uart.h: * DUART Baud Rate Register (Table 10-7)
asm-mips/ack:sibyte/sb1250_uart.h:#define V_DUART_BAUD_RATE(x)        (100000000/((x)*20)-1)
asm-mips/ack:sibyte/sb1250_uart.h: * DUART Data Registers (Table 10-8 and 10-9)
asm-mips/ack:sibyte/sb1250_uart.h: * DUART Input Port Register (Table 10-10)
asm-mips/ack:sibyte/sb1250_uart.h: * DUART Input Port Change Status Register (Tables 10-11, 10-12, and 10-13)
asm-mips/ack:sibyte/sb1250_uart.h: * DUART Output port control register (Table 10-14)
asm-mips/ack:sibyte/sb1250_uart.h: * DUART Aux Control Register (Table 10-15)
asm-mips/ack:sibyte/sb1250_uart.h: * DUART Interrupt Status Register (Table 10-16)
asm-mips/ack:sibyte/sb1250_uart.h: * DUART Channel A Interrupt Status Register (Table 10-17)
asm-mips/ack:sibyte/sb1250_uart.h: * DUART Channel B Interrupt Status Register (Table 10-18)
asm-mips/ack:sibyte/sb1250_uart.h: * DUART Interrupt Mask Register (Table 10-19)
asm-mips/ack:sibyte/sb1250_uart.h: * DUART Channel A Interrupt Mask Register (Table 10-20)
asm-mips/ack:sibyte/sb1250_uart.h: * DUART Channel B Interrupt Mask Register (Table 10-21)
asm-mips/ack:sibyte/sb1250_uart.h: * DUART Output Port Set Register (Table 10-22)
asm-mips/ack:sibyte/sb1250_uart.h: * DUART Output Port Clear Register (Table 10-23)
asm-mips/ack:sibyte/sb1250_uart.h: * DUART Output Port RTS Register (Table 10-24)
asm-mips/ack:siginfo.h:#define SI_PAD_SIZE	((SI_MAX_SIZE/sizeof(int)) - 3)
asm-mips/ack:siginfo.h:#define SI_PAD_SIZE	((SI_MAX_SIZE/sizeof(int)) - 4)
asm-mips/ack:siginfo.h:	int __pad0[SI_MAX_SIZE / sizeof(int) - SI_PAD_SIZE - 3];
asm-mips/ack:siginfo.h:#define SI_QUEUE	-1	/* sent by sigqueue */
asm-mips/ack:siginfo.h:#define SI_ASYNCIO	-2	/* sent by AIO completion */
asm-mips/ack:siginfo.h:#define SI_TIMER __SI_CODE(__SI_TIMER,-3) /* sent by timer expiration */
asm-mips/ack:siginfo.h:#define SI_MESGQ	-4	/* sent by real time mesq state change */
asm-mips/ack:siginfo.h:#define SI_SIGIO	-5	/* sent by queued SIGIO */
asm-mips/ack:siginfo.h:#define SI_TKILL	-6	/* sent by tkill system call */
asm-mips/ack:siginfo.h:#define SI_FROMUSER(siptr)	((siptr)->si_code <= 0)
asm-mips/ack:siginfo.h:#define SI_FROMKERNEL(siptr)	((siptr)->si_code > 0)
asm-mips/ack:siginfo.h:#define BUS_ADRERR	(__SI_FAULT|2)	/* non-existant physical address */
asm-mips/ack:siginfo.h:#define SIGEV_PAD_SIZE	((SIGEV_MAX_SIZE-SIGEV_HEAD_SIZE) / sizeof(int))
asm-mips/ack:siginfo.h:	if (from->si_code < 0)
asm-mips/ack:siginfo.h:		memcpy(to, from, 3*sizeof(int) + sizeof(from->_sifields._sigchld));
asm-mips/ack:signal.h:#define SIGFPE		 8	/* Floating-point exception (ANSI).  */
asm-mips/ack:signal.h:#define SIGUSR1		16	/* User-defined signal 1 (POSIX).  */
asm-mips/ack:signal.h:#define SIGUSR2		17	/* User-defined signal 2 (POSIX).  */
asm-mips/ack:signal.h:#define SIGRTMAX	(_NSIG-1)
asm-mips/ack:signal.h: * SA_INTERRUPT is a no-op, but left due to historical reasons. Use the
asm-mips/ack:signal.h:#define SA_INTERRUPT	0x20000000	/* dummy -- ignored */
asm-mips/ack:signal.h:#define SIG_ERR	((__sighandler_t)-1)	/* error return from signal */
asm-mips/ack:signal.h: * non-Linux/MIPS object files or make use of them in the future.
asm-mips/ack:signal.h:#define BRK_BD_TAKEN	3	/* For bd slot emulation - not implemented */
asm-mips/ack:signal.h:#define BRK_BD_NOTTAKEN	4	/* For bd slot emulation - not implemented */
asm-mips/ack:signal.h:#define BRK_NORLD	10	/* No rld found - not used by Linux/MIPS */
asm-mips/ack:smp.h: * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
asm-mips/ack:smp.h: * Copyright (C) 2000 - 2001 by Kanoj Sarcar (kanoj@sgi.com)
asm-mips/ack:smp.h: * Copyright (C) 2000 - 2001 by Silicon Graphics, Inc.
asm-mips/ack:smp.h:#define smp_processor_id()	(current->processor)
asm-mips/ack:smp.h:   not be idempotent when cpus failed to come on-line.  */
asm-mips/ack:smp.h:#define NO_PROC_ID	(-1)
asm-mips/ack:smp.h:/* These are defined by the board-specific code. */
asm-mips/ack:smplock.h:	if (task->lock_depth >= 0) \
asm-mips/ack:smplock.h: * Re-acquire the kernel lock
asm-mips/ack:smplock.h:	if (task->lock_depth >= 0) \
asm-mips/ack:smplock.h:	if (!++current->lock_depth)
asm-mips/ack:smplock.h:	if (--current->lock_depth < 0)
asm-mips/ack:sni.h: * Interrupt 0-16 are EISA interrupts.  Interrupts from 16 on are assigned
asm-mips/ack:socket.h:#define SO_OOBINLINE 0x0100	/* Receive out-of-band data in-band.  */
asm-mips/ack:socket.h:#define SO_SNDLOWAT	0x1003	/* send low-water mark */
asm-mips/ack:socket.h:#define SO_RCVLOWAT	0x1004	/* receive low-water mark */
asm-mips/ack:socket.h:/* linux-specific, might as well be the same as on i386 */
asm-mips/ack:socket.h:/* Security levels - as per NRL IPv6 - don't actually do anything */
asm-mips/ack:socket.h:/* Nast libc5 fixup - bletch */
asm-mips/ack:socket.h:#define SOCK_RDM	4		/* reliably-delivered message	*/
asm-mips/ack:sockios.h: * Socket-level I/O control calls.
asm-mips/ack:sockios.h:/* Socket-level I/O control calls. */
asm-mips/ack:sockios.h:#define SIOCGSTAMP	0x8906			/* Get stamp - linux-specific */
asm-mips/ack:softirq.h:	local_bh_count(cpu)--;
asm-mips/ack:softirq.h:	if (!--local_bh_count(cpu) && softirq_pending(cpu))	\
asm-mips/ack:spinlock.h:#define spin_lock_init(x)	do { (x)->lock = 0; } while(0)
asm-mips/ack:spinlock.h:#define spin_is_locked(x)	((x)->lock != 0)
asm-mips/ack:spinlock.h:#define spin_unlock_wait(x)	do { barrier(); } while ((x)->lock)
asm-mips/ack:spinlock.h:	: "=m" (lock->lock), "=&r" (tmp)
asm-mips/ack:spinlock.h:	: "m" (lock->lock)
asm-mips/ack:spinlock.h:	: "=m" (lock->lock)
asm-mips/ack:spinlock.h:	: "m" (lock->lock)
asm-mips/ack:spinlock.h: * Read-write spinlocks, allowing multiple readers but only one writer.
asm-mips/ack:spinlock.h: * writers. For those circumstances we can "mix" irq-safe locks - any writer
asm-mips/ack:spinlock.h: * needs to get a irq-safe write-lock, but readers can get non-irqsafe
asm-mips/ack:spinlock.h: * read-locks.
asm-mips/ack:spinlock.h:	: "=m" (rw->lock), "=&r" (tmp)
asm-mips/ack:spinlock.h:	: "m" (rw->lock)
asm-mips/ack:spinlock.h:	: "=m" (rw->lock), "=&r" (tmp)
asm-mips/ack:spinlock.h:	: "m" (rw->lock)
asm-mips/ack:spinlock.h:	: "=m" (rw->lock), "=&r" (tmp)
asm-mips/ack:spinlock.h:	: "m" (rw->lock)
asm-mips/ack:spinlock.h:	: "=m" (rw->lock)
asm-mips/ack:spinlock.h:	: "m" (rw->lock)
asm-mips/ack:statfs.h:	long		f_frsize;	/* Fragment size - unsupported */
asm-mips/ack:stat.h: * struct stat of the 64-bit kernel.
asm-mips/ack:string.h:		"lbu\t$1,-1(%0)\n\t"
asm-mips/ack:sysmips.h: * sysmips(2) is deprecated - though some existing software uses it.
asm-mips/ack:system.h: * Copyright (C) 1994 - 1999 by Ralf Baechle
asm-mips/ack:system.h: * Copyright (C) 1994 - 1999 by Ralf Baechle
asm-mips/ack:system.h:#endif /* Processor-dependent optimization */
asm-mips/ack:termbits.h:#define VKILL		 3		/* Kill-line character [ICANON].  */
asm-mips/ack:termbits.h:#define VTIME		 5		/* Time-out value (tenths of a second) [!ICANON].  */
asm-mips/ack:termbits.h:#define VSTART		 8		/* Start (X-ON) character [IXON, IXOFF].  */
asm-mips/ack:termbits.h:#define VSTOP		 9		/* Stop (X-OFF) character [IXON, IXOFF].  */
asm-mips/ack:termbits.h:#define VREPRINT	12		/* Reprint-line character [ICANON].  */
asm-mips/ack:termbits.h:#define VWERASE		14		/* Word-erase character [ICANON].  */
asm-mips/ack:termbits.h:#define VLNEXT		15		/* Literal-next character [IEXTEN].  */
asm-mips/ack:termbits.h:#define VEOF		16		/* End-of-file character [ICANON].  */
asm-mips/ack:termbits.h:#define VEOL		17		/* End-of-line character [ICANON].  */
asm-mips/ack:termbits.h:#define ONLCR	0000004		/* Map NL to CR-NL on output.  */
asm-mips/ack:termios.h:	int	sg_flags;	/* SGI special - int, not short */
asm-mips/ack:termios.h:#define N_IRDA		11	/* Linux IrDa - http://irda.sourceforge.net/ */
asm-mips/ack:termios.h:#define N_SMSBLOCK	12	/* SMS block mode - for talking to GSM data cards about SMS messages */
asm-mips/ack:termios.h:	get_user(tmp, &(termio)->c_iflag); \
asm-mips/ack:termios.h:	(termios)->c_iflag = (0xffff0000 & ((termios)->c_iflag)) | tmp; \
asm-mips/ack:termios.h:	get_user(tmp, &(termio)->c_oflag); \
asm-mips/ack:termios.h:	(termios)->c_oflag = (0xffff0000 & ((termios)->c_oflag)) | tmp; \
asm-mips/ack:termios.h:	get_user(tmp, &(termio)->c_cflag); \
asm-mips/ack:termios.h:	(termios)->c_cflag = (0xffff0000 & ((termios)->c_cflag)) | tmp; \
asm-mips/ack:termios.h:	get_user(tmp, &(termio)->c_lflag); \
asm-mips/ack:termios.h:	(termios)->c_lflag = (0xffff0000 & ((termios)->c_lflag)) | tmp; \
asm-mips/ack:termios.h:	get_user((termios)->c_line, &(termio)->c_line); \
asm-mips/ack:termios.h:	copy_from_user((termios)->c_cc, (termio)->c_cc, NCC); \
asm-mips/ack:termios.h:	put_user((termios)->c_iflag, &(termio)->c_iflag); \
asm-mips/ack:termios.h:	put_user((termios)->c_oflag, &(termio)->c_oflag); \
asm-mips/ack:termios.h:	put_user((termios)->c_cflag, &(termio)->c_cflag); \
asm-mips/ack:termios.h:	put_user((termios)->c_lflag, &(termio)->c_lflag); \
asm-mips/ack:termios.h:	put_user((termios)->c_line, &(termio)->c_line); \
asm-mips/ack:termios.h:	copy_to_user((termio)->c_cc, (termios)->c_cc, NCC); \
asm-mips/ack:time.h: * include/asm-mips/time.h
asm-mips/ack:time.h: * RTC ops.  By default, they point to no-RTC functions.
asm-mips/ack:time.h: *	rtc_get_time - mktime(year, mon, day, hour, min, sec) in seconds.
asm-mips/ack:time.h: *	rtc_set_time - reverse the above translation and set time to RTC.
asm-mips/ack:time.h: *	rtc_set_mmss - similar to rtc_set_time, but only min and sec need
asm-mips/ack:time.h: *			to be set.  Used by RTC sync-up.
asm-mips/ack:time.h: * mips_timer_ack may be NULL if the interrupt is self-recoverable.
asm-mips/ack:time.h: * If mips_hpt_read is NULL, an R4k-compatible timer setup is attempted.
asm-mips/ack:time.h: * high-level timer interrupt routines.
asm-mips/ack:time.h: * the corresponding low-level timer interrupt routine.
asm-mips/ack:time.h: * mips_hpt_frequency - must be set if you intend to use an R4k-compatible
asm-mips/ack:titan_dep.h: * Copyright 2003 PMC-Sierra
asm-mips/ack:titan_dep.h: * Author: Manish Lachwani (lachwani@pmc-sierra.com)
asm-mips/ack:titan_dep.h: * Board specific definititions for the PMC-Sierra Yosemite
asm-mips/ack:tlb.h:#include <asm-generic/tlb.h>
asm-mips/ack:traps.h: *	include/asm-mips/traps.h
asm-mips/ack:tx3912.h: *  include/asm-mips/tx3912.h
asm-mips/ack:tx3912.h: *	---------------                                                      *
asm-mips/ack:tx3912.h: *	-------------------                                                  *
asm-mips/ack:tx3912.h: *	---------------                                                      *
asm-mips/ack:tx3912.h: *	---------------                                                      *
asm-mips/ack:tx3912.h: *	--------------                                                       *
asm-mips/ack:tx3912.h: *	---------------                                                      *
asm-mips/ack:tx4927/tx4927.h: * Copyright 2001-2002 MontaVista Software Inc.
asm-mips/ack:tx4927/tx4927.h: followed by the device name from table 4.2.2 on page 4-3 and then followed
asm-mips/ack:tx4927/tx4927.h: by the register name from table 4.2.3 on pages 4-4 to 4-8.  The manaul
asm-mips/ack:tx4927/tx4927.h:/* TX4927 SDRAM controller (64-bit registers) */
asm-mips/ack:tx4927/tx4927.h:/* TX4927 external bus controller (64-bit registers) */
asm-mips/ack:tx4927/tx4927.h:/* TX4927 SDRRAM Error Check Correction (64-bit registers) */
asm-mips/ack:tx4927/tx4927.h:/* TX4927 DMA Controller (64-bit registers) */
asm-mips/ack:tx4927/tx4927.h:/* TX4927 PCI Controller (32-bit registers) */
asm-mips/ack:tx4927/tx4927.h:/* TX4927 Configuration registers (64-bit registers) */
asm-mips/ack:tx4927/tx4927.h:/* TX4927 Timer 0 (32-bit registers) */
asm-mips/ack:tx4927/tx4927.h:/* TX4927 Timer 1 (32-bit registers) */
asm-mips/ack:tx4927/tx4927.h:/* TX4927 Timer 2 (32-bit registers) */
asm-mips/ack:tx4927/tx4927.h:/* TX4927 serial port 0 (32-bit registers) */
asm-mips/ack:tx4927/tx4927.h:/* TX4927 serial port 1 (32-bit registers) */
asm-mips/ack:tx4927/tx4927.h:/* TX4927 parallel port (32-bit registers) */
asm-mips/ack:tx4927/tx4927.h:/* TX4927 Interrupt Controller (32-bit registers) */
asm-mips/ack:tx4927/tx4927.h:/* TX4927 AC-link controller (32-bit registers) */
asm-mips/ack:tx4927/tx4927.h:#define TX4927_IRQ_CP0_RAW_BEG   0    /* tx4927 cpu built-in cp0 */
asm-mips/ack:tx4927/tx4927.h:#define TX4927_IRQ_PIC_RAW_BEG   0    /* tx4927 cpu build-in pic */
asm-mips/ack:tx4927/tx4927_pci.h: * Copyright (C) 2000-2001 Toshiba Corporation
asm-mips/ack:tx4927/tx4927_pci.h:#define TX4927_NR_IRQ_IRC       32      /* On-Chip IRC */
asm-mips/ack:tx4927/tx4927_pci.h:#define TX4927_PCIC_IDSEL_AD_TO_SLOT(ad)        ((ad) - 11)
asm-mips/ack:tx4927/toshiba_rbtx4927.h: * Copyright 2001-2002 MontaVista Software Inc.
asm-mips/ack:tx4927/toshiba_rbtx4927.h:#define RBTX4927_RTL_8019_BASE (0x1c020280-TBTX4927_ISA_IO_OFFSET)
asm-mips/ack:tx4927/tx4927_mips.h: * Copyright 2001-2002 MontaVista Software Inc.
asm-mips/ack:uaccess.h:#define __UA_LIMIT	(- TASK_SIZE)
asm-mips/ack:uaccess.h: * userspace address.  Note that we limit 32-bit userspace to 0x7fff8000 but
asm-mips/ack:uaccess.h: * we use 0x80000000 here on 32-bit kernels.  If a process passes an invalid
asm-mips/ack:uaccess.h: * address in this range it's the process's problem, not ours :-)
asm-mips/ack:uaccess.h:#define get_fs()	(current->thread.current_ds)
asm-mips/ack:uaccess.h:#define set_fs(x)	(current->thread.current_ds = (x))
asm-mips/ack:uaccess.h: *  - "addr" doesn't have any high-bits set
asm-mips/ack:uaccess.h: *  - AND "size" doesn't have any high-bits set
asm-mips/ack:uaccess.h: *  - AND "addr+size" doesn't have any high-bits set
asm-mips/ack:uaccess.h: *  - OR we are in kernel mode.
asm-mips/ack:uaccess.h: * access_ok: - Checks if a user space pointer is valid
asm-mips/ack:uaccess.h: *        %VERIFY_WRITE is a superset of %VERIFY_READ - if it is safe
asm-mips/ack:uaccess.h: * checks that the pointer is in the user space range - after calling
asm-mips/ack:uaccess.h: * this function, memory access functions may still return -EFAULT.
asm-mips/ack:uaccess.h: * verify_area: - Obsolete, use access_ok()
asm-mips/ack:uaccess.h: * Returns zero if the memory block may be valid, -EFAULT
asm-mips/ack:uaccess.h:	return access_ok(type, addr, size) ? 0 : -EFAULT;
asm-mips/ack:uaccess.h: * put_user: - Write a simple value into user space.
asm-mips/ack:uaccess.h: * @ptr must have pointer-to-simple-variable type, and @x must be assignable
asm-mips/ack:uaccess.h: * Returns zero on success, or -EFAULT on error.
asm-mips/ack:uaccess.h: * get_user: - Get a simple variable from user space.
asm-mips/ack:uaccess.h: * @ptr must have pointer-to-simple-variable type, and the result of
asm-mips/ack:uaccess.h: * Returns zero on success, or -EFAULT on error.
asm-mips/ack:uaccess.h: * __put_user: - Write a simple value into user space, with less checking.
asm-mips/ack:uaccess.h: * @ptr must have pointer-to-simple-variable type, and @x must be assignable
asm-mips/ack:uaccess.h: * Returns zero on success, or -EFAULT on error.
asm-mips/ack:uaccess.h: * __get_user: - Get a simple variable from user space, with less checking.
asm-mips/ack:uaccess.h: * @ptr must have pointer-to-simple-variable type, and the result of
asm-mips/ack:uaccess.h: * Returns zero on success, or -EFAULT on error.
asm-mips/ack:uaccess.h:	: "0" (__gu_err), "o" (__m(__gu_addr)), "i" (-EFAULT));		\
asm-mips/ack:uaccess.h:	  "o" (__m(__gu_addr + 4)), "i" (-EFAULT));			\
asm-mips/ack:uaccess.h:	  "i" (-EFAULT));						\
asm-mips/ack:uaccess.h:	  "o" (__m(__pu_addr + 4)), "i" (-EFAULT));			\
asm-mips/ack:uaccess.h: * __copy_to_user: - Copy a block of data into user space, with less checking.
asm-mips/ack:uaccess.h: * copy_to_user: - Copy a block of data into user space.
asm-mips/ack:uaccess.h: * __copy_from_user: - Copy a block of data from user space, with less checking. * @to:   Destination address, in kernel space.
asm-mips/ack:uaccess.h: * copy_from_user: - Copy a block of data from user space.
asm-mips/ack:uaccess.h: * __clear_user: - Zero a block of memory in user space, with less checking.
asm-mips/ack:uaccess.h: * __strncpy_from_user: - Copy a NUL terminated string from userspace, with less checking.
asm-mips/ack:uaccess.h: * Copies a NUL-terminated string from userspace to kernel space.
asm-mips/ack:uaccess.h: * If access to userspace fails, returns -EFAULT (some data may have been
asm-mips/ack:uaccess.h: * strncpy_from_user: - Copy a NUL terminated string from userspace.
asm-mips/ack:uaccess.h: * Copies a NUL-terminated string from userspace to kernel space.
asm-mips/ack:uaccess.h: * If access to userspace fails, returns -EFAULT (some data may have been
asm-mips/ack:uaccess.h: * strlen_user: - Get the size of a string in user space.
asm-mips/ack:uaccess.h: * Get the size of a NUL-terminated string in user space.
asm-mips/ack:uaccess.h: * strlen_user: - Get the size of a string in user space.
asm-mips/ack:uaccess.h: * Get the size of a NUL-terminated string in user space.
asm-mips/ack:unaligned.h: * get_unaligned - get value from possibly mis-aligned location
asm-mips/ack:unaligned.h: * e.g. retrieving a u16 value from a location not u16-aligned.
asm-mips/ack:unaligned.h: * put_unaligned - put value to a possibly mis-aligned location
asm-mips/ack:unaligned.h: * e.g. writing a u16 value to a location not u16-aligned.
asm-mips/ack:unaligned.h:	return ptr->x;
asm-mips/ack:unaligned.h:	return ptr->x;
asm-mips/ack:unaligned.h:	return ptr->x;
asm-mips/ack:unaligned.h:	ptr->x = r5;
asm-mips/ack:unaligned.h:	ptr->x = r5;
asm-mips/ack:unaligned.h:	ptr->x = r5;
asm-mips/ack:unistd.h: * Linux 64-bit syscalls are in the range from 5000 to 5999.
asm-mips/ack:unistd.h: * Offset of the last Linux 64-bit flavoured syscall
asm-mips/ack:unistd.h:/* XXX - _foo needs to be __foo, while __NR_bar could be _NR_bar. */
asm-mips/ack:unistd.h:	return (type)-1; \
asm-mips/ack:unistd.h:	return (type)-1; \
asm-mips/ack:unistd.h:	return (type)-1; \
asm-mips/ack:unistd.h:	return (type)-1; \
asm-mips/ack:unistd.h:	return (type)-1; \
asm-mips/ack:unistd.h: * Using those means your brain needs more than an oil change ;-)
asm-mips/ack:unistd.h:	return (type)-1; \
asm-mips/ack:unistd.h:	return (type)-1; \
asm-mips/ack:unistd.h:	return (type)-1; \
asm-mips/ack:unistd.h:	return (type)-1; \
asm-mips/ack:unistd.h: * we need this inline - forking from kernel space will result
asm-mips/ack:unistd.h: * calls - which means inline code for fork too, as otherwise we
asm-mips/ack:unistd.h:	return waitpid(-1, wait_stat, 0);
asm-mips/ack:user.h: * linux we use the `trad-core' bfd, NOT the irix-core).  The file
asm-mips/ack:user.h: *  data: The data segment follows next.  We use current->end_text to
asm-mips/ack:user.h: *	current->brk to pick up all of the user variables, plus any memory
asm-mips/ack:user.h: *	page is demand-zero or if a page is totally unused, we just cover
asm-mips/ack:user.h: *	current->start_stack, so we round each of these in order to be able
asm-mips/ack:usioctl.h: * usema/usemaclone-related stuff.
asm-mips/ack:vr4181/irq.h:   IP0 - Software interrupt
asm-mips/ack:vr4181/irq.h:   IP1 - Software interrupt
asm-mips/ack:vr4181/irq.h:   IP2 - All but battery, high speed modem, and real time clock
asm-mips/ack:vr4181/irq.h:   IP3 - RTC Long1 (system timer)
asm-mips/ack:vr4181/irq.h:   IP4 - RTC Long2
asm-mips/ack:vr4181/irq.h:   IP5 - High Speed Modem (unused on VR4181)
asm-mips/ack:vr4181/irq.h:   IP6 - Unused
asm-mips/ack:vr4181/irq.h:   IP7 - Timer interrupt from CPO_COMPARE
asm-mips/ack:vr4181/irq.h:   IP2 - same as VR4181_IRQ_INT1
asm-mips/ack:vr4181/irq.h:   IP8 - This is a cascade to GPIO IRQ's. Do not use.
asm-mips/ack:vr4181/irq.h:   IP16 - same as VR4181_IRQ_INT2
asm-mips/ack:vr4181/irq.h:   IP18 - CompactFlash
asm-mips/ack:vr4181/vr4181.h:#define VR4181_MISCREG0		__preg16(KSEG1 + 0x0B000330)	/* Misc. R/W Battery Backed Registers for Non-Volatile Storage (R/W) */
asm-mips/ack:vr4181/vr4181.h:#define VR4181_MISCREG1		__preg16(KSEG1 + 0x0B000332)	/* Misc. R/W Battery Backed Registers for Non-Volatile Storage (R/W) */
asm-mips/ack:vr4181/vr4181.h:#define VR4181_MISCREG2		__preg16(KSEG1 + 0x0B000334)	/* Misc. R/W Battery Backed Registers for Non-Volatile Storage (R/W) */
asm-mips/ack:vr4181/vr4181.h:#define VR4181_MISCREG3		__preg16(KSEG1 + 0x0B000336)	/* Misc. R/W Battery Backed Registers for Non-Volatile Storage (R/W) */
asm-mips/ack:vr4181/vr4181.h:#define VR4181_MISCREG4		__preg16(KSEG1 + 0x0B000338)	/* Misc. R/W Battery Backed Registers for Non-Volatile Storage (R/W) */
asm-mips/ack:vr4181/vr4181.h:#define VR4181_MISCREG5		__preg16(KSEG1 + 0x0B00033A)	/* Misc. R/W Battery Backed Registers for Non-Volatile Storage (R/W) */
asm-mips/ack:vr4181/vr4181.h:#define VR4181_MISCREG6		__preg16(KSEG1 + 0x0B00033C)	/* Misc. R/W Battery Backed Registers for Non-Volatile Storage (R/W) */
asm-mips/ack:vr4181/vr4181.h:#define VR4181_MISCREG7		__preg16(KSEG1 + 0x0B00033D)	/* Misc. R/W Battery Backed Registers for Non-Volatile Storage (R/W) */
asm-mips/ack:vr4181/vr4181.h:#define VR4181_MISCREG8		__preg16(KSEG1 + 0x0B000340)	/* Misc. R/W Battery Backed Registers for Non-Volatile Storage (R/W) */
asm-mips/ack:vr4181/vr4181.h:#define VR4181_MISCREG9		__preg16(KSEG1 + 0x0B000342)	/* Misc. R/W Battery Backed Registers for Non-Volatile Storage (R/W) */
asm-mips/ack:vr4181/vr4181.h:#define VR4181_MISCREG10	__preg16(KSEG1 + 0x0B000344)	/* Misc. R/W Battery Backed Registers for Non-Volatile Storage (R/W) */
asm-mips/ack:vr4181/vr4181.h:#define VR4181_MISCREG11	__preg16(KSEG1 + 0x0B000346)	/* Misc. R/W Battery Backed Registers for Non-Volatile Storage (R/W) */
asm-mips/ack:vr4181/vr4181.h:#define VR4181_MISCREG12	__preg16(KSEG1 + 0x0B000348)	/* Misc. R/W Battery Backed Registers for Non-Volatile Storage (R/W) */
asm-mips/ack:vr4181/vr4181.h:#define VR4181_MISCREG13	__preg16(KSEG1 + 0x0B00034A)	/* Misc. R/W Battery Backed Registers for Non-Volatile Storage (R/W) */
asm-mips/ack:vr4181/vr4181.h:#define VR4181_MISCREG14	__preg16(KSEG1 + 0x0B00034C)	/* Misc. R/W Battery Backed Registers for Non-Volatile Storage (R/W) */
asm-mips/ack:vr4181/vr4181.h:#define VR4181_MISCREG15	__preg16(KSEG1 + 0x0B00034E)	/* Misc. R/W Battery Backed Registers for Non-Volatile Storage (R/W) */
asm-mips/ack:vr4181/vr4181.h:#define VR4181_SIUCSEL_2	__preg8(KSEG1 + 0x0C00000A)	/* IrDA Echo-back Control (R/W) */
asm-mips/ack:vr41xx/e55.h: *	include/asm-mips/vr41xx/e55.h
asm-mips/ack:vr41xx/e55.h: *	Include file for CASIO CASSIOPEIA E-10/15/55/65.
asm-mips/ack:vr41xx/eagle.h: *	include/asm-mips/vr41xx/eagle.h
asm-mips/ack:vr41xx/eagle.h: * Copyright 2001-2003 MontaVista Software Inc.
asm-mips/ack:vr41xx/eagle.h: * General-Purpose I/O Pin Number
asm-mips/ack:vr41xx/capcella.h: *	include/asm-mips/vr41xx/capcella.h
asm-mips/ack:vr41xx/capcella.h: * General-Purpose I/O Pin Number
asm-mips/ack:vr41xx/workpad.h: *	include/asm-mips/vr41xx/workpad.h
asm-mips/ack:vr41xx/mpc30x.h: *	include/asm-mips/vr41xx/mpc30x.h
asm-mips/ack:vr41xx/mpc30x.h: *	Include file for Victor MP-C303/304.
asm-mips/ack:vr41xx/mpc30x.h: * General-Purpose I/O Pin Number
asm-mips/ack:vr41xx/vr41xx.h: * include/asm-mips/vr41xx/vr41xx.h
asm-mips/ack:vr41xx/vr41xx.h:/* VR4122 0x00000c70-0x00000c72 */
asm-mips/ack:vr41xx/vr41xx.h:/* VR4181A 0x00000c73-0x00000c7f */
asm-mips/ack:vr41xx/vr41xx.h:/* VR4131 0x00000c80-0x00000c83 */
asm-mips/ack:vr41xx/vr41xx.h:/* VR4133 0x00000c84- */
asm-mips/ack:vr41xx/vr41xx.h:#define GIU_IRQ(x)		(GIU_IRQ_BASE + (x))	/* IRQ 40-71 */
asm-mips/ack:vr41xx/vr41xx.h:#define GIU_IRQ_TO_PIN(x)	((x) - GIU_IRQ_BASE)	/* Pin 0-31 */
asm-mips/ack:vr41xx/vr41xx.h: * General-Purpose I/O Unit
asm-mips/ack:vr41xx/vrc4171.h: *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
asm-mips/ack:vr41xx/vrc4173.h: *	include/asm-mips/vr41xx/vrc4173.h
asm-mips/ack:vr41xx/vrc4173.h: * Copyright 2001-2003 Montavista Software Inc.
asm-mips/ack:vr41xx/vrc4173.h: * General-Purpose I/O Unit
asm-mips/ack:vr41xx/tb0226.h: *	include/asm-mips/vr41xx/tb0226.h
asm-mips/ack:vr41xx/tb0226.h: * General-Purpose I/O Pin Number
asm-mips/ack:vr41xx/tb0229.h: *	include/asm-mips/vr41xx/tb0229.h
asm-mips/ack:vr41xx/tb0229.h: * General-Purpose I/O Pin Number
asm-mips/ack:war.h: * interrupts during indexed I-cache flushes seems to be sufficient to deal
asm-mips/ack:war.h: * pre-conditions for this problem.
asm-mips/ack:xor.h:#include <asm-generic/xor.h>
asm-mips/ack:xxs1500.h: *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm-mips/arc/types.h:/* The pointer types.  Note that we're using a 64-bit compiler but all
asm-mips/arc/types.h:   pointer in the ARC structures are only 32-bit, so we need some disgusting
asm-mips/arc/types.h:/* The pointer types.  We're 64-bit and the firmware is also 64-bit, so
asm-mips/dec/tc.h: * of the first card not in use or -ENODEV
asm-mips/dec/kn230.h: *	include/asm-mips/dec/kn230.h
asm-mips/dec/ecc.h: *	include/asm-mips/dec/ecc.h
asm-mips/dec/ecc.h: * The register is r/wc -- any write clears it.
asm-mips/dec/ecc.h: * from the last memory read.  The register is r/wc -- any write clears it.
asm-mips/dec/kn02ba.h: *	include/asm-mips/dec/kn02ba.h
asm-mips/dec/kn02ba.h: *	DECstation 5000/1xx (3min or KN02-BA) definitions.
asm-mips/dec/kn02ba.h: * I/O ASIC interrupt bits.  Star marks denote non-IRQ status bits.
asm-mips/dec/kn02ca.h: *	include/asm-mips/dec/kn02ca.h
asm-mips/dec/kn02ca.h: *	Personal DECstation 5000/xx (Maxine or KN02-CA) definitions.
asm-mips/dec/kn02ca.h: * I/O ASIC interrupt bits.  Star marks denote non-IRQ status bits.
asm-mips/dec/kn02ca.h:#define KN02CA_IO_INR_POWERON	13	/* (*) ACCESS.Bus/power-on reset */
asm-mips/dec/kn02xa.h: * The rest is defined in system-specific headers.
asm-mips/dec/kn02xa.h: * The rest is defined in system-specific headers.
asm-mips/dec/interrupts.h: * with the machine-specific interrupt routines.
asm-mips/dec/interrupts.h:#define DEC_IRQ_TC5		DEC_IRQ_ASC	/* virtual PMAZ-AA */
asm-mips/dec/interrupts.h:#define DEC_IRQ_TC6		DEC_IRQ_LANCE	/* virtual PMAD-AA */
asm-mips/dec/ioasic_addrs.h:#define IO_REG_SCSI_SCR		0x1b0	/* SCSI Partial-Word DMA Control */
asm-mips/dec/ioasic_addrs.h:#define IO_REG_FCTR		0x1e0	/* Free-Running Counter */
asm-mips/dec/ioasic_addrs.h: * The lower 16 bits are system-specific.  Bits 15,11:8 are common and
asm-mips/dec/ioasic_addrs.h: * defined here.  The rest is defined in system-specific headers.
asm-mips/dec/kn01.h:#define KN01_CSR_STATUS		(1<<14)	/* self-test result status output */
asm-mips/dec/kn03.h: * I/O ASIC interrupt bits.  Star marks denote non-IRQ status bits.
asm-mips/dec/kn05.h: *	include/asm-mips/dec/kn05.h
asm-mips/dec/kn05.h: * The register appears read-only.
asm-mips/dec/rtc-dec.h: *	include/asm-mips/dec/rtc-dec.h
asm-mips/dec/tcmodule.h: * EK-TCAAD-FS-004
asm-mips/dec/serial.h: *	include/asm-mips/dec/serial.h
asm-mips/dec/ioasic.h: *	include/asm-mips/dec/ioasic.h
asm-mips/dec/tcinfo.h: * EK-TCAAD-FS-004
asm-mips/dec/ioasic_ints.h: * The lower 16 bits are system-specific and thus defined in
asm-mips/dec/ioasic_ints.h: * system-specific headers.
asm-mips/sgi/mc.h:#define SGIMC_CCTRL0_LENDIAN	0x00020000 /* Put MC in little-endian mode */
asm-mips/sgi/mc.h:#define SGIMC_EEPROM_SDATAO	0x00000008 /* Serial EEPROM data-out */
asm-mips/sgi/mc.h:#define SGIMC_EEPROM_SDATAI	0x00000010 /* Serial EEPROM data-in */
asm-mips/sgi/mc.h:#define SGIMC_GIOPAR_HPC64	0x00000001 /* HPC talks to GIO using 64-bits */
asm-mips/sgi/mc.h:#define SGIMC_GIOPAR_GFX64	0x00000002 /* GFX talks to GIO using 64-bits */
asm-mips/sgi/mc.h:#define SGIMC_GIOPAR_EXP064	0x00000004 /* EXP(slot0) talks using 64-bits */
asm-mips/sgi/mc.h:#define SGIMC_GIOPAR_EXP164	0x00000008 /* EXP(slot1) talks using 64-bits */
asm-mips/sgi/mc.h:#define SGIMC_GIOPAR_EISA64	0x00000010 /* EISA bus talks 64-bits to GIO */
asm-mips/sgi/mc.h:#define SGIMC_GIOPAR_HPC264	0x00000020 /* 2nd HPX talks 64-bits to GIO */
asm-mips/sgi/mc.h:	volatile u32 syssembit;		/* Uni-bit system semaphore */
asm-mips/sgi/mc.h:	u32 _unused36[0x1000/4-2*4];
asm-mips/sgi/gio.h: * -----   --------- ----------------------- -----
asm-mips/sgi/gio.h: *   0     GFX       0x1f000000 - 0x1f3fffff   4MB
asm-mips/sgi/gio.h: *   1     EXP0      0x1f400000 - 0x1f5fffff   2MB
asm-mips/sgi/gio.h: *   2     EXP1      0x1f600000 - 0x1f9fffff   4MB
asm-mips/sgi/gio.h: * There are un-slotted devices, HPC, I/O and misc devices, which are grouped
asm-mips/sgi/gio.h: *   -     MISC      0x1fb00000 - 0x1fbfffff   1MB
asm-mips/sgi/gio.h: *   -     RESERVED  0x18000000 - 0x1effffff 112MB
asm-mips/sgi/gio.h: * 32-bit IDs are divided into
asm-mips/sgi/gio.h: *	bit 16		0=GIO32 and GIO32-bis, 1=GIO64.
asm-mips/sgi/gio.h: * 8-bit IDs
asm-mips/sgi/gio.h: *	0x0e		E-Plex 8-port Ethernet
asm-mips/sgi/gio.h: * [*] Device provide 32-bit ID.
asm-mips/sgi/ioc.h: * All registers are 8-bit wide alligned on 32-bit boundary. Bad things
asm-mips/sgi/ioc.h:#define SGINT_TCWORD_MOS	0x02	/* One-shot IRQ mode. */
asm-mips/sgi/pi1.h:#define PI1_STAT_DEVID		0x03	/* bits 0-1 */
asm-mips/sgi/pi1.h:#define PI1_DMACTRL_STDMODE	0x00    /* bits 2-3 */
asm-mips/sgi/pi1.h:#define PI1_DMACTRL_SGIMODE	0x04    /* bits 2-3 */
asm-mips/sgi/pi1.h:#define PI1_DMACTRL_RICOHMODE	0x08    /* bits 2-3 */
asm-mips/sgi/pi1.h:#define PI1_DMACTRL_HPMODE	0x0c    /* bits 2-3 */
asm-mips/sgi/hpc3.h:	u32 _unused0[0x1000/4 - 2];	/* padding */
asm-mips/sgi/hpc3.h:#define HPC3_PDMACTRL_HW	0x0000ff00 /* DMA High-water mark */
asm-mips/sgi/hpc3.h:	u32 _unused1[0x1000/4 - 1];	/* padding */
asm-mips/sgi/hpc3.h:	u32 _unused0[0x1000/4 - 2];	/* padding */
asm-mips/sgi/hpc3.h:#define HPC3_SDCFG_HW   0x01000 /* Enable 16-bit halfword DMA accesses to scsi */
asm-mips/sgi/hpc3.h:#define HPC3_SPCFG_HW   0x1000 /* Enable 16-bit halfword PIO accesses to scsi */
asm-mips/sgi/hpc3.h:	u32 _unused1[0x1000/4 - 6];	/* padding */
asm-mips/sgi/hpc3.h:	u32 _unused0[0x1000/4 - 2];	/* padding */
asm-mips/sgi/hpc3.h:	u32 _unused2[0x1000/4 - 8];	/* padding */
asm-mips/sgi/hpc3.h:	u32 _unused3[0x1000/4 - 2];	/* padding */
asm-mips/sgi/hpc3.h:	u32 _unused4[0x1000/4 - 4];	/* padding */
asm-mips/sgi/hpc3.h:	 * you it was a peculiar bug. ;-)
asm-mips/sgi/hpc3.h:#define HPC3_ISTAT_PBIMASK	0x0ff	/* irq bits for pbus devs 0 --> 7 */
asm-mips/sgi/hpc3.h:	u32 _unused1[0x14000/4 - 5];	/* padding */
asm-mips/sgi/hpc3.h:	/* Now direct PIO per-HPC3 peripheral access to external regs. */
asm-mips/sgi/hpc3.h:	/* Per-peripheral device external registers and DMA/PIO control. */
asm-mips/sgi/hpc3.h:	/* Enable 16-bit DMA access mode */
asm-mips/sgi/hpc3.h:	/* Enable 16-bit PIO accesses */
asm-mips/sgi/hpc3.h:	u32 _unused5[0x0800/4 - 1];
asm-mips/sgi/hpc3.h:	u32 _unused6[0x0800/4 - 1];
asm-mips/sgi/hpc3.h:	u32 _unused7[0x1000/4 - 1];
asm-mips/sgi/hpc3.h:	volatile u32 bbram[8192-50-14];	/* Battery backed ram */
asm-mips/sgi/ip22.h: * HAL2 driver). This will prevent many complications, trust me ;-)
asm-mips/sgi/ip22.h:#define SGI_GIO_0_IRQ	SGI_FIFO_IRQ		/* GIO-0 */
asm-mips/sgi/ip22.h:#define SGI_GIO_1_IRQ	SGINT_LOCAL0 + 6	/* GE / GIO-1 / 2nd-HPC */
asm-mips/sgi/ip22.h:#define SGI_GIO_2_IRQ	SGINT_LOCAL1 + 7	/* Vert retrace / GIO-2 */
asm-mips/sgi/ip22.h:#define ip22_is_fullhouse()	(sgioc->sysid & SGIOC_SYSID_FULLHOUSE)
asm-mips/io.h: * Copyright (C) 1994 - 2000 Ralf Baechle
asm-mips/io.h:#include <asm/pgtable-bits.h>
asm-mips/io.h:#define bus_to_baddr(bus, addr)	(bus_to_baddr[(bus)->number] + (addr))
asm-mips/io.h:#define baddr_to_bus(bus, addr)	((addr) - bus_to_baddr[(bus)->number])
asm-mips/io.h: * IP22 seems braindead enough to swap 16-bits values in hardware, but not
asm-mips/io.h: * 32-bits.  Go figure... Can't tell without documentation.
asm-mips/io.h: * We only do the swapping to keep the kernel config bits of bi-endian
asm-mips/io.h:#define page_to_phys(page)	((u64)(page - mem_map) << PAGE_SHIFT)
asm-mips/io.h:#define page_to_phys(page)	((page - mem_map) << PAGE_SHIFT)
asm-mips/io.h: *     ioremap         -       map bus memory into CPU space
asm-mips/io.h: *     ioremap_nocache         -       map bus memory into CPU space
asm-mips/io.h: * 24-31 on SNI.
asm-mips/io.h: * to PAGE_OFFSET is pure coincidence - it does not mean ISA values
asm-mips/io.h: * used as the IO-area pointer (it can be iounmapped as well, so the
asm-mips/io.h:#define eth_io_copy_and_sum(skb,src,len,unused) memcpy_fromio((skb)->data,(src),(len))
asm-mips/io.h: *     check_signature         -       find BIOS signatures
asm-mips/io.h:		length--;
asm-mips/io.h: *     isa_check_signature             -       find BIOS signatures
asm-mips/io.h:		length--;
asm-mips/io.h: *     virt_to_phys    -       map virtual addresses to physical
asm-mips/io.h:	return (unsigned long)address - PAGE_OFFSET;
asm-mips/io.h: *     phys_to_virt    -       map physical address to virtual
asm-mips/io.h:	return (unsigned long)address - PAGE_OFFSET;
asm-mips/io.h:	while (count--) {
asm-mips/io.h:	while (count--) {
asm-mips/io.h:	while (count--) {
asm-mips/io.h:	while (count--) {
asm-mips/io.h:	while (count--) {
asm-mips/io.h:	while (count--) {
asm-mips/io.h: * The caches on some architectures aren't dma-coherent and have need to
asm-mips/io.h: *  - dma_cache_wback_inv(start, size) makes caches and coherent by
asm-mips/io.h: *  - dma_cache_wback(start, size) makes caches and coherent by
asm-mips/io.h: *  - dma_cache_inv(start, size) invalidates the affected parts of the
asm-mips/ddb5xxx/ddb5074.h: *  include/asm-mips/ddb5074.h -- NEC DDB Vrc-5074 definitions
asm-mips/ddb5xxx/ddb5476.h:#define	DDB_DCS5_SIZE		0x00200000	/* 2MB, 8-bit */
asm-mips/ddb5xxx/ddb5476.h:#define	DDB_DCS4_SIZE		0x00200000	/* 2MB, 8-bit */
asm-mips/ddb5xxx/ddb5476.h:#define DDB_BOOTCS_SIZE         0x00200000      /* 2 MB - doc says 4MB */
asm-mips/ddb5xxx/ddb5476.h: *   . CPU itself - 8 sources
asm-mips/ddb5xxx/ddb5476.h: *   . i8259 - 16 sources
asm-mips/ddb5xxx/ddb5476.h: *   . vrc5476 - 16 sources
asm-mips/ddb5xxx/ddb5476.h: *  All VRC5476 PCI interrupts are level-triggered (no ack needed).
asm-mips/ddb5xxx/ddb5476.h: * vrc5476 irq defs, see page 52-64 of Vrc5074 system controller manual
asm-mips/ddb5xxx/ddb5476.h:#define irq_to_nile4(n)         ((n)-NUM_I8259_IRQ)
asm-mips/ddb5xxx/ddb5476.h: * low-level irq functions
asm-mips/ddb5xxx/ddb5477.h: * include/asm-mips/ddb5xxx/ddb5477.h
asm-mips/ddb5xxx/ddb5477.h:#undef  DDB_CPUSTAT		/* duplicate in Vrc-5477 */
asm-mips/ddb5xxx/ddb5477.h:#define	DDB_PCICTL0_L	0x02e0	/* PCI0 Control-L */
asm-mips/ddb5xxx/ddb5477.h:#define	DDB_PCICTL0_H	0x02e4	/* PCI0 Control-H */
asm-mips/ddb5xxx/ddb5477.h:#define	DDB_PCIARB0_L	0x02e8	/* PCI0 Arbitration-L */
asm-mips/ddb5xxx/ddb5477.h:#define	DDB_PCIARB0_H	0x02ec	/* PCI0 Arbitration-H */
asm-mips/ddb5xxx/ddb5477.h:#define	DDB_PCICTL1_L	0x06e0	/* PCI1 Control-L */
asm-mips/ddb5xxx/ddb5477.h:#define	DDB_PCICTL1_H	0x06e4	/* PCI1 Control-H */
asm-mips/ddb5xxx/ddb5477.h:#define	DDB_PCIARB1_L	0x06e8	/* PCI1 Arbitration-L */
asm-mips/ddb5xxx/ddb5477.h:#define	DDB_PCIARB1_H	0x06ec	/* PCI1 Arbitration-H */
asm-mips/ddb5xxx/ddb5477.h:#define DDB_GIUFUNSEL	0x4040  /* select dual-func pins */
asm-mips/ddb5xxx/ddb5477.h:/* the actual ram size is detected at run-time */
asm-mips/ddb5xxx/ddb5477.h:#define	DDB_BOOTCS_SIZE		0x00200000	/* 2 MB - doc says 4MB */
asm-mips/ddb5xxx/ddb5477.h:/* low-level routine for enabling vrc5477 irq, bypassing high-level */
asm-mips/ddb5xxx/ddb5477.h: *   . CPU itself - 8 sources
asm-mips/ddb5xxx/ddb5477.h: *   . i8259 - 16 sources
asm-mips/ddb5xxx/ddb5477.h: *   . vrc5477 - 32 sources
asm-mips/ddb5xxx/ddb5477.h: *  All VRC5477 PCI interrupts are level-triggered (no ack needed).
asm-mips/ddb5xxx/ddb5477.h:#define VRC5477_IRQ_IOPCI_INTA	(16 + VRC5477_IRQ_BASE)      /* USB-H */
asm-mips/ddb5xxx/ddb5477.h:#define VRC5477_IRQ_IOPCI_INTB	(17 + VRC5477_IRQ_BASE)      /* USB-P */
asm-mips/ddb5xxx/ddb5477.h:#define	VRC5477_I8259_CASCADE	(VRC5477_IRQ_INTC - VRC5477_IRQ_BASE)
asm-mips/ddb5xxx/ddb5xxx.h: * include/asm-mips/ddb5xxx/ddb5xxx.h
asm-mips/ddb5xxx/ddb5xxx.h: *	uPD31577(VRC5477) VR5432-SDRAM/PCI Bridge (Luke)
asm-mips/ddb5xxx/ddb5xxx.h:#define DDB_DCS2	0x0010	/* Device Chip-Select 2 [R/W] */
asm-mips/ddb5xxx/ddb5xxx.h:#define DDB_DCS3	0x0018	/* Device Chip-Select 3 [R/W] */
asm-mips/ddb5xxx/ddb5xxx.h:#define DDB_DCS4	0x0020	/* Device Chip-Select 4 [R/W] */
asm-mips/ddb5xxx/ddb5xxx.h:#define DDB_DCS5	0x0028	/* Device Chip-Select 5 [R/W] */
asm-mips/ddb5xxx/ddb5xxx.h:#define DDB_DCS6	0x0030	/* Device Chip-Select 6 [R/W] */
asm-mips/ddb5xxx/ddb5xxx.h:#define DDB_DCS7	0x0038	/* Device Chip-Select 7 [R/W] */
asm-mips/ddb5xxx/ddb5xxx.h:#define DDB_DCS8	0x0040	/* Device Chip-Select 8 [R/W] */
asm-mips/ddb5xxx/ddb5xxx.h:#define DDB_BOOTCS	0x0078	/* Boot ROM Chip-Select [R/W] */
asm-mips/ddb5xxx/ddb5xxx.h: *  Memory-Interface Registers
asm-mips/ddb5xxx/ddb5xxx.h: *  PCI-Bus Registers
asm-mips/ddb5xxx/ddb5xxx.h: *  Local-Bus Registers
asm-mips/ddb5xxx/ddb5xxx.h:#define DDB_LCST2	0x0110	/* Local Bus Chip-Select Timing 2 [R/W] */
asm-mips/ddb5xxx/ddb5xxx.h:#define DDB_LCST3	0x0118	/* Local Bus Chip-Select Timing 3 [R/W] */
asm-mips/ddb5xxx/ddb5xxx.h:#define DDB_LCST4	0x0120	/* Local Bus Chip-Select Timing 4 [R/W] */
asm-mips/ddb5xxx/ddb5xxx.h:#define DDB_LCST5	0x0128	/* Local Bus Chip-Select Timing 5 [R/W] */
asm-mips/ddb5xxx/ddb5xxx.h:#define DDB_LCST6	0x0130	/* Local Bus Chip-Select Timing 6 [R/W] */
asm-mips/ddb5xxx/ddb5xxx.h:#define DDB_LCST7	0x0138	/* Local Bus Chip-Select Timing 7 [R/W] */
asm-mips/ddb5xxx/ddb5xxx.h:#define DDB_LCST8	0x0140	/* Local Bus Chip-Select Timing 8 [R/W] */
asm-mips/ddb5xxx/ddb5xxx.h:#define DDB_DCSFN	0x0150	/* Device Chip-Select Muxing and Output */
asm-mips/ddb5xxx/ddb5xxx.h:#define DDB_DCSIO	0x0158	/* Device Chip-Selects As I/O Bits [R/W] */
asm-mips/ddb5xxx/ddb5xxx.h:#define DDB_BCST	0x0178	/* Local Boot Chip-Select Timing [R/W] */
asm-mips/ddb5xxx/ddb5xxx.h:#define DDB_T1CTRL	0x01D0	/* CPU-Bus Read Time-Out Control [R/W] */
asm-mips/ddb5xxx/ddb5xxx.h:#define DDB_T1CNTR	0x01D8	/* CPU-Bus Read Time-Out Counter [R/W] */
asm-mips/ddb5xxx/ddb5xxx.h:#define DDB_T2CTRL	0x01E0	/* General-Purpose Timer Control [R/W] */
asm-mips/ddb5xxx/ddb5xxx.h:#define DDB_T2CNTR	0x01E8	/* General-Purpose Timer Counter [R/W] */
asm-mips/ddb5xxx/ddb5xxx.h:#define DDB_SSVID	0x022C	/* PCI Sub-System Vendor ID [R/W] */
asm-mips/ddb5xxx/ddb5xxx.h:#define DDB_SSID	0x022E	/* PCI Sub-System ID [R/W] */
asm-mips/jmr3927/irq.h: *  linux/include/asm-mips/tx3927/irq.h
asm-mips/jmr3927/irq.h:	sp->next = tb_irq_spaces;
asm-mips/jmr3927/pci.h: * include/asm-mips/jmr3927/pci.h
asm-mips/jmr3927/pci.h: * Based on include/asm-mips/ddb5xxx/pci.h
asm-mips/jmr3927/pci.h: * Each pci channel is a top-level PCI bus seem by CPU.  A machine  with
asm-mips/jmr3927/tx3927.h:#define TX3927_PCIC_IDSEL_AD_TO_SLOT(ad)	((ad) - 11)
asm-mips/jmr3927/ds1742rtc.h: * ds1742rtc.h - register definitions for the Real-Time-Clock / CMOS RAM
asm-mips/jmr3927/ds1742rtc.h: *   Based on include/asm-mips/ds1643rtc.h.
asm-mips/jmr3927/ds1742rtc.h: * Copyright (C) 1999-2001 Toshiba Corporation
asm-mips/jmr3927/jmr3927.h: * Defines for the TJSYS JMR-TX3927/JMI-3927IO2/JMY-1394IF.
asm-mips/jmr3927/jmr3927.h: * Copyright (C) 2000-2001 Toshiba Corporation
asm-mips/jmr3927/jmr3927.h:	romcr3 = tx3927_romcptr->cr[3];
asm-mips/jmr3927/jmr3927.h:	tx3927_romcptr->cr[3] &= 0xffffefff;	/* do not wait infinitely */
asm-mips/jmr3927/jmr3927.h:	tx3927_romcptr->cr[3] = romcr3;
asm-mips/jmr3927/jmr3927.h:#define jmr3927_led_set(n/*0-16*/)	jmr3927_ioc_reg_out(~(n), JMR3927_IOC_LED_ADDR)
asm-mips/jmr3927/jmr3927.h:#define jmr3927_io_led_set(n/*0-3*/)	jmr3927_isac_reg_out((n), JMR3927_ISAC_LED_ADDR)
asm-mips/jmr3927/jmr3927.h:#define jmr3927_led_and_set(n/*0-16*/)	jmr3927_ioc_reg_out((~(n)) & jmr3927_ioc_reg_in(JMR3927_IOC_LED_ADDR), JMR3927_IOC_LED_ADDR)
asm-mips/jmr3927/jmr3927.h:#define jmr3927_dipsw1()	((tx3927_pioptr->din & (1 << 11)) == 0)
asm-mips/jmr3927/jmr3927.h:#define jmr3927_dipsw2()	((tx3927_pioptr->din & (1 << 10)) == 0)
asm-mips/jmr3927/jmr3927.h:/* use Pre-scaler T0 (1/2) */
asm-mips/jmr3927/jmr3927.h:#define JMR3927_NR_IRQ_IRC	16	/* On-Chip IRC */
asm-mips/jmr3927/jmr3927.h:/* RTL8019AS 10M Ether (JMI-3927IO2:JPW2:1-2 Short) */
asm-mips/jmr3927/jmr3927.h:/* TC35815 100M Ether (JMR-TX3912:JPW4:2-3 Short) */
asm-mips/jmr3927/jmr3927.h:#define JMR3927_ETHER1_PORT	(JMR3927_ISAIO_BASE - JMR3927_PORT_BASE + 0x280)
asm-mips/jmr3927/jmr3927.h:#define JMR3927_KBD_PORT	(JMR3927_ISAIO_BASE - JMR3927_PORT_BASE + 0x00800060)
asm-mips/jmr3927/jmr3927.h:#define JMR3927_IDE_PORT	(JMR3927_ISAIO_BASE - JMR3927_PORT_BASE + 0x001001f0)
asm-mips/atomic.h: * atomic_read - read atomic variable
asm-mips/atomic.h:#define atomic_read(v)	((v)->counter)
asm-mips/atomic.h: * atomic_set - set atomic variable
asm-mips/atomic.h:#define atomic_set(v,i)	((v)->counter = (i))
asm-mips/atomic.h: * atomic_add - add integer to atomic variable
asm-mips/atomic.h:	v->counter += i;
asm-mips/atomic.h: * atomic_sub - subtract the atomic variable
asm-mips/atomic.h:	v->counter -= i;
asm-mips/atomic.h:	temp = v->counter;
asm-mips/atomic.h:	v->counter = temp;
asm-mips/atomic.h:	temp = v->counter;
asm-mips/atomic.h:	temp -= i;
asm-mips/atomic.h:	v->counter = temp;
asm-mips/atomic.h: * atomic_add - add integer to atomic variable
asm-mips/atomic.h:		: "=&r" (temp), "=m" (v->counter)
asm-mips/atomic.h:		: "Ir" (i), "m" (v->counter));
asm-mips/atomic.h: * atomic_sub - subtract the atomic variable
asm-mips/atomic.h:		: "=&r" (temp), "=m" (v->counter)
asm-mips/atomic.h:		: "Ir" (i), "m" (v->counter));
asm-mips/atomic.h:		: "=&r" (result), "=&r" (temp), "=m" (v->counter)
asm-mips/atomic.h:		: "Ir" (i), "m" (v->counter)
asm-mips/atomic.h:		: "=&r" (result), "=&r" (temp), "=m" (v->counter)
asm-mips/atomic.h:		: "Ir" (i), "m" (v->counter)
asm-mips/atomic.h: * atomic_sub_and_test - subtract value from variable and test result
asm-mips/atomic.h: * atomic_inc_and_test - increment and test
asm-mips/atomic.h: * atomic_dec_and_test - decrement by 1 and test
asm-mips/atomic.h: * atomic_inc - increment atomic variable
asm-mips/atomic.h: * atomic_dec - decrement and test
asm-mips/atomic.h: * atomic_add_negative - add and test if negative
asm-mips/au1xxx_dbdma.h:/* Specifics for the Au1xxx Descriptor-Based DMA Controllers, first
asm-mips/au1xxx_dbdma.h:	u32	ddma_desptr;	/* 32-byte aligned pointer to descriptor */
asm-mips/au1xxx_dbdma.h:#define DDMA_CFG_DFN	(1 << 3)	/* Descriptor fetch non-coherent */
asm-mips/au1xxx_dbdma.h: * Must be 32-byte aligned.
asm-mips/au1xxx_dbdma.h:#define DSCR_CMD0_MEM		(1 << 30)	/* mem-mem transfer */
asm-mips/au1xxx_dbdma.h:#define DSCR_CMD0_SN		(0x1 << 12)	/* Source non-coherent */
asm-mips/au1xxx_dbdma.h:#define DSCR_CMD0_DN		(0x1 << 11)	/* Destination non-coherent */
asm-mips/au1xxx_dbdma.h:/* Source1, 1-dimensional stride.
asm-mips/au1xxx_dbdma.h:/* Dest1, 1-dimensional stride.
asm-mips/au1xxx_dbdma.h: 	Some compatibilty macros --
asm-mips/debug.h: * Debug macros for run-time debugging.  Turned on/off with 
asm-mips/debug.h: * run-time macros for catching spurious errors.  Eable CONFIG_RUNTIME_DEBUG in
asm-mips/debug.h: * Use them as run-time debugging aid.  NEVER USE THEM AS ERROR HANDLING CODE!!!
asm-mips/delay.h: * Copyright (C) 1995 - 1998, 2001 by Ralf Baechle
asm-mips/mc146818rtc.h:rtc_ops->rtc_read_data(addr); \
asm-mips/mc146818rtc.h:rtc_ops->rtc_write_data(val, addr); \
asm-mips/mc146818rtc.h:rtc_ops->rtc_bcd_mode()
asm-mips/mc146818rtc.h:#include <asm/dec/rtc-dec.h>
asm-mips/ipcbuf.h: * - 32-bit seq
asm-mips/ipcbuf.h: * - 2 miscellaneous 64-bit values
asm-mips/r4kcache.h: * Copyright (C) 1997 - 2002 Ralf Baechle (ralf@gnu.org)
asm-mips/r4kcache.h: * Copyright (C) 2004 Ralf Baechle (ralf@linux-mips.org)
asm-mips/r4kcache.h: * R10000 / R12000 hazard - these processors don't support the Hit_Writeback_D
asm-mips/r4kcache.h: * cacheop so we use Hit_Writeback_Inv_D which is supported by all R4000-style
asm-mips/r4kcache.h: * This one is RM7000-specific
asm-mips/shmbuf.h: * - 2 miscellaneous 32-bit values
asm-mips/sfp-machine.h:#define _FP_NANFRAC_S		((_FP_QNANBIT_S << 1) - 1)
asm-mips/sfp-machine.h:#define _FP_NANFRAC_D		((_FP_QNANBIT_D << 1) - 1), -1
asm-mips/sfp-machine.h:#define _FP_NANFRAC_Q		((_FP_QNANBIT_Q << 1) - 1), -1, -1, -1
asm-mips/bitops.h: * Copyright (c) 1994 - 1997, 1999, 2000  Ralf Baechle (ralf@gnu.org)
asm-mips/bitops.h: * set_bit - Atomically set a bit in memory
asm-mips/bitops.h: * restricted to acting on a single-word quantity.
asm-mips/bitops.h: * __set_bit - Set a bit in memory
asm-mips/bitops.h: * Unlike set_bit(), this function is non-atomic and may be reordered.
asm-mips/bitops.h: * clear_bit - Clears a bit in memory
asm-mips/bitops.h: * change_bit - Toggle a bit in memory
asm-mips/bitops.h: * restricted to acting on a single-word quantity.
asm-mips/bitops.h: * __change_bit - Toggle a bit in memory
asm-mips/bitops.h: * Unlike change_bit(), this function is non-atomic and may be reordered.
asm-mips/bitops.h: * test_and_set_bit - Set a bit and return its old value
asm-mips/bitops.h: * __test_and_set_bit - Set a bit and return its old value
asm-mips/bitops.h: * This operation is non-atomic and can be reordered.
asm-mips/bitops.h: * test_and_clear_bit - Clear a bit and return its old value
asm-mips/bitops.h: * __test_and_clear_bit - Clear a bit and return its old value
asm-mips/bitops.h: * This operation is non-atomic and can be reordered.
asm-mips/bitops.h: * test_and_change_bit - Change a bit and return its new value
asm-mips/bitops.h: * __test_and_change_bit - Change a bit and return its old value
asm-mips/bitops.h: * This operation is non-atomic and can be reordered.
asm-mips/bitops.h: * set_bit - Atomically set a bit in memory
asm-mips/bitops.h: * restricted to acting on a single-word quantity.
asm-mips/bitops.h: * __set_bit - Set a bit in memory
asm-mips/bitops.h: * Unlike set_bit(), this function is non-atomic and may be reordered.
asm-mips/bitops.h: * clear_bit - Clears a bit in memory
asm-mips/bitops.h: * change_bit - Toggle a bit in memory
asm-mips/bitops.h: * restricted to acting on a single-word quantity.
asm-mips/bitops.h: * __change_bit - Toggle a bit in memory
asm-mips/bitops.h: * Unlike change_bit(), this function is non-atomic and may be reordered.
asm-mips/bitops.h: * test_and_set_bit - Set a bit and return its old value
asm-mips/bitops.h: * __test_and_set_bit - Set a bit and return its old value
asm-mips/bitops.h: * This operation is non-atomic and can be reordered.
asm-mips/bitops.h: * test_and_clear_bit - Clear a bit and return its old value
asm-mips/bitops.h: * __test_and_clear_bit - Clear a bit and return its old value
asm-mips/bitops.h: * This operation is non-atomic and can be reordered.
asm-mips/bitops.h: * test_and_change_bit - Change a bit and return its new value
asm-mips/bitops.h: * __test_and_change_bit - Change a bit and return its old value
asm-mips/bitops.h: * This operation is non-atomic and can be reordered.
asm-mips/bitops.h: * test_bit - Determine whether a bit is set
asm-mips/bitops.h: * ffz - find first zero in word.
asm-mips/bitops.h: * ffs - find first bit set
asm-mips/bitops.h: * find_next_zero_bit - find the first zero bit in a memory region
asm-mips/bitops.h:	size -= result;
asm-mips/bitops.h:		tmp |= ~0UL >> (32-offset);
asm-mips/bitops.h:		size -= 32;
asm-mips/bitops.h:		size -= 32;
asm-mips/bitops.h:#if 0 /* Fool kernel-doc since it doesn't do macros yet */
asm-mips/bitops.h: * find_first_zero_bit - find the first zero bit in a memory region
asm-mips/bitops.h: * Returns the bit-number of the first zero bit, not the number of the byte
asm-mips/bitops.h: * hweightN - returns the hamming weight of a N-bit word
asm-mips/bitops.h:	size -= result;
asm-mips/bitops.h:		tmp |= ~0U >> (32-offset); /* bug or feature ? */
asm-mips/bitops.h:		size -= 32;
asm-mips/bitops.h:		size -= 32;
asm-mips/i8259.h: *	include/asm-mips/i8259.h
asm-mips/div64.h:		" addiu	%4, %4, -1\n\t" \
asm-mips/resource.h:#define RLIMIT_MEMLOCK 9		/* max locked-in-memory address space */
asm-mips/ptrace.h:/* 0 - 31 are integer registers, 32 - 63 are fp registers.  */
asm-mips/ptrace.h:        ".size\t" #symbol",. - " #symbol)
asm-mips/ptrace.h:#define user_mode(regs) (((regs)->cp0_status & KU_MASK) == KU_USER)
asm-mips/ptrace.h:#define instruction_pointer(regs) ((regs)->cp0_epc)
asm-mips/pgalloc.h: * Copyright (C) 1994 - 2001 by Ralf Baechle
asm-mips/pgalloc.h: *  - flush_tlb_all() flushes all processes TLB entries
asm-mips/pgalloc.h: *  - flush_tlb_mm(mm) flushes the specified mm context TLB entries
asm-mips/pgalloc.h: *  - flush_tlb_page(mm, vmaddr) flushes a single page
asm-mips/pgalloc.h: *  - flush_tlb_range(mm, start, end) flushes a range of pages
asm-mips/pgalloc.h: *  - flush_tlb_pgtables(mm, start, end) flushes a range of page tables
asm-mips/pgalloc.h: *  - flush_tlb_one(page) flushes a single kernel page
asm-mips/pgalloc.h:			(PTRS_PER_PGD - USER_PTRS_PER_PGD) * sizeof(pgd_t));
asm-mips/pgalloc.h:		pgtable_cache_size--;
asm-mips/pgalloc.h:		pgtable_cache_size--;
asm-mips/pgalloc.h:		pgtable_cache_size--;
asm-mips/pgalloc.h: * allocating and freeing a pmd is trivial: the 1-entry pmd is
asm-mips/unistd.h: * Linux 64-bit syscalls are in the range from 5000 to 5999.
asm-mips/unistd.h: * Offset of the last Linux 64-bit flavoured syscall
asm-mips/unistd.h:/* XXX - _foo needs to be __foo, while __NR_bar could be _NR_bar. */
asm-mips/unistd.h:	return (type)-1; \
asm-mips/unistd.h:	return (type)-1; \
asm-mips/unistd.h:	return (type)-1; \
asm-mips/unistd.h:	return (type)-1; \
asm-mips/unistd.h:	return (type)-1; \
asm-mips/unistd.h: * Using those means your brain needs more than an oil change ;-)
asm-mips/unistd.h:	return (type)-1; \
asm-mips/unistd.h:	return (type)-1; \
asm-mips/unistd.h:	return (type)-1; \
asm-mips/unistd.h:	return (type)-1; \
asm-mips/unistd.h: * we need this inline - forking from kernel space will result
asm-mips/unistd.h: * calls - which means inline code for fork too, as otherwise we
asm-mips/unistd.h:	return waitpid(-1, wait_stat, 0);
asm-mips/baget/vac.h:#define    VAC_CTRL_RECOVERY_IOSELI(x) ((((x)-1)&7)<<8)
asm-mips/baget/vac.h:#define    VAC_CTRL_DELAY_DSACKI(x)    ((((x)-1)&7)<<13)
asm-mips/baget/vic.h:#define    VIC_LOCAL_TIM_PAS_ASSERT(x)   (((x)-2)&0xf)
asm-mips/baget/vic.h:#define    VIC_LOCAT_TIM_DS_DEASSERT(x)  ((((x)-1)&1)<<4)
asm-mips/baget/vic.h:#define    VIC_LOCAL_TIM_PAS_DEASSERT(x) ((((x)-1)&0x7)<<5)
asm-mips/baget/baget.h:#define BAGET_A24M_BASE       0xFC000000      /* VME-master A24 base address  */
asm-mips/baget/baget.h:#define BAGET_A24S_BASE       0x00000000      /* VME-slave A24 base address   */
asm-mips/baget/baget.h:#define BAGET_A24S_MASK       0x00c00000      /* VME-slave A24 address mask   */
asm-mips/baget/baget.h:#define BAGET_IRQ_MASK(x)       ((NR_IRQS-1) & (x))
asm-mips/asm.h: * away by gas in -O mode. These nops are however required to fill delay
asm-mips/asm.h: * LEAF - declare leaf routine
asm-mips/asm.h: * NESTED - declare nested routine entry point
asm-mips/asm.h: * END - mark end of function
asm-mips/asm.h:		.size	function,.-function
asm-mips/asm.h: * EXPORT - export definition of symbol
asm-mips/asm.h: * FEXPORT - export definition of a function symbol
asm-mips/asm.h: * ABS - export absolute symbol
asm-mips/asm.h: * Macros to handle different pointer/register sizes for 32/64-bit code
asm-mips/cpu.h:  +----------------+----------------+----------------+----------------+
asm-mips/cpu.h:  +----------------+----------------+----------------+----------------+
asm-mips/cpu.h:   that bits 16-23 have been 0 for all MIPS processors before the MIPS32/64
asm-mips/cpu.h: * +---------------------------------+----------------+----------------+
asm-mips/cpu.h: * +---------------------------------+----------------+----------------+
asm-mips/cpu.h: * Bit 15 encodes if an ISA level supports 64-bit operations.
asm-mips/cpu.h:#define MIPS_CPU_SUBSET_CACHES	0x00020000 /* P-cache subset enforced */
asm-mips/dma.h: *  controller 1: channels 0-3, byte operations, ports 00-1F
asm-mips/dma.h: *  controller 2: channels 4-7, word operations, ports C0-DF
asm-mips/dma.h: *  - ALL registers are 8 bits only, regardless of transfer size
asm-mips/dma.h: *  - channel 4 is not used - cascades 1 into 2.
asm-mips/dma.h: *  - channels 0-3 are byte - addresses/counts are for physical bytes
asm-mips/dma.h: *  - channels 5-7 are word - addresses/counts are for physical words
asm-mips/dma.h: *  - transfers must not cross physical 64K (0-3) or 128K (5-7) boundaries
asm-mips/dma.h: *  - transfer count loaded to registers is 1 less than actual count
asm-mips/dma.h: *  - controller 2 offsets are all even (2x offsets for controller 1)
asm-mips/dma.h: *  - page registers for 5-7 don't use data bit 0, represent 128K pages
asm-mips/dma.h: *  - page registers for 0-3 use bit 0, represent 64K pages
asm-mips/dma.h: *  Address mapping for channels 0-3:
asm-mips/dma.h: *  Address mapping for channels 5-7:
asm-mips/dma.h: * Again, channels 5-7 transfer _physical_ words (16 bits), so addresses
asm-mips/dma.h: * and counts _must_ be word-aligned (the lowest address bit is _ignored_ at
asm-mips/dma.h: * the hardware level, so odd-byte transfers aren't possible).
asm-mips/dma.h: * count - 1 : 64K => 0xFFFF, 1 => 0x0000.  Thus, count is always 1 or more,
asm-mips/dma.h: * and up to 128K bytes may be transferred on channels 5-7 in one operation.
asm-mips/dma.h:#define DMA1_MASK_REG		0x0A	/* single-channel mask (w) */
asm-mips/dma.h:#define DMA1_CLEAR_FF_REG	0x0C	/* clear pointer flip-flop (w) */
asm-mips/dma.h:#define DMA1_MASK_ALL_REG       0x0F    /* all-channels mask (w) */
asm-mips/dma.h:#define DMA2_MASK_REG		0xD4	/* single-channel mask (w) */
asm-mips/dma.h:#define DMA2_CLEAR_FF_REG	0xD8	/* clear pointer flip-flop (w) */
asm-mips/dma.h:#define DMA2_MASK_ALL_REG       0xDE    /* all-channels mask (w) */
asm-mips/dma.h:#define DMA_MODE_CASCADE 0xC0   /* pass thru DREQ->HRQ, DACK<-HLDA only */
asm-mips/dma.h: * After that, keep track of it. :-)
asm-mips/dma.h: * --- In order to do that, the DMA routines below should ---
asm-mips/dma.h: * --- only be used while holding the DMA lock ! ---
asm-mips/dma.h: * Assumes dma flip-flop is clear.
asm-mips/dma.h: * NOTE 2: "count" represents _bytes_ and must be even for channels 5-7.
asm-mips/dma.h:        count--;
asm-mips/dma.h: * Assumes DMA flip-flop is clear.
asm-mips/dma.h:	/* using short to get 16-bit wrap around */
asm-mips/elf.h:#define EF_MIPS_ARCH_1      0x00000000  /* -mips1 code.  */
asm-mips/elf.h:#define EF_MIPS_ARCH_2      0x10000000  /* -mips2 code.  */
asm-mips/elf.h:#define EF_MIPS_ARCH_3      0x20000000  /* -mips3 code.  */
asm-mips/elf.h:#define EF_MIPS_ARCH_4      0x30000000  /* -mips4 code.  */
asm-mips/elf.h:#define EF_MIPS_ARCH_5      0x40000000  /* -mips5 code.  */
asm-mips/elf.h:	if (__h->e_machine != EM_MIPS)					\
asm-mips/elf.h:	if (__h->e_ident[EI_CLASS] != ELFCLASS32)			\
asm-mips/elf.h:	if ((__h->e_flags & EF_MIPS_ABI2) != 0)				\
asm-mips/elf.h:	if (((__h->e_flags & EF_MIPS_ABI) != 0) &&			\
asm-mips/elf.h:	    ((__h->e_flags & EF_MIPS_ABI) != EF_MIPS_ABI_O32))		\
asm-mips/elf.h:#define irix_elf_check_arch(hdr)	((hdr)->e_machine == EM_MIPS)
asm-mips/elf.h: * See comments in asm-alpha/elf.h, this is the same thing
asm-mips/elf.h:	_r->regs[1] = _r->regs[2] = _r->regs[3] = _r->regs[4] = 0;	\
asm-mips/elf.h:	_r->regs[5] = _r->regs[6] = _r->regs[7] = _r->regs[8] = 0;	\
asm-mips/elf.h:	_r->regs[9] = _r->regs[10] = _r->regs[11] = _r->regs[12] = 0;	\
asm-mips/elf.h:	_r->regs[13] = _r->regs[14] = _r->regs[15] = _r->regs[16] = 0;	\
asm-mips/elf.h:	_r->regs[17] = _r->regs[18] = _r->regs[19] = _r->regs[20] = 0;	\
asm-mips/elf.h:	_r->regs[21] = _r->regs[22] = _r->regs[23] = _r->regs[24] = 0;	\
asm-mips/elf.h:	_r->regs[25] = _r->regs[26] = _r->regs[27] = _r->regs[28] = 0;	\
asm-mips/elf.h:	_r->regs[30] = _r->regs[31] = 0;				\
asm-mips/cachectl.h: * cachectl.h -- defines for MIPS cache control system calls
asm-mips/fpu.h:#define clear_fpu_owner() do { current->flags &= ~PF_USEDFPU; } while(0)
asm-mips/fpu.h:	return cpu_has_fpu && ((current->flags & PF_USEDFPU) != 0); 
asm-mips/fpu.h:		current->flags |= PF_USEDFPU;
asm-mips/fpu.h:		current->flags &= ~PF_USEDFPU;
asm-mips/fpu.h:		return (unsigned long long *)&tsk->thread.fpu.hard.fp_regs[0];
asm-mips/fpu.h:		return (unsigned long long *)tsk->thread.fpu.soft.regs;
asm-mips/gfx.h: * This is the user-visible SGI GFX interface.
asm-mips/gfx.h: * any kernel-only bits on it.
asm-mips/ide.h: * Copyright (C) 1994-1996  Linus Torvalds & authors
asm-mips/ide.h:	return ide_ops->ide_default_irq(base);
asm-mips/ide.h:	return ide_ops->ide_default_io_base(index);
asm-mips/ide.h:	ide_ops->ide_init_hwif_ports(hw, data_port, ctrl_port, irq);
asm-mips/ide.h:#define ide_ack_intr(hwif)	((hwif)->hw.ack_intr ? (hwif)->hw.ack_intr(hwif) : 1)
asm-mips/ide.h:/* MIPS port and memory-mapped I/O string operations.  */
asm-mips/ide.h:	while (count--) {
asm-mips/ide.h:	while (count--) {
asm-mips/ide.h:	while (count--) {
asm-mips/ide.h:	while (count--) {
asm-mips/lasat/lasat.h: *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm-mips/lasat/lasat.h:/* Configuration descriptor encoding - see the doc for details */
asm-mips/pci.h:   already-configured bus numbers - to be used for buggy BIOSes
asm-mips/pci.h: * NULL for PCI-like buses (ISA, EISA).
asm-mips/pci.h: * Returns non-NULL cpu-view pointer to the buffer if successful and
asm-mips/pci.h: * The 32-bit bus address to use is returned.
asm-mips/pci.h:	return bus_to_baddr(hwdev->bus, __pa(ptr));
asm-mips/pci.h:		addr = baddr_to_bus(hwdev->bus, dma_addr) + PAGE_OFFSET;
asm-mips/pci.h:	return bus_to_baddr(hwdev->bus, page_to_phys(page) + offset);
asm-mips/pci.h:		addr = baddr_to_bus(hwdev->bus, dma_address) + PAGE_OFFSET;
asm-mips/pci.h: * mode for DMA.  This is the scather-gather version of the
asm-mips/pci.h:		if (sg->address && sg->page)
asm-mips/pci.h:		else if (!sg->address && !sg->page)
asm-mips/pci.h:		if (sg->address) {
asm-mips/pci.h:			dma_cache_wback_inv((unsigned long)sg->address,
asm-mips/pci.h:			                    sg->length);
asm-mips/pci.h:			sg->dma_address = bus_to_baddr(hwdev->bus, __pa(sg->address));
asm-mips/pci.h:			sg->dma_address = page_to_bus(sg->page) +
asm-mips/pci.h:			                  sg->offset;
asm-mips/pci.h:				(page_address(sg->page) + sg->offset),
asm-mips/pci.h:				sg->length);
asm-mips/pci.h:		if (sg->address && sg->page)
asm-mips/pci.h:		else if (!sg->address && !sg->page)
asm-mips/pci.h:		if (!sg->address)
asm-mips/pci.h:		dma_cache_wback_inv((unsigned long)sg->address, sg->length);
asm-mips/pci.h:	addr = baddr_to_bus(hwdev->bus, dma_handle) + PAGE_OFFSET;
asm-mips/pci.h: * The same as pci_dma_sync_single but for a scatter-gather list,
asm-mips/pci.h:		dma_cache_wback_inv((unsigned long)sg->address, sg->length);
asm-mips/pci.h: * only drive the low 24-bits during PCI bus mastering, then
asm-mips/pci.h:	return (dma64_addr_t) bus_to_baddr(pdev->bus, addr);
asm-mips/pci.h:	unsigned long poff = baddr_to_bus(pdev->bus, dma_addr) >> PAGE_SHIFT;
asm-mips/pci.h:	addr = baddr_to_bus(pdev->bus, dma_addr) + PAGE_OFFSET;
asm-mips/pci.h:#define sg_dma_address(sg)	((sg)->dma_address)
asm-mips/pci.h:#define sg_dma_len(sg)		((sg)->length)
asm-mips/fpregdef.h: * These definitions only cover the R3000-ish 16/32 register model.
asm-mips/reg.h: * This defines/structures correspond to the register layout on stack -
asm-mips/reg.h: * include/asm-mips/stackframe.h
asm-mips/cacheops.h: * Cache Operations available on all MIPS processors with R4000-style caches
asm-mips/cacheops.h: * R4000-specific cacheops
asm-mips/cacheops.h: * R4000SC and R4400SC-specific cacheops
asm-mips/cacheops.h: * R5000-specific cacheops
asm-mips/cacheops.h: * RM7000-specific cacheops
asm-mips/cacheops.h: * R1000-specific cacheops
asm-mips/cacheops.h: * Cacheops 0x02, 0x06, 0x0a, 0x0c-0x0e, 0x16, 0x1a and 0x1e are unused.
asm-mips/smp.h: * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
asm-mips/smp.h: * Copyright (C) 2000 - 2001 by Kanoj Sarcar (kanoj@sgi.com)
asm-mips/smp.h: * Copyright (C) 2000 - 2001 by Silicon Graphics, Inc.
asm-mips/smp.h:#define smp_processor_id()	(current->processor)
asm-mips/smp.h:   not be idempotent when cpus failed to come on-line.  */
asm-mips/smp.h:#define NO_PROC_ID	(-1)
asm-mips/smp.h:/* These are defined by the board-specific code. */
asm-mips/sni.h: * Interrupt 0-16 are EISA interrupts.  Interrupts from 16 on are assigned
asm-mips/tlb.h:#include <asm-generic/tlb.h>
asm-mips/war.h: * interrupts during indexed I-cache flushes seems to be sufficient to deal
asm-mips/war.h: * pre-conditions for this problem.
asm-mips/xor.h:#include <asm-generic/xor.h>
asm-mips/branch.h:	return regs->cp0_cause & CAUSEF_BD;
asm-mips/branch.h:		return regs->cp0_epc;
asm-mips/branch.h:	return regs->cp0_epc + 4;
asm-mips/branch.h:		regs->cp0_epc += 4;
asm-mips/signal.h:#define SIGFPE		 8	/* Floating-point exception (ANSI).  */
asm-mips/signal.h:#define SIGUSR1		16	/* User-defined signal 1 (POSIX).  */
asm-mips/signal.h:#define SIGUSR2		17	/* User-defined signal 2 (POSIX).  */
asm-mips/signal.h:#define SIGRTMAX	(_NSIG-1)
asm-mips/signal.h: * SA_INTERRUPT is a no-op, but left due to historical reasons. Use the
asm-mips/signal.h:#define SA_INTERRUPT	0x20000000	/* dummy -- ignored */
asm-mips/signal.h:#define SIG_ERR	((__sighandler_t)-1)	/* error return from signal */
asm-mips/signal.h: * non-Linux/MIPS object files or make use of them in the future.
asm-mips/signal.h:#define BRK_BD_TAKEN	3	/* For bd slot emulation - not implemented */
asm-mips/signal.h:#define BRK_BD_NOTTAKEN	4	/* For bd slot emulation - not implemented */
asm-mips/signal.h:#define BRK_NORLD	10	/* No rld found - not used by Linux/MIPS */
asm-mips/tx3912.h: *  include/asm-mips/tx3912.h
asm-mips/tx3912.h: *	---------------                                                      *
asm-mips/tx3912.h: *	-------------------                                                  *
asm-mips/tx3912.h: *	---------------                                                      *
asm-mips/tx3912.h: *	---------------                                                      *
asm-mips/tx3912.h: *	--------------                                                       *
asm-mips/tx3912.h: *	---------------                                                      *
asm-mips/fpu_emulator.h: *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm-mips/ficmmp.h: *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm-mips/ficmmp.h:#define AU1XXX_ATA_MEM_SIZE		(AU1XXX_ATA_END - AU1XXX_ATA_BASE +1)
asm-mips/hardirq.h:#define irq_exit(cpu, irq)	(local_irq_count(cpu)--)
asm-mips/hardirq.h:	--local_irq_count(cpu);
asm-mips/au1000_pcmcia.h: *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm-mips/au1000_pcmcia.h: * These really belong in a board-specific header file...
asm-mips/au1000.h: * Taken from PPC tree.  -- Dan
asm-mips/au1000.h:	return 31 - lz;
asm-mips/au1000.h:	return __ilog2(x & -x);
asm-mips/au1000.h:	return __ilog2(x & -x) + 1;
asm-mips/au1000.h:/* UARTS 0-3 */
asm-mips/au1000.h:#define UART_LSR_THRE	0x20	/* Transmit-hold-register empty */
asm-mips/au1000.h:#define SSI_CONFIG_ALEN_N(N)		((N-1)<<20)
asm-mips/au1000.h:#define SSI_CONFIG_DLEN_N(N)		((N-1)<<16)
asm-mips/au1000.h:  /* FIXME - double check this from asm-ppc/pci-bridge.h */
asm-mips/au1000.h:  ({ long _ctl_ = -1;                                 \
asm-mips/au1000.h:	       _ctl_ = pci_irq_table[idsel - min_idsel][pin-1];               \
asm-mips/shmiq.h:        volatile unsigned int flags; /* place for out-of-band data */
asm-mips/shmiq.h:/* -------------------- iDev stuff -------------------- */
asm-mips/shmiq.h:/* These are only interpreted by SHMIQ-attacheable devices and are internal
asm-mips/mv64340.h:* mv64340.h - MV-64340 Internal registers definition file.
asm-mips/processor.h:#define MIPS_CACHE_IC_F_DC	0x00000008	/* Ic can refill from D-cache */
asm-mips/processor.h:	struct cache_desc icache;	/* Primary I-cache */
asm-mips/processor.h: * Size of io_bitmap in longwords: 32 is ports 0-0x3ff.
asm-mips/processor.h: * the FPU emulator for now.  See asm-mips/fpu_emulator.h.
asm-mips/processor.h:	if (t->reg31 == (unsigned long) ret_from_fork)
asm-mips/processor.h:		return t->reg31;
asm-mips/processor.h:	return ((unsigned long *)t->reg29)[schedule_frame.pc_offset];
asm-mips/processor.h:#define __PT_REG(reg) ((long)&((struct pt_regs *)0)->reg - sizeof(struct pt_regs))
asm-mips/processor.h:#define __KSTK_TOS(tsk) ((unsigned long)(tsk) + KERNEL_STACK_SIZE - 32)
asm-mips/processor.h:#define THREAD_MASK		(THREAD_SIZE - 1UL)
asm-mips/processor.h:#define get_task_struct(tsk)      atomic_inc(&virt_to_page(tsk)->count)
asm-mips/processor.h: * (MIPS, Alpha) or is unuseable with -fomit-frame-pointer (i386).
asm-mips/processor.h: * __builtin_return_address works only for non-leaf functions.  We avoid the
asm-mips/linux_logo.h: * include/asm-mips/linux_logo.h: This is a linux logo
asm-mips/mmu_context.h: * use the processor id via current->processor, where current is stored
asm-mips/mmu_context.h:#define cpu_context(cpu, mm)	((mm)->context[cpu])
asm-mips/mmu_context.h:#define ASID_VERSION_MASK  ((unsigned long)~(ASID_MASK|(ASID_MASK-1)))
asm-mips/mmu_context.h:	TLBMISS_HANDLER_SETUP_PGD(next->pgd);
asm-mips/mmu_context.h:	 * Mark current->active_mm as not "active" anymore.
asm-mips/mmu_context.h:	clear_bit(cpu, &prev->cpu_vm_mask);
asm-mips/mmu_context.h:	set_bit(cpu, &next->cpu_vm_mask);
asm-mips/mmu_context.h: * After we have set current->mm to a new value, this activates
asm-mips/mmu_context.h:	TLBMISS_HANDLER_SETUP_PGD(next->pgd);
asm-mips/mmu_context.h:	clear_bit(cpu, &prev->cpu_vm_mask);
asm-mips/mmu_context.h:	set_bit(cpu, &next->cpu_vm_mask);
asm-mips/mmu_context.h:	if (test_bit(cpu, &mm->cpu_vm_mask))  {
asm-mips/sysmips.h: * sysmips(2) is deprecated - though some existing software uses it.
asm-mips/db1200.h: *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm-mips/db1200.h: *    *example: IDE bis pos is  = 64 - 64
asm-mips/db1200.h:                ETH bit pos is  = 65 - 64
asm-mips/db1200.h:#define BOARD_CARD_INSERTED(SOCKET) bcsr->sig_status & (1<<(8+(2*SOCKET)))
asm-mips/pgtable-32.h: * traditional mips two-level paging structure:
asm-mips/pgtable-32.h:#define PMD_SHIFT       (2 * PAGE_SHIFT - PTE_T_LOG2)
asm-mips/pgtable-32.h:        pte_val(__pte) = ((phys_t)(page - mem_map) << (PAGE_SHIFT + 2)) | \
asm-mips/pgtable-32.h:	pte_val(__pte) = ((phys_t)(page - mem_map) << PAGE_SHIFT) | \
asm-mips/pgtable-64.h:#define mk_pte(page, pgprot) __mk_pte((page) - mem_map, (pgprot))
asm-mips/pgtable-64.h: * value and then use set_pte to update it.  -ben
asm-mips/pgtable-64.h:	ptep->pte_high = pte.pte_high;
asm-mips/pgtable-64.h:	ptep->pte_low = pte.pte_low;
asm-mips/pgtable-64.h:			buddy->pte_low |= _PAGE_GLOBAL;
asm-mips/semaphore.h:	atomic_set(&sem->count, val);
asm-mips/semaphore.h:	atomic_set(&sem->waking, 0);
asm-mips/semaphore.h:	init_waitqueue_head(&sem->wait);
asm-mips/semaphore.h:	sem->__magic = (long)&sem->__magic;
asm-mips/semaphore.h: * sem->count and sem->waking atomic.
asm-mips/semaphore.h:	CHECK_MAGIC(sem->__magic);
asm-mips/semaphore.h:	count = atomic_dec_return(&sem->count);
asm-mips/semaphore.h: * it, return zero.  If we were interrupted, returns -EINTR
asm-mips/semaphore.h:	CHECK_MAGIC(sem->__magic);
asm-mips/semaphore.h:	count = atomic_dec_return(&sem->count);
asm-mips/semaphore.h: * Here, we do this by using lld/scd on the pair of 32-bit words.
asm-mips/semaphore.h: *   Decrement(sem->count)
asm-mips/semaphore.h: *   If(sem->count >=0) {
asm-mips/semaphore.h: *	If(sem->waking <= 0) {		// if no wakeup pending
asm-mips/semaphore.h: *	   Increment(sem->count)	// undo decrement
asm-mips/semaphore.h: *	   Decrement(sem->waking)	// otherwise "steal" wakeup
asm-mips/semaphore.h:	CHECK_MAGIC(sem->__magic);
asm-mips/semaphore.h:	"	dli	%3, 0x0000000100000000	# count -= 1		\n"
asm-mips/semaphore.h:	"	blez	%2, 1f			# if waking < 0 -> 1f	\n"
asm-mips/semaphore.h:	"	daddiu	%1, %1, -1		# waking -= 1		\n"
asm-mips/semaphore.h:	CHECK_MAGIC(sem->__magic);
asm-mips/semaphore.h:	"	dsll32 %1, %1, 0	# zero-extend %1	\n"
asm-mips/semaphore.h: * Non-blockingly attempt to down() a semaphore.
asm-mips/semaphore.h:	CHECK_MAGIC(sem->__magic);
asm-mips/semaphore.h:	count = atomic_read(&sem->count) - 1;
asm-mips/semaphore.h:	atomic_set(&sem->count, count);
asm-mips/semaphore.h:		waking = atomic_read(&sem->waking);
asm-mips/semaphore.h:			atomic_set(&sem->count, count + 1);
asm-mips/semaphore.h:			atomic_set(&sem->waking, waking - 1);
asm-mips/semaphore.h:	CHECK_MAGIC(sem->__magic);
asm-mips/semaphore.h:	count = atomic_read(&sem->count) + 1;
asm-mips/semaphore.h:	waking = atomic_read(&sem->waking);
asm-mips/semaphore.h:	atomic_set(&sem->count, count);
asm-mips/semaphore.h:	atomic_set(&sem->waking, waking);
asm-mips/semaphore.h:	return atomic_read(&sem->count);
asm-mips/fcntl.h:/* open/fcntl - O_SYNC is only implemented on blocks devices and on files
asm-mips/fcntl.h:#define F_GETFL		3	/* get file->f_flags */
asm-mips/fcntl.h:#define F_SETFL		4	/* set file->f_flags */
asm-mips/au1000_dma.h:	au_writel(DMA_BE0, chan->io + DMA_MODE_SET);
asm-mips/au1000_dma.h:	au_writel(DMA_BE1, chan->io + DMA_MODE_SET);
asm-mips/au1000_dma.h:	au_writel(DMA_BE0 | DMA_BE1, chan->io + DMA_MODE_SET);
asm-mips/au1000_dma.h:	au_writel(DMA_GO, chan->io + DMA_MODE_SET);
asm-mips/au1000_dma.h:	au_writel(DMA_GO, chan->io + DMA_MODE_CLEAR);
asm-mips/au1000_dma.h:		if (au_readl(chan->io + DMA_MODE_READ) & DMA_HALT)
asm-mips/au1000_dma.h:	au_writel(~DMA_GO, chan->io + DMA_MODE_CLEAR);
asm-mips/au1000_dma.h:	return (au_readl(chan->io + DMA_MODE_READ) & DMA_HALT) ? 1 : 0;
asm-mips/au1000_dma.h:	au_writel(PHYSADDR(chan->fifo_addr),
asm-mips/au1000_dma.h:		  chan->io + DMA_PERIPHERAL_ADDR);
asm-mips/au1000_dma.h:	mode = chan->mode | (chan->dev_id << DMA_DID_BIT);
asm-mips/au1000_dma.h:	if (chan->irq)
asm-mips/au1000_dma.h:	au_writel(~mode, chan->io + DMA_MODE_CLEAR);
asm-mips/au1000_dma.h:	au_writel(mode, chan->io + DMA_MODE_SET);
asm-mips/au1000_dma.h:	chan->mode &= ~(DMA_BE | DMA_DR | DMA_TS8 | DMA_DW_MASK | DMA_NC);
asm-mips/au1000_dma.h:	chan->mode |= mode;
asm-mips/au1000_dma.h:	return chan->mode;
asm-mips/au1000_dma.h:		return -1;
asm-mips/au1000_dma.h:	return (au_readl(chan->io + DMA_MODE_READ) & DMA_AB) ? 1 : 0;
asm-mips/au1000_dma.h: * set the device FIFO address for a specific DMA channel - only
asm-mips/au1000_dma.h:	if (chan->mode & DMA_DS)	/* second bank of device ids */
asm-mips/au1000_dma.h:	if (chan->dev_id != DMA_ID_GP04 && chan->dev_id != DMA_ID_GP05)
asm-mips/au1000_dma.h:	au_writel(PHYSADDR(a), chan->io + DMA_PERIPHERAL_ADDR);
asm-mips/au1000_dma.h:	au_writel(DMA_D0, chan->io + DMA_MODE_CLEAR);
asm-mips/au1000_dma.h:	au_writel(DMA_D1, chan->io + DMA_MODE_CLEAR);
asm-mips/au1000_dma.h: * This does nothing - not applicable to Au1000 DMA.
asm-mips/au1000_dma.h:	au_writel(a, chan->io + DMA_BUFFER0_START);
asm-mips/au1000_dma.h:	au_writel(a, chan->io + DMA_BUFFER1_START);
asm-mips/au1000_dma.h:	au_writel(count, chan->io + DMA_BUFFER0_COUNT);
asm-mips/au1000_dma.h:	au_writel(count, chan->io + DMA_BUFFER1_COUNT);
asm-mips/au1000_dma.h:	au_writel(count, chan->io + DMA_BUFFER0_COUNT);
asm-mips/au1000_dma.h:	au_writel(count, chan->io + DMA_BUFFER1_COUNT);
asm-mips/au1000_dma.h: * Returns -1 if neither or both done bits set.
asm-mips/au1000_dma.h:    return au_readl(chan->io + DMA_MODE_READ) & (DMA_D0 | DMA_D1);
asm-mips/au1000_dma.h:		return -1;
asm-mips/au1000_dma.h:	return chan->irq;
asm-mips/au1000_dma.h:	curBufCntReg = (au_readl(chan->io + DMA_MODE_READ) & DMA_AB) ?
asm-mips/au1000_dma.h:	count = au_readl(chan->io + curBufCntReg) & DMA_COUNT_MASK;
asm-mips/au1000_dma.h:	if ((chan->mode & DMA_DW_MASK) == DMA_DW16)
asm-mips/au1000_dma.h:	else if ((chan->mode & DMA_DW_MASK) == DMA_DW32)
asm-mips/module.h: * modutils/obj/obj-mips.c
asm-mips/module.h:	archdata = (struct archdata *)(mod->archdata_start);
asm-mips/module.h:	if (archdata->dbe_table_start > archdata->dbe_table_end ||
asm-mips/module.h:	    (archdata->dbe_table_start &&
asm-mips/module.h:	     !((unsigned long)archdata->dbe_table_start >=
asm-mips/module.h:	       ((unsigned long)mod + mod->size_of_struct) &&
asm-mips/module.h:	       ((unsigned long)archdata->dbe_table_end <
asm-mips/module.h:	        (unsigned long)mod + mod->size))) ||
asm-mips/module.h:            (((unsigned long)archdata->dbe_table_start -
asm-mips/module.h:	      (unsigned long)archdata->dbe_table_end) %
asm-mips/module.h:			"module_arch_init: archdata->dbe_table_* invalid.\n");
asm-mips/module.h:	mod->archdata_start = (char *)&archdata;
asm-mips/module.h:	mod->archdata_end = mod->archdata_start + sizeof(archdata);
asm-mips/pgtable-bits.h: * Copyright (C) 1994 - 2002 by Ralf Baechle
asm-mips/pgtable-bits.h:/* bobtseng --, 2005.12.16 */
asm-mips/spinlock.h:#define spin_lock_init(x)	do { (x)->lock = 0; } while(0)
asm-mips/spinlock.h:#define spin_is_locked(x)	((x)->lock != 0)
asm-mips/spinlock.h:#define spin_unlock_wait(x)	do { barrier(); } while ((x)->lock)
asm-mips/spinlock.h:	: "=m" (lock->lock), "=&r" (tmp)
asm-mips/spinlock.h:	: "m" (lock->lock)
asm-mips/spinlock.h:	: "=m" (lock->lock)
asm-mips/spinlock.h:	: "m" (lock->lock)
asm-mips/spinlock.h: * Read-write spinlocks, allowing multiple readers but only one writer.
asm-mips/spinlock.h: * writers. For those circumstances we can "mix" irq-safe locks - any writer
asm-mips/spinlock.h: * needs to get a irq-safe write-lock, but readers can get non-irqsafe
asm-mips/spinlock.h: * read-locks.
asm-mips/spinlock.h:	: "=m" (rw->lock), "=&r" (tmp)
asm-mips/spinlock.h:	: "m" (rw->lock)
asm-mips/spinlock.h:	: "=m" (rw->lock), "=&r" (tmp)
asm-mips/spinlock.h:	: "m" (rw->lock)
asm-mips/spinlock.h:	: "=m" (rw->lock), "=&r" (tmp)
asm-mips/spinlock.h:	: "m" (rw->lock)
asm-mips/spinlock.h:	: "=m" (rw->lock)
asm-mips/spinlock.h:	: "m" (rw->lock)
asm-mips/errno.h:#define	EXDEV		18	/* Cross-device link */
asm-mips/errno.h:#define	EROFS		30	/* Read-only file system */
asm-mips/errno.h:#define	ENOTSOCK	95	/* Socket operation on non-socket */
asm-mips/db1x00.h: *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm-mips/db1x00.h:#define BOARD_CARD_INSERTED(SOCKET) !(bcsr->status & (1<<(4+SOCKET)))
asm-mips/db1x00.h:#define BOARD_CARD_INSERTED(SOCKET) !(bcsr->status & (1<<(4+SOCKET)))
asm-mips/hazards.h: * mtc0->mfc0 hazard
asm-mips/hazards.h: * mtc0->mfc0 hazard
asm-mips/hazards.h: * R10000 rocks - all hazards handled in hardware, so this becomes a nobrainer.
asm-mips/hazards.h: * care about the irq_enable_hazard - sooner or later the hardware will
asm-mips/galileo-boards/gt96100.h: *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm-mips/galileo-boards/gt96100.h:/* TDPR0 - Transmit Dual Port RAM. block size 0xff */
asm-mips/galileo-boards/gt96100.h:/* RDPR0 - Receive Dual Port RAM. block size 0xff */
asm-mips/usioctl.h: * usema/usemaclone-related stuff.
asm-mips/softirq.h:	local_bh_count(cpu)--;
asm-mips/softirq.h:	if (!--local_bh_count(cpu) && softirq_pending(cpu))	\
asm-mips/au1000_usbdev.h: *	Au1000 USB Device-Side Driver
asm-mips/bugs.h: * This is included by init/main.c to check for architecture-dependent bugs.
asm-mips/namei.h: * linux/include/asm-mips/namei.h
asm-mips/namei.h:	if (current->personality != PER_IRIX32)
asm-mips/ng1hw.h:#define REX3WAIT(rex3)  while ((rex3)->p1.set.status & GFXBUSY)
asm-mips/ng1hw.h:#define BFIFOWAIT(rex3)  while ((rex3)->p1.set.status & BACKBUSY)
asm-mips/termbits.h:#define VKILL		 3		/* Kill-line character [ICANON].  */
asm-mips/termbits.h:#define VTIME		 5		/* Time-out value (tenths of a second) [!ICANON].  */
asm-mips/termbits.h:#define VSTART		 8		/* Start (X-ON) character [IXON, IXOFF].  */
asm-mips/termbits.h:#define VSTOP		 9		/* Stop (X-OFF) character [IXON, IXOFF].  */
asm-mips/termbits.h:#define VREPRINT	12		/* Reprint-line character [ICANON].  */
asm-mips/termbits.h:#define VWERASE		14		/* Word-erase character [ICANON].  */
asm-mips/termbits.h:#define VLNEXT		15		/* Literal-next character [IEXTEN].  */
asm-mips/termbits.h:#define VEOF		16		/* End-of-file character [ICANON].  */
asm-mips/termbits.h:#define VEOL		17		/* End-of-line character [ICANON].  */
asm-mips/termbits.h:#define ONLCR	0000004		/* Map NL to CR-NL on output.  */
asm-mips/riscos-syscall.h: * The syscalls 0 - 3999 are reserved for a down to the root syscall
asm-mips/highmem.h: * Redesigned the x86 32-bit VM architecture to deal with
asm-mips/highmem.h:#define LAST_PKMAP_MASK (LAST_PKMAP-1)
asm-mips/highmem.h:#define PKMAP_NR(virt)  ((virt-PKMAP_BASE) >> PAGE_SHIFT)
asm-mips/highmem.h: * The use of kmap_atomic/kunmap_atomic is discouraged - kmap/kunmap
asm-mips/highmem.h:	set_pte(kmap_pte-idx, mk_pte(page, kmap_prot));
asm-mips/au1xxx_psc.h:/* Enable slots 3-12.
asm-mips/au1xxx_psc.h:#define PSC_AC97CFG_TXSLOT_ENA(x)	(1 << (((x) - 3) + 11))
asm-mips/au1xxx_psc.h:#define PSC_AC97CFG_RXSLOT_ENA(x)	(1 << (((x) - 3) + 1))
asm-mips/au1xxx_psc.h:#define PSC_AC97CFG_SET_LEN(x)	(((((x)-2)/2) & 0xf) << 21)
asm-mips/au1xxx_psc.h:#define PSC_I2SCFG_SET_WS(x)	(((((x) / 2) - 1) & 0x7f) << 16)
asm-mips/au1xxx_psc.h:#define PSC_I2SCFG_SET_LEN(x)	((((x) - 1) & 0x1f) << 4)
asm-mips/au1xxx_psc.h:#define PSC_SPICFG_SET_LEN(x)	(((x-1) & 0x1f) << 4)
asm-mips/fixmap.h: * fixmap.h: compile-time virtual memory allocation
asm-mips/fixmap.h: * Here we define all the compile-time 'special' virtual
asm-mips/fixmap.h: * Also this lets us do fail-safe vmalloc(), we
asm-mips/fixmap.h: * vmalloc()-ed addresses never overlap.
asm-mips/fixmap.h: * these 'compile-time allocated' memory buffers are
asm-mips/fixmap.h: * fixed-size 4k pages. (or larger if used with an increment
asm-mips/fixmap.h: * fix-mapped?
asm-mips/fixmap.h:	FIX_KMAP_END = FIX_KMAP_BEGIN+(KM_TYPE_NR*NR_CPUS)-1,
asm-mips/fixmap.h:#define FIXADDR_START	(FIXADDR_TOP - FIXADDR_SIZE)
asm-mips/fixmap.h:#define __fix_to_virt(x)	(FIXADDR_TOP - ((x) << PAGE_SHIFT))
asm-mips/fixmap.h: * directly without tranlation, we catch the bug with a NULL-deference
asm-mips/fixmap.h:	 * out-of-range indices).
asm-mips/jazz.h: * Copyright (C) 1995 - 1998 by Andreas Busse and Ralf Baechle
asm-mips/jazz.h: * 0xf0000000 - Rev1
asm-mips/jazz.h: * 0xf0000001 - Rev2
asm-mips/jazz.h: * 0xf0000002 - Rev3
asm-mips/jazz.h: *      ---------
asm-mips/jazz.h: *      ---------
asm-mips/jazz.h: *      --------- . (0)
asm-mips/jazz.h: * Note: Channels 4...7 are not used with respect to the Acer PICA-61
asm-mips/init.h:#error "<asm/init.h> should never be used - use <linux/init.h> instead"
asm-mips/inst.h:	 * The others (0x14 - 0x1f) are unused.
asm-mips/inst.h: * Damn ...  bitfields depend from byteorder :-(
asm-mips/it8172/it8172_int.h: * and the non-maskable ints from 48 to 53.
asm-mips/it8172/it8172_int.h:/* 12 - 15 reserved */
asm-mips/it8172/it8172_int.h:#define MIPS_CPU_TIMER_IRQ       (NR_IRQS-1)
asm-mips/uaccess.h:#define __UA_LIMIT	(- TASK_SIZE)
asm-mips/uaccess.h: * userspace address.  Note that we limit 32-bit userspace to 0x7fff8000 but
asm-mips/uaccess.h: * we use 0x80000000 here on 32-bit kernels.  If a process passes an invalid
asm-mips/uaccess.h: * address in this range it's the process's problem, not ours :-)
asm-mips/uaccess.h:#define get_fs()	(current->thread.current_ds)
asm-mips/uaccess.h:#define set_fs(x)	(current->thread.current_ds = (x))
asm-mips/uaccess.h: *  - "addr" doesn't have any high-bits set
asm-mips/uaccess.h: *  - AND "size" doesn't have any high-bits set
asm-mips/uaccess.h: *  - AND "addr+size" doesn't have any high-bits set
asm-mips/uaccess.h: *  - OR we are in kernel mode.
asm-mips/uaccess.h: * access_ok: - Checks if a user space pointer is valid
asm-mips/uaccess.h: *        %VERIFY_WRITE is a superset of %VERIFY_READ - if it is safe
asm-mips/uaccess.h: * checks that the pointer is in the user space range - after calling
asm-mips/uaccess.h: * this function, memory access functions may still return -EFAULT.
asm-mips/uaccess.h: * verify_area: - Obsolete, use access_ok()
asm-mips/uaccess.h: * Returns zero if the memory block may be valid, -EFAULT
asm-mips/uaccess.h:	return access_ok(type, addr, size) ? 0 : -EFAULT;
asm-mips/uaccess.h: * put_user: - Write a simple value into user space.
asm-mips/uaccess.h: * @ptr must have pointer-to-simple-variable type, and @x must be assignable
asm-mips/uaccess.h: * Returns zero on success, or -EFAULT on error.
asm-mips/uaccess.h: * get_user: - Get a simple variable from user space.
asm-mips/uaccess.h: * @ptr must have pointer-to-simple-variable type, and the result of
asm-mips/uaccess.h: * Returns zero on success, or -EFAULT on error.
asm-mips/uaccess.h: * __put_user: - Write a simple value into user space, with less checking.
asm-mips/uaccess.h: * @ptr must have pointer-to-simple-variable type, and @x must be assignable
asm-mips/uaccess.h: * Returns zero on success, or -EFAULT on error.
asm-mips/uaccess.h: * __get_user: - Get a simple variable from user space, with less checking.
asm-mips/uaccess.h: * @ptr must have pointer-to-simple-variable type, and the result of
asm-mips/uaccess.h: * Returns zero on success, or -EFAULT on error.
asm-mips/uaccess.h:	: "0" (__gu_err), "o" (__m(__gu_addr)), "i" (-EFAULT));		\
asm-mips/uaccess.h:	  "o" (__m(__gu_addr + 4)), "i" (-EFAULT));			\
asm-mips/uaccess.h:	  "i" (-EFAULT));						\
asm-mips/uaccess.h:	  "o" (__m(__pu_addr + 4)), "i" (-EFAULT));			\
asm-mips/uaccess.h: * __copy_to_user: - Copy a block of data into user space, with less checking.
asm-mips/uaccess.h: * copy_to_user: - Copy a block of data into user space.
asm-mips/uaccess.h: * __copy_from_user: - Copy a block of data from user space, with less checking. * @to:   Destination address, in kernel space.
asm-mips/uaccess.h: * copy_from_user: - Copy a block of data from user space.
asm-mips/uaccess.h: * __clear_user: - Zero a block of memory in user space, with less checking.
asm-mips/uaccess.h: * __strncpy_from_user: - Copy a NUL terminated string from userspace, with less checking.
asm-mips/uaccess.h: * Copies a NUL-terminated string from userspace to kernel space.
asm-mips/uaccess.h: * If access to userspace fails, returns -EFAULT (some data may have been
asm-mips/uaccess.h: * strncpy_from_user: - Copy a NUL terminated string from userspace.
asm-mips/uaccess.h: * Copies a NUL-terminated string from userspace to kernel space.
asm-mips/uaccess.h: * If access to userspace fails, returns -EFAULT (some data may have been
asm-mips/uaccess.h: * strlen_user: - Get the size of a string in user space.
asm-mips/uaccess.h: * Get the size of a NUL-terminated string in user space.
asm-mips/uaccess.h: * strlen_user: - Get the size of a string in user space.
asm-mips/uaccess.h: * Get the size of a NUL-terminated string in user space.
asm-mips/traps.h: *	include/asm-mips/traps.h
asm-mips/nile4.h: *  asm-mips/nile4.h -- NEC Vrc-5074 Nile 4 definitions
asm-mips/nile4.h:#define NILE4_DCS2	0x0010	/* Device Chip-Select 2 [R/W] */
asm-mips/nile4.h:#define NILE4_DCS3	0x0018	/* Device Chip-Select 3 [R/W] */
asm-mips/nile4.h:#define NILE4_DCS4	0x0020	/* Device Chip-Select 4 [R/W] */
asm-mips/nile4.h:#define NILE4_DCS5	0x0028	/* Device Chip-Select 5 [R/W] */
asm-mips/nile4.h:#define NILE4_DCS6	0x0030	/* Device Chip-Select 6 [R/W] */
asm-mips/nile4.h:#define NILE4_DCS7	0x0038	/* Device Chip-Select 7 [R/W] */
asm-mips/nile4.h:#define NILE4_DCS8	0x0040	/* Device Chip-Select 8 [R/W] */
asm-mips/nile4.h:#define NILE4_BOOTCS	0x0078	/* Boot ROM Chip-Select [R/W] */
asm-mips/nile4.h:     *  Memory-Interface Registers
asm-mips/nile4.h:     *  PCI-Bus Registers
asm-mips/nile4.h:     *  Local-Bus Registers
asm-mips/nile4.h:#define NILE4_LCST2	0x0110	/* Local Bus Chip-Select Timing 2 [R/W] */
asm-mips/nile4.h:#define NILE4_LCST3	0x0118	/* Local Bus Chip-Select Timing 3 [R/W] */
asm-mips/nile4.h:#define NILE4_LCST4	0x0120	/* Local Bus Chip-Select Timing 4 [R/W] */
asm-mips/nile4.h:#define NILE4_LCST5	0x0128	/* Local Bus Chip-Select Timing 5 [R/W] */
asm-mips/nile4.h:#define NILE4_LCST6	0x0130	/* Local Bus Chip-Select Timing 6 [R/W] */
asm-mips/nile4.h:#define NILE4_LCST7	0x0138	/* Local Bus Chip-Select Timing 7 [R/W] */
asm-mips/nile4.h:#define NILE4_LCST8	0x0140	/* Local Bus Chip-Select Timing 8 [R/W] */
asm-mips/nile4.h:#define NILE4_DCSFN	0x0150	/* Device Chip-Select Muxing and Output */
asm-mips/nile4.h:#define NILE4_DCSIO	0x0158	/* Device Chip-Selects As I/O Bits [R/W] */
asm-mips/nile4.h:#define NILE4_BCST	0x0178	/* Local Boot Chip-Select Timing [R/W] */
asm-mips/nile4.h:#define NILE4_T1CTRL	0x01D0	/* CPU-Bus Read Time-Out Control [R/W] */
asm-mips/nile4.h:#define NILE4_T1CNTR	0x01D8	/* CPU-Bus Read Time-Out Counter [R/W] */
asm-mips/nile4.h:#define NILE4_T2CTRL	0x01E0	/* General-Purpose Timer Control [R/W] */
asm-mips/nile4.h:#define NILE4_T2CNTR	0x01E8	/* General-Purpose Timer Counter [R/W] */
asm-mips/nile4.h:#define NILE4_SSVID	0x022C	/* PCI Sub-System Vendor ID [R/W] */
asm-mips/nile4.h:#define NILE4_SSID	0x022E	/* PCI Sub-System ID [R/W] */
asm-mips/nile4.h:     *  Serial-Port Registers
asm-mips/nile4.h:#define NILE4_INT_CPCE	0	/* CPU-Interface Parity-Error Interrupt */
asm-mips/nile4.h:#define NILE4_INT_CNTD	1	/* CPU No-Target Decode Interrupt */
asm-mips/nile4.h:#define NILE4_INT_MCE	2	/* Memory-Check Error Interrupt */
asm-mips/nile4.h:#define NILE4_INT_GPT	6	/* General-Purpose Timer Interrupt */
asm-mips/nile4.h:#define NILE4_INT_LBRTD	7	/* Local-Bus Ready Timer Interrupt */
asm-mips/nile4.h:#define irq_to_nile4(n)		((n)-NUM_I8259_INTERRUPTS)
asm-mips/pb1000.h: *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm-mips/pb1000.h:/* VPPEN1 - VPPEN0 */
asm-mips/pb1000.h:/* VCCEN1 - VCCEN0 */
asm-mips/pb1100.h: *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm-mips/pb1200.h: *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm-mips/pb1200.h: *    *example: IDE bis pos is  = 64 - 64
asm-mips/pb1200.h:                ETH bit pos is  = 65 - 64
asm-mips/pb1200.h:#define BOARD_CARD_INSERTED(SOCKET) bcsr->sig_status & (1<<(8+(2*SOCKET)))
asm-mips/pb1500.h: *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm-mips/pb1550.h: *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm-mips/pb1550.h:#define DAUGHTER_CARD_MEM_SIZE		(0xADFFFFFF - DAUGHTER_CARD_BASE + 1)
asm-mips/mman.h:/* These are linux-specific */
asm-mips/mman.h:#define MAP_GROWSDOWN	0x1000		/* stack-like segment */
asm-mips/mman.h:#define MADV_NORMAL	0x0		/* default page-in behavior */
asm-mips/mman.h:#define MADV_RANDOM	0x1		/* page-in minimum required */
asm-mips/mman.h:#define MADV_SEQUENTIAL	0x2		/* read-ahead aggressively */
asm-mips/mman.h:#define MADV_WILLNEED	0x3		/* pre-fault pages */
asm-mips/linux_logo_dec.h: * include/asm-mips/linux_logo_dec.h: This is a linux logo
asm-mips/linux_logo_dec.h: * Copyright (C) 2001 Jan-Benedict Glaw <jbglaw@lug-owl.de>
asm-mips/addrspace.h: *  32-bit MIPS address spaces
asm-mips/addrspace.h: * 64-bit address conversions
asm-mips/posix_types.h: * This file is generally used by user-level software, so you need to
asm-mips/posix_types.h:	__fdsetp->fds_bits[__tmp] |= (1UL<<__rem);
asm-mips/posix_types.h:	__fdsetp->fds_bits[__tmp] &= ~(1UL<<__rem);
asm-mips/posix_types.h:	return (__p->fds_bits[__tmp] & (1UL<<__rem)) != 0;
asm-mips/posix_types.h: * for a 256-bit fd_set)
asm-mips/posix_types.h:	unsigned long *__tmp = __p->fds_bits;
asm-mips/posix_types.h:		__i--;
asm-mips/smplock.h:	if (task->lock_depth >= 0) \
asm-mips/smplock.h: * Re-acquire the kernel lock
asm-mips/smplock.h:	if (task->lock_depth >= 0) \
asm-mips/smplock.h:	if (!++current->lock_depth)
asm-mips/smplock.h:	if (--current->lock_depth < 0)
asm-mips/linux_logo_sgi.h: * include/asm-mips/linux_logo_sgi.h: This is a linux logo
asm-mips/linux_logo_sgi.h: * Copyright (C) 2001 Jan-Benedict Glaw <jbglaw@lug-owl.de>
asm-mips/mv64340_dep.h: * include/asm-mips/mv64340-dep.h
asm-mips/mv64340_dep.h: *     Board-dependent definitions for MV-64340 chip.
asm-mips/page.h: * Copyright (C) 1994 - 1999, 2003 by Ralf Baechle
asm-mips/page.h:#define PAGE_MASK	(~(PAGE_SIZE-1))
asm-mips/page.h: * These are used to make use of C type-checking..
asm-mips/page.h:	size = (size-1) >> (PAGE_SHIFT-1);
asm-mips/page.h:	order = -1;
asm-mips/page.h:#define PAGE_ALIGN(addr)	(((addr) + PAGE_SIZE - 1) & PAGE_MASK)
asm-mips/page.h:#define __pa(x)		((unsigned long) (x) - PAGE_OFFSET)
asm-mips/page.h:#define VALID_PAGE(page)	((page - mem_map) < max_mapnr)
asm-mips/page.h:#define UNCAC_ADDR(addr)	((addr) - PAGE_OFFSET + UNCAC_BASE)
asm-mips/page.h:#define CAC_ADDR(addr)		((addr) - UNCAC_BASE + PAGE_OFFSET)
asm-mips/gt64120/gt64120.h: *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm-mips/gt64120/gt64120.h:#define MSK(n)                    ((1 << (n)) - 1)
asm-mips/gt64120/gt64120.h: *   GT_WRITE(ofs, data)           - read/write GT64120 registers in 32bit
asm-mips/gt64120/gt64120.h: *   TIMER 	- gt64120 timer irq, temporary solution until
asm-mips/gt64120/gt64120.h:#include <asm/gt64120/mips-boards/gt64120_dep.h>
asm-mips/gt64120/gt64120.h:#include <asm/gt64120/mips-boards/gt64120_dep.h>
asm-mips/gt64120/gt64120.h: * bytes when running bigendian.  We also provide non-swapping versions.
asm-mips/gt64120/gt64120.h: * Board-dependent functions, which must be defined in
asm-mips/hdreg.h: *  Copyright (C) 1994-1996  Linus Torvalds & authors
asm-mips/poll.h:/* XXX This one seems to be more-or-less nonstandard.  */
asm-mips/rt2880/surfboard.h: *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm-mips/rt2880/surfboardint.bob: *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm-mips/rt2880/surfboardint.bob: * Surfboard registers are memory mapped on 32-bit aligned boundaries and
asm-mips/rt2880/surfboardint.bob:/* bobtseng added --, 2006.3.6. */
asm-mips/rt2880/surfboardint.org: *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm-mips/rt2880/surfboardint.org: * Surfboard registers are memory mapped on 32-bit aligned boundaries and
asm-mips/rt2880/generic.h: * 59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm-mips/rt2880/generic.h: * Defines of the Palmchip boards specific address-MAP, registers, etc.
asm-mips/rt2880/generic.h: * Power-off register
asm-mips/rt2880/prom.h: *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm-mips/rt2880/surfboardint.h: *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm-mips/rt2880/surfboardint.h: * Surfboard registers are memory mapped on 32-bit aligned boundaries and
asm-mips/rt2880/surfboardint.h:/* bobtseng added --, 2006.3.6. */
asm-mips/sembuf.h: * - 2 miscellaneous 64-bit values
asm-mips/sibyte/sb1250_dma.h:    *  MA 02111-1307 USA
asm-mips/sibyte/sb1250_dma.h: * Ethernet and Serial DMA Configuration Register 0  (Table 7-4)
asm-mips/sibyte/sb1250_dma.h: * Ethernet and Serial DMA Configuration Register 1 (Table 7-5)
asm-mips/sibyte/sb1250_dma.h: * Ethernet and Serial DMA Descriptor base address (Table 7-6)
asm-mips/sibyte/sb1250_dma.h: * ASIC Mode Base Address (Table 7-7)
asm-mips/sibyte/sb1250_dma.h: * DMA Descriptor Count Registers (Table 7-8)
asm-mips/sibyte/sb1250_dma.h: * Current Descriptor Address Register (Table 7-11)
asm-mips/sibyte/sb1250_dma.h: * Descriptor doubleword "A"  (Table 7-12)
asm-mips/sibyte/sb1250_dma.h: * Descriptor doubleword "B"  (Table 7-13)
asm-mips/sibyte/sb1250_dma.h: * Ethernet Descriptor Status Bits (Table 7-15)
asm-mips/sibyte/sb1250_dma.h: * Ethernet Transmit Status Bits (Table 7-16)
asm-mips/sibyte/sb1250_dma.h: * Ethernet Transmit Options (Table 7-17)
asm-mips/sibyte/sb1250_dma.h: * Serial Receive Options (Table 7-18)
asm-mips/sibyte/sb1250_dma.h: * Serial Transmit Status Bits (Table 7-20)
asm-mips/sibyte/sb1250_dma.h: * Serial Transmit Options (Table 7-21)
asm-mips/sibyte/sb1250_dma.h: * Data Mover Descriptor Base Address Register (Table 7-22)
asm-mips/sibyte/sb1250_dma.h: * Data Mover Descriptor Count Register (Table 7-25)
asm-mips/sibyte/sb1250_dma.h: * Data Mover Current Descriptor Address (Table 7-24)
asm-mips/sibyte/sb1250_dma.h: * Data Mover Descriptor Doubleword "A"  (Table 7-26)
asm-mips/sibyte/sb1250_dma.h: * Data Mover Descriptor Doubleword "B"  (Table 7-25)
asm-mips/sibyte/sb1250_l2c.h:    *  MA 02111-1307 USA
asm-mips/sibyte/sb1250_l2c.h: * Level 2 Cache Tag register (Table 5-3)
asm-mips/sibyte/sb1250_l2c.h: * Format of level 2 cache management address (table 5-2)
asm-mips/sibyte/sb1250_int.h:    *  MA 02111-1307 USA
asm-mips/sibyte/sb1250_int.h: * Interrupt sources (Table 4-8, UM 0.2)
asm-mips/sibyte/sb1250_int.h: * LDT Interrupt Set Register (table 4-5)
asm-mips/sibyte/sb1250_int.h: * Vector format (Table 4-6)
asm-mips/sibyte/sb1250_ldt.h:    *  MA 02111-1307 USA
asm-mips/sibyte/sb1250_ldt.h: * LDT Command Register (Table 8-13)
asm-mips/sibyte/sb1250_ldt.h: * LDT Status Register (Table 8-14).  Note that these constants
asm-mips/sibyte/sb1250_ldt.h: * together (32-bit read at offset 0x04)
asm-mips/sibyte/sb1250_ldt.h: * register (Table 8-15), offset 0x1C
asm-mips/sibyte/sb1250_ldt.h: * Bridge Control Register (Table 8-16).  Note that these 
asm-mips/sibyte/sb1250_ldt.h: * constants assume you've read the register as a 32-bit 
asm-mips/sibyte/sb1250_ldt.h: * LDT Command Register (Table 8-17).  Note that these constants
asm-mips/sibyte/sb1250_ldt.h: * 32-bit read at offset 0x40
asm-mips/sibyte/sb1250_ldt.h: * LDT link control register (Table 8-18), and (Table 8-19)
asm-mips/sibyte/sb1250_ldt.h: * LDT Link frequency register  (Table 8-20) offset 0x48
asm-mips/sibyte/sb1250_ldt.h: * LDT SRI Command Register (Table 8-21).  Note that these constants
asm-mips/sibyte/sb1250_ldt.h: * 32-bit read at offset 0x50
asm-mips/sibyte/sb1250_ldt.h: * LDT Error control and status register (Table 8-22) (Table 8-23)
asm-mips/sibyte/sb1250_ldt.h: * SRI Control register (Table 8-24, 8-25)  Offset 0x6C
asm-mips/sibyte/sb1250_ldt.h: * LDT SRI Transmit Buffer Count register (Table 8-26)
asm-mips/sibyte/sb1250_mac.h:    *  MA 02111-1307 USA
asm-mips/sibyte/sb1250_mac.h: * MAC Configuration Register (Table 9-13)
asm-mips/sibyte/sb1250_mac.h: * MAC Fifo Threshhold registers (Table 9-14)
asm-mips/sibyte/sb1250_mac.h: * MAC Frame Configuration Registers (Table 9-15)
asm-mips/sibyte/sb1250_mac.h: * MAC VLAN Tag Registers (Table 9-16)
asm-mips/sibyte/sb1250_mac.h: * MAC Status Registers (Table 9-17)
asm-mips/sibyte/sb1250_mac.h: * Also used for the MAC Interrupt Mask Register (Table 9-18)
asm-mips/sibyte/sb1250_mac.h: *  and pass just the six bits to a DMA-channel-specific ISR
asm-mips/sibyte/sb1250_mac.h: * MAC Fifo Pointer Registers (Table 9-19)    [Debug register]
asm-mips/sibyte/sb1250_mac.h: * MAC Fifo End Of Packet Count Registers (Table 9-20)  [Debug register]
asm-mips/sibyte/sb1250_mac.h: * MAC Recieve Address Filter Exact Match Registers (Table 9-21)
asm-mips/sibyte/sb1250_mac.h: * MAC Recieve Address Filter Hash Match Registers (Table 9-22)
asm-mips/sibyte/sb1250_mac.h: * MAC Transmit Source Address Registers (Table 9-23)
asm-mips/sibyte/sb1250_mac.h: * MAC Receive Address Filter Control Registers (Table 9-24)
asm-mips/sibyte/sb1250_mac.h: * MAC Receive Channel Select Registers (Table 9-25)
asm-mips/sibyte/sb1250_mac.h: * MAC MII Management Interface Registers (Table 9-26)
asm-mips/sibyte/sb1250_scd.h:    *  MA 02111-1307 USA
asm-mips/sibyte/sb1250_scd.h: * System Revision Register (Table 4-1)
asm-mips/sibyte/sb1250_scd.h: * System Config Register (Table 4-2)
asm-mips/sibyte/sb1250_scd.h: * Mailbox Registers (Table 4-3)
asm-mips/sibyte/sb1250_scd.h: * Watchdog Registers (Table 4-8) (Table 4-9) (Table 4-10)
asm-mips/sibyte/sb1250_scd.h: * Timer Registers (Table 4-11) (Table 4-12) (Table 4-13)
asm-mips/sibyte/trace_prof.h: * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
asm-mips/sibyte/trace_prof.h: * Routines for using 40-bit SCD cycle counter
asm-mips/sibyte/trace_prof.h: * zclk_timer_init(0) at least every 2^40 - 1 ZCLKs.
asm-mips/sibyte/sb1250_syncser.h:    *  MA 02111-1307 USA
asm-mips/sibyte/sb1250.h: * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
asm-mips/sibyte/sb1250_mc.h:    *  MA 02111-1307 USA
asm-mips/sibyte/sb1250_mc.h: * Memory Channel Config Register (table 6-14)
asm-mips/sibyte/sb1250_mc.h: * Memory clock config register (Table 6-15)
asm-mips/sibyte/sb1250_mc.h: * DRAM Command Register (Table 6-13)
asm-mips/sibyte/sb1250_mc.h: * DRAM Mode Register (Table 6-14)
asm-mips/sibyte/sb1250_mc.h: * SDRAM Timing Register  (Table 6-15)
asm-mips/sibyte/sb1250_mc.h: * Chip Select Start Address Register (Table 6-17)
asm-mips/sibyte/sb1250_mc.h: * Chip Select End Address Register (Table 6-18)
asm-mips/sibyte/sb1250_mc.h: * Chip Select Interleave Register (Table 6-19)
asm-mips/sibyte/sb1250_mc.h: * Row Address Bits Register (Table 6-20)
asm-mips/sibyte/sb1250_mc.h: * Column Address Bits Register (Table 6-21)
asm-mips/sibyte/sb1250_mc.h: * Bank Address Address Bits Register (Table 6-22)
asm-mips/sibyte/sb1250_mc.h: * Chip Select Attribute Register (Table 6-23)
asm-mips/sibyte/sb1250_mc.h: * ECC Test ECC Register (Table 6-25)
asm-mips/sibyte/swarm.h: * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
asm-mips/sibyte/carmel.h: * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
asm-mips/sibyte/sb1250_smbus.h:    *  MA 02111-1307 USA
asm-mips/sibyte/sb1250_smbus.h: * SMBus Clock Frequency Register (Table 14-2)
asm-mips/sibyte/sb1250_smbus.h: * SMBus control register (Table 14-4)
asm-mips/sibyte/sb1250_smbus.h: * SMBus status registers (Table 14-5)
asm-mips/sibyte/sb1250_smbus.h: * SMBus Start/Command registers (Table 14-9)
asm-mips/sibyte/sb1250_smbus.h: * SMBus Data Register (Table 14-6) and SMBus Extra Register (Table 14-7)
asm-mips/sibyte/sb1250_smbus.h: * SMBus Packet Error Check register (Table 14-8)
asm-mips/sibyte/sentosa.h: * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
asm-mips/sibyte/64bit.h: * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
asm-mips/sibyte/64bit.h: * This is annoying...we can't actually write the 64-bit IO register properly
asm-mips/sibyte/64bit.h: * without having access to 64-bit registers...  which doesn't work by default
asm-mips/sibyte/64bit.h: * driver code for the 32-bit and 64-bit trees
asm-mips/sibyte/64bit.h: * Avoid interrupt mucking, just adjust the address for 4-byte access.
asm-mips/sibyte/64bit.h: * Assume the addresses are 8-byte aligned.
asm-mips/sibyte/sb1250_defs.h:    *  MA 02111-1307 USA
asm-mips/sibyte/sb1250_defs.h: * 'long long' (64-bit integer) support.
asm-mips/sibyte/sb1250_defs.h:    ((SIBYTE_HDR_FMASK(chip, pass) - 1) & SIBYTE_HDR_FMASK_ALLREVS(chip))
asm-mips/sibyte/sb1250_defs.h:     | (SIBYTE_HDR_FMASK(chip, pass) - 1)) & SIBYTE_HDR_FMASK_ALLREVS(chip))
asm-mips/sibyte/sb1250_defs.h:    *                  For multi-bit fields, all bits in the field will
asm-mips/sibyte/sb1250_defs.h:    *  K_xxx           "Code" constant (value for data in a multi-bit
asm-mips/sibyte/sb1250_defs.h:    *  G_xxx(X)        GET value.  This macro obtains a multi-bit field
asm-mips/sibyte/sb1250_defs.h: * Cast to 64-bit number.  Presumably the syntax is different in 
asm-mips/sibyte/sb1250_defs.h:#define _SB_MAKEMASK(v,n) (_SB_MAKE64((_SB_MAKE64(1)<<(v))-1) << _SB_MAKE64(n))
asm-mips/sibyte/sb1250_defs.h:#define _SB_MAKEMASK_32(v,n) (_SB_MAKE32((_SB_MAKE32(1)<<(v))-1) << _SB_MAKE32(n))
asm-mips/sibyte/sb1250_defs.h: * Macros to read/write on-chip registers
asm-mips/sibyte/sb1250_genbus.h:    *  MA 02111-1307 USA
asm-mips/sibyte/sb1250_genbus.h: * Generic Bus Region Configuration Registers (Table 11-4)
asm-mips/sibyte/sb1250_genbus.h: * Generic Bus Region Size register (Table 11-5)
asm-mips/sibyte/sb1250_genbus.h: * Generic Bus Region Address (Table 11-6)
asm-mips/sibyte/sb1250_genbus.h: * Generic Bus Region 0 Timing Registers (Table 11-7)
asm-mips/sibyte/sb1250_genbus.h: * Generic Bus Timing 1 Registers (Table 11-8)
asm-mips/sibyte/sb1250_genbus.h: * Generic Bus Interrupt Status Register (Table 11-9)
asm-mips/sibyte/sb1250_genbus.h: * PCMCIA configuration register (Table 12-6)
asm-mips/sibyte/sb1250_genbus.h: * PCMCIA status register (Table 12-7)
asm-mips/sibyte/sb1250_genbus.h: * GPIO Interrupt Type Register (table 13-3)
asm-mips/sibyte/board.h: * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
asm-mips/sibyte/sb1250_regs.h:    *  This module contains the addresses of the on-chip peripherals
asm-mips/sibyte/sb1250_regs.h:    *  MA 02111-1307 USA
asm-mips/sibyte/sb1250_regs.h:/* Backward-compatibility definitions.  */
asm-mips/sibyte/sb1250_uart.h:    *  MA 02111-1307 USA
asm-mips/sibyte/sb1250_uart.h: * DUART Mode Register #1 (Table 10-3)
asm-mips/sibyte/sb1250_uart.h: * DUART Mode Register #2 (Table 10-4)
asm-mips/sibyte/sb1250_uart.h: * DUART Command Register (Table 10-5)
asm-mips/sibyte/sb1250_uart.h: * DUART Status Register (Table 10-6)
asm-mips/sibyte/sb1250_uart.h: * READ-ONLY
asm-mips/sibyte/sb1250_uart.h: * DUART Baud Rate Register (Table 10-7)
asm-mips/sibyte/sb1250_uart.h:#define V_DUART_BAUD_RATE(x)        (100000000/((x)*20)-1)
asm-mips/sibyte/sb1250_uart.h: * DUART Data Registers (Table 10-8 and 10-9)
asm-mips/sibyte/sb1250_uart.h: * DUART Input Port Register (Table 10-10)
asm-mips/sibyte/sb1250_uart.h: * DUART Input Port Change Status Register (Tables 10-11, 10-12, and 10-13)
asm-mips/sibyte/sb1250_uart.h: * DUART Output port control register (Table 10-14)
asm-mips/sibyte/sb1250_uart.h: * DUART Aux Control Register (Table 10-15)
asm-mips/sibyte/sb1250_uart.h: * DUART Interrupt Status Register (Table 10-16)
asm-mips/sibyte/sb1250_uart.h: * DUART Channel A Interrupt Status Register (Table 10-17)
asm-mips/sibyte/sb1250_uart.h: * DUART Channel B Interrupt Status Register (Table 10-18)
asm-mips/sibyte/sb1250_uart.h: * DUART Interrupt Mask Register (Table 10-19)
asm-mips/sibyte/sb1250_uart.h: * DUART Channel A Interrupt Mask Register (Table 10-20)
asm-mips/sibyte/sb1250_uart.h: * DUART Channel B Interrupt Mask Register (Table 10-21)
asm-mips/sibyte/sb1250_uart.h: * DUART Output Port Set Register (Table 10-22)
asm-mips/sibyte/sb1250_uart.h: * DUART Output Port Clear Register (Table 10-23)
asm-mips/sibyte/sb1250_uart.h: * DUART Output Port RTS Register (Table 10-24)
asm-mips/system.h: * Copyright (C) 1994 - 1999 by Ralf Baechle
asm-mips/system.h: * Copyright (C) 1994 - 1999 by Ralf Baechle
asm-mips/system.h:#endif /* Processor-dependent optimization */
asm-mips/stat.h: * struct stat of the 64-bit kernel.
asm-mips/time.h: * include/asm-mips/time.h
asm-mips/time.h: * RTC ops.  By default, they point to no-RTC functions.
asm-mips/time.h: *	rtc_get_time - mktime(year, mon, day, hour, min, sec) in seconds.
asm-mips/time.h: *	rtc_set_time - reverse the above translation and set time to RTC.
asm-mips/time.h: *	rtc_set_mmss - similar to rtc_set_time, but only min and sec need
asm-mips/time.h: *			to be set.  Used by RTC sync-up.
asm-mips/time.h: * mips_timer_ack may be NULL if the interrupt is self-recoverable.
asm-mips/time.h: * If mips_hpt_read is NULL, an R4k-compatible timer setup is attempted.
asm-mips/time.h: * high-level timer interrupt routines.
asm-mips/time.h: * the corresponding low-level timer interrupt routine.
asm-mips/time.h: * mips_hpt_frequency - must be set if you intend to use an R4k-compatible
asm-mips/checksum.h: * and adds in "sum" (32-bit)
asm-mips/checksum.h: * returns a 32-bit number suitable for feeding into itself
asm-mips/checksum.h: * it's best to have buff aligned on a 32-bit boundary
asm-mips/checksum.h:		*err_ptr = -EFAULT;
asm-mips/checksum.h:		return -1;
asm-mips/checksum.h: * computes the checksum of the TCP/UDP pseudo-header
asm-mips/checksum.h: * returns a 16-bit checksum, already complemented
asm-mips/checksum.h: * this routine is used for miscellaneous IP-like checksums, mainly
asm-mips/xxs1500.h: *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm-mips/tx4927/tx4927.h: * Copyright 2001-2002 MontaVista Software Inc.
asm-mips/tx4927/tx4927.h: followed by the device name from table 4.2.2 on page 4-3 and then followed
asm-mips/tx4927/tx4927.h: by the register name from table 4.2.3 on pages 4-4 to 4-8.  The manaul
asm-mips/tx4927/tx4927.h:/* TX4927 SDRAM controller (64-bit registers) */
asm-mips/tx4927/tx4927.h:/* TX4927 external bus controller (64-bit registers) */
asm-mips/tx4927/tx4927.h:/* TX4927 SDRRAM Error Check Correction (64-bit registers) */
asm-mips/tx4927/tx4927.h:/* TX4927 DMA Controller (64-bit registers) */
asm-mips/tx4927/tx4927.h:/* TX4927 PCI Controller (32-bit registers) */
asm-mips/tx4927/tx4927.h:/* TX4927 Configuration registers (64-bit registers) */
asm-mips/tx4927/tx4927.h:/* TX4927 Timer 0 (32-bit registers) */
asm-mips/tx4927/tx4927.h:/* TX4927 Timer 1 (32-bit registers) */
asm-mips/tx4927/tx4927.h:/* TX4927 Timer 2 (32-bit registers) */
asm-mips/tx4927/tx4927.h:/* TX4927 serial port 0 (32-bit registers) */
asm-mips/tx4927/tx4927.h:/* TX4927 serial port 1 (32-bit registers) */
asm-mips/tx4927/tx4927.h:/* TX4927 parallel port (32-bit registers) */
asm-mips/tx4927/tx4927.h:/* TX4927 Interrupt Controller (32-bit registers) */
asm-mips/tx4927/tx4927.h:/* TX4927 AC-link controller (32-bit registers) */
asm-mips/tx4927/tx4927.h:#define TX4927_IRQ_CP0_RAW_BEG   0    /* tx4927 cpu built-in cp0 */
asm-mips/tx4927/tx4927.h:#define TX4927_IRQ_PIC_RAW_BEG   0    /* tx4927 cpu build-in pic */
asm-mips/tx4927/tx4927_pci.h: * Copyright (C) 2000-2001 Toshiba Corporation
asm-mips/tx4927/tx4927_pci.h:#define TX4927_NR_IRQ_IRC       32      /* On-Chip IRC */
asm-mips/tx4927/tx4927_pci.h:#define TX4927_PCIC_IDSEL_AD_TO_SLOT(ad)        ((ad) - 11)
asm-mips/tx4927/toshiba_rbtx4927.h: * Copyright 2001-2002 MontaVista Software Inc.
asm-mips/tx4927/toshiba_rbtx4927.h:#define RBTX4927_RTL_8019_BASE (0x1c020280-TBTX4927_ISA_IO_OFFSET)
asm-mips/tx4927/tx4927_mips.h: * Copyright 2001-2002 MontaVista Software Inc.
asm-mips/termios.h:	int	sg_flags;	/* SGI special - int, not short */
asm-mips/termios.h:#define N_IRDA		11	/* Linux IrDa - http://irda.sourceforge.net/ */
asm-mips/termios.h:#define N_SMSBLOCK	12	/* SMS block mode - for talking to GSM data cards about SMS messages */
asm-mips/termios.h:	get_user(tmp, &(termio)->c_iflag); \
asm-mips/termios.h:	(termios)->c_iflag = (0xffff0000 & ((termios)->c_iflag)) | tmp; \
asm-mips/termios.h:	get_user(tmp, &(termio)->c_oflag); \
asm-mips/termios.h:	(termios)->c_oflag = (0xffff0000 & ((termios)->c_oflag)) | tmp; \
asm-mips/termios.h:	get_user(tmp, &(termio)->c_cflag); \
asm-mips/termios.h:	(termios)->c_cflag = (0xffff0000 & ((termios)->c_cflag)) | tmp; \
asm-mips/termios.h:	get_user(tmp, &(termio)->c_lflag); \
asm-mips/termios.h:	(termios)->c_lflag = (0xffff0000 & ((termios)->c_lflag)) | tmp; \
asm-mips/termios.h:	get_user((termios)->c_line, &(termio)->c_line); \
asm-mips/termios.h:	copy_from_user((termios)->c_cc, (termio)->c_cc, NCC); \
asm-mips/termios.h:	put_user((termios)->c_iflag, &(termio)->c_iflag); \
asm-mips/termios.h:	put_user((termios)->c_oflag, &(termio)->c_oflag); \
asm-mips/termios.h:	put_user((termios)->c_cflag, &(termio)->c_cflag); \
asm-mips/termios.h:	put_user((termios)->c_lflag, &(termio)->c_lflag); \
asm-mips/termios.h:	put_user((termios)->c_line, &(termio)->c_line); \
asm-mips/termios.h:	copy_to_user((termio)->c_cc, (termios)->c_cc, NCC); \
asm-mips/titan_dep.h: * Copyright 2003 PMC-Sierra
asm-mips/titan_dep.h: * Author: Manish Lachwani (lachwani@pmc-sierra.com)
asm-mips/titan_dep.h: * Board specific definititions for the PMC-Sierra Yosemite
asm-mips/au1000_gpio.h:#define NOT_AVAIL		(-1)
asm-mips/au1000_gpio.h:#define MINOR_TO_GPIOPIN(minor)		((minor < AU1X00_MAX_PRIMARY_GPIO) ? minor : (minor - AU1X00_MAX_PRIMARY_GPIO))
asm-mips/au1000_gpio.h: * GPIO0-GPIO31, minor=0-31.
asm-mips/au1000_gpio.h: * GPIO200-GPIO215, minor=32-47.
asm-mips/au1000_gpio.h:	int data;	// Pin output when itized (0/1), or at the term. 0/1/-1 (tristate).
asm-mips/user.h: * linux we use the `trad-core' bfd, NOT the irix-core).  The file
asm-mips/user.h: *  data: The data segment follows next.  We use current->end_text to
asm-mips/user.h: *	current->brk to pick up all of the user variables, plus any memory
asm-mips/user.h: *	page is demand-zero or if a page is totally unused, we just cover
asm-mips/user.h: *	current->start_stack, so we round each of these in order to be able
asm-mips/paccess.h: * by sending a DBE error like accessing possibly non-existant memory or
asm-mips/paccess.h:	".word\t1b-4,3b\n\t" \
asm-mips/paccess.h:	:"o" (__mp(__gu_addr)), "i" (-EFAULT)); })
asm-mips/paccess.h:	".word\t1b-4,3b\n\t" \
asm-mips/paccess.h:	:"r" (__pu_val), "o" (__mp(__pu_addr)), "i" (-EFAULT)); })
asm-mips/vr4181/irq.h:   IP0 - Software interrupt
asm-mips/vr4181/irq.h:   IP1 - Software interrupt
asm-mips/vr4181/irq.h:   IP2 - All but battery, high speed modem, and real time clock
asm-mips/vr4181/irq.h:   IP3 - RTC Long1 (system timer)
asm-mips/vr4181/irq.h:   IP4 - RTC Long2
asm-mips/vr4181/irq.h:   IP5 - High Speed Modem (unused on VR4181)
asm-mips/vr4181/irq.h:   IP6 - Unused
asm-mips/vr4181/irq.h:   IP7 - Timer interrupt from CPO_COMPARE
asm-mips/vr4181/irq.h:   IP2 - same as VR4181_IRQ_INT1
asm-mips/vr4181/irq.h:   IP8 - This is a cascade to GPIO IRQ's. Do not use.
asm-mips/vr4181/irq.h:   IP16 - same as VR4181_IRQ_INT2
asm-mips/vr4181/irq.h:   IP18 - CompactFlash
asm-mips/vr4181/vr4181.h:#define VR4181_MISCREG0		__preg16(KSEG1 + 0x0B000330)	/* Misc. R/W Battery Backed Registers for Non-Volatile Storage (R/W) */
asm-mips/vr4181/vr4181.h:#define VR4181_MISCREG1		__preg16(KSEG1 + 0x0B000332)	/* Misc. R/W Battery Backed Registers for Non-Volatile Storage (R/W) */
asm-mips/vr4181/vr4181.h:#define VR4181_MISCREG2		__preg16(KSEG1 + 0x0B000334)	/* Misc. R/W Battery Backed Registers for Non-Volatile Storage (R/W) */
asm-mips/vr4181/vr4181.h:#define VR4181_MISCREG3		__preg16(KSEG1 + 0x0B000336)	/* Misc. R/W Battery Backed Registers for Non-Volatile Storage (R/W) */
asm-mips/vr4181/vr4181.h:#define VR4181_MISCREG4		__preg16(KSEG1 + 0x0B000338)	/* Misc. R/W Battery Backed Registers for Non-Volatile Storage (R/W) */
asm-mips/vr4181/vr4181.h:#define VR4181_MISCREG5		__preg16(KSEG1 + 0x0B00033A)	/* Misc. R/W Battery Backed Registers for Non-Volatile Storage (R/W) */
asm-mips/vr4181/vr4181.h:#define VR4181_MISCREG6		__preg16(KSEG1 + 0x0B00033C)	/* Misc. R/W Battery Backed Registers for Non-Volatile Storage (R/W) */
asm-mips/vr4181/vr4181.h:#define VR4181_MISCREG7		__preg16(KSEG1 + 0x0B00033D)	/* Misc. R/W Battery Backed Registers for Non-Volatile Storage (R/W) */
asm-mips/vr4181/vr4181.h:#define VR4181_MISCREG8		__preg16(KSEG1 + 0x0B000340)	/* Misc. R/W Battery Backed Registers for Non-Volatile Storage (R/W) */
asm-mips/vr4181/vr4181.h:#define VR4181_MISCREG9		__preg16(KSEG1 + 0x0B000342)	/* Misc. R/W Battery Backed Registers for Non-Volatile Storage (R/W) */
asm-mips/vr4181/vr4181.h:#define VR4181_MISCREG10	__preg16(KSEG1 + 0x0B000344)	/* Misc. R/W Battery Backed Registers for Non-Volatile Storage (R/W) */
asm-mips/vr4181/vr4181.h:#define VR4181_MISCREG11	__preg16(KSEG1 + 0x0B000346)	/* Misc. R/W Battery Backed Registers for Non-Volatile Storage (R/W) */
asm-mips/vr4181/vr4181.h:#define VR4181_MISCREG12	__preg16(KSEG1 + 0x0B000348)	/* Misc. R/W Battery Backed Registers for Non-Volatile Storage (R/W) */
asm-mips/vr4181/vr4181.h:#define VR4181_MISCREG13	__preg16(KSEG1 + 0x0B00034A)	/* Misc. R/W Battery Backed Registers for Non-Volatile Storage (R/W) */
asm-mips/vr4181/vr4181.h:#define VR4181_MISCREG14	__preg16(KSEG1 + 0x0B00034C)	/* Misc. R/W Battery Backed Registers for Non-Volatile Storage (R/W) */
asm-mips/vr4181/vr4181.h:#define VR4181_MISCREG15	__preg16(KSEG1 + 0x0B00034E)	/* Misc. R/W Battery Backed Registers for Non-Volatile Storage (R/W) */
asm-mips/vr4181/vr4181.h:#define VR4181_SIUCSEL_2	__preg8(KSEG1 + 0x0C00000A)	/* IrDA Echo-back Control (R/W) */
asm-mips/vr41xx/e55.h: *	include/asm-mips/vr41xx/e55.h
asm-mips/vr41xx/e55.h: *	Include file for CASIO CASSIOPEIA E-10/15/55/65.
asm-mips/vr41xx/eagle.h: *	include/asm-mips/vr41xx/eagle.h
asm-mips/vr41xx/eagle.h: * Copyright 2001-2003 MontaVista Software Inc.
asm-mips/vr41xx/eagle.h: * General-Purpose I/O Pin Number
asm-mips/vr41xx/capcella.h: *	include/asm-mips/vr41xx/capcella.h
asm-mips/vr41xx/capcella.h: * General-Purpose I/O Pin Number
asm-mips/vr41xx/workpad.h: *	include/asm-mips/vr41xx/workpad.h
asm-mips/vr41xx/mpc30x.h: *	include/asm-mips/vr41xx/mpc30x.h
asm-mips/vr41xx/mpc30x.h: *	Include file for Victor MP-C303/304.
asm-mips/vr41xx/mpc30x.h: * General-Purpose I/O Pin Number
asm-mips/vr41xx/vr41xx.h: * include/asm-mips/vr41xx/vr41xx.h
asm-mips/vr41xx/vr41xx.h:/* VR4122 0x00000c70-0x00000c72 */
asm-mips/vr41xx/vr41xx.h:/* VR4181A 0x00000c73-0x00000c7f */
asm-mips/vr41xx/vr41xx.h:/* VR4131 0x00000c80-0x00000c83 */
asm-mips/vr41xx/vr41xx.h:/* VR4133 0x00000c84- */
asm-mips/vr41xx/vr41xx.h:#define GIU_IRQ(x)		(GIU_IRQ_BASE + (x))	/* IRQ 40-71 */
asm-mips/vr41xx/vr41xx.h:#define GIU_IRQ_TO_PIN(x)	((x) - GIU_IRQ_BASE)	/* Pin 0-31 */
asm-mips/vr41xx/vr41xx.h: * General-Purpose I/O Unit
asm-mips/vr41xx/vrc4171.h: *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
asm-mips/vr41xx/vrc4173.h: *	include/asm-mips/vr41xx/vrc4173.h
asm-mips/vr41xx/vrc4173.h: * Copyright 2001-2003 Montavista Software Inc.
asm-mips/vr41xx/vrc4173.h: * General-Purpose I/O Unit
asm-mips/vr41xx/tb0226.h: *	include/asm-mips/vr41xx/tb0226.h
asm-mips/vr41xx/tb0226.h: * General-Purpose I/O Pin Number
asm-mips/vr41xx/tb0229.h: *	include/asm-mips/vr41xx/tb0229.h
asm-mips/vr41xx/tb0229.h: * General-Purpose I/O Pin Number
asm-mips/statfs.h:	long		f_frsize;	/* Fragment size - unsupported */
asm-mips/serial.h:#include <asm/mips-boards/atlas.h>
asm-mips/serial.h:#include <asm/mips-boards/atlasint.h>
asm-mips/serial.h:#include <asm/mips-boards/sead.h>
asm-mips/serial.h:#include <asm/mips-boards/seadint.h>
asm-mips/serial.h:#include <asm/galileo-boards/ev96100int.h>
asm-mips/serial.h: * Also look in ip27-pci.c:pci_fixuop_ioc3() for some comments on working
asm-mips/pgtable.h:	test_bit(PG_dcache_dirty, &(page)->flags)
asm-mips/pgtable.h:	set_bit(PG_dcache_dirty, &(page)->flags)
asm-mips/pgtable.h:	clear_bit(PG_dcache_dirty, &(page)->flags)
asm-mips/pgtable.h: * - add_wired_entry() add a fixed TLB entry, and move wired register
asm-mips/pgtable.h: * - add_temporary_entry() add a temporary TLB entry. We use TLB entries
asm-mips/pgtable.h:/* Basically we have the same two-level (which is the logical three level
asm-mips/pgtable.h:/* PMD_SHIFT determines the size of the area a second-level page table can map */
asm-mips/pgtable.h:#define PMD_MASK	(~(PMD_SIZE-1))
asm-mips/pgtable.h:/* PGDIR_SHIFT determines what a third-level page table entry can map */
asm-mips/pgtable.h:#define PGDIR_MASK	(~(PGDIR_SIZE-1))
asm-mips/pgtable.h:# define VMALLOC_END	(PKMAP_BASE-2*PAGE_SIZE)
asm-mips/pgtable.h:# define VMALLOC_END	(FIXADDR_START-2*PAGE_SIZE)
asm-mips/pgtable.h:#include <asm/pgtable-bits.h>
asm-mips/pgtable.h:#include <asm/pgtable-64.h>
asm-mips/pgtable.h:#include <asm/pgtable-32.h>
asm-mips/pgtable.h: * The "pgd_xxx()" functions here are trivial for a folded two-level
asm-mips/pgtable.h:	(((address) >> PMD_SHIFT) & (PTRS_PER_PMD-1))
asm-mips/pgtable.h:/* to find an entry in a kernel page-table-directory */
asm-mips/pgtable.h:/* to find an entry in a page-table-directory */
asm-mips/pgtable.h:	return mm->pgd + pgd_index(address);
asm-mips/pgtable.h:/* Find an entry in the second-level page table.. */
asm-mips/pgtable.h:/* Find an entry in the third-level page table.. */
asm-mips/pgtable.h:	       ((address >> PAGE_SHIFT) & (PTRS_PER_PTE - 1));
asm-mips/pgtable.h:#include <asm-generic/pgtable.h>
asm-mips/unaligned.h: * get_unaligned - get value from possibly mis-aligned location
asm-mips/unaligned.h: * e.g. retrieving a u16 value from a location not u16-aligned.
asm-mips/unaligned.h: * put_unaligned - put value to a possibly mis-aligned location
asm-mips/unaligned.h: * e.g. writing a u16 value to a location not u16-aligned.
asm-mips/unaligned.h:	return ptr->x;
asm-mips/unaligned.h:	return ptr->x;
asm-mips/unaligned.h:	return ptr->x;
asm-mips/unaligned.h:	ptr->x = r5;
asm-mips/unaligned.h:	ptr->x = r5;
asm-mips/unaligned.h:	ptr->x = r5;
asm-mips/cacheflush.h: *  - flush_cache_all() flushes entire cache
asm-mips/cacheflush.h: *  - flush_cache_mm(mm) flushes the specified mm context's cache lines
asm-mips/cacheflush.h: *  - flush_cache_page(mm, vmaddr) flushes a single page
asm-mips/cacheflush.h: *  - flush_cache_range(mm, start, end) flushes a range of pages
asm-mips/cacheflush.h: *  - flush_page_to_ram(page) write back kernel page to ram
asm-mips/cacheflush.h: *  - flush_icache_range(start, end) flush a range of instructions
asm-mips/cacheflush.h: *  - flush_cache_sigtramp() flush signal trampoline
asm-mips/cacheflush.h: *  - flush_icache_all() flush the entire instruction cache
asm-mips/cacheflush.h: *  - flush_data_cache_page() flushes a page from the data cache
asm-mips/ddb5074.h: *  include/asm-mips/ddb5074.h -- NEC DDB Vrc-5074 definitions
asm-mips/param.h:    * Ye olde division-by-multiplication trick.
asm-mips/param.h:#  define QUOTIENT ((1UL << (32 - LOG_2_HZ)) * 100)
asm-mips/param.h:   unless you know what you're doing - changing breaks binary compatibility.  */
asm-mips/param.h:#define NOGROUP		(-1)
asm-mips/ds1286.h: * mc146818rtc.h - register definitions for the Real-Time-Clock / CMOS RAM
asm-mips/ds1286.h: * Copyright Torsten Duwe <duwe@informatik.uni-erlangen.de> 1993
asm-mips/mipsregs.h:#define FPU_CSR_RD      0x3     /* towards -Infinity */
asm-mips/mipsregs.h: * physical address space running the 32-bit kernel.  That's none atm :-)
asm-mips/bootinfo.h:#define MACH_GROUP_TITAN       22 /* PMC-Sierra Titan 			    */
asm-mips/bootinfo.h:#define MACH_ACER_PICA_61	0	/* Acer PICA-61 (PICA1)		*/
asm-mips/bootinfo.h:#define MACH_OLIVETTI_M700      2	/* Olivetti M700-10 (-15 ??)    */
asm-mips/bootinfo.h:#define MACH_NEC_DDB5074	0	/* NEC DDB Vrc-5074 */
asm-mips/bootinfo.h:#define MACH_NEC_DDB5476	1	/* NEC DDB Vrc-5476 */
asm-mips/bootinfo.h:#define MACH_NEC_DDB5477	2	/* NEC DDB Vrc-5477 */
asm-mips/bootinfo.h:#define MACH_BAGET201		0	/* BT23-201 */
asm-mips/bootinfo.h:#define MACH_BAGET202		1	/* BT23-202 */
asm-mips/bootinfo.h:#define MACH_TOSHIBA_JMR3927	3	/* JMR-TX3927 CPU/IO board */
asm-mips/bootinfo.h:#define MACH_PB1000		0	/* Au1000-based eval board */
asm-mips/bootinfo.h:#define MACH_PB1100		1	/* Au1100-based eval board */
asm-mips/bootinfo.h:#define MACH_PB1500		2	/* Au1500-based eval board */
asm-mips/bootinfo.h:#define MACH_DB1000		3       /* Au1000-based eval board */
asm-mips/bootinfo.h:#define MACH_DB1100		4       /* Au1100-based eval board */
asm-mips/bootinfo.h:#define MACH_DB1500		5       /* Au1500-based eval board */
asm-mips/bootinfo.h:#define MACH_XXS1500		6       /* Au1500-based eval board */
asm-mips/bootinfo.h:#define MACH_MTX1		7	/* 4G MTX-1 Au1500-based board */
asm-mips/bootinfo.h:#define MACH_PB1550     	9       /* Au1550-based eval board */
asm-mips/bootinfo.h:#define MACH_PB1200     	10      /* Au1200-based eval board */
asm-mips/bootinfo.h:#define MACH_DB1550     	11      /* Au1550-based eval board */
asm-mips/bootinfo.h:#define MACH_DB1200     	12      /* Au1200-based eval board */
asm-mips/bootinfo.h:#define MACH_VICTOR_MPC30X	3	/* Victor MP-C303/304 */
asm-mips/bootinfo.h:#define MACH_CASIO_E55		5	/* CASIO CASSIOPEIA E-10/15/55/65 */
asm-mips/bootinfo.h:#define	MACH_TITAN_YOSEMITE	1 	/* PMC-Sierra Yosemite */
asm-mips/mips-boards/msc01_pci.h:#define MSC01_PCI_HEAD11_OFS		0x2058  /* SubSystem ID, -VendorID */
asm-mips/mips-boards/msc01_pci.h: * FIXME - are these macros specific to Malta and co or to the MSC?  If the
asm-mips/mips-boards/atlasint.h: *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm-mips/mips-boards/atlasint.h: * Atlas registers are memory mapped on 64-bit aligned boundaries and
asm-mips/mips-boards/malta.h: *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm-mips/mips-boards/malta.h: * Defines of the Malta board specific address-MAP, registers, etc.
asm-mips/mips-boards/malta.h: * Malta RTC-device indirect register access.
asm-mips/mips-boards/saa9730_uart.h: *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm-mips/mips-boards/generic.h: * 59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm-mips/mips-boards/generic.h: * Defines of the MIPS boards specific address-MAP, registers, etc.
asm-mips/mips-boards/generic.h:#include <asm/mips-boards/bonito64.h>
asm-mips/mips-boards/seadint.h: *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm-mips/mips-boards/prom.h: *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm-mips/mips-boards/sead.h: *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm-mips/mips-boards/sead.h: * Defines of the SEAD board specific address-MAP, registers, etc.
asm-mips/mips-boards/maltaint.h: *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm-mips/mips-boards/bonito64.h:#define BONITO_BOOT_TOP 		(BONITO_BOOT_BASE+BONITO_BOOT_SIZE-1)
asm-mips/mips-boards/bonito64.h:#define BONITO_FLASH_TOP		(BONITO_FLASH_BASE+BONITO_FLASH_SIZE-1)
asm-mips/mips-boards/bonito64.h:#define BONITO_SOCKET_TOP		(BONITO_SOCKET_BASE+BONITO_SOCKET_SIZE-1)
asm-mips/mips-boards/bonito64.h:#define BONITO_REG_TOP			(BONITO_REG_BASE+BONITO_REG_SIZE-1)
asm-mips/mips-boards/bonito64.h:#define BONITO_DEV_TOP			(BONITO_DEV_BASE+BONITO_DEV_SIZE-1)
asm-mips/mips-boards/bonito64.h:#define BONITO_PCILO_TOP		(BONITO_PCILO_BASE+BONITO_PCILO_SIZE-1)
asm-mips/mips-boards/bonito64.h:#define BONITO_PCIHI_TOP		(BONITO_PCIHI_BASE+BONITO_PCIHI_SIZE-1)
asm-mips/mips-boards/bonito64.h:#define BONITO_PCIIO_TOP		(BONITO_PCIIO_BASE+BONITO_PCIIO_SIZE-1)
asm-mips/mips-boards/bonito64.h:#define BONITO_PCICFG_TOP		(BONITO_PCICFG_BASE+BONITO_PCICFG_SIZE-1)
asm-mips/mips-boards/bonito64.h:/* Added by RPF 11-9-00 */
asm-mips/mips-boards/bonito64.h:/* --- */
asm-mips/mips-boards/bonito64.h:/* GPIO Regs - r/w */
asm-mips/mips-boards/bonito64.h:/* ICU Configuration Regs - r/w */
asm-mips/mips-boards/bonito64.h:/* ICU Enable Regs - IntEn & IntISR are r/o. */
asm-mips/mips-boards/bonito64.h:/* DRAM - sdCfg */
asm-mips/mips-boards/bonito64.h:/* Changed by RPF 11-9-00 */
asm-mips/mips-boards/bonito64.h:/* --- */
asm-mips/mips-boards/bonito64.h:/* Added by RPF 11-9-00 */
asm-mips/mips-boards/bonito64.h:/* --- */
asm-mips/mips-boards/bonito64.h:/* PCI Cache - pciCacheCtrl */
asm-mips/mips-boards/bonito64.h:/* Added by RPF 11-9-00 */
asm-mips/mips-boards/bonito64.h:/* --- */
asm-mips/mips-boards/bonito64.h:#define BONITO_PCIMAP_WINOFFSET(ADDR)	((ADDR) & (BONITO_PCIMAP_WINSIZE - 1))
asm-mips/mips-boards/bonito64.h:#define BONITO_PCIMEMBASECFGSIZE(WIN,SIZE)	(((~((SIZE)-1))>>(BONITO_PCIMEMBASECFG_ASHIFT-BONITO_PCIMEMBASECFG_MEMBASE##WIN##_MASK_SHIFT)) & BONITO_PCIMEMBASECFG_MEMBASE##WIN##_MASK)
asm-mips/mips-boards/bonito64.h:#define BONITO_PCIMEMBASECFGBASE(WIN,BASE)	(((BASE)>>(BONITO_PCIMEMBASECFG_ASHIFT-BONITO_PCIMEMBASECFG_MEMBASE##WIN##_TRANS_SHIFT)) & BONITO_PCIMEMBASECFG_MEMBASE##WIN##_TRANS)
asm-mips/mips-boards/bonito64.h:#define BONITO_PCIMEMBASECFG_SIZE(WIN,CFG)  (((((~(CFG)) & BONITO_PCIMEMBASECFG_MEMBASE##WIN##_MASK)) << (BONITO_PCIMEMBASECFG_ASHIFT - BONITO_PCIMEMBASECFG_MEMBASE##WIN##_MASK_SHIFT)) | BONITO_PCIMEMBASECFG_AMASK)
asm-mips/mips-boards/atlas.h: *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm-mips/mips-boards/atlas.h: * Defines of the Atlas board specific address-MAP, registers, etc.
asm-mips/mips-boards/atlas.h: * Atlas RTC-device indirect register access.
asm-mips/mips-boards/piix4.h: *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm-mips/csb250.h: *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm-mips/gdb-stub.h: * Derived from the stack layout described in asm-mips/stackframe.h
asm-mips/gdb-stub.h:#define GDB_FR_SIZE		((((GDB_FR_CP0_PRID) + 4) + (PTRSIZE-1)) & ~(PTRSIZE-1))
asm-mips/gdb-stub.h: * This is the same as above, but for the high-level
asm-mips/sgialib.h:/* A 32-bit ARC PROM pass arguments and environment as 32-bit pointer.
asm-mips/sgialib.h:/* Simple char-by-char console I/O. */
asm-mips/sgialib.h:/* Running stand-along programs. */
asm-mips/jazzdma.h: * Helpfile for jazzdma.c -- Mips Jazz R4030 DMA controller support
asm-mips/jazzdma.h:#define VDMA_OFFSET(a)          ((unsigned int)(a) & (VDMA_PAGESIZE-1))
asm-mips/sgiarcs.h:#define ROMVECTOR ((struct linux_romvec *) (long)(PROMBLOCK)->romvec)
asm-mips/sgiarcs.h:#define SGIPROM_ROFILE    0x01  /* read-only file */
asm-mips/sgiarcs.h: * Macros for calling a 32-bit ARC implementation from 64-bit code
asm-mips/sgiarcs.h:	long __vec = (long) romvec->dest;				\
asm-mips/sgiarcs.h:	long __vec = (long) romvec->dest;				\
asm-mips/sgiarcs.h:	long __vec = (long) romvec->dest;				\
asm-mips/sgiarcs.h:	long __vec = (long) romvec->dest;				\
asm-mips/sgiarcs.h:	long __vec = (long) romvec->dest;				\
asm-mips/sgiarcs.h:	long __vec = (long) romvec->dest;				\
asm-mips/sgiarcs.h:	long (*__vec)(void) = (void *) romvec->dest;			\
asm-mips/sgiarcs.h:	long (*__vec)(long) = (void *) romvec->dest;			\
asm-mips/sgiarcs.h:	long (*__vec)(long, long) = (void *) romvec->dest;		\
asm-mips/sgiarcs.h:	long (*__vec)(long, long, long)	= (void *) romvec->dest;	\
asm-mips/sgiarcs.h:	long (*__vec)(long, long, long, long) = (void *) romvec->dest;	\
asm-mips/sgiarcs.h:	__vec = (void *) romvec->dest;					\
asm-mips/sgiarcs.h:#endif /* both kernel and ARC either 32-bit or 64-bit */
asm-mips/siginfo.h:#define SI_PAD_SIZE	((SI_MAX_SIZE/sizeof(int)) - 3)
asm-mips/siginfo.h:#define SI_PAD_SIZE	((SI_MAX_SIZE/sizeof(int)) - 4)
asm-mips/siginfo.h:	int __pad0[SI_MAX_SIZE / sizeof(int) - SI_PAD_SIZE - 3];
asm-mips/siginfo.h:#define SI_QUEUE	-1	/* sent by sigqueue */
asm-mips/siginfo.h:#define SI_ASYNCIO	-2	/* sent by AIO completion */
asm-mips/siginfo.h:#define SI_TIMER __SI_CODE(__SI_TIMER,-3) /* sent by timer expiration */
asm-mips/siginfo.h:#define SI_MESGQ	-4	/* sent by real time mesq state change */
asm-mips/siginfo.h:#define SI_SIGIO	-5	/* sent by queued SIGIO */
asm-mips/siginfo.h:#define SI_TKILL	-6	/* sent by tkill system call */
asm-mips/siginfo.h:#define SI_FROMUSER(siptr)	((siptr)->si_code <= 0)
asm-mips/siginfo.h:#define SI_FROMKERNEL(siptr)	((siptr)->si_code > 0)
asm-mips/siginfo.h:#define BUS_ADRERR	(__SI_FAULT|2)	/* non-existant physical address */
asm-mips/siginfo.h:#define SIGEV_PAD_SIZE	((SIGEV_MAX_SIZE-SIGEV_HEAD_SIZE) / sizeof(int))
asm-mips/siginfo.h:	if (from->si_code < 0)
asm-mips/siginfo.h:		memcpy(to, from, 3*sizeof(int) + sizeof(from->_sifields._sigchld));
asm-mips/floppy.h: * Copyright (C) 1995 - 2000 Ralf Baechle
asm-mips/floppy.h:#define fd_inb(port)		fd_ops->fd_inb(port)
asm-mips/floppy.h:#define fd_outb(value,port)	fd_ops->fd_outb(value,port)
asm-mips/floppy.h:#define fd_enable_dma()		fd_ops->fd_enable_dma(FLOPPY_DMA)
asm-mips/floppy.h:#define fd_disable_dma()	fd_ops->fd_disable_dma(FLOPPY_DMA)
asm-mips/floppy.h:#define fd_request_dma()	fd_ops->fd_request_dma(FLOPPY_DMA)
asm-mips/floppy.h:#define fd_free_dma()		fd_ops->fd_free_dma(FLOPPY_DMA)
asm-mips/floppy.h:#define fd_clear_dma_ff()	fd_ops->fd_clear_dma_ff(FLOPPY_DMA)
asm-mips/floppy.h:#define fd_set_dma_mode(mode)	fd_ops->fd_set_dma_mode(FLOPPY_DMA, mode)
asm-mips/floppy.h:#define fd_set_dma_addr(addr)	fd_ops->fd_set_dma_addr(FLOPPY_DMA, \
asm-mips/floppy.h:#define fd_set_dma_count(count)	fd_ops->fd_set_dma_count(FLOPPY_DMA,count)
asm-mips/floppy.h:#define fd_get_dma_residue()	fd_ops->fd_get_dma_residue(FLOPPY_DMA)
asm-mips/floppy.h:#define fd_enable_irq()		fd_ops->fd_enable_irq(FLOPPY_IRQ)
asm-mips/floppy.h:#define fd_disable_irq()	fd_ops->fd_disable_irq(FLOPPY_IRQ)
asm-mips/floppy.h:#define fd_dma_mem_alloc(size)	fd_ops->fd_dma_mem_alloc(size)
asm-mips/floppy.h:#define fd_dma_mem_free(mem,size) fd_ops->fd_dma_mem_free(mem,size)
asm-mips/floppy.h:#define fd_drive_type(n)	fd_ops->fd_drive_type(n)
asm-mips/floppy.h:#define FDC1			fd_ops->fd_getfdaddr1();
asm-mips/floppy.h:#define CROSS_64KB(a,s) ((unsigned long)(a)/K_64 != ((unsigned long)(a) + (s) - 1) / K_64)
asm-mips/irq_cpu.h: *	include/asm-mips/irq_cpu.h
asm-mips/sockios.h: * Socket-level I/O control calls.
asm-mips/sockios.h:/* Socket-level I/O control calls. */
asm-mips/sockios.h:#define SIOCGSTAMP	0x8906			/* Get stamp - linux-specific */
asm-mips/keyboard.h: * Copyright (C) 1994 - 1999 Ralf Baechle
asm-mips/keyboard.h:#define kbd_request_region() kbd_ops->kbd_request_region()
asm-mips/keyboard.h:#define kbd_request_irq(handler) kbd_ops->kbd_request_irq(handler)
asm-mips/keyboard.h:#define aux_request_irq(hand, dev_id) kbd_ops->aux_request_irq(hand)
asm-mips/keyboard.h:#define aux_free_irq(dev_id) kbd_ops->aux_free_irq()
asm-mips/keyboard.h:#define kbd_read_input() kbd_ops->kbd_read_input()
asm-mips/keyboard.h:#define kbd_write_output(val) kbd_ops->kbd_write_output(val)
asm-mips/keyboard.h:#define kbd_write_command(val) kbd_ops->kbd_write_command(val)
asm-mips/keyboard.h:#define kbd_read_status() kbd_ops->kbd_read_status()
asm-mips/ioctl.h:#define _IOC_NRMASK	((1 << _IOC_NRBITS)-1)
asm-mips/ioctl.h:#define _IOC_TYPEMASK	((1 << _IOC_TYPEBITS)-1)
asm-mips/ioctl.h:#define _IOC_SIZEMASK	((1 << _IOC_SIZEBITS)-1)
asm-mips/ioctl.h:#define _IOC_DIRMASK	((1 << _IOC_DIRBITS)-1)
asm-mips/au1100_mmc.h: * From "AMD Alchemy Solutions Au1100 Processor Data Book - Preliminary"
asm-mips/au1100_mmc.h:/* support routines required on a platform-specific basis */
asm-mips/string.h:		"lbu\t$1,-1(%0)\n\t"
asm-mips/break.h: * non-Linux/MIPS object files or make use of them in the future.
asm-mips/break.h:#define BRK_BD_TAKEN	3	/* For bd slot emulation - not implemented */
asm-mips/break.h:#define BRK_BD_NOTTAKEN	4	/* For bd slot emulation - not implemented */
asm-mips/break.h:#define BRK_NORLD	10	/* No rld found - not used by Linux/MIPS */
asm-mips/ioctls.h:						/* 127-124 compat */
asm-mips/ioctls.h:#define TIOCGPTN	_IOR('T',0x30, unsigned int) /* Get Pty Number (of pty-mux device) */
asm-mips/msgbuf.h: * - extension of time_t to 64-bit on 32-bitsystem to solve the y2038 problem
asm-mips/msgbuf.h: * - 2 miscellaneous unsigned long values
asm-mips/pci_channel.h: * Each pci channel is a top-level PCI bus seem by CPU.  A machine  with
asm-mips/bcache.h:/* Some R4000 / R4400 / R4600 / R5000 machines may have a non-dma-coherent,
asm-mips/bcache.h:	bcops->bc_enable();
asm-mips/bcache.h:	bcops->bc_disable();
asm-mips/bcache.h:	bcops->bc_wback_inv(page, size);
asm-mips/bcache.h:	bcops->bc_inv(page, size);
asm-mips/regdef.h: * include/asm-mips/regdefs.h
asm-mips/regdef.h:#define AT      $1      /* assembler temp  - uppercase because of ".set at" */
asm-mips/socket.h:#define SO_OOBINLINE 0x0100	/* Receive out-of-band data in-band.  */
asm-mips/socket.h:#define SO_SNDLOWAT	0x1003	/* send low-water mark */
asm-mips/socket.h:#define SO_RCVLOWAT	0x1004	/* receive low-water mark */
asm-mips/socket.h:/* linux-specific, might as well be the same as on i386 */
asm-mips/socket.h:/* Security levels - as per NRL IPv6 - don't actually do anything */
asm-mips/socket.h:/* Nast libc5 fixup - bletch */
asm-mips/socket.h:#define SOCK_RDM	4		/* reliably-delivered message	*/
asm-mips64/sn/sn0/hub.h: * Copyright (C) 1992 - 1997, 1999 Silicon Graphics, Inc.
asm-mips64/sn/sn0/arch.h: * Copyright (C) 1995 - 1997, 1999 Silcon Graphics, Inc.
asm-mips64/sn/sn0/ip27.h: * Copyright (C) 1992 - 1997, 1999 Silicon Graphics, Inc.
asm-mips64/sn/sn0/ip27.h:#define SCACHE_LINEMASK	(SCACHE_LINESIZE - 1)
asm-mips64/sn/sn0/addrs.h: * Copyright (C) 1992 - 1997, 1999 Silicon Graphics, Inc.
asm-mips64/sn/sn0/addrs.h: * should this change, the base registers may very well become processor-
asm-mips64/sn/sn0/addrs.h: *	 files.  Please bracket any language-dependent definitions
asm-mips64/sn/sn0/addrs.h: * whether the system is running in N-mode (more nodes with less memory)
asm-mips64/sn/sn0/addrs.h: * or M-mode (fewer nodes with more memory).  We expect that it will
asm-mips64/sn/sn0/addrs.h:#else /* !defined(CONFIG_SGI_SN0_N_MODE), assume that M-mode is desired */
asm-mips64/sn/sn0/addrs.h:#define	BWIN_SIZEMASK		(BWIN_SIZE - 1)
asm-mips64/sn/sn0/addrs.h: * The following define the major position-independent aliases used
asm-mips64/sn/sn0/addrs.h: *	CALIAS -- Varies in size, points to the first n bytes of memory
asm-mips64/sn/sn0/addrs.h:#define CACHE_ERR_SP_PTR	(0x1000 - 32)	/* why -32? TBD */
asm-mips64/sn/sn0/addrs.h:#define CACHE_ERR_IBASE_PTR	(0x1000 - 40)
asm-mips64/sn/sn0/addrs.h:#define CACHE_ERR_SP		(CACHE_ERR_SP_PTR - 16)
asm-mips64/sn/sn0/addrs.h:#define CACHE_ERR_AREA_SIZE	(ARCS_SPB_OFFSET - CACHE_ERR_EFRAME)
asm-mips64/sn/sn0/addrs.h: * install. The COMPONENT->Key field is used for this purpose.
asm-mips64/sn/sn0/addrs.h: * COMPONENT->Key field to the respective base address.
asm-mips64/sn/sn0/addrs.h: *  +----------------------------------------------------+
asm-mips64/sn/sn0/addrs.h: *  +----------------------------------------------------+
asm-mips64/sn/sn0/addrs.h:#define PUT_INSTALL_STATUS(c,s)		c->Revision = s
asm-mips64/sn/sn0/addrs.h:#define GET_INSTALL_STATUS(c)		c->Revision
asm-mips64/sn/sn0/addrs.h:#define OLD_ERR_STS_WAR_OFFSET	((MD_MEM_BANKS * MD_BANK_SIZE) - 0x100)
asm-mips64/sn/sn0/sn0_fru.h: * Copyright (C) 1992 - 1997, 1999 Silcon Graphics, Inc.
asm-mips64/sn/sn0/hubio.h: * Copyright (C) 1992 - 1997, 1999 Silicon Graphics, Inc.
asm-mips64/sn/sn0/hubio.h:#define IIO_BTE_OFF_1	IIO_IBLS_1 - IIO_IBLS_0 /* Offset from base to BTE 1 */
asm-mips64/sn/sn0/hubio.h:#define BTEOFF_SRC		(IIO_BTE_SRC_0 - IIO_BTE_STAT_0)
asm-mips64/sn/sn0/hubio.h:#define BTEOFF_DEST		(IIO_BTE_DEST_0 - IIO_BTE_STAT_0)
asm-mips64/sn/sn0/hubio.h:#define BTEOFF_CTRL		(IIO_BTE_CTRL_0 - IIO_BTE_STAT_0)
asm-mips64/sn/sn0/hubio.h:#define BTEOFF_NOTIFY		(IIO_BTE_NOTIFY_0 - IIO_BTE_STAT_0)
asm-mips64/sn/sn0/hubio.h:#define BTEOFF_INT		(IIO_BTE_INT_0 - IIO_BTE_STAT_0)
asm-mips64/sn/sn0/hubio.h:#define IIO_IGFX_W_NUM_MASK	((1<<IIO_IGFX_W_NUM_BITS)-1)
asm-mips64/sn/sn0/hubio.h:#define IIO_IGFX_N_NUM_MASK	((1<<IIO_IGFX_N_NUM_BITS)-1)
asm-mips64/sn/sn0/hubio.h:#define IIO_IGFX_P_NUM_MASK	((1<<IIO_IGFX_P_NUM_BITS)-1)
asm-mips64/sn/sn0/hubio.h:#define IIO_IGFX_VLD_MASK	((1<<IIO_IGFX_VLD_BITS)-1)
asm-mips64/sn/sn0/hubio.h:#define HUB_NUM_BIG_WINDOW	IIO_NUM_ITTES - 1
asm-mips64/sn/sn0/hubio.h:#define	IIO_WIDPRTE(x)	IIO_PRTE(((x) - 8)) /* widget ID to its PRTE num */
asm-mips64/sn/sn0/hubio.h:/* XXX - This is now tuneable:
asm-mips64/sn/sn0/hubio.h:/* XXX - IBUE register coming for Hub 2 */
asm-mips64/sn/sn0/hubio.h:/* XXX - Is this still right?  Check the spec. */
asm-mips64/sn/sn0/hubio.h:			sleep: 	1,	/* xtalk req sleeping till IO-sync */
asm-mips64/sn/sn0/hubio.h:/* XXX - Need to fix this for Hub 2 */
asm-mips64/sn/sn0/hubio.h:		rsvd1: 12,  /* 53-42: reserved			*/
asm-mips64/sn/sn0/hubio.h:		sidn:	4,  /* 40-37: SIDN field of xtalk rqst	*/
asm-mips64/sn/sn0/hubio.h:		tnum:	5,  /* 36-32: TNUM of xtalk request	*/
asm-mips64/sn/sn0/hubio.h:		size:	2,  /* 28-27: size of xtalk request	*/
asm-mips64/sn/sn0/hubio.h:		excl:	4,  /* 26-23: exclusive bit(s)		*/
asm-mips64/sn/sn0/hubio.h:		stall:	3,  /* 22-20: stall (xtalk, bte 0/1)	*/
asm-mips64/sn/sn0/hubio.h:		ack_cnt:11, /* 14-04: counter of invalidate acks*/
asm-mips64/sn/sn0/hubio.h:		tscaler:4;  /* 03-00: Timeout prescaler		*/
asm-mips64/sn/sn0/hubmd.h: * Copyright (C) 1992 - 1997, 1999 Silicon Graphics, Inc.
asm-mips64/sn/sn0/hubmd.h:#define	MD_FANDOP_CAC_STAT	0x200028 /* Fetch-and-op cache status 	    */
asm-mips64/sn/sn0/hubmd.h:#define MD_LED0			0x220050 /* Eight-bit LED for CPU A 	    */
asm-mips64/sn/sn0/hubmd.h:#define MD_LED1			0x220058 /* Eight-bit LED for CPU B 	    */
asm-mips64/sn/sn0/hubmd.h: * various MD registers.  For multi-bit registers, we define both
asm-mips64/sn/sn0/hubmd.h: * to forcing the ECC to be written as-is instead of recalculated.
asm-mips64/sn/sn0/hubmd.h: * as shown, and low and/or high indicates which double-word of the entry.
asm-mips64/sn/sn0/hubmd.h: * as shown, and low and/or high indicates which double-word of the entry.
asm-mips64/sn/sn0/hubmd.h:		rsvd1:	  19,	/* 60-42: reserved		*/
asm-mips64/sn/sn0/hubmd.h:		bad_prot:  3,	/* 41-39: encoding, bad access rights*/
asm-mips64/sn/sn0/hubmd.h:		bad_syn:   7,	/* 38-32: bad dir syndrome	*/
asm-mips64/sn/sn0/hubmd.h:		rsvd2:	   2,	/* 31-30: reserved		*/
asm-mips64/sn/sn0/hubmd.h:		hspec_addr:27,	/* 29-03: bddir space bad entry */
asm-mips64/sn/sn0/hubmd.h:		rsvd1:	  22,	/* 61-40: reserved		*/
asm-mips64/sn/sn0/hubmd.h:		bad_syn:   8,	/* 39-32: bad mem ecc syndrome	*/
asm-mips64/sn/sn0/hubmd.h:		address:  29,	/* 31-03: bad entry pointer	*/
asm-mips64/sn/sn0/hubmd.h:		rsvd1:	   2,	/* 62-61: reserved		*/
asm-mips64/sn/sn0/hubmd.h:		initiator:11,	/* 60-50: id of request initiator*/
asm-mips64/sn/sn0/hubmd.h:		backoff:   2,	/* 49-48: backoff control	*/
asm-mips64/sn/sn0/hubmd.h:		msg_type:  8,	/* 47-40: type of request	*/
asm-mips64/sn/sn0/hubmd.h:		access:	   2,	/* 39-38: access rights of initiator*/
asm-mips64/sn/sn0/hubmd.h:		dir_state: 4,	/* 36-33: state of directory	*/
asm-mips64/sn/sn0/hubmd.h:		address:  29,	/* 31-03: request address	*/
asm-mips64/sn/sn0/hubmd.h:		rsvd2:	   2,	/* 02-01: reserved		*/
asm-mips64/sn/sn0/hubni.h: * Copyright (C) 1992-1997, 1999 Silicon Graphics, Inc.
asm-mips64/sn/sn0/hubni.h:#define NDP_LLP8BITMODE		(UINT64_CAST 1 << 12)	/* LLP 8-bit mode   */
asm-mips64/sn/sn0/hubpi.h: * Copyright (C) 1992 - 1997, 1999 Silicon Graphics, Inc.
asm-mips64/sn/sn0/hubpi.h:#define PI_NMI_OFFSET		(PI_NMI_B - PI_NMI_A)
asm-mips64/sn/sn0/hubpi.h:/* Built-In Self Test support */
asm-mips64/sn/sn0/hubpi.h:#define PI_GFX_OFFSET		(PI_GFX_PAGE_B - PI_GFX_PAGE_A)
asm-mips64/sn/sn0/hubpi.h:#define PI_STACKADDR_OFFSET	(PI_ERR_STACK_ADDR_B - PI_ERR_STACK_ADDR_A)
asm-mips64/sn/sn0/hubpi.h:#define PI_ERRSTAT_OFFSET	(PI_ERR_STATUS0_B - PI_ERR_STATUS0_A)
asm-mips64/sn/sn0/hubpi.h:#define PI_RDCLR_OFFSET		(PI_ERR_STATUS0_A_RCLR - PI_ERR_STATUS0_A)
asm-mips64/sn/sn0/hubpi.h:       ((_sz) ? (PI_MIN_STACK_SIZE << ((_sz) - 1)) : 0)
asm-mips64/sn/sn0/hubpi.h: * XXX - This register's definition has changed, but it's only implemented
asm-mips64/sn/io.h:#define IIO_ITTE_OFFSET_MASK	((1<<IIO_ITTE_OFFSET_BITS)-1)
asm-mips64/sn/io.h:#define IIO_ITTE_WIDGET_MASK	((1<<IIO_ITTE_WIDGET_BITS)-1)
asm-mips64/sn/io.h: * 0, 8 - 0xF
asm-mips64/sn/io.h:			(_x) - (HUB_WIDGET_ID_MIN-1)) << 3) )
asm-mips64/sn/gda.h: * Copyright (C) 1992 - 1997, 2000 Silicon Graphics, Inc.
asm-mips64/sn/gda.h: * gda.h -- Contains the data structure for the global data area,
asm-mips64/sn/gda.h: * -------------+-------------------------------------------------------
asm-mips64/sn/nmi.h: * Copyright (C) 1992 - 1997 Silicon Graphics, Inc.
asm-mips64/sn/kldir.h: * Copyright (C) 1992 - 1997, 1999, 2000 Silicon Graphics, Inc.
asm-mips64/sn/kldir.h: * 0x2000000 (32M)         +-----------------------------------------+
asm-mips64/sn/kldir.h: * 0x1F80000 (31.5M)       +-----------------------------------------+
asm-mips64/sn/kldir.h: * 0x1C00000 (30M)         +-----------------------------------------+
asm-mips64/sn/kldir.h: * 0x0800000 (28M)         +-----------------------------------------+
asm-mips64/sn/kldir.h: * 0x1B00000 (27M)         +-----------------------------------------+
asm-mips64/sn/kldir.h: * 0x1A00000 (26M)         +-----------------------------------------+
asm-mips64/sn/kldir.h: * 0x1800000 (24M)         +-----------------------------------------+
asm-mips64/sn/kldir.h: * 0x1600000 (22M)         +-----------------------------------------+
asm-mips64/sn/kldir.h: *                         +-----------------------------------------+
asm-mips64/sn/kldir.h: * 0x190000 (2M--)         +-----------------------------------------+
asm-mips64/sn/kldir.h: * 0x34000 (208K)          +-----------------------------------------+
asm-mips64/sn/kldir.h: * 0x25000 (148K)          +-----------------------------------------+
asm-mips64/sn/kldir.h: *                         |      KLCONFIG - II (temp)               |
asm-mips64/sn/kldir.h: *                         |    ----------------------------         |
asm-mips64/sn/kldir.h: *                         |      UNIX NON-DEBUG Version             |
asm-mips64/sn/kldir.h: * 0x19000 (100K)          +-----------------------------------------+
asm-mips64/sn/kldir.h: * 0x19000 (100K)          +-----------------------------------------+
asm-mips64/sn/kldir.h: * 0x12000 (72K)           +-----------------------------------------+
asm-mips64/sn/kldir.h: * 0x11c00 (71K)           +-----------------------------------------+
asm-mips64/sn/kldir.h: * 0x11a00 (70.5K)         +-----------------------------------------+
asm-mips64/sn/kldir.h: * 0x11800 (70K)           +-----------------------------------------+
asm-mips64/sn/kldir.h: * 0x11600 (69.5K)         +-----------------------------------------+
asm-mips64/sn/kldir.h: * 0x11400 (69K)           +-----------------------------------------+
asm-mips64/sn/kldir.h: * 0x11000 (68K)           +-----------------------------------------+
asm-mips64/sn/kldir.h: * 0x10800  (66k)	   +-----------------------------------------+
asm-mips64/sn/kldir.h: * 0x10400 (65K)           +-----------------------------------------+
asm-mips64/sn/kldir.h: * 0x10000 (64K)           +-----------------------------------------+
asm-mips64/sn/kldir.h: *                         |      KLCONFIG - I (permanent) (48K)     |
asm-mips64/sn/kldir.h: * 0x4000 (16K)            +-----------------------------------------+
asm-mips64/sn/kldir.h: * 0x3000 (12K)            +-----------------------------------------+
asm-mips64/sn/kldir.h: * 0x2c00 (11K)            +-----------------------------------------+
asm-mips64/sn/kldir.h: * 0x2800 (10K)            +-----------------------------------------+
asm-mips64/sn/kldir.h: * 0x2400 (9K)             +-----------------------------------------+
asm-mips64/sn/kldir.h: * 0x2000 (8K)             +-----------------------------------------+
asm-mips64/sn/kldir.h: * 0x1000 (4K)             +-----------------------------------------+
asm-mips64/sn/kldir.h: * 0x800  (2k)	           +-----------------------------------------+
asm-mips64/sn/kldir.h: * 0x400 (1K)              +-----------------------------------------+
asm-mips64/sn/kldir.h: * 0x0   (0K)              +-----------------------------------------+
asm-mips64/sn/kldir.h:#define IP27_FREEMEM_SIZE		-1
asm-mips64/sn/kldir.h: * The actual offsets of each memory area are machine-dependent
asm-mips64/sn/arch.h: * Copyright (C) 1995 - 1997, 1999 Silcon Graphics, Inc.
asm-mips64/sn/arch.h:#define CNODE_NUM_CPUS(_cnode)		(NODEPDA(_cnode)->node_num_cpus)
asm-mips64/sn/arch.h:#define CNODE_TO_CPU_BASE(_cnode)	(NODEPDA(_cnode)->node_first_cpu)
asm-mips64/sn/arch.h:#define INVALID_NASID		(nasid_t)-1
asm-mips64/sn/arch.h:#define INVALID_CNODEID		(cnodeid_t)-1
asm-mips64/sn/arch.h:#define INVALID_PNODEID		(pnodeid_t)-1
asm-mips64/sn/arch.h:#define INVALID_MODULE		(moduleid_t)-1
asm-mips64/sn/arch.h:#define	INVALID_PARTID		(partid_t)-1
asm-mips64/sn/arch.h: * macros below.  (Really want private data members here :-)
asm-mips64/sn/arch.h:#define SLOT_BITMASK    	(MAX_MEM_SLOTS - 1)
asm-mips64/sn/arch.h:#define	SLOT_PFNSHIFT		(SLOT_SHIFT - PAGE_SHIFT)
asm-mips64/sn/arch.h:#define	PFN_NASIDSHFT		(NASID_SHFT - PAGE_SHIFT)
asm-mips64/sn/klconfig.h: * Copyright (C) 1992 - 1997, 1999, 2000 Silicon Graphics, Inc.
asm-mips64/sn/klconfig.h:/* lboard_t->brd_flags fields */
asm-mips64/sn/klconfig.h:/* klinfo->flags fields */
asm-mips64/sn/klconfig.h:#define IS_CONSOLE_IOC3(i)	((((klinfo_t *)i)->flags) & KLINFO_INSTALL)
asm-mips64/sn/klconfig.h:                                (KL_CONFIG_HDR(_nasid)->ch_malloc_hdr)
asm-mips64/sn/klconfig.h:        (KL_CONFIG_HDR(_nasid)->ch_board_info)
asm-mips64/sn/klconfig.h:        (KL_CONFIG_HDR(_nasid)->ch_board_info = (_off))
asm-mips64/sn/klconfig.h:        (lboard_t *)((KL_CONFIG_HDR(_nasid)->ch_board_info) ?		\
asm-mips64/sn/klconfig.h:	 NODE_OFFSET_TO_K1((_nasid), KL_CONFIG_HDR(_nasid)->ch_board_info) : \
asm-mips64/sn/klconfig.h:#define KL_CONFIG_MAGIC(_nasid)		(KL_CONFIG_HDR(_nasid)->ch_magic)
asm-mips64/sn/klconfig.h:        (KL_CONFIG_HDR(_nasid)->ch_magic == KLCFGINFO_MAGIC)
asm-mips64/sn/klconfig.h:                  (KL_CONFIG_HDR(_nasid)->ch_magic = KLCFGINFO_MAGIC)
asm-mips64/sn/klconfig.h:/* --- New Macros for the changed kl_config_hdr_t structure --- */
asm-mips64/sn/klconfig.h:			((__psunsigned_t)_k + (_k->ch_malloc_hdr_off)))
asm-mips64/sn/klconfig.h:			(unsigned long)_k + (_k->ch_malloc_hdr_off)))
asm-mips64/sn/klconfig.h:			((__psunsigned_t)_k + (_k->ch_cons_off)))
asm-mips64/sn/klconfig.h:			((unsigned long)_k + (_k->ch_cons_off)))
asm-mips64/sn/klconfig.h:/* ------------------------------------------------------------- */
asm-mips64/sn/klconfig.h:#define KL_CONFIG_BOARD_NASID(_brd)	((_brd)->brd_nasid)
asm-mips64/sn/klconfig.h:#define KL_CONFIG_BOARD_SET_NEXT(_brd, _off)	((_brd)->brd_next = (_off))
asm-mips64/sn/klconfig.h:#define KL_CONFIG_DUPLICATE_BOARD(_brd)	((_brd)->brd_flags & DUPLICATE_BOARD)
asm-mips64/sn/klconfig.h:               ((_xbowp)->xbow_port_info[(_link) - BASE_XBOW_PORT].port_flag & XBOW_PORT_HUB)
asm-mips64/sn/klconfig.h:               ((_xbowp)->xbow_port_info[(_link) - BASE_XBOW_PORT].port_flag & XBOW_PORT_IO)
asm-mips64/sn/klconfig.h:               ((_xbowp)->xbow_port_info[(_link) - BASE_XBOW_PORT].port_flag & XBOW_PORT_ENABLE)
asm-mips64/sn/klconfig.h:               ((_xbowp)->xbow_port_info[(_link) - BASE_XBOW_PORT].port_nasid)
asm-mips64/sn/klconfig.h: * node.(TBD - Need a way to treat ROUTER boards.)
asm-mips64/sn/klconfig.h: * There are 2 different structures to represent these boards -
asm-mips64/sn/klconfig.h: * lboard - Local board, rboard - remote board. These 2 structures
asm-mips64/sn/klconfig.h: * is used to find out its type - no unions are used.
asm-mips64/sn/klconfig.h: +------------+      +------------+      +------------+      +------------+
asm-mips64/sn/klconfig.h: |  lboard    |  +-->|   lboard   |  +-->|   rboard   |  +-->|   lboard   |
asm-mips64/sn/klconfig.h: +------------+  |   +------------+  |   +------------+  |   +------------+
asm-mips64/sn/klconfig.h: +------------+  |   +------------+  |   +------------+  |   +------------+
asm-mips64/sn/klconfig.h: | offset     |--+   |  offset    |--+   |  offset    |--+   |offset=NULL |
asm-mips64/sn/klconfig.h: +------------+      +------------+      +------------+      +------------+
asm-mips64/sn/klconfig.h: +------------+
asm-mips64/sn/klconfig.h: +------------+       +--------------------------------+
asm-mips64/sn/klconfig.h: | compt 1    |------>| type, rev, diaginfo, size ...  |  (CPU)
asm-mips64/sn/klconfig.h: +------------+       +--------------------------------+
asm-mips64/sn/klconfig.h: | compt 2    |--+
asm-mips64/sn/klconfig.h: +------------+  |    +--------------------------------+
asm-mips64/sn/klconfig.h: |  ...       |  +--->| type, rev, diaginfo, size ...  |  (MEM_BANK)
asm-mips64/sn/klconfig.h: +------------+       +--------------------------------+
asm-mips64/sn/klconfig.h: | errinfo    |--+
asm-mips64/sn/klconfig.h: +------------+  |    +--------------------------------+
asm-mips64/sn/klconfig.h:                 +--->|r/l brd errinfo,compt err flags |
asm-mips64/sn/klconfig.h:                      +--------------------------------+
asm-mips64/sn/klconfig.h: * be used. If the NODE is non-zero (remote) then each offset should
asm-mips64/sn/klconfig.h:#define KL_CPU_NONE		(-1)	/* no cpu present in slot */
asm-mips64/sn/klconfig.h:					    and the non-graphics widget boards */
asm-mips64/sn/klconfig.h:#define IS_MIO_PRESENT(l)	((l->brd_type == KLTYPE_BASEIO) && \
asm-mips64/sn/klconfig.h:				 (l->brd_flags & SECOND_NIC_PRESENT))
asm-mips64/sn/klconfig.h:#define BOARD_SLOT(_brd)	((_brd)->brd_slot)
asm-mips64/sn/klconfig.h:#define KLCF_CLASS(_brd)	KLCLASS((_brd)->brd_type)
asm-mips64/sn/klconfig.h:#define KLCF_TYPE(_brd)		KLTYPE((_brd)->brd_type)
asm-mips64/sn/klconfig.h:#define KLCF_REMOTE(_brd)  	(((_brd)->struct_type & LOCAL_BOARD) ? 0 : 1)
asm-mips64/sn/klconfig.h:#define KLCF_NUM_COMPS(_brd)	((_brd)->brd_numcompts)
asm-mips64/sn/klconfig.h:#define KLCF_MODULE_ID(_brd)	((_brd)->brd_module)
asm-mips64/sn/klconfig.h:#define KLCF_NEXT(_brd) 		((_brd)->brd_next ? (lboard_t *)((_brd)->brd_next):  NULL)
asm-mips64/sn/klconfig.h:#define KLCF_COMP(_brd, _ndx)   	(klinfo_t *)((_brd)->brd_compts[(_ndx)])
asm-mips64/sn/klconfig.h:#define KLCF_COMP_ERROR(_brd, _comp)   	(_brd = _brd , (_comp)->errinfo)
asm-mips64/sn/klconfig.h:        ((_brd)->brd_next ? 	\
asm-mips64/sn/klconfig.h:	 (lboard_t *)(NODE_OFFSET_TO_K1(NASID_GET(_brd), (_brd)->brd_next)):\
asm-mips64/sn/klconfig.h:					       (_brd)->brd_compts[(_ndx)]))
asm-mips64/sn/klconfig.h:               (NODE_OFFSET_TO_K1(NASID_GET(_brd), (_comp)->errinfo))
asm-mips64/sn/klconfig.h:#define KLCF_COMP_TYPE(_comp)	((_comp)->struct_type)
asm-mips64/sn/klconfig.h:#define KLCF_BRIDGE_W_ID(_comp)	((_comp)->physid)	/* Widget ID */
asm-mips64/sn/klconfig.h:	unsigned char	widid;	          /* Widget id - if applicable */
asm-mips64/sn/klconfig.h:	nasid_t		nasid;            /* node number - from parent */
asm-mips64/sn/klconfig.h:#define KLCONFIG_INFO_ENABLED(_i)	((_i)->flags & KLINFO_ENABLE)
asm-mips64/sn/klconfig.h:                            ((_info)->membnk_bnksz[(_bank)])
asm-mips64/sn/klconfig.h:                            ((_info)->membnk_attr & (MEMBNK_PREMIUM << (_bank)))
asm-mips64/sn/klconfig.h:				KLCF_COMP(_l, _l->brd_numcompts))
asm-mips64/sn/klconfig.h:typedef struct klvmeb_s {                          /* VME BRIDGE - PCI CTLR */
asm-mips64/sn/klconfig.h:typedef struct klvmed_s {                          /* VME DEVICE - VME BOARD */
asm-mips64/sn/klconfig.h:/* XXX - Don't we need the number of ports here?!? */
asm-mips64/sn/klconfig.h: * TBD - Can the ARCS and device driver related info also be included in the
asm-mips64/sn/klconfig.h: * TBD - Allocation issues.
asm-mips64/sn/ioc3.h:	volatile u8		fill0[0x150 - 0x142 - 1];
asm-mips64/sn/ioc3.h:	volatile u8		fill1[0x158 - 0x152 - 1];
asm-mips64/sn/ioc3.h:	volatile u8		fill2[0x168 - 0x15a - 1];
asm-mips64/sn/ioc3.h:	volatile u8		fill3[0x170 - 0x169 - 1];
asm-mips64/sn/ioc3.h:	volatile u32	pad1[(0x20000 - 0x00154) / 4];
asm-mips64/sn/ioc3.h:	volatile u32	pad2[(0x40000 - 0x20180) / 4];
asm-mips64/sn/ioc3.h:	volatile u32	ssram[(0x80000 - 0x40000) / 4];
asm-mips64/sn/ioc3.h:	   0x80000 -   Access to the generic devices selected with   DEV0
asm-mips64/sn/ioc3.h:	   0xA0000 -   Access to the generic devices selected with   DEV1
asm-mips64/sn/ioc3.h:	   0xC0000 -   Access to the generic devices selected with   DEV2
asm-mips64/sn/ioc3.h:	   0xE0000 -   Access to the generic devices selected with   DEV3
asm-mips64/sn/ioc3.h:/* ------------------------------------------------------------------------- */
asm-mips64/sn/ioc3.h:#define SSCR_RX_RING_DCD 0x00040000	/* post RX record on delta-DCD */
asm-mips64/sn/ioc3.h:#define SSCR_RX_RING_CTS 0x00080000	/* post RX record on delta-CTS */
asm-mips64/sn/ioc3.h:#define SIO_IR_SA_INT		0x00000040	/* port A pass-thru intr */
asm-mips64/sn/ioc3.h:#define SIO_IR_PP_INT		0x00040000	/* P port pass-thru intr */
asm-mips64/sn/ioc3.h:#define IOC3_PENDING_INTRS(mem) (PCI_INW(&((mem)->sio_ir)) & \
asm-mips64/sn/ioc3.h:				 PCI_INW(&((mem)->sio_ies_ro)))
asm-mips64/sn/ioc3.h:#define SIO_CR_ARB_DIAG_IDLE	0x00400000	/* 0 -> active request (ro) */
asm-mips64/sn/ioc3.h:	 100 / INT_OUT_NS_PER_TICK - 1)
asm-mips64/sn/ioc3.h:#define IOC3_ALL_SUBDEVS	((1<<ioc3_nsubdevs)-1)
asm-mips64/sn/intr.h: * Copyright (C) 1992 - 1997 Silicon Graphics, Inc.
asm-mips64/sn/intr.h: * Hard-coded interrupt levels:
asm-mips64/sn/intr.h:/* INT_PEND0 hard-coded bits. */
asm-mips64/sn/intr.h:/* INT_PEND1 hard-coded bits: */
asm-mips64/sn/addrs.h: * Copyright (C) 1992 - 1997, 1999, 2000 Silicon Graphics, Inc.
asm-mips64/sn/addrs.h:#define NODE_ADDRSPACE_MASK	(NODE_ADDRSPACE_SIZE - 1)
asm-mips64/sn/addrs.h:#define	SWIN_SIZEMASK		(SWIN_SIZE - 1)
asm-mips64/sn/addrs.h: * to Xtalk address in the range 0 -> SWINZ_SIZEMASK
asm-mips64/sn/addrs.h: * The following define the major position-independent aliases used
asm-mips64/sn/addrs.h: *	UALIAS -- 256MB in size, reads in the UALIAS result in
asm-mips64/sn/addrs.h: *	CPU_UALIAS -- 128kb in size, the bottom part of UALIAS is flipped
asm-mips64/sn/addrs.h: *	LBOOT  -- 256MB in size, reads in the LBOOT area result in
asm-mips64/sn/addrs.h: *			other directory-bus connected devices.
asm-mips64/sn/addrs.h: *	IALIAS -- 8MB in size, reads in the IALIAS result in uncached
asm-mips64/sn/addrs.h: *   BDDIR_ENTRY_LO returns the address of the low double-word of the dir
asm-mips64/sn/addrs.h: *   BDDIR_ENTRY_HI returns the address of the high double-word of the entry.
asm-mips64/sn/addrs.h: *   BDPRT_ENTRY    returns the address of the double-word protection entry
asm-mips64/sn/addrs.h: *                  double-word at a specified physical address.
asm-mips64/sn/addrs.h: *                  quad-word at a specified physical address.
asm-mips64/sn/addrs.h: * Software structure locations -- permanently fixed
asm-mips64/sn/addrs.h: * Software structure locations -- indirected through KLDIR
asm-mips64/sn/addrs.h:	(KLD_LAUNCH(nasid)->offset +					\
asm-mips64/sn/addrs.h:	 KLD_LAUNCH(nasid)->stride * (slice))
asm-mips64/sn/addrs.h:#define LAUNCH_SIZE(nasid)	KLD_LAUNCH(nasid)->size
asm-mips64/sn/addrs.h:	(KLD_NMI(nasid)->offset +					\
asm-mips64/sn/addrs.h:	 KLD_NMI(nasid)->stride * (slice))
asm-mips64/sn/addrs.h:#define NMI_SIZE(nasid)	KLD_NMI(nasid)->size
asm-mips64/sn/addrs.h:#define KLCONFIG_OFFSET(nasid)	KLD_KLCONFIG(nasid)->offset
asm-mips64/sn/addrs.h:#define KLCONFIG_SIZE(nasid)	KLD_KLCONFIG(nasid)->size
asm-mips64/sn/addrs.h:#define GDA_ADDR(nasid)		KLD_GDA(nasid)->pointer
asm-mips64/sn/addrs.h:#define GDA_SIZE(nasid)		KLD_GDA(nasid)->size
asm-mips64/sn/addrs.h:	(KLD_SYMMON_STK(nasid)->offset +				\
asm-mips64/sn/addrs.h:	 KLD_SYMMON_STK(nasid)->stride * (slice))
asm-mips64/sn/addrs.h:#define SYMMON_STK_STRIDE(nasid)	KLD_SYMMON_STK(nasid)->stride
asm-mips64/sn/addrs.h:#define SYMMON_STK_SIZE(nasid)	KLD_SYMMON_STK(nasid)->stride
asm-mips64/sn/addrs.h:#define SYMMON_STK_END(nasid)	(SYMMON_STK_ADDR(nasid, 0) + KLD_SYMMON_STK(nasid)->size)
asm-mips64/sn/addrs.h:	TO_NODE(nasid, PHYS_TO_K0(UNIX_DEBUG_LOADADDR - 0x1000))
asm-mips64/sn/addrs.h:#define FREEMEM_OFFSET(nasid)	KLD_FREEMEM(nasid)->offset
asm-mips64/sn/addrs.h:#define FREEMEM_SIZE(nasid)	KLD_FREEMEM(nasid)->size
asm-mips64/sn/addrs.h:#define PI_ERROR_OFFSET(nasid)	KLD_PI_ERROR(nasid)->offset
asm-mips64/sn/addrs.h:#define PI_ERROR_SIZE(nasid)	KLD_PI_ERROR(nasid)->size
asm-mips64/sn/addrs.h:#define KERN_VARS_ADDR(nasid)	KLD_KERN_VARS(nasid)->pointer
asm-mips64/sn/addrs.h:#define KERN_VARS_SIZE(nasid)	KLD_KERN_VARS(nasid)->size
asm-mips64/sn/addrs.h:#define	KERN_XP_ADDR(nasid)	KLD_KERN_XP(nasid)->pointer
asm-mips64/sn/addrs.h:#define	KERN_XP_SIZE(nasid)	KLD_KERN_XP(nasid)->size
asm-mips64/sn/agent.h: * Copyright (C) 1992 - 1997, 1999, 2000 Silcon Graphics, Inc.
asm-mips64/sn/types.h:typedef signed short	nasid_t;	/* node id in numa-as-id space */
asm-mips64/sn/types.h:typedef signed short	cnodeid_t;	/* node id in compact-id space */
asm-mips64/sn/types.h:typedef signed short	moduleid_t;	/* user-visible module number type */
asm-mips64/sn/intr_public.h: * Copyright (C) 1992 - 1997 Silicon Graphics, Inc.
asm-mips64/sn/intr_public.h:#define INTPEND0_MAXMASK	(N_INTPEND0_MASKS - 1)
asm-mips64/sn/intr_public.h:#define INTPEND1_MAXMASK	(N_INTPEND1_MASKS - 1)
asm-mips64/sn/intr_public.h:	 * The masks are stored with the lowest-priority (most inclusive)
asm-mips64/sn/intr_public.h:	 * in the lowest-numbered masks (i.e., 0, 1, 2...).
asm-mips64/sn/launch.h: * Copyright (C) 1992 - 1997, 2000 Silicon Graphics, Inc.
asm-mips64/sn/mapped_kernel.h: * using the change-addresses makefile option. Use elfdump -of
asm-mips64/sn/mapped_kernel.h:#define MAPPED_ADDR_RO_TO_PHYS(x)	(x - CKSSEG)
asm-mips64/sn/mapped_kernel.h:#define MAPPED_ADDR_RW_TO_PHYS(x)	(x - CKSSEG - 16777216)
asm-mips64/sn/mapped_kernel.h:			(PLAT_NODE_DATA(n)->kern_vars.kv_ro_baseaddr)
asm-mips64/sn/mapped_kernel.h:			(PLAT_NODE_DATA(n)->kern_vars.kv_rw_baseaddr)
asm-mips64/sn/mapped_kernel.h:#define MAPPED_KERN_RO_TO_PHYS(x)	(x - CKSEG0)
asm-mips64/sn/mapped_kernel.h:#define MAPPED_KERN_RW_TO_PHYS(x)	(x - CKSEG0)
asm-mips64/arc/hinv.h:#define SGI_ARCS_VERS	64			/* sgi 64-bit version */
asm-mips64/arc/types.h:/* The pointer types.  Note that we're using a 64-bit compiler but all
asm-mips64/arc/types.h:   pointer in the ARC structures are only 32-bit, so we need some disgusting
asm-mips64/arc/types.h:/* The pointer types.  We're 64-bit and the firmware is also 64-bit, so
asm-mips64/dec/io.h: *      include/asm-mips64/dec/io.h
asm-mips64/dec/tc.h: * of the first card not in use or -ENODEV
asm-mips64/dec/kn230.h: *	include/asm-mips/dec/kn230.h
asm-mips64/dec/ecc.h: *	include/asm-mips/dec/ecc.h
asm-mips64/dec/ecc.h: * The register is r/wc -- any write clears it.
asm-mips64/dec/ecc.h: * from the last memory read.  The register is r/wc -- any write clears it.
asm-mips64/dec/kn02ba.h: *	include/asm-mips/dec/kn02ba.h
asm-mips64/dec/kn02ba.h: *	DECstation 5000/1xx (3min or KN02-BA) definitions.
asm-mips64/dec/kn02ba.h: * I/O ASIC interrupt bits.  Star marks denote non-IRQ status bits.
asm-mips64/dec/kn02ca.h: *	include/asm-mips/dec/kn02ca.h
asm-mips64/dec/kn02ca.h: *	Personal DECstation 5000/xx (Maxine or KN02-CA) definitions.
asm-mips64/dec/kn02ca.h: * I/O ASIC interrupt bits.  Star marks denote non-IRQ status bits.
asm-mips64/dec/kn02ca.h:#define KN02CA_IO_INR_POWERON	13	/* (*) ACCESS.Bus/power-on reset */
asm-mips64/dec/kn02xa.h: * The rest is defined in system-specific headers.
asm-mips64/dec/kn02xa.h: * The rest is defined in system-specific headers.
asm-mips64/dec/interrupts.h: * with the machine-specific interrupt routines.
asm-mips64/dec/interrupts.h:#define DEC_IRQ_TC5		DEC_IRQ_ASC	/* virtual PMAZ-AA */
asm-mips64/dec/interrupts.h:#define DEC_IRQ_TC6		DEC_IRQ_LANCE	/* virtual PMAD-AA */
asm-mips64/dec/ioasic_addrs.h:#define IO_REG_SCSI_SCR		0x1b0	/* SCSI Partial-Word DMA Control */
asm-mips64/dec/ioasic_addrs.h:#define IO_REG_FCTR		0x1e0	/* Free-Running Counter */
asm-mips64/dec/ioasic_addrs.h: * The lower 16 bits are system-specific.  Bits 15,11:8 are common and
asm-mips64/dec/ioasic_addrs.h: * defined here.  The rest is defined in system-specific headers.
asm-mips64/dec/kn01.h:#define KN01_CSR_STATUS		(1<<14)	/* self-test result status output */
asm-mips64/dec/kn03.h: * I/O ASIC interrupt bits.  Star marks denote non-IRQ status bits.
asm-mips64/dec/kn05.h: *	include/asm-mips/dec/kn05.h
asm-mips64/dec/kn05.h: * The register appears read-only.
asm-mips64/dec/rtc-dec.h: *	include/asm-mips/dec/rtc-dec.h
asm-mips64/dec/tcmodule.h: * EK-TCAAD-FS-004
asm-mips64/dec/serial.h: *	include/asm-mips/dec/serial.h
asm-mips64/dec/ioasic.h: *	include/asm-mips/dec/ioasic.h
asm-mips64/dec/tcinfo.h: * EK-TCAAD-FS-004
asm-mips64/dec/ioasic_ints.h: * The lower 16 bits are system-specific and thus defined in
asm-mips64/dec/ioasic_ints.h: * system-specific headers.
asm-mips64/pci/bridge.h: * bridge.h - bridge chip header file, derived from IRIX <sys/PCI/bridge.h>,
asm-mips64/pci/bridge.h:#define IOPGOFF(x)		((x) & (IOPGSIZE-1))
asm-mips64/pci/bridge.h: * using 32-bit loads and stores.
asm-mips64/pci/bridge.h:	/* Local Registers			       0x000000-0x00FFFF */
asm-mips64/pci/bridge.h:	/* standard widget configuration	       0x000000-0x000057 */
asm-mips64/pci/bridge.h:	/* bridge-specific widget configuration	0x000058-0x00007F */
asm-mips64/pci/bridge.h:	/* PMU & Map 0x000080-0x00008F */
asm-mips64/pci/bridge.h:	/* SSRAM 0x000090-0x00009F */
asm-mips64/pci/bridge.h:	/* Arbitration 0x0000A0-0x0000AF */
asm-mips64/pci/bridge.h:	/* Number In A Can 0x0000B0-0x0000BF */
asm-mips64/pci/bridge.h:	/* PCI/GIO 0x0000C0-0x0000FF */
asm-mips64/pci/bridge.h:	/* Interrupt 0x000100-0x0001FF */
asm-mips64/pci/bridge.h:	/* Device 0x000200-0x0003FF */
asm-mips64/pci/bridge.h:	char		_pad_000300[0x10000 - 0x000300];
asm-mips64/pci/bridge.h:	/* Internal Address Translation Entry RAM 0x010000-0x0103FF */
asm-mips64/pci/bridge.h:		bridge_ate_t	wr;			/* write-only */
asm-mips64/pci/bridge.h:			bridgereg_t	rd;		/* read-only */
asm-mips64/pci/bridge.h:	char	_pad_010400[0x11000 - 0x010400];
asm-mips64/pci/bridge.h:	/* Internal Address Translation Entry RAM LOW 0x011000-0x0113FF */
asm-mips64/pci/bridge.h:		bridgereg_t	rd;		/* read-only */
asm-mips64/pci/bridge.h:	char	_pad_011400[0x20000 - 0x011400];
asm-mips64/pci/bridge.h:	/* PCI Device Configuration Spaces 0x020000-0x027FFF */
asm-mips64/pci/bridge.h:    /* PCI Type 1 Configuration Space 0x028000-0x028FFF */
asm-mips64/pci/bridge.h:	} b_type1_cfg;					/* 0x028000-0x029000 */
asm-mips64/pci/bridge.h:	char	_pad_029000[0x007000];			/* 0x029000-0x030000 */
asm-mips64/pci/bridge.h:	u8	_pad_030007[0x04fff8];			/* 0x030008-0x07FFFF */
asm-mips64/pci/bridge.h:	/* External Address Translation Entry RAM 0x080000-0x0FFFFF */
asm-mips64/pci/bridge.h:	/* Reserved 0x100000-0x1FFFFF */
asm-mips64/pci/bridge.h:	char	_pad_100000[0x200000-0x100000];
asm-mips64/pci/bridge.h:	/* PCI/GIO Device Spaces 0x200000-0xBFFFFF */
asm-mips64/pci/bridge.h:	/* External Flash Proms 1,0 0xC00000-0xFFFFFF */
asm-mips64/pci/bridge.h:		u8	c[0x400000 / 1];	/* read-only */
asm-mips64/pci/bridge.h:		u16	s[0x400000 / 2];	/* read-write */
asm-mips64/pci/bridge.h:		u32	l[0x400000 / 4];	/* read-only */
asm-mips64/pci/bridge.h:		u64	d[0x400000 / 8];	/* read-only */
asm-mips64/pci/bridge.h: * regularly against the offsets of the like-named fields
asm-mips64/pci/bridge.h:#define BRIDGE_DEVIO(x)		((x)<=1 ? BRIDGE_DEVIO0+(x)*BRIDGE_DEVIO_2MB : BRIDGE_DEVIO2+((x)-2)*BRIDGE_DEVIO_1MB)
asm-mips64/pci/bridge.h:/* Bridge Bus time-out register bits definition */
asm-mips64/pci/bridge.h:		((adr) & (BRIDGE_DIRECT_32_SEG_SIZE - 1)) + PHYS_RAMBASE)
asm-mips64/pci/bridge.h:/* 64-bit address attribute masks */
asm-mips64/sgi/mc.h:#define SGIMC_CCTRL0_LENDIAN	0x00020000 /* Put MC in little-endian mode */
asm-mips64/sgi/mc.h:#define SGIMC_EEPROM_SDATAO	0x00000008 /* Serial EEPROM data-out */
asm-mips64/sgi/mc.h:#define SGIMC_EEPROM_SDATAI	0x00000010 /* Serial EEPROM data-in */
asm-mips64/sgi/mc.h:#define SGIMC_GIOPAR_HPC64	0x00000001 /* HPC talks to GIO using 64-bits */
asm-mips64/sgi/mc.h:#define SGIMC_GIOPAR_GFX64	0x00000002 /* GFX talks to GIO using 64-bits */
asm-mips64/sgi/mc.h:#define SGIMC_GIOPAR_EXP064	0x00000004 /* EXP(slot0) talks using 64-bits */
asm-mips64/sgi/mc.h:#define SGIMC_GIOPAR_EXP164	0x00000008 /* EXP(slot1) talks using 64-bits */
asm-mips64/sgi/mc.h:#define SGIMC_GIOPAR_EISA64	0x00000010 /* EISA bus talks 64-bits to GIO */
asm-mips64/sgi/mc.h:#define SGIMC_GIOPAR_HPC264	0x00000020 /* 2nd HPX talks 64-bits to GIO */
asm-mips64/sgi/mc.h:	volatile u32 syssembit;		/* Uni-bit system semaphore */
asm-mips64/sgi/mc.h:	u32 _unused36[0x1000/4-2*4];
asm-mips64/sgi/gio.h: * -----   --------- ----------------------- -----
asm-mips64/sgi/gio.h: *   0     GFX       0x1f000000 - 0x1f3fffff   4MB
asm-mips64/sgi/gio.h: *   1     EXP0      0x1f400000 - 0x1f5fffff   2MB
asm-mips64/sgi/gio.h: *   2     EXP1      0x1f600000 - 0x1f9fffff   4MB
asm-mips64/sgi/gio.h: * There are un-slotted devices, HPC, I/O and misc devices, which are grouped
asm-mips64/sgi/gio.h: *   -     MISC      0x1fb00000 - 0x1fbfffff   1MB
asm-mips64/sgi/gio.h: *   -     RESERVED  0x18000000 - 0x1effffff 112MB
asm-mips64/sgi/gio.h: * 32-bit IDs are divided into
asm-mips64/sgi/gio.h: *	bit 16		0=GIO32 and GIO32-bis, 1=GIO64.
asm-mips64/sgi/gio.h: * 8-bit IDs
asm-mips64/sgi/gio.h: *	0x0e		E-Plex 8-port Ethernet
asm-mips64/sgi/gio.h: * [*] Device provide 32-bit ID.
asm-mips64/sgi/ioc.h: * All registers are 8-bit wide alligned on 32-bit boundary. Bad things
asm-mips64/sgi/ioc.h:#define SGINT_TCWORD_MOS	0x02	/* One-shot IRQ mode. */
asm-mips64/sgi/pi1.h:#define PI1_STAT_DEVID		0x03	/* bits 0-1 */
asm-mips64/sgi/pi1.h:#define PI1_DMACTRL_STDMODE	0x00    /* bits 2-3 */
asm-mips64/sgi/pi1.h:#define PI1_DMACTRL_SGIMODE	0x04    /* bits 2-3 */
asm-mips64/sgi/pi1.h:#define PI1_DMACTRL_RICOHMODE	0x08    /* bits 2-3 */
asm-mips64/sgi/pi1.h:#define PI1_DMACTRL_HPMODE	0x0c    /* bits 2-3 */
asm-mips64/sgi/hpc3.h:	u32 _unused0[0x1000/4 - 2];	/* padding */
asm-mips64/sgi/hpc3.h:#define HPC3_PDMACTRL_HW	0x0000ff00 /* DMA High-water mark */
asm-mips64/sgi/hpc3.h:	u32 _unused1[0x1000/4 - 1];	/* padding */
asm-mips64/sgi/hpc3.h:	u32 _unused0[0x1000/4 - 2];	/* padding */
asm-mips64/sgi/hpc3.h:#define HPC3_SDCFG_HW   0x01000 /* Enable 16-bit halfword DMA accesses to scsi */
asm-mips64/sgi/hpc3.h:#define HPC3_SPCFG_HW   0x1000 /* Enable 16-bit halfword PIO accesses to scsi */
asm-mips64/sgi/hpc3.h:	u32 _unused1[0x1000/4 - 6];	/* padding */
asm-mips64/sgi/hpc3.h:	u32 _unused0[0x1000/4 - 2];	/* padding */
asm-mips64/sgi/hpc3.h:	u32 _unused2[0x1000/4 - 8];	/* padding */
asm-mips64/sgi/hpc3.h:	u32 _unused3[0x1000/4 - 2];	/* padding */
asm-mips64/sgi/hpc3.h:	u32 _unused4[0x1000/4 - 4];	/* padding */
asm-mips64/sgi/hpc3.h:	 * you it was a peculiar bug. ;-)
asm-mips64/sgi/hpc3.h:#define HPC3_ISTAT_PBIMASK	0x0ff	/* irq bits for pbus devs 0 --> 7 */
asm-mips64/sgi/hpc3.h:	u32 _unused1[0x14000/4 - 5];	/* padding */
asm-mips64/sgi/hpc3.h:	/* Now direct PIO per-HPC3 peripheral access to external regs. */
asm-mips64/sgi/hpc3.h:	/* Per-peripheral device external registers and DMA/PIO control. */
asm-mips64/sgi/hpc3.h:	/* Enable 16-bit DMA access mode */
asm-mips64/sgi/hpc3.h:	/* Enable 16-bit PIO accesses */
asm-mips64/sgi/hpc3.h:	u32 _unused5[0x0800/4 - 1];
asm-mips64/sgi/hpc3.h:	u32 _unused6[0x0800/4 - 1];
asm-mips64/sgi/hpc3.h:	u32 _unused7[0x1000/4 - 1];
asm-mips64/sgi/hpc3.h:	volatile u32 bbram[8192-50-14];	/* Battery backed ram */
asm-mips64/sgi/ip22.h: * HAL2 driver). This will prevent many complications, trust me ;-)
asm-mips64/sgi/ip22.h:#define SGI_GIO_0_IRQ	SGI_FIFO_IRQ		/* GIO-0 */
asm-mips64/sgi/ip22.h:#define SGI_GIO_1_IRQ	SGINT_LOCAL0 + 6	/* GE / GIO-1 / 2nd-HPC */
asm-mips64/sgi/ip22.h:#define SGI_GIO_2_IRQ	SGINT_LOCAL1 + 7	/* Vert retrace / GIO-2 */
asm-mips64/sgi/ip22.h:#define ip22_is_fullhouse()	(sgioc->sysid & SGIOC_SYSID_FULLHOUSE)
asm-mips64/io.h: * Copyright (C) 1994 - 2000, 03 Ralf Baechle
asm-mips64/io.h:#include <asm/mips-boards/io.h>
asm-mips64/io.h:#include <asm/mips-boards/io.h>
asm-mips64/io.h:#include <asm/mips-boards/io.h>
asm-mips64/io.h:#define bus_to_baddr(bus, addr)	(bus_to_baddr[(bus)->number] + (addr))
asm-mips64/io.h:#define baddr_to_bus(bus, addr)	((addr) - bus_to_baddr[(bus)->number])
asm-mips64/io.h: * IP22 seems braindead enough to swap 16-bits values in hardware, but not
asm-mips64/io.h: * 32-bits.  Go figure... Can't tell without documentation.
asm-mips64/io.h: * We only do the swapping to keep the kernel config bits of bi-endian
asm-mips64/io.h: *     ioremap         -       map bus memory into CPU space
asm-mips64/io.h: *     ioremap_nocache         -       map bus memory into CPU space
asm-mips64/io.h: * 24-31 on SNI.
asm-mips64/io.h: * to PAGE_OFFSET is pure coincidence - it does not mean ISA values
asm-mips64/io.h: * used as the IO-area pointer (it can be iounmapped as well, so the
asm-mips64/io.h:#define eth_io_copy_and_sum(skb,src,len,unused) memcpy_fromio((skb)->data,(src),(len))
asm-mips64/io.h: *     check_signature         -       find BIOS signatures
asm-mips64/io.h:		length--;
asm-mips64/io.h: *     isa_check_signature             -       find BIOS signatures
asm-mips64/io.h:		length--;
asm-mips64/io.h: *     virt_to_phys    -       map virtual addresses to physical
asm-mips64/io.h:	return (unsigned long)address - PAGE_OFFSET;
asm-mips64/io.h: *     phys_to_virt    -       map physical address to virtual
asm-mips64/io.h:	return (unsigned long)address - PAGE_OFFSET;
asm-mips64/io.h:	while (count--) {
asm-mips64/io.h:	while (count--) {
asm-mips64/io.h:	while (count--) {
asm-mips64/io.h:	while (count--) {
asm-mips64/io.h:	while (count--) {
asm-mips64/io.h:	while (count--) {
asm-mips64/io.h: * The caches on some architectures aren't dma-coherent and have need to
asm-mips64/io.h: *  - dma_cache_wback_inv(start, size) makes caches and coherent by
asm-mips64/io.h: *  - dma_cache_wback(start, size) makes caches and coherent by
asm-mips64/io.h: *  - dma_cache_inv(start, size) invalidates the affected parts of the
asm-mips64/atomic.h: * atomic_read - read atomic variable
asm-mips64/atomic.h:#define atomic_read(v)	((v)->counter)
asm-mips64/atomic.h: * atomic_set - set atomic variable
asm-mips64/atomic.h:#define atomic_set(v,i)	((v)->counter = (i))
asm-mips64/atomic.h:		: "=&r" (temp), "=m" (v->counter)
asm-mips64/atomic.h:		: "Ir" (i), "m" (v->counter));
asm-mips64/atomic.h: * atomic_sub - subtract the atomic variable
asm-mips64/atomic.h:		: "=&r" (temp), "=m" (v->counter)
asm-mips64/atomic.h:		: "Ir" (i), "m" (v->counter));
asm-mips64/atomic.h:		: "=&r" (result), "=&r" (temp), "=m" (v->counter)
asm-mips64/atomic.h:		: "Ir" (i), "m" (v->counter)
asm-mips64/atomic.h:		: "=&r" (result), "=&r" (temp), "=m" (v->counter)
asm-mips64/atomic.h:		: "Ir" (i), "m" (v->counter)
asm-mips64/atomic.h: * atomic_sub_and_test - subtract value from variable and test result
asm-mips64/atomic.h: * atomic_inc_and_test - increment and test
asm-mips64/atomic.h: * atomic_dec_and_test - decrement by 1 and test
asm-mips64/atomic.h: * atomic_inc - increment atomic variable
asm-mips64/atomic.h: * atomic_dec - decrement and test
asm-mips64/atomic.h: * atomic_add_negative - add and test if negative
asm-mips64/delay.h: * Copyright (C) 1995 - 2000 by Ralf Baechle
asm-mips64/mc146818rtc.h:rtc_ops->rtc_read_data(addr); \
asm-mips64/mc146818rtc.h:rtc_ops->rtc_write_data(val, addr); \
asm-mips64/mc146818rtc.h:rtc_ops->rtc_bcd_mode()
asm-mips64/mc146818rtc.h:#include <asm/dec/rtc-dec.h>
asm-mips64/ipcbuf.h: * - 32-bit seq
asm-mips64/ipcbuf.h: * - 2 miscellaneous 64-bit values
asm-mips64/r4kcache.h: * Copyright (C) 1997 - 2002 Ralf Baechle (ralf@gnu.org)
asm-mips64/r4kcache.h: * Copyright (C) 2004 Ralf Baechle (ralf@linux-mips.org)
asm-mips64/r4kcache.h: * R10000 / R12000 hazard - these processors don't support the Hit_Writeback_D
asm-mips64/r4kcache.h: * cacheop so we use Hit_Writeback_Inv_D which is supported by all R4000-style
asm-mips64/r4kcache.h: * This one is RM7000-specific
asm-mips64/shmbuf.h: * - 2 miscellaneous 64-bit values
asm-mips64/sfp-machine.h:#define _FP_NANFRAC_S		((_FP_QNANBIT_S << 1) - 1)
asm-mips64/sfp-machine.h:#define _FP_NANFRAC_D		((_FP_QNANBIT_D << 1) - 1)
asm-mips64/sfp-machine.h:#define _FP_NANFRAC_Q		((_FP_QNANBIT_Q << 1) - 1), -1
asm-mips64/bitops.h: * set_bit - Atomically set a bit in memory
asm-mips64/bitops.h: * restricted to acting on a single-word quantity.
asm-mips64/bitops.h: * __set_bit - Set a bit in memory
asm-mips64/bitops.h: * Unlike set_bit(), this function is non-atomic and may be reordered.
asm-mips64/bitops.h: * clear_bit - Clears a bit in memory
asm-mips64/bitops.h: * change_bit - Toggle a bit in memory
asm-mips64/bitops.h: * restricted to acting on a single-word quantity.
asm-mips64/bitops.h: * __change_bit - Toggle a bit in memory
asm-mips64/bitops.h: * Unlike change_bit(), this function is non-atomic and may be reordered.
asm-mips64/bitops.h: * test_and_set_bit - Set a bit and return its old value
asm-mips64/bitops.h: * __test_and_set_bit - Set a bit and return its old value
asm-mips64/bitops.h: * This operation is non-atomic and can be reordered.
asm-mips64/bitops.h: * test_and_clear_bit - Clear a bit and return its old value
asm-mips64/bitops.h: * __test_and_clear_bit - Clear a bit and return its old value
asm-mips64/bitops.h: * This operation is non-atomic and can be reordered.
asm-mips64/bitops.h: * test_and_change_bit - Change a bit and return its new value
asm-mips64/bitops.h: * __test_and_change_bit - Change a bit and return its old value
asm-mips64/bitops.h: * This operation is non-atomic and can be reordered.
asm-mips64/bitops.h: * test_bit - Determine whether a bit is set
asm-mips64/bitops.h: * ffz - find first zero in word.
asm-mips64/bitops.h: * find_next_zero_bit - find the first zero bit in a memory region
asm-mips64/bitops.h:	size -= result;
asm-mips64/bitops.h:		tmp |= ~0UL >> (_MIPS_SZLONG-offset);
asm-mips64/bitops.h:		size -= _MIPS_SZLONG;
asm-mips64/bitops.h:		size -= _MIPS_SZLONG;
asm-mips64/bitops.h: * ffs - find first bit set
asm-mips64/bitops.h: * hweightN - returns the hamming weight of a N-bit word
asm-mips64/bitops.h:	size -= result;
asm-mips64/bitops.h:		tmp |= ~0U >> (32-offset); /* bug or feature ? */
asm-mips64/bitops.h:		size -= 32;
asm-mips64/bitops.h:		size -= 32;
asm-mips64/i8259.h: *	include/asm-mips/i8259.h
asm-mips64/div64.h: * Hey, we're already 64-bit, no
asm-mips64/resource.h:#define RLIMIT_MEMLOCK 9		/* max locked-in-memory address space */
asm-mips64/ptrace.h:/* 0 - 31 are integer registers, 32 - 63 are fp registers.  */
asm-mips64/ptrace.h:        ".size\t" #symbol",. - " #symbol)
asm-mips64/ptrace.h:#define instruction_pointer(regs) ((regs)->cp0_epc)
asm-mips64/pgalloc.h: * Copyright (C) 1994 - 2001 by Ralf Baechle at alii
asm-mips64/pgalloc.h: *  - flush_tlb_all() flushes all processes TLB entries
asm-mips64/pgalloc.h: *  - flush_tlb_mm(mm) flushes the specified mm context TLB entries
asm-mips64/pgalloc.h: *  - flush_tlb_page(mm, vmaddr) flushes a single page
asm-mips64/pgalloc.h: *  - flush_tlb_range(mm, start, end) flushes a range of pages
asm-mips64/pgalloc.h: *  - flush_tlb_pgtables(mm, start, end) flushes a range of page tables
asm-mips64/pgalloc.h: *  - flush_tlb_one(page) flushes a single kernel page
asm-mips64/pgalloc.h:		pgtable_cache_size--;
asm-mips64/pgalloc.h:		pgtable_cache_size--;
asm-mips64/pgalloc.h:		pgtable_cache_size--;
asm-mips64/pgalloc.h:		pgtable_cache_size--;
asm-mips64/pgalloc.h:		pgtable_cache_size--;
asm-mips64/unistd.h: * Linux 64-bit syscalls are in the range from 5000 to 5999.
asm-mips64/unistd.h: * Offset of the last Linux 64-bit flavoured syscall
asm-mips64/unistd.h:/* XXX - _foo needs to be __foo, while __NR_bar could be _NR_bar. */
asm-mips64/unistd.h:	return (type)-1; \
asm-mips64/unistd.h:	return (type)-1; \
asm-mips64/unistd.h:	return (type)-1; \
asm-mips64/unistd.h:	return (type)-1; \
asm-mips64/unistd.h:	return (type)-1; \
asm-mips64/unistd.h: * Using those means your brain needs more than an oil change ;-)
asm-mips64/unistd.h:	return (type)-1; \
asm-mips64/unistd.h:	return (type)-1; \
asm-mips64/unistd.h:	return (type)-1; \
asm-mips64/unistd.h:	return (type)-1; \
asm-mips64/unistd.h: * we need this inline - forking from kernel space will result
asm-mips64/unistd.h: * calls - which means inline code for fork too, as otherwise we
asm-mips64/unistd.h:	return waitpid(-1, wait_stat, 0);
asm-mips64/asm.h: * away by gas in -O mode. These nops are however required to fill delay
asm-mips64/asm.h: * LEAF - declare leaf routine
asm-mips64/asm.h: * NESTED - declare nested routine entry point
asm-mips64/asm.h: * END - mark end of function
asm-mips64/asm.h:		.size	function,.-function
asm-mips64/asm.h: * EXPORT - export definition of symbol
asm-mips64/asm.h: * FEXPORT - export definition of a function symbol
asm-mips64/asm.h: * ABS - export absolute symbol
asm-mips64/asm.h: * Macros to handle different pointer/register sizes for 32/64-bit code
asm-mips64/cpu.h:  +----------------+----------------+----------------+----------------+
asm-mips64/cpu.h:  +----------------+----------------+----------------+----------------+
asm-mips64/cpu.h:   that bits 16-23 have been 0 for all MIPS processors before the MIPS32/64
asm-mips64/cpu.h: * +---------------------------------+----------------+----------------+
asm-mips64/cpu.h: * +---------------------------------+----------------+----------------+
asm-mips64/cpu.h: * Bit 15 encodes if an ISA level supports 64-bit operations.
asm-mips64/cpu.h:#define MIPS_CPU_SUBSET_CACHES	0x00020000 /* P-cache subset enforced */
asm-mips64/dma.h: *  controller 1: channels 0-3, byte operations, ports 00-1F
asm-mips64/dma.h: *  controller 2: channels 4-7, word operations, ports C0-DF
asm-mips64/dma.h: *  - ALL registers are 8 bits only, regardless of transfer size
asm-mips64/dma.h: *  - channel 4 is not used - cascades 1 into 2.
asm-mips64/dma.h: *  - channels 0-3 are byte - addresses/counts are for physical bytes
asm-mips64/dma.h: *  - channels 5-7 are word - addresses/counts are for physical words
asm-mips64/dma.h: *  - transfers must not cross physical 64K (0-3) or 128K (5-7) boundaries
asm-mips64/dma.h: *  - transfer count loaded to registers is 1 less than actual count
asm-mips64/dma.h: *  - controller 2 offsets are all even (2x offsets for controller 1)
asm-mips64/dma.h: *  - page registers for 5-7 don't use data bit 0, represent 128K pages
asm-mips64/dma.h: *  - page registers for 0-3 use bit 0, represent 64K pages
asm-mips64/dma.h: *  Address mapping for channels 0-3:
asm-mips64/dma.h: *  Address mapping for channels 5-7:
asm-mips64/dma.h: * Again, channels 5-7 transfer _physical_ words (16 bits), so addresses
asm-mips64/dma.h: * and counts _must_ be word-aligned (the lowest address bit is _ignored_ at
asm-mips64/dma.h: * the hardware level, so odd-byte transfers aren't possible).
asm-mips64/dma.h: * count - 1 : 64K => 0xFFFF, 1 => 0x0000.  Thus, count is always 1 or more,
asm-mips64/dma.h: * and up to 128K bytes may be transferred on channels 5-7 in one operation.
asm-mips64/dma.h:#define DMA1_MASK_REG		0x0A	/* single-channel mask (w) */
asm-mips64/dma.h:#define DMA1_CLEAR_FF_REG	0x0C	/* clear pointer flip-flop (w) */
asm-mips64/dma.h:#define DMA1_MASK_ALL_REG       0x0F    /* all-channels mask (w) */
asm-mips64/dma.h:#define DMA2_MASK_REG		0xD4	/* single-channel mask (w) */
asm-mips64/dma.h:#define DMA2_CLEAR_FF_REG	0xD8	/* clear pointer flip-flop (w) */
asm-mips64/dma.h:#define DMA2_MASK_ALL_REG       0xDE    /* all-channels mask (w) */
asm-mips64/dma.h:#define DMA_MODE_CASCADE 0xC0   /* pass thru DREQ->HRQ, DACK<-HLDA only */
asm-mips64/dma.h: * After that, keep track of it. :-)
asm-mips64/dma.h: * --- In order to do that, the DMA routines below should ---
asm-mips64/dma.h: * --- only be used while holding the DMA lock ! ---
asm-mips64/dma.h: * Assumes dma flip-flop is clear.
asm-mips64/dma.h: * NOTE 2: "count" represents _bytes_ and must be even for channels 5-7.
asm-mips64/dma.h:        count--;
asm-mips64/dma.h: * Assumes DMA flip-flop is clear.
asm-mips64/dma.h:	/* using short to get 16-bit wrap around */
asm-mips64/elf.h:#define EF_MIPS_ARCH_1      0x00000000  /* -mips1 code.  */
asm-mips64/elf.h:#define EF_MIPS_ARCH_2      0x10000000  /* -mips2 code.  */
asm-mips64/elf.h:#define EF_MIPS_ARCH_3      0x20000000  /* -mips3 code.  */
asm-mips64/elf.h:#define EF_MIPS_ARCH_4      0x30000000  /* -mips4 code.  */
asm-mips64/elf.h:#define EF_MIPS_ARCH_5      0x40000000  /* -mips5 code.  */
asm-mips64/elf.h:	if (__h->e_machine != EM_MIPS)					\
asm-mips64/elf.h:	if (__h->e_ident[EI_CLASS] == ELFCLASS32) 			\
asm-mips64/elf.h: * See comments in asm-alpha/elf.h, this is the same thing
asm-mips64/elf.h:	_r->regs[1] = _r->regs[2] = _r->regs[3] = _r->regs[4] = 0;	\
asm-mips64/elf.h:	_r->regs[5] = _r->regs[6] = _r->regs[7] = _r->regs[8] = 0;	\
asm-mips64/elf.h:	_r->regs[9] = _r->regs[10] = _r->regs[11] = _r->regs[12] = 0;	\
asm-mips64/elf.h:	_r->regs[13] = _r->regs[14] = _r->regs[15] = _r->regs[16] = 0;	\
asm-mips64/elf.h:	_r->regs[17] = _r->regs[18] = _r->regs[19] = _r->regs[20] = 0;	\
asm-mips64/elf.h:	_r->regs[21] = _r->regs[22] = _r->regs[23] = _r->regs[24] = 0;	\
asm-mips64/elf.h:	_r->regs[25] = _r->regs[26] = _r->regs[27] = _r->regs[28] = 0;	\
asm-mips64/elf.h:	_r->regs[30] = _r->regs[31] = 0;				\
asm-mips64/elf.h:do {	current->thread.mflags &= ~MF_ABI_MASK;		\
asm-mips64/elf.h:			current->thread.mflags |= MF_N32;	\
asm-mips64/elf.h:			current->thread.mflags |= MF_O32;	\
asm-mips64/elf.h:		current->thread.mflags |= MF_N64;	\
asm-mips64/elf.h:	else if (current->personality != PER_LINUX32)	\
asm-mips64/fpu.h:#define clear_fpu_owner() do { current->flags &= ~PF_USEDFPU; } while(0)
asm-mips64/fpu.h:	return cpu_has_fpu && ((current->flags & PF_USEDFPU) != 0); 
asm-mips64/fpu.h:		current->flags |= PF_USEDFPU;
asm-mips64/fpu.h:		current->flags &= ~PF_USEDFPU;
asm-mips64/fpu.h:		return (unsigned long *)&tsk->thread.fpu.hard.fp_regs[0];
asm-mips64/fpu.h:		return (unsigned long *)tsk->thread.fpu.soft.regs;
asm-mips64/gfx.h: * This is the user-visible SGI GFX interface.
asm-mips64/gfx.h: * any kernel-only bits on it.
asm-mips64/ide.h: * Copyright (C) 1994-1996  Linus Torvalds & authors
asm-mips64/ide.h:	return ide_ops->ide_default_irq(base);
asm-mips64/ide.h:	return ide_ops->ide_default_io_base(index);
asm-mips64/ide.h:	ide_ops->ide_init_hwif_ports(hw, data_port, ctrl_port, irq);
asm-mips64/ide.h:#define ide_ack_intr(hwif)    ((hwif)->hw.ack_intr ? (hwif)->hw.ack_intr(hwif) : 1)
asm-mips64/ide.h:/* MIPS port and memory-mapped I/O string operations.  */
asm-mips64/ide.h:	while (count--) {
asm-mips64/ide.h:	while (count--) {
asm-mips64/ide.h:	while (count--) {
asm-mips64/ide.h:	while (count--) {
asm-mips64/irq.h: * since bits 0-6 are pre-allocated for other purposes.
asm-mips64/pci.h:   already-configured bus numbers - to be used for buggy BIOSes
asm-mips64/pci.h: * NULL for PCI-like buses (ISA, EISA).
asm-mips64/pci.h: * Returns non-NULL cpu-view pointer to the buffer if successful and
asm-mips64/pci.h: * The 32-bit bus address to use is returned.
asm-mips64/pci.h:	return bus_to_baddr(hwdev->bus, __pa(ptr));
asm-mips64/pci.h:		addr = baddr_to_bus(hwdev->bus, dma_addr) + PAGE_OFFSET;
asm-mips64/pci.h:	return bus_to_baddr(hwdev->bus, page_to_phys(page) + offset);
asm-mips64/pci.h:		addr = baddr_to_bus(hwdev->bus, dma_address) + PAGE_OFFSET;
asm-mips64/pci.h: * mode for DMA.  This is the scather-gather version of the
asm-mips64/pci.h:		if (sg->address && sg->page)
asm-mips64/pci.h:		else if (!sg->address && !sg->page)
asm-mips64/pci.h:		if (sg->address) {
asm-mips64/pci.h:			dma_cache_wback_inv((unsigned long)sg->address,
asm-mips64/pci.h:			                    sg->length);
asm-mips64/pci.h:			sg->dma_address = bus_to_baddr(hwdev->bus, __pa(sg->address));
asm-mips64/pci.h:			sg->dma_address = page_to_bus(sg->page) +
asm-mips64/pci.h:			                  sg->offset;
asm-mips64/pci.h:				(page_address(sg->page) + sg->offset),
asm-mips64/pci.h:				sg->length);
asm-mips64/pci.h:		if (sg->address && sg->page)
asm-mips64/pci.h:		else if (!sg->address && !sg->page)
asm-mips64/pci.h:		if (!sg->address)
asm-mips64/pci.h:		dma_cache_wback_inv((unsigned long)sg->address, sg->length);
asm-mips64/pci.h:	addr = baddr_to_bus(hwdev->bus, dma_handle) + PAGE_OFFSET;
asm-mips64/pci.h: * The same as pci_dma_sync_single but for a scatter-gather list,
asm-mips64/pci.h:		dma_cache_wback_inv((unsigned long)sg->address, sg->length);
asm-mips64/pci.h: * only drive the low 24-bits during PCI bus mastering, then
asm-mips64/pci.h:	return (dma64_addr_t) bus_to_baddr(pdev->bus, addr);
asm-mips64/pci.h:	unsigned long poff = baddr_to_bus(pdev->bus, dma_addr) >> PAGE_SHIFT;
asm-mips64/pci.h:	addr = baddr_to_bus(pdev->bus, dma_addr) + PAGE_OFFSET;
asm-mips64/pci.h:#define sg_dma_address(sg)	((sg)->dma_address)
asm-mips64/pci.h:#define sg_dma_len(sg)		((sg)->length)
asm-mips64/m48t35.h: *  Registers for the SGS-Thomson M48T35 Timekeeper RAM chip
asm-mips64/fpregdef.h: * Copyright (C) 1990 - 1992, 1999 Silicon Graphics, Inc.
asm-mips64/reg.h: * This defines/structures correspond to the register layout on stack -
asm-mips64/reg.h: * include/asm-mips/stackframe.h
asm-mips64/cacheops.h: * Cache Operations available on all MIPS processors with R4000-style caches
asm-mips64/cacheops.h: * R4000-specific cacheops
asm-mips64/cacheops.h: * R4000SC and R4400SC-specific cacheops
asm-mips64/cacheops.h: * R5000-specific cacheops
asm-mips64/cacheops.h: * RM7000-specific cacheops
asm-mips64/cacheops.h: * R1000-specific cacheops
asm-mips64/cacheops.h: * Cacheops 0x02, 0x06, 0x0a, 0x0c-0x0e, 0x16, 0x1a and 0x1e are unused.
asm-mips64/smp.h: * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
asm-mips64/smp.h: * Copyright (C) 2000 - 2001 by Kanoj Sarcar (kanoj@sgi.com)
asm-mips64/smp.h: * Copyright (C) 2000 - 2001 by Silicon Graphics, Inc.
asm-mips64/smp.h:#define smp_processor_id()	(current->processor)
asm-mips64/smp.h:   not be idempotent when cpus failed to come on-line.  */
asm-mips64/smp.h:#define NO_PROC_ID	(-1)
asm-mips64/smp.h:/* These are defined by the board-specific code. */
asm-mips64/tlb.h:#include <asm-generic/tlb.h>
asm-mips64/war.h: * interrupts during indexed I-cache flushes seems to be sufficient to deal
asm-mips64/war.h: * pre-conditions for this problem.
asm-mips64/xor.h:#include <asm-generic/xor.h>
asm-mips64/xtalk/xtalk.h: * xtalk.h -- platform-independent crosstalk interface, derived from
asm-mips64/xtalk/xtalk.h: * Copyright (C) 1995 - 1997, 1999 Silcon Graphics, Inc.
asm-mips64/xtalk/xtalk.h: * User-level device driver visible types
asm-mips64/xtalk/xtalk.h:#define XWIDGET_NONE		-1
asm-mips64/xtalk/xtalk.h:#define XWIDGET_PART_NUM_NONE	-1
asm-mips64/xtalk/xtalk.h:#define XWIDGET_REV_NUM_NONE	-1
asm-mips64/xtalk/xtalk.h:#define XWIDGET_MFG_NUM_NONE	-1
asm-mips64/xtalk/xwidget.h: * xwidget.h - generic crosstalk widget header file, derived from IRIX
asm-mips64/xtalk/xwidget.h: * according to the crosstalk spec, only 32-bits access to the widget
asm-mips64/xtalk/xwidget.h: * configuration registers is allowed.  some widgets may allow 64-bits
asm-mips64/xtalk/xwidget.h:	(((hwid1)->part_num == (hwid2)->part_num) && \
asm-mips64/xtalk/xwidget.h:	(((hwid1)->mfg_num == XWIDGET_MFG_NUM_NONE) || \
asm-mips64/xtalk/xwidget.h:	((hwid2)->mfg_num == XWIDGET_MFG_NUM_NONE) || \
asm-mips64/xtalk/xwidget.h:	((hwid1)->mfg_num == (hwid2)->mfg_num)))
asm-mips64/branch.h:	return regs->cp0_cause & CAUSEF_BD;
asm-mips64/branch.h:		return regs->cp0_epc;
asm-mips64/branch.h:	return regs->cp0_epc + 4;
asm-mips64/branch.h:		regs->cp0_epc += 4;
asm-mips64/signal.h: * Copyright (C) 1995 - 1999 by Ralf Baechle
asm-mips64/signal.h:#define SIGFPE		 8	/* Floating-point exception (ANSI).  */
asm-mips64/signal.h:#define SIGUSR1		16	/* User-defined signal 1 (POSIX).  */
asm-mips64/signal.h:#define SIGUSR2		17	/* User-defined signal 2 (POSIX).  */
asm-mips64/signal.h:#define SIGRTMAX	(_NSIG-1)
asm-mips64/signal.h: * SA_INTERRUPT is a no-op, but left due to historical reasons. Use the
asm-mips64/signal.h:#define SA_INTERRUPT	0x20000000	/* dummy -- ignored */
asm-mips64/signal.h:#define SIG_ERR	((__sighandler_t)-1)	/* error return from signal */
asm-mips64/signal.h: * non-Linux/MIPS object files or make use of them in the future.
asm-mips64/signal.h:#define BRK_BD_TAKEN	3	/* For bd slot emulation - not implemented */
asm-mips64/signal.h:#define BRK_BD_NOTTAKEN	4	/* For bd slot emulation - not implemented */
asm-mips64/signal.h:#define BRK_NORLD	10	/* No rld found - not used by Linux/MIPS */
asm-mips64/fpu_emulator.h: *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm-mips64/hardirq.h: * Copyright (C) 1997 - 2000, 2001 by Ralf Baechle
asm-mips64/hardirq.h:#define irq_exit(cpu, irq)	(local_irq_count(cpu)--)
asm-mips64/hardirq.h:	--local_irq_count(cpu);
asm-mips64/shmiq.h:        volatile unsigned int flags; /* place for out-of-band data */
asm-mips64/shmiq.h:/* -------------------- iDev stuff -------------------- */
asm-mips64/shmiq.h:/* These are only interpreted by SHMIQ-attacheable devices and are internal
asm-mips64/mv64340.h:* mv64340.h - MV-64340 Internal registers definition file.
asm-mips64/processor.h:#define MIPS_CACHE_IC_F_DC	0x00000008	/* Ic can refill from D-cache */
asm-mips64/processor.h:	cnodeid_t	p_nodeid;	/* my node ID in compact-id-space */
asm-mips64/processor.h:	nasid_t		p_nasid;	/* my node ID in numa-as-id-space */
asm-mips64/processor.h:	hub_intmasks_t	p_intmasks;	/* SN0 per-CPU interrupt masks */
asm-mips64/processor.h:	struct cache_desc icache;	/* Primary I-cache */
asm-mips64/processor.h:#define TASK_UNMAPPED_BASE	((current->thread.mflags & MF_32BIT_ADDR) ? \
asm-mips64/processor.h: * Size of io_bitmap in longwords: 32 is ports 0-0x3ff.
asm-mips64/processor.h: * the FPU emulator for now.  See asm-mips/fpu_emulator.h.
asm-mips64/processor.h:#define MF_32BIT_ADDR	8		/* 32-bit address space (o32/n32) */
asm-mips64/processor.h:	if (t->reg31 == (unsigned long) ret_from_sys_call)
asm-mips64/processor.h:		return t->reg31;
asm-mips64/processor.h:	return ((unsigned long *)t->reg29)[schedule_frame.pc_offset];
asm-mips64/processor.h:#define user_mode(regs)	(((regs)->cp0_status & ST0_KSU) == KSU_USER)
asm-mips64/processor.h:#define __PT_REG(reg) ((long)&((struct pt_regs *)0)->reg - sizeof(struct pt_regs))
asm-mips64/processor.h:#define __KSTK_TOS(tsk) ((unsigned long)(tsk) + KERNEL_STACK_SIZE - 32)
asm-mips64/processor.h:#define THREAD_MASK		(THREAD_SIZE - 1UL)
asm-mips64/processor.h:#define get_task_struct(tsk)	atomic_inc(&virt_to_page(tsk)->count)
asm-mips64/processor.h: * (MIPS, Alpha) or is unuseable with -fomit-frame-pointer (i386).
asm-mips64/processor.h: * __builtin_return_address works only for non-leaf functions.  We avoid the
asm-mips64/linux_logo.h: * include/asm-mips/linux_logo.h: This is a linux logo
asm-mips64/mmu_context.h: * use the processor id via current->processor, where current is stored
asm-mips64/mmu_context.h:#define cpu_context(cpu, mm)	((mm)->context[cpu])
asm-mips64/mmu_context.h:#define ASID_VERSION_MASK  ((unsigned long)~(ASID_MASK|(ASID_MASK-1)))
asm-mips64/mmu_context.h:	TLBMISS_HANDLER_SETUP_PGD(next->pgd);
asm-mips64/mmu_context.h:	 * Mark current->active_mm as not "active" anymore.
asm-mips64/mmu_context.h:	clear_bit(cpu, &prev->cpu_vm_mask);
asm-mips64/mmu_context.h:	set_bit(cpu, &next->cpu_vm_mask);
asm-mips64/mmu_context.h: * After we have set current->mm to a new value, this activates
asm-mips64/mmu_context.h:	TLBMISS_HANDLER_SETUP_PGD(next->pgd);
asm-mips64/mmu_context.h:	clear_bit(cpu, &prev->cpu_vm_mask);
asm-mips64/mmu_context.h:	set_bit(cpu, &next->cpu_vm_mask);
asm-mips64/mmu_context.h:	if (test_bit(cpu, &mm->cpu_vm_mask))  {
asm-mips64/sysmips.h: * sysmips(2) is deprecated - though some existing software uses it.
asm-mips64/semaphore.h:	atomic_set(&sem->count, val);
asm-mips64/semaphore.h:	atomic_set(&sem->waking, 0);
asm-mips64/semaphore.h:	init_waitqueue_head(&sem->wait);
asm-mips64/semaphore.h:	sem->__magic = (long)&sem->__magic;
asm-mips64/semaphore.h: * sem->count and sem->waking atomic.
asm-mips64/semaphore.h:	CHECK_MAGIC(sem->__magic);
asm-mips64/semaphore.h:	count = atomic_dec_return(&sem->count);
asm-mips64/semaphore.h: * it, return zero.  If we were interrupted, returns -EINTR
asm-mips64/semaphore.h:	CHECK_MAGIC(sem->__magic);
asm-mips64/semaphore.h:	count = atomic_dec_return(&sem->count);
asm-mips64/semaphore.h: * Here, we do this by using lld/scd on the pair of 32-bit words.
asm-mips64/semaphore.h: *   Decrement(sem->count)
asm-mips64/semaphore.h: *   If(sem->count >=0) {
asm-mips64/semaphore.h: *	If(sem->waking <= 0) {		// if no wakeup pending
asm-mips64/semaphore.h: *	   Increment(sem->count)	// undo decrement
asm-mips64/semaphore.h: *	   Decrement(sem->waking)	// otherwise "steal" wakeup
asm-mips64/semaphore.h:	CHECK_MAGIC(sem->__magic);
asm-mips64/semaphore.h:	"	dli	%3, 0x0000000100000000	# count -= 1		\n"
asm-mips64/semaphore.h:	"	blez	%2, 1f			# if waking < 0 -> 1f	\n"
asm-mips64/semaphore.h:	"	daddiu	%1, %1, -1		# waking -= 1		\n"
asm-mips64/semaphore.h:	CHECK_MAGIC(sem->__magic);
asm-mips64/semaphore.h:	"	dsll32 %1, %1, 0	# zero-extend %1	\n"
asm-mips64/semaphore.h: * Non-blockingly attempt to down() a semaphore.
asm-mips64/semaphore.h:	CHECK_MAGIC(sem->__magic);
asm-mips64/semaphore.h:	count = atomic_read(&sem->count) - 1;
asm-mips64/semaphore.h:	atomic_set(&sem->count, count);
asm-mips64/semaphore.h:		waking = atomic_read(&sem->waking);
asm-mips64/semaphore.h:			atomic_set(&sem->count, count + 1);
asm-mips64/semaphore.h:			atomic_set(&sem->waking, waking - 1);
asm-mips64/semaphore.h:	CHECK_MAGIC(sem->__magic);
asm-mips64/semaphore.h:	count = atomic_read(&sem->count) + 1;
asm-mips64/semaphore.h:	waking = atomic_read(&sem->waking);
asm-mips64/semaphore.h:	atomic_set(&sem->count, count);
asm-mips64/semaphore.h:	atomic_set(&sem->waking, waking);
asm-mips64/semaphore.h:	return atomic_read(&sem->count);
asm-mips64/fcntl.h:/* open/fcntl - O_SYNC is only implemented on blocks devices and on files
asm-mips64/fcntl.h:#define F_GETFL		3	/* get file->f_flags */
asm-mips64/fcntl.h:#define F_SETFL		4	/* set file->f_flags */
asm-mips64/fcntl.h:struct flock32 {				/* for 32-bit compat code */
asm-mips64/mmzone.h:#define PLAT_NODE_DATA_STARTNR(n)    (PLAT_NODE_DATA(n)->gendata.node_start_mapnr)
asm-mips64/mmzone.h:#define PLAT_NODE_DATA_SIZE(n)	     (PLAT_NODE_DATA(n)->gendata.node_size)
asm-mips64/mmzone.h:		(((p) - PLAT_NODE_DATA(n)->gendata.node_start_paddr) >> PAGE_SHIFT)
asm-mips64/mmzone.h:#define numa_node_id()	cputocnode(current->processor)
asm-mips64/mmzone.h:	((NASID_TO_COMPACT_NODEID(NASID_GET(__pa(kaddr))) != -1) ? \
asm-mips64/mmzone.h:	numa_debug(), -1))
asm-mips64/mmzone.h:#define NODE_DATA(n)	(&((PLAT_NODE_DATA(n))->gendata))
asm-mips64/mmzone.h:#define NODE_MEM_MAP(nid)	(NODE_DATA(nid)->node_mem_map)
asm-mips64/mmzone.h:#define LOCAL_BASE_ADDR(kaddr)	((unsigned long)(kaddr) & ~(NODE_MAX_MEM_SIZE-1))
asm-mips64/mmzone.h:	(((unsigned long)(kvaddr)-LOCAL_BASE_ADDR((kvaddr))) >> PAGE_SHIFT)
asm-mips64/mmzone.h:		(((unsigned long)ADDR_TO_MAPBASE((kaddr)) - PAGE_OFFSET) / \
asm-mips64/mmzone.h:	-1) ? 0 : (test_bit(LOCAL_MAP_NR((addr)), \
asm-mips64/mmzone.h:	NODE_DATA(KVADDR_TO_NID((unsigned long)addr))->valid_addr_bitmap)))
asm-mips64/mmzone.h:#define VALID_PAGE(page)	((page - mem_map) < max_mapnr)
asm-mips64/module.h: * modutils/obj/obj-mips64.c
asm-mips64/module.h:	archdata = (struct archdata *)(mod->archdata_start);
asm-mips64/module.h:	if (archdata->dbe_table_start > archdata->dbe_table_end ||
asm-mips64/module.h:	    (archdata->dbe_table_start &&
asm-mips64/module.h:	     !((unsigned long)archdata->dbe_table_start >=
asm-mips64/module.h:	       ((unsigned long)mod + mod->size_of_struct) &&
asm-mips64/module.h:	       ((unsigned long)archdata->dbe_table_end <
asm-mips64/module.h:	        (unsigned long)mod + mod->size))) ||
asm-mips64/module.h:            (((unsigned long)archdata->dbe_table_start -
asm-mips64/module.h:	      (unsigned long)archdata->dbe_table_end) %
asm-mips64/module.h:			"module_arch_init: archdata->dbe_table_* invalid.\n");
asm-mips64/module.h:	mod->archdata_start = (char *)&archdata;
asm-mips64/module.h:	mod->archdata_end = mod->archdata_start + sizeof(archdata);
asm-mips64/pgtable-bits.h: * Copyright (C) 1994 - 2002 by Ralf Baechle
asm-mips64/spinlock.h:#define spin_lock_init(x)	do { (x)->lock = 0; } while(0)
asm-mips64/spinlock.h:#define spin_is_locked(x)	((x)->lock != 0)
asm-mips64/spinlock.h:#define spin_unlock_wait(x)	do { barrier(); } while ((x)->lock)
asm-mips64/spinlock.h:	: "=m" (lock->lock), "=&r" (tmp)
asm-mips64/spinlock.h:	: "m" (lock->lock)
asm-mips64/spinlock.h:	: "=m" (lock->lock)
asm-mips64/spinlock.h:	: "m" (lock->lock)
asm-mips64/spinlock.h:	: "=&r" (temp), "=m" (lock->lock), "=&r" (res)
asm-mips64/spinlock.h:	: "r" (1), "m" (lock->lock)
asm-mips64/spinlock.h: * Read-write spinlocks, allowing multiple readers but only one writer.
asm-mips64/spinlock.h: * writers. For those circumstances we can "mix" irq-safe locks - any writer
asm-mips64/spinlock.h: * needs to get a irq-safe write-lock, but readers can get non-irqsafe
asm-mips64/spinlock.h: * read-locks.
asm-mips64/spinlock.h:	: "=m" (rw->lock), "=&r" (tmp)
asm-mips64/spinlock.h:	: "m" (rw->lock)
asm-mips64/spinlock.h:	: "=m" (rw->lock), "=&r" (tmp)
asm-mips64/spinlock.h:	: "m" (rw->lock)
asm-mips64/spinlock.h:	: "=m" (rw->lock), "=&r" (tmp)
asm-mips64/spinlock.h:	: "m" (rw->lock)
asm-mips64/spinlock.h:	: "=m" (rw->lock)
asm-mips64/spinlock.h:	: "m" (rw->lock)
asm-mips64/errno.h:#define	EXDEV		18	/* Cross-device link */
asm-mips64/errno.h:#define	EROFS		30	/* Read-only file system */
asm-mips64/errno.h:#define	ENOTSOCK	95	/* Socket operation on non-socket */
asm-mips64/hazards.h: * mtc0->mfc0 hazard
asm-mips64/hazards.h: * mtc0->mfc0 hazard
asm-mips64/hazards.h: * R10000 rocks - all hazards handled in hardware, so this becomes a nobrainer.
asm-mips64/hazards.h: * care about the irq_enable_hazard - sooner or later the hardware will
asm-mips64/usioctl.h: * usema/usemaclone-related stuff.
asm-mips64/softirq.h:	local_bh_count(cpu)--;
asm-mips64/softirq.h:	if (!--local_bh_count(cpu) && softirq_pending(cpu))	\
asm-mips64/bugs.h: * This is included by init/main.c to check for architecture-dependent bugs.
asm-mips64/namei.h: * Look at asm-sparc/namei.h for details.
asm-mips64/termbits.h:#define VKILL		 3		/* Kill-line character [ICANON].  */
asm-mips64/termbits.h:#define VTIME		 5		/* Time-out value (tenths of a second) [!ICANON].  */
asm-mips64/termbits.h:#define VSTART		 8		/* Start (X-ON) character [IXON, IXOFF].  */
asm-mips64/termbits.h:#define VSTOP		 9		/* Stop (X-OFF) character [IXON, IXOFF].  */
asm-mips64/termbits.h:#define VREPRINT	12		/* Reprint-line character [ICANON].  */
asm-mips64/termbits.h:#define VWERASE		14		/* Word-erase character [ICANON].  */
asm-mips64/termbits.h:#define VLNEXT		15		/* Literal-next character [IEXTEN].  */
asm-mips64/termbits.h:#define VEOF		16		/* End-of-file character [ICANON].  */
asm-mips64/termbits.h:#define VEOL		17		/* End-of-line character [ICANON].  */
asm-mips64/termbits.h:#define ONLCR	0000004		/* Map NL to CR-NL on output.  */
asm-mips64/riscos-syscall.h: * The syscalls 0 - 3999 are reserved for a down to the root syscall
asm-mips64/init.h:#error "<asm/init.h> should never be used - use <linux/init.h> instead"
asm-mips64/inst.h:	 * The others (0x14 - 0x1f) are unused.
asm-mips64/inst.h: * Damn ...  bitfields depend from byteorder :-(
asm-mips64/uaccess.h:#define __UA_LIMIT	(- TASK_SIZE)
asm-mips64/uaccess.h: * userspace address.  Note that we limit 32-bit userspace to 0x7fff8000 but
asm-mips64/uaccess.h: * we use 0x80000000 here on 32-bit kernels.  If a process passes an invalid
asm-mips64/uaccess.h: * address in this range it's the process's problem, not ours :-)
asm-mips64/uaccess.h:#define get_fs()	(current->thread.current_ds)
asm-mips64/uaccess.h:#define set_fs(x)	(current->thread.current_ds = (x))
asm-mips64/uaccess.h: *  - "addr" doesn't have any high-bits set
asm-mips64/uaccess.h: *  - AND "size" doesn't have any high-bits set
asm-mips64/uaccess.h: *  - AND "addr+size" doesn't have any high-bits set
asm-mips64/uaccess.h: *  - OR we are in kernel mode.
asm-mips64/uaccess.h: * access_ok: - Checks if a user space pointer is valid
asm-mips64/uaccess.h: *        %VERIFY_WRITE is a superset of %VERIFY_READ - if it is safe
asm-mips64/uaccess.h: * checks that the pointer is in the user space range - after calling
asm-mips64/uaccess.h: * this function, memory access functions may still return -EFAULT.
asm-mips64/uaccess.h: * verify_area: - Obsolete, use access_ok()
asm-mips64/uaccess.h: * Returns zero if the memory block may be valid, -EFAULT
asm-mips64/uaccess.h:	return access_ok(type, addr, size) ? 0 : -EFAULT;
asm-mips64/uaccess.h: * put_user: - Write a simple value into user space.
asm-mips64/uaccess.h: * @ptr must have pointer-to-simple-variable type, and @x must be assignable
asm-mips64/uaccess.h: * Returns zero on success, or -EFAULT on error.
asm-mips64/uaccess.h: * get_user: - Get a simple variable from user space.
asm-mips64/uaccess.h: * @ptr must have pointer-to-simple-variable type, and the result of
asm-mips64/uaccess.h: * Returns zero on success, or -EFAULT on error.
asm-mips64/uaccess.h: * __put_user: - Write a simple value into user space, with less checking.
asm-mips64/uaccess.h: * @ptr must have pointer-to-simple-variable type, and @x must be assignable
asm-mips64/uaccess.h: * Returns zero on success, or -EFAULT on error.
asm-mips64/uaccess.h: * __get_user: - Get a simple variable from user space, with less checking.
asm-mips64/uaccess.h: * @ptr must have pointer-to-simple-variable type, and the result of
asm-mips64/uaccess.h: * Returns zero on success, or -EFAULT on error.
asm-mips64/uaccess.h:	: "0" (__gu_err), "o" (__m(__gu_addr)), "i" (-EFAULT));		\
asm-mips64/uaccess.h:	  "o" (__m(__gu_addr + 4)), "i" (-EFAULT));			\
asm-mips64/uaccess.h:	  "i" (-EFAULT));						\
asm-mips64/uaccess.h:	  "o" (__m(__pu_addr + 4)), "i" (-EFAULT));			\
asm-mips64/uaccess.h: * __copy_to_user: - Copy a block of data into user space, with less checking.
asm-mips64/uaccess.h: * copy_to_user: - Copy a block of data into user space.
asm-mips64/uaccess.h: * __copy_from_user: - Copy a block of data from user space, with less checking. * @to:   Destination address, in kernel space.
asm-mips64/uaccess.h: * copy_from_user: - Copy a block of data from user space.
asm-mips64/uaccess.h: * __clear_user: - Zero a block of memory in user space, with less checking.
asm-mips64/uaccess.h: * __strncpy_from_user: - Copy a NUL terminated string from userspace, with less checking.
asm-mips64/uaccess.h: * Copies a NUL-terminated string from userspace to kernel space.
asm-mips64/uaccess.h: * If access to userspace fails, returns -EFAULT (some data may have been
asm-mips64/uaccess.h: * strncpy_from_user: - Copy a NUL terminated string from userspace.
asm-mips64/uaccess.h: * Copies a NUL-terminated string from userspace to kernel space.
asm-mips64/uaccess.h: * If access to userspace fails, returns -EFAULT (some data may have been
asm-mips64/uaccess.h: * strlen_user: - Get the size of a string in user space.
asm-mips64/uaccess.h: * Get the size of a NUL-terminated string in user space.
asm-mips64/uaccess.h: * strlen_user: - Get the size of a string in user space.
asm-mips64/uaccess.h: * Get the size of a NUL-terminated string in user space.
asm-mips64/traps.h: *	include/asm-mips64/traps.h
asm-mips64/mman.h:/* These are linux-specific */
asm-mips64/mman.h:#define MAP_GROWSDOWN	0x1000		/* stack-like segment */
asm-mips64/mman.h:#define MADV_NORMAL	0x0		/* default page-in behavior */
asm-mips64/mman.h:#define MADV_RANDOM	0x1		/* page-in minimum required */
asm-mips64/mman.h:#define MADV_SEQUENTIAL	0x2		/* read-ahead aggressively */
asm-mips64/mman.h:#define MADV_WILLNEED	0x3		/* pre-fault pages */
asm-mips64/addrspace.h: *  32-bit MIPS address spaces
asm-mips64/addrspace.h:#define TO_PHYS_MASK		0x0000000fffffffff	/* 2^^36 - 1 */
asm-mips64/addrspace.h:#define TO_PHYS_MASK		0x000000ffffffffff	/* 2^^40 - 1 */
asm-mips64/addrspace.h:#define TO_PHYS_MASK		0x000000ffffffffff	/* 2^^40 - 1 */
asm-mips64/addrspace.h:#define PHYS_TO_COMPATK1(x)	((x) | COMPAT_K1BASE32) /* 32-bit compat k1 */
asm-mips64/posix_types.h: * This file is generally used by user-level software, so you need to
asm-mips64/posix_types.h:	__fdsetp->fds_bits[__tmp] |= (1UL<<__rem);
asm-mips64/posix_types.h:	__fdsetp->fds_bits[__tmp] &= ~(1UL<<__rem);
asm-mips64/posix_types.h:	return (__p->fds_bits[__tmp] & (1UL<<__rem)) != 0;
asm-mips64/posix_types.h: * for a 256-bit fd_set)
asm-mips64/posix_types.h:	unsigned long *__tmp = __p->fds_bits;
asm-mips64/posix_types.h:		__i--;
asm-mips64/smplock.h:	if (task->lock_depth >= 0)
asm-mips64/smplock.h: * Re-acquire the kernel lock
asm-mips64/smplock.h:	if (task->lock_depth >= 0)
asm-mips64/smplock.h:	if (!++current->lock_depth)
asm-mips64/smplock.h:	if (--current->lock_depth < 0)
asm-mips64/mv64340_dep.h: * include/asm-mips/mv64340-dep.h
asm-mips64/mv64340_dep.h: *     Board-dependent definitions for MV-64340 chip.
asm-mips64/page.h: * Copyright (C) 1994 - 1999, 2000 by Ralf Baechle
asm-mips64/page.h:#define PAGE_MASK	(~(PAGE_SIZE-1))
asm-mips64/page.h: * These are used to make use of C type-checking..
asm-mips64/page.h:	size = (size-1) >> (PAGE_SHIFT-1);
asm-mips64/page.h:	order = -1;
asm-mips64/page.h:#define PAGE_ALIGN(addr)	(((addr)+PAGE_SIZE-1)&PAGE_MASK)
asm-mips64/page.h:#define __pa(x)		((unsigned long) (x) - PAGE_OFFSET)
asm-mips64/page.h:#define VALID_PAGE(page)	((page - mem_map) < max_mapnr)
asm-mips64/page.h:#define UNCAC_ADDR(addr)	((addr) - PAGE_OFFSET + UNCAC_BASE)
asm-mips64/page.h:#define CAC_ADDR(addr)		((addr) - UNCAC_BASE + PAGE_OFFSET)
asm-mips64/gt64120/gt64120.h: *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm-mips64/gt64120/gt64120.h:#define MSK(n)                    ((1 << (n)) - 1)
asm-mips64/gt64120/gt64120.h: *   GT_WRITE(ofs, data)           - read/write GT64120 registers in 32bit
asm-mips64/gt64120/gt64120.h: *   TIMER 	- gt64120 timer irq, temporary solution until
asm-mips64/gt64120/gt64120.h:#include <asm/gt64120/mips-boards/gt64120_dep.h>
asm-mips64/gt64120/gt64120.h:#include <asm/gt64120/mips-boards/gt64120_dep.h>
asm-mips64/gt64120/gt64120.h: * bytes when running bigendian.  We also provide non-swapping versions.
asm-mips64/gt64120/gt64120.h: * Board-dependent functions, which must be defined in
asm-mips64/hdreg.h: *  Copyright (C) 1994-1996  Linus Torvalds & authors
asm-mips64/poll.h:/* XXX This one seems to be more-or-less nonstandard.  */
asm-mips64/sembuf.h: * - 2 miscellaneous 64-bit values
asm-mips64/sibyte/sb1250_dma.h:    *  MA 02111-1307 USA
asm-mips64/sibyte/sb1250_dma.h: * Ethernet and Serial DMA Configuration Register 0  (Table 7-4)
asm-mips64/sibyte/sb1250_dma.h: * Ethernet and Serial DMA Configuration Register 1 (Table 7-5)
asm-mips64/sibyte/sb1250_dma.h: * Ethernet and Serial DMA Descriptor base address (Table 7-6)
asm-mips64/sibyte/sb1250_dma.h: * ASIC Mode Base Address (Table 7-7)
asm-mips64/sibyte/sb1250_dma.h: * DMA Descriptor Count Registers (Table 7-8)
asm-mips64/sibyte/sb1250_dma.h: * Current Descriptor Address Register (Table 7-11)
asm-mips64/sibyte/sb1250_dma.h: * Descriptor doubleword "A"  (Table 7-12)
asm-mips64/sibyte/sb1250_dma.h: * Descriptor doubleword "B"  (Table 7-13)
asm-mips64/sibyte/sb1250_dma.h: * Ethernet Descriptor Status Bits (Table 7-15)
asm-mips64/sibyte/sb1250_dma.h: * Ethernet Transmit Status Bits (Table 7-16)
asm-mips64/sibyte/sb1250_dma.h: * Ethernet Transmit Options (Table 7-17)
asm-mips64/sibyte/sb1250_dma.h: * Serial Receive Options (Table 7-18)
asm-mips64/sibyte/sb1250_dma.h: * Serial Transmit Status Bits (Table 7-20)
asm-mips64/sibyte/sb1250_dma.h: * Serial Transmit Options (Table 7-21)
asm-mips64/sibyte/sb1250_dma.h: * Data Mover Descriptor Base Address Register (Table 7-22)
asm-mips64/sibyte/sb1250_dma.h: * Data Mover Descriptor Count Register (Table 7-25)
asm-mips64/sibyte/sb1250_dma.h: * Data Mover Current Descriptor Address (Table 7-24)
asm-mips64/sibyte/sb1250_dma.h: * Data Mover Descriptor Doubleword "A"  (Table 7-26)
asm-mips64/sibyte/sb1250_dma.h: * Data Mover Descriptor Doubleword "B"  (Table 7-25)
asm-mips64/sibyte/sb1250_l2c.h:    *  MA 02111-1307 USA
asm-mips64/sibyte/sb1250_l2c.h: * Level 2 Cache Tag register (Table 5-3)
asm-mips64/sibyte/sb1250_l2c.h: * Format of level 2 cache management address (table 5-2)
asm-mips64/sibyte/sb1250_int.h:    *  MA 02111-1307 USA
asm-mips64/sibyte/sb1250_int.h: * Interrupt sources (Table 4-8, UM 0.2)
asm-mips64/sibyte/sb1250_int.h: * LDT Interrupt Set Register (table 4-5)
asm-mips64/sibyte/sb1250_int.h: * Vector format (Table 4-6)
asm-mips64/sibyte/sb1250_ldt.h:    *  MA 02111-1307 USA
asm-mips64/sibyte/sb1250_ldt.h: * LDT Command Register (Table 8-13)
asm-mips64/sibyte/sb1250_ldt.h: * LDT Status Register (Table 8-14).  Note that these constants
asm-mips64/sibyte/sb1250_ldt.h: * together (32-bit read at offset 0x04)
asm-mips64/sibyte/sb1250_ldt.h: * register (Table 8-15), offset 0x1C
asm-mips64/sibyte/sb1250_ldt.h: * Bridge Control Register (Table 8-16).  Note that these 
asm-mips64/sibyte/sb1250_ldt.h: * constants assume you've read the register as a 32-bit 
asm-mips64/sibyte/sb1250_ldt.h: * LDT Command Register (Table 8-17).  Note that these constants
asm-mips64/sibyte/sb1250_ldt.h: * 32-bit read at offset 0x40
asm-mips64/sibyte/sb1250_ldt.h: * LDT link control register (Table 8-18), and (Table 8-19)
asm-mips64/sibyte/sb1250_ldt.h: * LDT Link frequency register  (Table 8-20) offset 0x48
asm-mips64/sibyte/sb1250_ldt.h: * LDT SRI Command Register (Table 8-21).  Note that these constants
asm-mips64/sibyte/sb1250_ldt.h: * 32-bit read at offset 0x50
asm-mips64/sibyte/sb1250_ldt.h: * LDT Error control and status register (Table 8-22) (Table 8-23)
asm-mips64/sibyte/sb1250_ldt.h: * SRI Control register (Table 8-24, 8-25)  Offset 0x6C
asm-mips64/sibyte/sb1250_ldt.h: * LDT SRI Transmit Buffer Count register (Table 8-26)
asm-mips64/sibyte/sb1250_mac.h:    *  MA 02111-1307 USA
asm-mips64/sibyte/sb1250_mac.h: * MAC Configuration Register (Table 9-13)
asm-mips64/sibyte/sb1250_mac.h: * MAC Fifo Threshhold registers (Table 9-14)
asm-mips64/sibyte/sb1250_mac.h: * MAC Frame Configuration Registers (Table 9-15)
asm-mips64/sibyte/sb1250_mac.h: * MAC VLAN Tag Registers (Table 9-16)
asm-mips64/sibyte/sb1250_mac.h: * MAC Status Registers (Table 9-17)
asm-mips64/sibyte/sb1250_mac.h: * Also used for the MAC Interrupt Mask Register (Table 9-18)
asm-mips64/sibyte/sb1250_mac.h: *  and pass just the six bits to a DMA-channel-specific ISR
asm-mips64/sibyte/sb1250_mac.h: * MAC Fifo Pointer Registers (Table 9-19)    [Debug register]
asm-mips64/sibyte/sb1250_mac.h: * MAC Fifo End Of Packet Count Registers (Table 9-20)  [Debug register]
asm-mips64/sibyte/sb1250_mac.h: * MAC Recieve Address Filter Exact Match Registers (Table 9-21)
asm-mips64/sibyte/sb1250_mac.h: * MAC Recieve Address Filter Hash Match Registers (Table 9-22)
asm-mips64/sibyte/sb1250_mac.h: * MAC Transmit Source Address Registers (Table 9-23)
asm-mips64/sibyte/sb1250_mac.h: * MAC Receive Address Filter Control Registers (Table 9-24)
asm-mips64/sibyte/sb1250_mac.h: * MAC Receive Channel Select Registers (Table 9-25)
asm-mips64/sibyte/sb1250_mac.h: * MAC MII Management Interface Registers (Table 9-26)
asm-mips64/sibyte/sb1250_scd.h:    *  MA 02111-1307 USA
asm-mips64/sibyte/sb1250_scd.h: * System Revision Register (Table 4-1)
asm-mips64/sibyte/sb1250_scd.h: * System Config Register (Table 4-2)
asm-mips64/sibyte/sb1250_scd.h: * Mailbox Registers (Table 4-3)
asm-mips64/sibyte/sb1250_scd.h: * Watchdog Registers (Table 4-8) (Table 4-9) (Table 4-10)
asm-mips64/sibyte/sb1250_scd.h: * Timer Registers (Table 4-11) (Table 4-12) (Table 4-13)
asm-mips64/sibyte/trace_prof.h: * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
asm-mips64/sibyte/trace_prof.h: * Routines for using 40-bit SCD cycle counter
asm-mips64/sibyte/trace_prof.h: * zclk_timer_init(0) at least every 2^40 - 1 ZCLKs.
asm-mips64/sibyte/sb1250_syncser.h:    *  MA 02111-1307 USA
asm-mips64/sibyte/sb1250.h: * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
asm-mips64/sibyte/sb1250_mc.h:    *  MA 02111-1307 USA
asm-mips64/sibyte/sb1250_mc.h: * Memory Channel Config Register (table 6-14)
asm-mips64/sibyte/sb1250_mc.h: * Memory clock config register (Table 6-15)
asm-mips64/sibyte/sb1250_mc.h: * DRAM Command Register (Table 6-13)
asm-mips64/sibyte/sb1250_mc.h: * DRAM Mode Register (Table 6-14)
asm-mips64/sibyte/sb1250_mc.h: * SDRAM Timing Register  (Table 6-15)
asm-mips64/sibyte/sb1250_mc.h: * Chip Select Start Address Register (Table 6-17)
asm-mips64/sibyte/sb1250_mc.h: * Chip Select End Address Register (Table 6-18)
asm-mips64/sibyte/sb1250_mc.h: * Chip Select Interleave Register (Table 6-19)
asm-mips64/sibyte/sb1250_mc.h: * Row Address Bits Register (Table 6-20)
asm-mips64/sibyte/sb1250_mc.h: * Column Address Bits Register (Table 6-21)
asm-mips64/sibyte/sb1250_mc.h: * Bank Address Address Bits Register (Table 6-22)
asm-mips64/sibyte/sb1250_mc.h: * Chip Select Attribute Register (Table 6-23)
asm-mips64/sibyte/sb1250_mc.h: * ECC Test ECC Register (Table 6-25)
asm-mips64/sibyte/swarm.h: * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
asm-mips64/sibyte/carmel.h: * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
asm-mips64/sibyte/sb1250_smbus.h:    *  MA 02111-1307 USA
asm-mips64/sibyte/sb1250_smbus.h: * SMBus Clock Frequency Register (Table 14-2)
asm-mips64/sibyte/sb1250_smbus.h: * SMBus control register (Table 14-4)
asm-mips64/sibyte/sb1250_smbus.h: * SMBus status registers (Table 14-5)
asm-mips64/sibyte/sb1250_smbus.h: * SMBus Start/Command registers (Table 14-9)
asm-mips64/sibyte/sb1250_smbus.h: * SMBus Data Register (Table 14-6) and SMBus Extra Register (Table 14-7)
asm-mips64/sibyte/sb1250_smbus.h: * SMBus Packet Error Check register (Table 14-8)
asm-mips64/sibyte/sentosa.h: * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
asm-mips64/sibyte/64bit.h: * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
asm-mips64/sibyte/64bit.h: * This is annoying...we can't actually write the 64-bit IO register properly
asm-mips64/sibyte/64bit.h: * without having access to 64-bit registers...  which doesn't work by default
asm-mips64/sibyte/64bit.h: * driver code for the 32-bit and 64-bit trees
asm-mips64/sibyte/64bit.h: * Avoid interrupt mucking, just adjust the address for 4-byte access.
asm-mips64/sibyte/64bit.h: * Assume the addresses are 8-byte aligned.
asm-mips64/sibyte/sb1250_defs.h:    *  MA 02111-1307 USA
asm-mips64/sibyte/sb1250_defs.h: * 'long long' (64-bit integer) support.
asm-mips64/sibyte/sb1250_defs.h:    ((SIBYTE_HDR_FMASK(chip, pass) - 1) & SIBYTE_HDR_FMASK_ALLREVS(chip))
asm-mips64/sibyte/sb1250_defs.h:     | (SIBYTE_HDR_FMASK(chip, pass) - 1)) & SIBYTE_HDR_FMASK_ALLREVS(chip))
asm-mips64/sibyte/sb1250_defs.h:    *                  For multi-bit fields, all bits in the field will
asm-mips64/sibyte/sb1250_defs.h:    *  K_xxx           "Code" constant (value for data in a multi-bit
asm-mips64/sibyte/sb1250_defs.h:    *  G_xxx(X)        GET value.  This macro obtains a multi-bit field
asm-mips64/sibyte/sb1250_defs.h: * Cast to 64-bit number.  Presumably the syntax is different in 
asm-mips64/sibyte/sb1250_defs.h:#define _SB_MAKEMASK(v,n) (_SB_MAKE64((_SB_MAKE64(1)<<(v))-1) << _SB_MAKE64(n))
asm-mips64/sibyte/sb1250_defs.h:#define _SB_MAKEMASK_32(v,n) (_SB_MAKE32((_SB_MAKE32(1)<<(v))-1) << _SB_MAKE32(n))
asm-mips64/sibyte/sb1250_defs.h: * Macros to read/write on-chip registers
asm-mips64/sibyte/sb1250_genbus.h:    *  MA 02111-1307 USA
asm-mips64/sibyte/sb1250_genbus.h: * Generic Bus Region Configuration Registers (Table 11-4)
asm-mips64/sibyte/sb1250_genbus.h: * Generic Bus Region Size register (Table 11-5)
asm-mips64/sibyte/sb1250_genbus.h: * Generic Bus Region Address (Table 11-6)
asm-mips64/sibyte/sb1250_genbus.h: * Generic Bus Region 0 Timing Registers (Table 11-7)
asm-mips64/sibyte/sb1250_genbus.h: * Generic Bus Timing 1 Registers (Table 11-8)
asm-mips64/sibyte/sb1250_genbus.h: * Generic Bus Interrupt Status Register (Table 11-9)
asm-mips64/sibyte/sb1250_genbus.h: * PCMCIA configuration register (Table 12-6)
asm-mips64/sibyte/sb1250_genbus.h: * PCMCIA status register (Table 12-7)
asm-mips64/sibyte/sb1250_genbus.h: * GPIO Interrupt Type Register (table 13-3)
asm-mips64/sibyte/board.h: * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
asm-mips64/sibyte/sb1250_regs.h:    *  This module contains the addresses of the on-chip peripherals
asm-mips64/sibyte/sb1250_regs.h:    *  MA 02111-1307 USA
asm-mips64/sibyte/sb1250_regs.h:/* Backward-compatibility definitions.  */
asm-mips64/sibyte/sb1250_uart.h:    *  MA 02111-1307 USA
asm-mips64/sibyte/sb1250_uart.h: * DUART Mode Register #1 (Table 10-3)
asm-mips64/sibyte/sb1250_uart.h: * DUART Mode Register #2 (Table 10-4)
asm-mips64/sibyte/sb1250_uart.h: * DUART Command Register (Table 10-5)
asm-mips64/sibyte/sb1250_uart.h: * DUART Status Register (Table 10-6)
asm-mips64/sibyte/sb1250_uart.h: * READ-ONLY
asm-mips64/sibyte/sb1250_uart.h: * DUART Baud Rate Register (Table 10-7)
asm-mips64/sibyte/sb1250_uart.h:#define V_DUART_BAUD_RATE(x)        (100000000/((x)*20)-1)
asm-mips64/sibyte/sb1250_uart.h: * DUART Data Registers (Table 10-8 and 10-9)
asm-mips64/sibyte/sb1250_uart.h: * DUART Input Port Register (Table 10-10)
asm-mips64/sibyte/sb1250_uart.h: * DUART Input Port Change Status Register (Tables 10-11, 10-12, and 10-13)
asm-mips64/sibyte/sb1250_uart.h: * DUART Output port control register (Table 10-14)
asm-mips64/sibyte/sb1250_uart.h: * DUART Aux Control Register (Table 10-15)
asm-mips64/sibyte/sb1250_uart.h: * DUART Interrupt Status Register (Table 10-16)
asm-mips64/sibyte/sb1250_uart.h: * DUART Channel A Interrupt Status Register (Table 10-17)
asm-mips64/sibyte/sb1250_uart.h: * DUART Channel B Interrupt Status Register (Table 10-18)
asm-mips64/sibyte/sb1250_uart.h: * DUART Interrupt Mask Register (Table 10-19)
asm-mips64/sibyte/sb1250_uart.h: * DUART Channel A Interrupt Mask Register (Table 10-20)
asm-mips64/sibyte/sb1250_uart.h: * DUART Channel B Interrupt Mask Register (Table 10-21)
asm-mips64/sibyte/sb1250_uart.h: * DUART Output Port Set Register (Table 10-22)
asm-mips64/sibyte/sb1250_uart.h: * DUART Output Port Clear Register (Table 10-23)
asm-mips64/sibyte/sb1250_uart.h: * DUART Output Port RTS Register (Table 10-24)
asm-mips64/stat.h:/* The memory layout is the same as of struct stat64 of the 32-bit kernel.  */
asm-mips64/time.h: * include/asm-mips/time.h
asm-mips64/time.h: * RTC ops.  By default, they point to no-RTC functions.
asm-mips64/time.h: *	rtc_get_time - mktime(year, mon, day, hour, min, sec) in seconds.
asm-mips64/time.h: *	rtc_set_time - reverse the above translation and set time to RTC.
asm-mips64/time.h: *	rtc_set_mmss - similar to rtc_set_time, but only min and sec need
asm-mips64/time.h: *			to be set.  Used by RTC sync-up.
asm-mips64/time.h: * mips_timer_ack may be NULL if the interrupt is self-recoverable.
asm-mips64/time.h: * If mips_hpt_read is NULL, an R4k-compatible timer setup is attempted.
asm-mips64/time.h: * high-level timer interrupt routines.
asm-mips64/time.h: * the corresponding low-level timer interrupt routine.
asm-mips64/time.h: * mips_hpt_frequency - must be set if you intend to use an R4k-compatible
asm-mips64/checksum.h: * and adds in "sum" (32-bit)
asm-mips64/checksum.h: * returns a 32-bit number suitable for feeding into itself
asm-mips64/checksum.h: * it's best to have buff aligned on a 32-bit boundary
asm-mips64/checksum.h:		*err_ptr = -EFAULT;
asm-mips64/checksum.h:		return -1;
asm-mips64/checksum.h: * signed int.  --macro
asm-mips64/checksum.h: * computes the checksum of the TCP/UDP pseudo-header
asm-mips64/checksum.h: * returns a 16-bit checksum, already complemented
asm-mips64/checksum.h: * this routine is used for miscellaneous IP-like checksums, mainly
asm-mips64/termios.h:	int	sg_flags;	/* SGI special - int, not short */
asm-mips64/termios.h:#define N_IRDA		11	/* Linux IrDa - http://irda.sourceforge.net/ */
asm-mips64/termios.h:#define N_SMSBLOCK	12	/* SMS block mode - for talking to GSM data cards about SMS messages */
asm-mips64/termios.h:	get_user(tmp, &(termio)->c_iflag); \
asm-mips64/termios.h:	(termios)->c_iflag = (0xffff0000 & ((termios)->c_iflag)) | tmp; \
asm-mips64/termios.h:	get_user(tmp, &(termio)->c_oflag); \
asm-mips64/termios.h:	(termios)->c_oflag = (0xffff0000 & ((termios)->c_oflag)) | tmp; \
asm-mips64/termios.h:	get_user(tmp, &(termio)->c_cflag); \
asm-mips64/termios.h:	(termios)->c_cflag = (0xffff0000 & ((termios)->c_cflag)) | tmp; \
asm-mips64/termios.h:	get_user(tmp, &(termio)->c_lflag); \
asm-mips64/termios.h:	(termios)->c_lflag = (0xffff0000 & ((termios)->c_lflag)) | tmp; \
asm-mips64/termios.h:	get_user((termios)->c_line, &(termio)->c_line); \
asm-mips64/termios.h:	copy_from_user((termios)->c_cc, (termio)->c_cc, NCC); \
asm-mips64/termios.h:	put_user((termios)->c_iflag, &(termio)->c_iflag); \
asm-mips64/termios.h:	put_user((termios)->c_oflag, &(termio)->c_oflag); \
asm-mips64/termios.h:	put_user((termios)->c_cflag, &(termio)->c_cflag); \
asm-mips64/termios.h:	put_user((termios)->c_lflag, &(termio)->c_lflag); \
asm-mips64/termios.h:	put_user((termios)->c_line, &(termio)->c_line); \
asm-mips64/termios.h:	copy_to_user((termio)->c_cc, (termios)->c_cc, NCC); \
asm-mips64/titan_dep.h: * Copyright 2003 PMC-Sierra
asm-mips64/titan_dep.h: * Author: Manish Lachwani (lachwani@pmc-sierra.com)
asm-mips64/titan_dep.h: * Board specific definititions for the PMC-Sierra Yosemite
asm-mips64/user.h: * linux we use the `trad-core' bfd, NOT the irix-core).  The file
asm-mips64/user.h: *  data: The data segment follows next.  We use current->end_text to
asm-mips64/user.h: *	current->brk to pick up all of the user variables, plus any memory
asm-mips64/user.h: *	page is demand-zero or if a page is totally unused, we just cover
asm-mips64/user.h: *	current->start_stack, so we round each of these in order to be able
asm-mips64/paccess.h: * by sending a DBE error like accessing possibly non-existant memory or
asm-mips64/paccess.h:	:"o" (__mp(__gu_addr)), "i" (-EFAULT)); })
asm-mips64/paccess.h:	:"r" (__pu_val), "o" (__mp(__pu_addr)), "i" (-EFAULT)); })
asm-mips64/statfs.h:	long		f_frsize;	/* Fragment size - unsupported */
asm-mips64/serial.h:#include <asm/mips-boards/sead.h>
asm-mips64/serial.h:#include <asm/mips-boards/seadint.h>
asm-mips64/serial.h: * Also look in ip27-pci.c:pci_fixuop_ioc3() for some comments on working
asm-mips64/pgtable.h: * Copyright (C) 1994 - 2001 by Ralf Baechle at alii
asm-mips64/pgtable.h:	test_bit(PG_dcache_dirty, &(page)->flags)
asm-mips64/pgtable.h:	set_bit(PG_dcache_dirty, &(page)->flags)
asm-mips64/pgtable.h:	clear_bit(PG_dcache_dirty, &(page)->flags)
asm-mips64/pgtable.h:/* PMD_SHIFT determines the size of the area a second-level page table can map */
asm-mips64/pgtable.h:#define PMD_SHIFT	(PAGE_SHIFT + (PAGE_SHIFT - 3))
asm-mips64/pgtable.h:#define PMD_MASK	(~(PMD_SIZE-1))
asm-mips64/pgtable.h:/* PGDIR_SHIFT determines what a third-level page table entry can map */
asm-mips64/pgtable.h:#define PGDIR_SHIFT	(PMD_SHIFT + (PAGE_SHIFT + 1 - 3))
asm-mips64/pgtable.h:#define PGDIR_MASK	(~(PGDIR_SIZE-1))
asm-mips64/pgtable.h:#include <asm/pgtable-bits.h>
asm-mips64/pgtable.h: * for zero-mapped memory areas etc..
asm-mips64/pgtable.h:#define PAGE_TO_PA(page)	((page - mem_map) << PAGE_SHIFT)
asm-mips64/pgtable.h:		((((page) - page_zone(page)->zone_mem_map) << PAGE_SHIFT) \
asm-mips64/pgtable.h:		  + (page_zone(page)->zone_start_paddr))
asm-mips64/pgtable.h:/* to find an entry in a kernel page-table-directory */
asm-mips64/pgtable.h:#define pgd_index(address)	((address >> PGDIR_SHIFT) & (PTRS_PER_PGD - 1))
asm-mips64/pgtable.h:/* to find an entry in a page-table-directory */
asm-mips64/pgtable.h:	return mm->pgd + pgd_index(address);
asm-mips64/pgtable.h:/* Find an entry in the second-level page table.. */
asm-mips64/pgtable.h:	       ((address >> PMD_SHIFT) & (PTRS_PER_PMD - 1));
asm-mips64/pgtable.h:/* Find an entry in the third-level page table.. */
asm-mips64/pgtable.h:	       ((address >> PAGE_SHIFT) & (PTRS_PER_PTE - 1));
asm-mips64/pgtable.h: * Non-present pages:  high 24 bits are offset, next 8 bits type,
asm-mips64/pgtable.h:#include <asm-generic/pgtable.h>
asm-mips64/unaligned.h: * get_unaligned - get value from possibly mis-aligned location
asm-mips64/unaligned.h: * e.g. retrieving a u16 value from a location not u16-aligned.
asm-mips64/unaligned.h: * put_unaligned - put value to a possibly mis-aligned location
asm-mips64/unaligned.h: * e.g. writing a u16 value to a location not u16-aligned.
asm-mips64/unaligned.h:	return ptr->x;
asm-mips64/unaligned.h:	return ptr->x;
asm-mips64/unaligned.h:	return ptr->x;
asm-mips64/unaligned.h:	ptr->x = r5;
asm-mips64/unaligned.h:	ptr->x = r5;
asm-mips64/unaligned.h:	ptr->x = r5;
asm-mips64/cacheflush.h: *  - flush_cache_all() flushes entire cache
asm-mips64/cacheflush.h: *  - flush_cache_mm(mm) flushes the specified mm context's cache lines
asm-mips64/cacheflush.h: *  - flush_cache_page(mm, vmaddr) flushes a single page
asm-mips64/cacheflush.h: *  - flush_cache_range(mm, start, end) flushes a range of pages
asm-mips64/cacheflush.h: *  - flush_page_to_ram(page) write back kernel page to ram
asm-mips64/cacheflush.h: *  - flush_icache_range(start, end) flush a range of instructions
asm-mips64/cacheflush.h: *  - flush_cache_sigtramp() flush signal trampoline
asm-mips64/cacheflush.h: *  - flush_icache_all() flush the entire instruction cache
asm-mips64/cacheflush.h: *  - flush_data_cache_page() flushes a page from the data cache
asm-mips64/param.h: * Copyright 1994 - 2000 Ralf Baechle (ralf@gnu.org)
asm-mips64/param.h:    * Ye olde division-by-multiplication trick.
asm-mips64/param.h:#  define QUOTIENT ((1UL << (64 - LOG_2_HZ)) * 100)
asm-mips64/param.h:   unless you know what you're doing - changing breaks binary compatibility.  */
asm-mips64/param.h:#define NOGROUP		(-1)
asm-mips64/ds1286.h: * mc146818rtc.h - register definitions for the Real-Time-Clock / CMOS RAM
asm-mips64/ds1286.h: * Copyright Torsten Duwe <duwe@informatik.uni-erlangen.de> 1993
asm-mips64/exception.h: * Copyright (C) 1994 - 1999 by Ralf Baechle
asm-mips64/mipsregs.h:#define FPU_CSR_RD      0x3     /* towards -Infinity */
asm-mips64/mipsregs.h: * physical address space running the 32-bit kernel.  That's none atm :-)
asm-mips64/bootinfo.h:#define MACH_GROUP_TITAN       22 /* PMC-Sierra Titan 			    */
asm-mips64/bootinfo.h:#define MACH_ACER_PICA_61	0	/* Acer PICA-61 (PICA1)		*/
asm-mips64/bootinfo.h:#define MACH_OLIVETTI_M700      2	/* Olivetti M700-10 (-15 ??)    */
asm-mips64/bootinfo.h:#define MACH_NEC_DDB5074	0	/* NEC DDB Vrc-5074 */
asm-mips64/bootinfo.h:#define MACH_NEC_DDB5476	1	/* NEC DDB Vrc-5476 */
asm-mips64/bootinfo.h:#define MACH_NEC_DDB5477	2	/* NEC DDB Vrc-5477 */
asm-mips64/bootinfo.h:#define MACH_BAGET201		0	/* BT23-201 */
asm-mips64/bootinfo.h:#define MACH_BAGET202		1	/* BT23-202 */
asm-mips64/bootinfo.h:#define MACH_TOSHIBA_JMR3927	3	/* JMR-TX3927 CPU/IO board */
asm-mips64/bootinfo.h:#define MACH_PB1000		0	/* Au1000-based eval board */
asm-mips64/bootinfo.h:#define MACH_PB1100		1	/* Au1100-based eval board */
asm-mips64/bootinfo.h:#define MACH_PB1500		2	/* Au1500-based eval board */
asm-mips64/bootinfo.h:#define MACH_DB1000		3       /* Au1000-based eval board */
asm-mips64/bootinfo.h:#define MACH_DB1100		4       /* Au1100-based eval board */
asm-mips64/bootinfo.h:#define MACH_DB1500		5       /* Au1500-based eval board */
asm-mips64/bootinfo.h:#define MACH_XXS1500		6       /* Au1500-based eval board */
asm-mips64/bootinfo.h:#define MACH_MTX1		7	/* 4G MTX-1 Au1500-based board */
asm-mips64/bootinfo.h:#define MACH_VICTOR_MPC30X	3	/* Victor MP-C303/304 */
asm-mips64/bootinfo.h:#define MACH_CASIO_E55		5	/* CASIO CASSIOPEIA E-10/15/55/65 */
asm-mips64/bootinfo.h:#define	MACH_TITAN_YOSEMITE	1 	/* PMC-Sierra Yosemite */
asm-mips64/mips-boards/io.h: *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm-mips64/mips-boards/io.h: * Defines of the MIPS boards specific IO address-MAP.
asm-mips64/mips-boards/msc01_pci.h:#define MSC01_PCI_HEAD11_OFS		0x2058  /* SubSystem ID, -VendorID */
asm-mips64/mips-boards/msc01_pci.h: * FIXME - are these macros specific to Malta and co or to the MSC?  If the
asm-mips64/mips-boards/atlasint.h: *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm-mips64/mips-boards/atlasint.h: * Atlas registers are memory mapped on 64-bit aligned boundaries and
asm-mips64/mips-boards/malta.h: *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm-mips64/mips-boards/malta.h: * Defines of the Malta board specific address-MAP, registers, etc.
asm-mips64/mips-boards/malta.h: * Malta RTC-device indirect register access.
asm-mips64/mips-boards/saa9730_uart.h: *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm-mips64/mips-boards/generic.h: * 59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm-mips64/mips-boards/generic.h: * Defines of the MIPS boards specific address-MAP, registers, etc.
asm-mips64/mips-boards/generic.h:#include <asm/mips-boards/bonito64.h>
asm-mips64/mips-boards/seadint.h: *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm-mips64/mips-boards/prom.h: *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm-mips64/mips-boards/sead.h: *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm-mips64/mips-boards/sead.h: * Defines of the SEAD board specific address-MAP, registers, etc.
asm-mips64/mips-boards/maltaint.h: *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm-mips64/mips-boards/bonito64.h:#define BONITO_BOOT_TOP 		(BONITO_BOOT_BASE+BONITO_BOOT_SIZE-1)
asm-mips64/mips-boards/bonito64.h:#define BONITO_FLASH_TOP		(BONITO_FLASH_BASE+BONITO_FLASH_SIZE-1)
asm-mips64/mips-boards/bonito64.h:#define BONITO_SOCKET_TOP		(BONITO_SOCKET_BASE+BONITO_SOCKET_SIZE-1)
asm-mips64/mips-boards/bonito64.h:#define BONITO_REG_TOP			(BONITO_REG_BASE+BONITO_REG_SIZE-1)
asm-mips64/mips-boards/bonito64.h:#define BONITO_DEV_TOP			(BONITO_DEV_BASE+BONITO_DEV_SIZE-1)
asm-mips64/mips-boards/bonito64.h:#define BONITO_PCILO_TOP		(BONITO_PCILO_BASE+BONITO_PCILO_SIZE-1)
asm-mips64/mips-boards/bonito64.h:#define BONITO_PCIHI_TOP		(BONITO_PCIHI_BASE+BONITO_PCIHI_SIZE-1)
asm-mips64/mips-boards/bonito64.h:#define BONITO_PCIIO_TOP		(BONITO_PCIIO_BASE+BONITO_PCIIO_SIZE-1)
asm-mips64/mips-boards/bonito64.h:#define BONITO_PCICFG_TOP		(BONITO_PCICFG_BASE+BONITO_PCICFG_SIZE-1)
asm-mips64/mips-boards/bonito64.h:/* Added by RPF 11-9-00 */
asm-mips64/mips-boards/bonito64.h:/* --- */
asm-mips64/mips-boards/bonito64.h:/* GPIO Regs - r/w */
asm-mips64/mips-boards/bonito64.h:/* ICU Configuration Regs - r/w */
asm-mips64/mips-boards/bonito64.h:/* ICU Enable Regs - IntEn & IntISR are r/o. */
asm-mips64/mips-boards/bonito64.h:/* DRAM - sdCfg */
asm-mips64/mips-boards/bonito64.h:/* Changed by RPF 11-9-00 */
asm-mips64/mips-boards/bonito64.h:/* --- */
asm-mips64/mips-boards/bonito64.h:/* Added by RPF 11-9-00 */
asm-mips64/mips-boards/bonito64.h:/* --- */
asm-mips64/mips-boards/bonito64.h:/* PCI Cache - pciCacheCtrl */
asm-mips64/mips-boards/bonito64.h:/* Added by RPF 11-9-00 */
asm-mips64/mips-boards/bonito64.h:/* --- */
asm-mips64/mips-boards/bonito64.h:#define BONITO_PCIMAP_WINOFFSET(ADDR)	((ADDR) & (BONITO_PCIMAP_WINSIZE - 1))
asm-mips64/mips-boards/bonito64.h:#define BONITO_PCIMEMBASECFGSIZE(WIN,SIZE)	(((~((SIZE)-1))>>(BONITO_PCIMEMBASECFG_ASHIFT-BONITO_PCIMEMBASECFG_MEMBASE##WIN##_MASK_SHIFT)) & BONITO_PCIMEMBASECFG_MEMBASE##WIN##_MASK)
asm-mips64/mips-boards/bonito64.h:#define BONITO_PCIMEMBASECFGBASE(WIN,BASE)	(((BASE)>>(BONITO_PCIMEMBASECFG_ASHIFT-BONITO_PCIMEMBASECFG_MEMBASE##WIN##_TRANS_SHIFT)) & BONITO_PCIMEMBASECFG_MEMBASE##WIN##_TRANS)
asm-mips64/mips-boards/bonito64.h:#define BONITO_PCIMEMBASECFG_SIZE(WIN,CFG)  (((((~(CFG)) & BONITO_PCIMEMBASECFG_MEMBASE##WIN##_MASK)) << (BONITO_PCIMEMBASECFG_ASHIFT - BONITO_PCIMEMBASECFG_MEMBASE##WIN##_MASK_SHIFT)) | BONITO_PCIMEMBASECFG_AMASK)
asm-mips64/mips-boards/atlas.h: *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm-mips64/mips-boards/atlas.h: * Defines of the Atlas board specific address-MAP, registers, etc.
asm-mips64/mips-boards/atlas.h: * Atlas RTC-device indirect register access.
asm-mips64/mips-boards/piix4.h: *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
asm-mips64/gdb-stub.h: * Derived from the stack layout described in asm-mips/stackframe.h
asm-mips64/gdb-stub.h:#define GDB_FR_SIZE		((((GDB_FR_CP0_PRID) + 8) + (PTRSIZE-1)) & ~(PTRSIZE-1))
asm-mips64/gdb-stub.h: * This is the same as above, but for the high-level
asm-mips64/sgialib.h:/* A 32-bit ARC PROM pass arguments and environment as 32-bit pointer.
asm-mips64/sgialib.h:/* Simple char-by-char console I/O. */
asm-mips64/sgialib.h:/* Running stand-along programs. */
asm-mips64/sgiarcs.h:#define ROMVECTOR ((struct linux_romvec *) (long)(PROMBLOCK)->romvec)
asm-mips64/sgiarcs.h:#define SGIPROM_ROFILE    0x01  /* read-only file */
asm-mips64/sgiarcs.h: * Macros for calling a 32-bit ARC implementation from 64-bit code
asm-mips64/sgiarcs.h:	long __vec = (long) romvec->dest;				\
asm-mips64/sgiarcs.h:	long __vec = (long) romvec->dest;				\
asm-mips64/sgiarcs.h:	long __vec = (long) romvec->dest;				\
asm-mips64/sgiarcs.h:	long __vec = (long) romvec->dest;				\
asm-mips64/sgiarcs.h:	long __vec = (long) romvec->dest;				\
asm-mips64/sgiarcs.h:	long __vec = (long) romvec->dest;				\
asm-mips64/sgiarcs.h:	long (*__vec)(void) = (void *) romvec->dest;			\
asm-mips64/sgiarcs.h:	long (*__vec)(long) = (void *) romvec->dest;			\
asm-mips64/sgiarcs.h:	long (*__vec)(long, long) = (void *) romvec->dest;		\
asm-mips64/sgiarcs.h:	long (*__vec)(long, long, long)	= (void *) romvec->dest;	\
asm-mips64/sgiarcs.h:	long (*__vec)(long, long, long, long) = (void *) romvec->dest;	\
asm-mips64/sgiarcs.h:	__vec = (void *) romvec->dest;					\
asm-mips64/sgiarcs.h:#endif /* both kernel and ARC either 32-bit or 64-bit */
asm-mips64/siginfo.h:#define SI_PAD_SIZE	((SI_MAX_SIZE/sizeof(int)) - 3)
asm-mips64/siginfo.h:#define SI_PAD_SIZE	((SI_MAX_SIZE/sizeof(int)) - 4)
asm-mips64/siginfo.h:	int __pad0[SI_MAX_SIZE / sizeof(int) - SI_PAD_SIZE - 3];
asm-mips64/siginfo.h:#define SI_QUEUE	-1	/* sent by sigqueue */
asm-mips64/siginfo.h:#define SI_ASYNCIO	-2	/* sent by AIO completion */
asm-mips64/siginfo.h:#define SI_TIMER __SI_CODE(__SI_TIMER,-3) /* sent by timer expiration */
asm-mips64/siginfo.h:#define SI_MESGQ	-4	/* sent by real time mesq state change */
asm-mips64/siginfo.h:#define SI_SIGIO	-5	/* sent by queued SIGIO */
asm-mips64/siginfo.h:#define SI_TKILL	-6	/* sent by tkill system call */
asm-mips64/siginfo.h:#define SI_FROMUSER(siptr)	((siptr)->si_code <= 0)
asm-mips64/siginfo.h:#define SI_FROMKERNEL(siptr)	((siptr)->si_code > 0)
asm-mips64/siginfo.h:#define BUS_ADRERR	(__SI_FAULT|2)	/* non-existant physical address */
asm-mips64/siginfo.h:#define SIGEV_PAD_SIZE	((SIGEV_MAX_SIZE-SIGEV_HEAD_SIZE) / sizeof(int))
asm-mips64/siginfo.h:	if (from->si_code < 0)
asm-mips64/siginfo.h:		memcpy(to, from, 3*sizeof(int) + sizeof(from->_sifields._sigchld));
asm-mips64/floppy.h: * Copyright (C) 1995 - 2000 Ralf Baechle
asm-mips64/floppy.h:#define fd_inb(port)		fd_ops->fd_inb(port)
asm-mips64/floppy.h:#define fd_outb(value,port)	fd_ops->fd_outb(value,port)
asm-mips64/floppy.h:#define fd_enable_dma()		fd_ops->fd_enable_dma(FLOPPY_DMA)
asm-mips64/floppy.h:#define fd_disable_dma()	fd_ops->fd_disable_dma(FLOPPY_DMA)
asm-mips64/floppy.h:#define fd_request_dma()	fd_ops->fd_request_dma(FLOPPY_DMA)
asm-mips64/floppy.h:#define fd_free_dma()		fd_ops->fd_free_dma(FLOPPY_DMA)
asm-mips64/floppy.h:#define fd_clear_dma_ff()	fd_ops->fd_clear_dma_ff(FLOPPY_DMA)
asm-mips64/floppy.h:#define fd_set_dma_mode(mode)	fd_ops->fd_set_dma_mode(FLOPPY_DMA, mode)
asm-mips64/floppy.h:#define fd_set_dma_addr(addr)	fd_ops->fd_set_dma_addr(FLOPPY_DMA, \
asm-mips64/floppy.h:#define fd_set_dma_count(count)	fd_ops->fd_set_dma_count(FLOPPY_DMA,count)
asm-mips64/floppy.h:#define fd_get_dma_residue()	fd_ops->fd_get_dma_residue(FLOPPY_DMA)
asm-mips64/floppy.h:#define fd_enable_irq()		fd_ops->fd_enable_irq(FLOPPY_IRQ)
asm-mips64/floppy.h:#define fd_disable_irq()	fd_ops->fd_disable_irq(FLOPPY_IRQ)
asm-mips64/floppy.h:#define fd_dma_mem_alloc(size)	fd_ops->fd_dma_mem_alloc(size)
asm-mips64/floppy.h:#define fd_dma_mem_free(mem,size) fd_ops->fd_dma_mem_free(mem,size)
asm-mips64/floppy.h:#define fd_drive_type(n)	fd_ops->fd_drive_type(n)
asm-mips64/floppy.h:#define FDC1			fd_ops->fd_getfdaddr1();
asm-mips64/floppy.h:#define CROSS_64KB(a,s) ((unsigned long)(a)/K_64 != ((unsigned long)(a) + (s) - 1) / K_64)
asm-mips64/irq_cpu.h: *	include/asm-mips/irq_cpu.h
asm-mips64/sockios.h:/* Socket-level I/O control calls. */
asm-mips64/sockios.h:#define SIOCGSTAMP	0x8906			/* Get stamp - linux-specific */
asm-mips64/keyboard.h: * Copyright (C) 1994 - 1999 Ralf Baechle
asm-mips64/keyboard.h:#define kbd_request_region() kbd_ops->kbd_request_region()
asm-mips64/keyboard.h:#define kbd_request_irq(handler) kbd_ops->kbd_request_irq(handler)
asm-mips64/keyboard.h:#define aux_request_irq(hand, dev_id) kbd_ops->aux_request_irq(hand)
asm-mips64/keyboard.h:#define aux_free_irq(dev_id) kbd_ops->aux_free_irq()
asm-mips64/keyboard.h:#define kbd_read_input() kbd_ops->kbd_read_input()
asm-mips64/keyboard.h:#define kbd_write_output(val) kbd_ops->kbd_write_output(val)
asm-mips64/keyboard.h:#define kbd_write_command(val) kbd_ops->kbd_write_command(val)
asm-mips64/keyboard.h:#define kbd_read_status() kbd_ops->kbd_read_status()
asm-mips64/a.out.h: * Copyright (C) 1994 - 1999 by Ralf Baechle
asm-mips64/a.out.h:#define STACK_TOP (current->thread.mflags & MF_32BIT_ADDR ? TASK_SIZE32 : TASK_SIZE)
asm-mips64/ioctl.h:#define _IOC_NRMASK	((1 << _IOC_NRBITS)-1)
asm-mips64/ioctl.h:#define _IOC_TYPEMASK	((1 << _IOC_TYPEBITS)-1)
asm-mips64/ioctl.h:#define _IOC_SIZEMASK	((1 << _IOC_SIZEBITS)-1)
asm-mips64/ioctl.h:#define _IOC_DIRMASK	((1 << _IOC_DIRBITS)-1)
asm-mips64/string.h: * Copyright (c) 1994 - 2000 by Ralf Baechle
asm-mips64/break.h: * non-Linux/MIPS object files or make use of them in the future.
asm-mips64/break.h:#define BRK_BD_TAKEN	3	/* For bd slot emulation - not implemented */
asm-mips64/break.h:#define BRK_BD_NOTTAKEN	4	/* For bd slot emulation - not implemented */
asm-mips64/break.h:#define BRK_NORLD	10	/* No rld found - not used by Linux/MIPS */
asm-mips64/ioctls.h:						/* 127-124 compat */
asm-mips64/ioctls.h:#define TIOCGPTN	_IOR('T',0x30, unsigned int) /* Get Pty Number (of pty-mux device) */
asm-mips64/msgbuf.h: * - extension of time_t to 64-bit on 32-bitsystem to solve the y2038 problem
asm-mips64/msgbuf.h: * - 2 miscellaneous unsigned long values
asm-mips64/pci_channel.h: * Each pci channel is a top-level PCI bus seem by CPU.  A machine  with
asm-mips64/bcache.h:/* Some R4000 / R4400 / R4600 / R5000 machines may have a non-dma-coherent,
asm-mips64/bcache.h:	bcops->bc_enable();
asm-mips64/bcache.h:	bcops->bc_disable();
asm-mips64/bcache.h:	bcops->bc_wback_inv(page, size);
asm-mips64/bcache.h:	bcops->bc_inv(page, size);
asm-mips64/regdef.h: * Copyright (C) 1990 - 1992, 1999 Silicon Graphics, Inc.
asm-mips64/regdef.h:#define AT	$at	/* assembler temp - uppercase because of ".set at" */
asm-mips64/regdef.h:#define v0	$2	/* return value - caller saved */
asm-mips64/regdef.h:#define gp	$28	/* global pointer - caller saved for PIC */
asm-mips64/socket.h:#define SO_OOBINLINE 0x0100	/* Receive out-of-band data in-band.  */
asm-mips64/socket.h:#define SO_SNDLOWAT	0x1003	/* send low-water mark */
asm-mips64/socket.h:#define SO_RCVLOWAT	0x1004	/* receive low-water mark */
asm-mips64/socket.h:/* linux-specific, might as well be the same as on i386 */
asm-mips64/socket.h:/* Security levels - as per NRL IPv6 - don't actually do anything */
asm-mips64/socket.h:/* Nast libc5 fixup - bletch */
asm-mips64/socket.h:#define SOCK_RDM	4		/* reliably-delivered message	*/
asm-parisc/io.h: * XXX - We don't have csum_partial_copy_fromio() yet, so we cheat here and 
asm-parisc/io.h:  memcpy_fromio((skb)->data,(src),(len))
asm-parisc/io.h:  isa_memcpy_fromio((skb)->data,(src),(len))
asm-parisc/io.h:/* Port-space IO */
asm-parisc/io.h:	return -1;
asm-parisc/io.h:	return -1;
asm-parisc/io.h:	return -1;
asm-parisc/atomic.h:** Since "a" is usually an address, ">>8" makes one spinlock per 64-bytes.
asm-parisc/atomic.h:#  define ATOMIC_HASH(a) (&__atomic_hash[(((unsigned long) a)>>8)&(ATOMIC_HASH_SIZE-1)])
asm-parisc/atomic.h:#define SPIN_LOCK(x)	do { while(__ldcw(&(x)->lock) == 0); } while(0)
asm-parisc/atomic.h:#define SPIN_UNLOCK(x)  do { (x)->lock = 1; } while(0)
asm-parisc/atomic.h:/* Note that we need not lock read accesses - aligned word writes/reads
asm-parisc/atomic.h: * Cache-line alignment would conflict with, for example, linux/module.h
asm-parisc/atomic.h:** REVISIT - Abandoned use of LDCW in xchg() for now:
asm-parisc/atomic.h:** o and while we are at it, could 64-bit code use LDCD too?
asm-parisc/atomic.h:/* bug catcher for when unsupported size is used - won't link */
asm-parisc/atomic.h:	ret = (v->counter += i);
asm-parisc/atomic.h:	v->counter = i;
asm-parisc/atomic.h:	return v->counter;
asm-parisc/atomic.h:#define atomic_sub(i,v)		((void)(__atomic_add_return(-(i),(v))))
asm-parisc/atomic.h:#define atomic_dec(v)		((void)(__atomic_add_return(  -1,(v))))
asm-parisc/atomic.h:#define atomic_sub_return(i,v)	(__atomic_add_return(-(i),(v)))
asm-parisc/atomic.h:#define atomic_dec_return(v)	(__atomic_add_return(  -1,(v)))
asm-parisc/delay.h:	"	addib,UV -1,%0,.\n"
asm-parisc/delay.h:	while ((mfctl(16) - start) < clocks)
asm-parisc/ipcbuf.h: * The ipc64_perm structure for PA-RISC is almost identical to
asm-parisc/ipcbuf.h: * kern_ipc_perm as we have always had 32-bit UIDs and GIDs in the kernel.
asm-parisc/ipcbuf.h: * on 64-bit kernels as on 32-bit ones.
asm-parisc/parport_gsc.h:/* --- register definitions ------------------------------- */
asm-parisc/parport_gsc.h:#define EPPDATA(p)  ((p)->base    + 0x4)
asm-parisc/parport_gsc.h:#define EPPADDR(p)  ((p)->base    + 0x3)
asm-parisc/parport_gsc.h:#define CONTROL(p)  ((p)->base    + 0x2)
asm-parisc/parport_gsc.h:#define STATUS(p)   ((p)->base    + 0x1)
asm-parisc/parport_gsc.h:#define DATA(p)     ((p)->base    + 0x0)
asm-parisc/parport_gsc.h:	struct parport_gsc_private *priv = p->physport->private_data;
asm-parisc/parport_gsc.h:	unsigned char ctr = priv->ctr;
asm-parisc/parport_gsc.h:		"__parport_gsc_frob_control(%02x,%02x): %02x -> %02x\n",
asm-parisc/parport_gsc.h:		mask, val, ctr, ((ctr & ~mask) ^ val) & priv->ctr_writable);
asm-parisc/parport_gsc.h:	ctr &= priv->ctr_writable; /* only write writable bits. */
asm-parisc/parport_gsc.h:	priv->ctr = ctr;	/* Update soft copy */
asm-parisc/parport_gsc.h:			p->name, p->cad->name);
asm-parisc/parport_gsc.h:	const struct parport_gsc_private *priv = p->physport->private_data;
asm-parisc/parport_gsc.h:	return priv->ctr & rm; /* Use soft copy */
asm-parisc/parport_gsc.h:			p->name, p->cad->name,
asm-parisc/parport.h: * parport.h: ia32-compatible parport initialisation
asm-parisc/hardware.h:	unsigned long	mod_index;	/* PAT specific - Misc Module info */
asm-parisc/hardware.h:	unsigned long	mod_info;	/* PAT specific - Misc Module info */
asm-parisc/shmbuf.h: * - 64-bit time_t to solve y2038 problem
asm-parisc/shmbuf.h: * - 2 miscellaneous 32-bit values
asm-parisc/shmbuf.h: * ensure that a 32-bit app calling shmctl(*,IPC_INFO,*) will work on
asm-parisc/shmbuf.h: * they may need to be 'long long' instead. -PB XXX FIXME
asm-parisc/bitops.h: * HP-PARISC specific bit operations
asm-parisc/bitops.h: * to include/asm-i386/bitops.h or kerneldoc
asm-parisc/bitops.h:#define CHOP_SHIFTCOUNT(x) ((x) & (BITS_PER_LONG - 1))
asm-parisc/bitops.h: * of bits set) of a N-bit word
asm-parisc/bitops.h: * Linus' asm-alpha/bitops.h.
asm-parisc/bitops.h:	unsigned long result = offset & ~(BITS_PER_LONG-1);
asm-parisc/bitops.h:	size -= result;
asm-parisc/bitops.h:	offset &= (BITS_PER_LONG-1);
asm-parisc/bitops.h:		tmp |= ~0UL >> (BITS_PER_LONG-offset);
asm-parisc/bitops.h:		size -= BITS_PER_LONG;
asm-parisc/bitops.h:	while (size & ~(BITS_PER_LONG -1)) {
asm-parisc/bitops.h:		size -= BITS_PER_LONG;
asm-parisc/bitops.h: * Linus' asm-alpha/bitops.h and modified for a big-endian machine.
asm-parisc/bitops.h:	size -= result;
asm-parisc/bitops.h:		tmp |= ~0UL >> (32-offset);
asm-parisc/bitops.h:		size -= 32;
asm-parisc/bitops.h:		size -= 32;
asm-parisc/div64.h: * Copyright (C) 1999 Hewlett-Packard Co
asm-parisc/div64.h: * Copyright (C) 1999 David Mosberger-Tang <davidm@hpl.hp.com>
asm-parisc/div64.h: * vsprintf uses this to divide a 64-bit integer N by a small integer BASE.
asm-parisc/div64.h: * This is incredibly hard on IA-64 and HPPA
asm-parisc/resource.h:#define RLIMIT_MEMLOCK	8		/* max locked-in-memory address space */
asm-parisc/ptrace.h:** Copyright (C) 2000 Grant Grundler, Hewlett-Packard
asm-parisc/ptrace.h: * These ones are taken from IA-64 on the assumption that theirs are
asm-parisc/ptrace.h:#define user_mode(regs)			(((regs)->iaoq[0] &  3) ? 1 : 0)
asm-parisc/ptrace.h:#define instruction_pointer(regs)	((regs)->iaoq[0] & ~3)
asm-parisc/pgalloc.h:/* The usual comment is "Caches aren't brain-dead on the <architecture>".
asm-parisc/pgalloc.h: * Unfortunately, that doesn't apply to PA-RISC. */
asm-parisc/pgalloc.h:	if ((end - start) < FLUSH_THRESHOLD)
asm-parisc/pgalloc.h:	if ((end - start) < FLUSH_THRESHOLD)
asm-parisc/pgalloc.h:	if (!mm->context) {
asm-parisc/pgalloc.h:	if (mm->context == sr3) {
asm-parisc/pgalloc.h:	if (!vma->vm_mm->context) {
asm-parisc/pgalloc.h:	if (vma->vm_mm->context == sr3) {
asm-parisc/pgalloc.h:		if (vma->vm_flags & VM_EXEC)
asm-parisc/pgalloc.h:		if (vma->vm_flags & VM_EXEC)
asm-parisc/pgalloc.h:	if (page->mapping && !page->mapping->i_mmap &&
asm-parisc/pgalloc.h:			!page->mapping->i_mmap_shared) {
asm-parisc/pgalloc.h:		set_bit(PG_dcache_dirty, &page->flags);
asm-parisc/pgalloc.h:	mtctl(context >> (SPACEID_SHIFT - 1),8);
asm-parisc/pgalloc.h: * XXX This code is NOT valid for HP-UX compatibility processes,
asm-parisc/pgalloc.h: * (although it will probably work 99% of the time). HP-UX
asm-parisc/pgalloc.h:		if (mm->context != 0)
asm-parisc/pgalloc.h:			free_sid(mm->context);
asm-parisc/pgalloc.h:		mm->context = alloc_sid();
asm-parisc/pgalloc.h:		if (mm == current->active_mm)
asm-parisc/pgalloc.h:			load_context(mm->context);
asm-parisc/pgalloc.h:	mtsp(vma->vm_mm->context,1);
asm-parisc/pgalloc.h:	npages = ((end - (start & PAGE_MASK)) + (PAGE_SIZE - 1)) >> PAGE_SHIFT;
asm-parisc/pgalloc.h:		mtsp(mm->context,1);
asm-parisc/pgalloc.h:			while (npages--) {
asm-parisc/pgalloc.h:			while (npages--) {
asm-parisc/pgalloc.h: * allocating and freeing a pmd is trivial: the 1-entry pmd is
asm-parisc/unistd.h: *   HP-UX system calls get their native numbers for binary compatibility.
asm-parisc/unistd.h:/* 201 - 223 missing */
asm-parisc/unistd.h:/* 251 - 258 missing */
asm-parisc/unistd.h:/* 261 - 266 missing */
asm-parisc/unistd.h:/* 298 - 311 missing */
asm-parisc/unistd.h: * 64-bit HPUX binaries get the syscall gateway address passed in a register
asm-parisc/unistd.h: * it is essentially duplicated -- which sucks.  -PB
asm-parisc/unistd.h:   arch/parisc/kernel/signal.c - dhd, 2000-07-26 */
asm-parisc/unistd.h:        if (__sys_res >= (unsigned long)-4095) {                \
asm-parisc/unistd.h:		errno = -__sys_res;				\
asm-parisc/unistd.h:                __sys_res = (unsigned long)-1;                 \
asm-parisc/unistd.h:	return sys_wait4(-1, wait_stat, 0, NULL);
asm-parisc/dma.h:** DMA_CHUNK_SIZE is used by the SCSI mid-layer to break up
asm-parisc/dma.h:** We don't have DMA channels... well V-class does but the
asm-parisc/dma.h:** Note: this is not relevant right now for PA-RISC, but we cannot 
asm-parisc/dma.h:** won't compile :-(
asm-parisc/dma.h:#define DMA1_MASK_REG		0x0A	/* single-channel mask (w) */
asm-parisc/dma.h:#define DMA1_CLEAR_FF_REG	0x0C	/* clear pointer flip-flop (w) */
asm-parisc/dma.h:#define DMA1_MASK_ALL_REG       0x0F    /* all-channels mask (w) */
asm-parisc/dma.h:#define DMA2_MASK_REG		0xD4	/* single-channel mask (w) */
asm-parisc/dma.h:#define DMA2_CLEAR_FF_REG	0xD8	/* clear pointer flip-flop (w) */
asm-parisc/dma.h:#define DMA2_MASK_ALL_REG       0xDE    /* all-channels mask (w) */
asm-parisc/dma.h: * Assumes DMA flip-flop is clear.
asm-parisc/dma.h:	/* using short to get 16-bit wrap around */
asm-parisc/dma.h: * After that, keep track of it. :-)
asm-parisc/dma.h: * --- In order to do that, the DMA routines below should ---
asm-parisc/dma.h: * --- only be used while holding the DMA lock ! ---
asm-parisc/dma.h: * Assumes dma flip-flop is clear.
asm-parisc/dma.h: * NOTE 2: "count" represents _bytes_ and must be even for channels 5-7.
asm-parisc/elf.h: * The following definitions are those for 32-bit ELF binaries on a 32-bit kernel
asm-parisc/elf.h: * and for 64-bit binaries on a 64-bit kernel.  To run 32-bit binaries on a 64-bit
asm-parisc/elf.h:#define ELF_PLATFORM  ("PARISC\0" /*+((boot_cpu_data.x86-3)*5) */)
asm-parisc/elf.h:	current->personality = PER_LINUX
asm-parisc/elf.h: * much the same registers as hp-ux, although in a different order.
asm-parisc/elf.h:	memcpy(dst + 0, pt->gr, 32 * sizeof(elf_greg_t)); \
asm-parisc/elf.h:	memcpy(dst + 32, pt->sr, 8 * sizeof(elf_greg_t)); \
asm-parisc/elf.h:	memcpy(dst + 40, pt->iaoq, 2 * sizeof(elf_greg_t)); \
asm-parisc/elf.h:	memcpy(dst + 42, pt->iasq, 2 * sizeof(elf_greg_t)); \
asm-parisc/elf.h:	dst[44] = pt->sar;   dst[45] = pt->iir; \
asm-parisc/elf.h:	dst[46] = pt->isr;   dst[47] = pt->ior; \
asm-parisc/elf.h:#define elf_check_arch(x) ((x)->e_machine == EM_PARISC && (x)->e_ident[EI_CLASS] == ELF_CLASS)
asm-parisc/elf.h:#define ELF_PLAT_INIT(_r, load_addr)       _r->gr[23] = 0
asm-parisc/ide.h: *  linux/include/asm-parisc/ide.h
asm-parisc/ide.h: *  Copyright (C) 1994-1996  Linus Torvalds & authors
asm-parisc/ide.h:		hw->io_ports[i] = reg;
asm-parisc/ide.h:		hw->io_ports[IDE_CONTROL_OFFSET] = ctrl_port;
asm-parisc/ide.h:		hw->io_ports[IDE_CONTROL_OFFSET] = hw->io_ports[IDE_DATA_OFFSET] + 0x206;
asm-parisc/ide.h:	hw->io_ports[IDE_IRQ_OFFSET] = 0;
asm-parisc/ide.h:#include <asm-generic/ide_iops.h>
asm-parisc/irq.h: *	linux/include/asm-parisc/irq.h
asm-parisc/irq.h: *	<tomsoft@informatik.tu-chemnitz.de>
asm-parisc/irq.h:/* This should be 31 for PA1.1 binaries and 63 for PA-2.0 wide mode */
asm-parisc/irq.h:#define MAX_CPU_IRQ		(BITS_PER_LONG - 1)
asm-parisc/irq.h:#define IRQ_OFFSET(irq)		((irq) & ((1<<IRQ_REGION_SHIFT)-1))
asm-parisc/pci.h:**    (workstations 1-~4, servers 2-~32)
asm-parisc/pci.h:** For linux add another dimension - processor architectures.
asm-parisc/pci.h:** would support this argument. - grant
asm-parisc/pci.h:** dev->sysdata structure.  I've heard this called "C inheritance" too.
asm-parisc/pci.h:	unsigned long   lmmio_space_offset;  /* CPU view - PCI view */
asm-parisc/pci.h:	/* REVISIT - spinlock to protect resources? */
asm-parisc/pci.h:#define PCI_PORT_ADDR(a)	((a) & (HBA_PORT_SPACE_SIZE - 1))
asm-parisc/pci.h:#define PCI_BUS_ADDR(hba,a)	((a) - hba->lmmio_space_offset)
asm-parisc/pci.h:#define PCI_HOST_ADDR(hba,a)	((a) + hba->lmmio_space_offset)
asm-parisc/pci.h:**    force in-flight write transaction(s) out to the targeted device
asm-parisc/pci.h:**    before in-flight DMA reaches memory. Since most SMP PA platforms
asm-parisc/pci.h:** See Documentation/DMA-mapping.txt
asm-parisc/pci.h:**  a) PA-7x00LC    uncachable host memory          flush/purge
asm-parisc/pci.h:** PA-7[13]00LC processors have a GSC bus interface and no I/O MMU.
asm-parisc/pci.h:** Systems (eg PCX-T workstations) that don't fall into the above
asm-parisc/pci.h:	return -1;
asm-parisc/pci.h:	: hppa_dma_ops->dma_supported(p,m) \
asm-parisc/pci.h:#define pci_alloc_consistent(p, s, a)	hppa_dma_ops->alloc_consistent(p,s,a)
asm-parisc/pci.h:#define pci_free_consistent(p, s, v, a)	hppa_dma_ops->free_consistent(p,s,v,a)
asm-parisc/pci.h:#define pci_map_single(p, v, s, d)	hppa_dma_ops->map_single(p, v, s, d)
asm-parisc/pci.h:#define pci_unmap_single(p, a, s, d)	hppa_dma_ops->unmap_single(p, a, s, d)
asm-parisc/pci.h:#define pci_map_sg(p, sg, n, d)		hppa_dma_ops->map_sg(p, sg, n, d)
asm-parisc/pci.h:#define pci_unmap_sg(p, sg, n, d)	hppa_dma_ops->unmap_sg(p, sg, n, d)
asm-parisc/pci.h:	((PTR)->ADDR_NAME)
asm-parisc/pci.h:	(((PTR)->ADDR_NAME) = (VAL))
asm-parisc/pci.h:	((PTR)->LEN_NAME)
asm-parisc/pci.h:	(((PTR)->LEN_NAME) = (VAL))
asm-parisc/pci.h:#define pci_dma_sync_single(p, a, s, d)	{ if (hppa_dma_ops->dma_sync_single) \
asm-parisc/pci.h:	hppa_dma_ops->dma_sync_single(p, a, s, d); \
asm-parisc/pci.h:#define pci_dma_sync_sg(p, sg, n, d)	{ if (hppa_dma_ops->dma_sync_sg) \
asm-parisc/pci.h:	hppa_dma_ops->dma_sync_sg(p, sg, n, d); \
asm-parisc/pci.h:extern int pci_post_reset_delay;	/* delay after de-asserting #RESET */
asm-parisc/pci.h:**   0 == check if bridge is numbered before re-numbering.
asm-parisc/pci.h:**   1 == pci_do_scan_bus() should automatically number all PCI-PCI bridges.
asm-parisc/pci.h:#define PCIBIOS_MIN_MEM         0x1000 /* NBPG - but pci/setup-res.c dies */
asm-parisc/pci.h:#define GET_IOC(dev) ((struct ioc *)(HBA_DATA(dev->sysdata)->iommu))
asm-parisc/pdc.h:#define PDC_BAD_PROC		 -1	/* Called non-existent procedure*/
asm-parisc/pdc.h:#define PDC_BAD_OPTION		 -2	/* Called with non-existent option */
asm-parisc/pdc.h:#define PDC_ERROR		 -3	/* Call could not complete without an error */
asm-parisc/pdc.h:#define PDC_NE_MOD		 -5	/* Module not found		*/
asm-parisc/pdc.h:#define PDC_NE_CELL_MOD		 -7	/* Cell module not found	*/
asm-parisc/pdc.h:#define PDC_INVALID_ARG		-10	/* Called with an invalid argument */
asm-parisc/pdc.h:#define PDC_BUS_POW_WARN	-12	/* Call could not complete in allowed power budget */
asm-parisc/pdc.h:#define PDC_NOT_NARROW		-17	/* Narrow mode not supported	*/
asm-parisc/pdc.h:#define PDC_POW_FAIL	1		/* perform a power-fail		*/
asm-parisc/pdc.h:#define PDC_CHASSIS	2		/* PDC-chassis functions	*/
asm-parisc/pdc.h:#define PDC_MODEL_VERSIONS	2	/* returns cpu-internal versions*/
asm-parisc/pdc.h:#define PDC_MODEL_CPU_ID	6	/* returns cpu-id (only newer machines!) */
asm-parisc/pdc.h:#define PDC_MODEL_CAPABILITIES	7	/* returns OS32/OS64-flags	*/
asm-parisc/pdc.h:#define PDC_CACHE_RET_SPID	2	/* returns space-ID bits	*/
asm-parisc/pdc.h:#define PDC_COPROC	7		/* Co-Processor (usually FP unit(s)) */
asm-parisc/pdc.h:#define PDC_COPROC_CFG		0	/* Co-Processor Cfg (FP unit(s) enabled?) */
asm-parisc/pdc.h:/*				1, 2	   obsolete - HVERSION dependent*/
asm-parisc/pdc.h:/*				7	  obsolete - HVERSION dependent */
asm-parisc/pdc.h:#define PDC_IODC_NINIT		2	/* non-destructive init		*/
asm-parisc/pdc.h:#define PDC_IODC_BUS_ERROR	-4	/* bus error return value	*/
asm-parisc/pdc.h:#define PDC_IODC_INVALID_INDEX	-5	/* invalid index return value	*/
asm-parisc/pdc.h:#define PDC_IODC_COUNT		-6	/* count is too small		*/
asm-parisc/pdc.h:#define PDC_TOD		9		/* time-of-day clock (TOD)	*/
asm-parisc/pdc.h:#define PDC_BLOCK_TLB	18		/* manage hardware block-TLB	*/
asm-parisc/pdc.h:#define PDC_MEM_RET_PDT_FULL		-11
asm-parisc/pdc.h:#define PDC_EEPROM_EEPROM_PASSWORD -1000
asm-parisc/pdc.h:#define PDC_NVM		130		/* NVM (non-volatile memory) access */
asm-parisc/pdc.h:#define PDC_IO_EEPROM_IO_ERR_TABLE_FULL	-5	/* return value */
asm-parisc/pdc.h:#define PDC_IO_NO_SUSPEND		-6	/* return value */
asm-parisc/pdc.h:#define OS_ID_HPUX		1	/* HP-UX OS		*/
asm-parisc/pdc.h:#define OS_ID_HPRT		4	/* HP-RT OS		*/
asm-parisc/pdc.h:#define PDC_PAT_CELL_NUMBER_TO_LOC 10L	/* Cell Number -> Location	*/
asm-parisc/pdc.h:#define PDC_PAT_CELL_CHANGE_ALIAS  129L	/* Change Non-Equivalent Alias Checking */
asm-parisc/pdc.h:#define PDC_PAT_EVENT_GET_NB_CALL	4L /* Get Non-Blocking call Args*/
asm-parisc/pdc.h:#define PDC_PAT_IO		71L	/* On-line services for I/O modules */
asm-parisc/pdc.h:#define PDC_PAT_NVOLATILE	73L	   /* Access Non-Volatile Memory*/
asm-parisc/pdc.h:#define PDC_PAT_NVOLATILE_READ		0L /* Read Non-Volatile Memory	*/
asm-parisc/pdc.h:#define PDC_PAT_NVOLATILE_WRITE		1L /* Write Non-Volatile Memory	*/
asm-parisc/pdc.h:#define PDC_TYPE_ILLEGAL	-1
asm-parisc/pdc.h:#define PDC_TYPE_PAT		 0 /* 64-bit PAT-PDC */
asm-parisc/pdc.h:#define PDC_TYPE_SYSTEM_MAP	 1 /* 32-bit, but supports PDC_SYSTEM_MAP */
asm-parisc/pdc.h:/* Values for PDC_MODEL_CAPABILITES non-equivalent virtual aliasing support */
asm-parisc/pdc.h:struct pdc_cache_cf {		/* for PDC_CACHE  (I/D-caches) */
asm-parisc/pdc.h:		cc_wt	: 1,	/* 0 = WT-Dcache, 1 = WB-Dcache */
asm-parisc/pdc.h:		cc_sh	: 2,	/* 0 = separate I/D-cache, else shared I/D-cache */
asm-parisc/pdc.h:		cc_cst  : 3,	/* 0 = incoherent D-cache, 1=coherent D-cache */
asm-parisc/pdc.h:		cc_assoc: 8;	/* associativity of I/D-cache */
asm-parisc/pdc.h:struct pdc_tlb_cf {		/* for PDC_CACHE (I/D-TLB's) */
asm-parisc/pdc.h:		tc_sh	: 2,	/* 0 = separate I/D-TLB, else shared I/D-TLB */
asm-parisc/pdc.h:		tc_page : 1,	/* 0 = 2K page-size-machine, 1 = 4k page size */
asm-parisc/pdc.h:		tc_pad1 : 8;	/* ITLB: width of space-registers (encoded) */
asm-parisc/pdc.h:struct pdc_cache_info {		/* main-PDC_CACHE-structure (caches & TLB's) */
asm-parisc/pdc.h:	/* I-cache */
asm-parisc/pdc.h:	unsigned long	ic_base;	/* base-addr */
asm-parisc/pdc.h:	/* D-cache */
asm-parisc/pdc.h:	unsigned long	dc_base;	/* base-addr */
asm-parisc/pdc.h:	/* Instruction-TLB */
asm-parisc/pdc.h:	unsigned long	it_size;	/* number of entries in I-TLB */
asm-parisc/pdc.h:	struct pdc_tlb_cf it_conf;	/* I-TLB-configuration */
asm-parisc/pdc.h:	/* data-TLB */
asm-parisc/pdc.h:	unsigned long	dt_size;	/* number of entries in D-TLB */
asm-parisc/pdc.h:	struct pdc_tlb_cf dt_conf;	/* D-TLB-configuration */
asm-parisc/pdc.h: * work with 64-bit firmware I think -PB
asm-parisc/pdc.h:	unsigned int layers[6]; /* device-specific info (ctlr #, unit # ...) */
asm-parisc/pdc.h:/* Only used on some pre-PA2.0 boxes */
asm-parisc/pdc.h:struct device_path {		/* page 1-69 */
asm-parisc/pdc.h:	unsigned int  layers[6];/* device-specific layer-info */
asm-parisc/pdc.h: * page 3-33 of IO-Firmware ARS
asm-parisc/pdc.h:#define	CL_DUPLEX	7	/* full-duplex point-to-point (RS-232, Net) */
asm-parisc/pdc.h:#define	CL_KEYBD	8	/* half-duplex console (HIL Keyboard) */
asm-parisc/pdc.h:#define	CL_DISPL	9	/* half-duplex console (display) */
asm-parisc/pdc.h:/* DEFINITION OF THE ZERO-PAGE (PAG0) */
asm-parisc/pdc.h:	unsigned int mem_pdc_hi;	/* used for 64-bit */
asm-parisc/pdc.h:	/* [0x360] various parameters for the boot-CPU */
asm-parisc/pdc.h:	unsigned int mem_hpa;		/* HPA of the boot-CPU */
asm-parisc/pdc.h:/* wrapper-functions from pdc.c */
asm-parisc/pdc.h:* ----------------------------------------------------------
asm-parisc/pdc.h:* Bit  0 to 51 - conf_base_addr
asm-parisc/pdc.h:* Bit 52 to 62 - reserved
asm-parisc/pdc.h:* Bit       63 - endianess bit
asm-parisc/pdc.h:* ----------------------------------------------------
asm-parisc/pdc.h:* Bit  0 to  7 - entity type
asm-parisc/pdc.h:* Bit  8 to 15 - DVI
asm-parisc/pdc.h:* Bit 16 to 23 - IOC functions
asm-parisc/pdc.h:* Bit 24 to 39 - reserved
asm-parisc/pdc.h:* Bit 40 to 63 - mod_pages
asm-parisc/pdc.h:/* No PAT support for 32-bit kernels...sorry */
asm-parisc/rtc.h:/* include/asm-parisc/rtc.h */
asm-parisc/rtc.h:#define RTC_UIE 0x10		/* update-finished interrupt enable */
asm-parisc/rtc.h:#define RTC_SQWE 0x08		/* enable square-wave output */
asm-parisc/rtc.h:#define RTC_24H 0x02		/* 24 hour mode - else hours bit 7 means pm */
asm-parisc/rtc.h:#define RTC_DST_EN 0x01	        /* auto switch DST - works f. USA only */
asm-parisc/rtc.h:/* How many days come before each month (0-12).  */
asm-parisc/rtc.h:	 * by the RTC when initially set to a non-zero value.
asm-parisc/rtc.h:	wtime->tm_hour = rem / SECS_PER_HOUR;
asm-parisc/rtc.h:	wtime->tm_min = rem / 60;
asm-parisc/rtc.h:	wtime->tm_sec = rem % 60;
asm-parisc/rtc.h:#define DIV(a, b) ((a) / (b) - ((a) % (b) < 0))
asm-parisc/rtc.h:#define LEAPS_THRU_END_OF(y) (DIV (y, 4) - DIV (y, 100) + DIV (y, 400))
asm-parisc/rtc.h:		long int yg = y + days / 365 - (days % 365 < 0);
asm-parisc/rtc.h:		days -= ((yg - y) * 365
asm-parisc/rtc.h:			 + LEAPS_THRU_END_OF (yg - 1)
asm-parisc/rtc.h:			 - LEAPS_THRU_END_OF (y - 1));
asm-parisc/rtc.h:	wtime->tm_year = y - 1900;
asm-parisc/rtc.h:	for (y = 11; days < (long int) ip[y]; --y)
asm-parisc/rtc.h:	days -= ip[y];
asm-parisc/rtc.h:	wtime->tm_mon = y;
asm-parisc/rtc.h:	wtime->tm_mday = days + 1;
asm-parisc/rtc.h:	secs = mktime(wtime->tm_year + 1900, wtime->tm_mon + 1, wtime->tm_mday, 
asm-parisc/rtc.h:		      wtime->tm_hour, wtime->tm_min, wtime->tm_sec);
asm-parisc/rtc.h:		return -EINVAL;
asm-parisc/rtc.h:	return -EINVAL;
asm-parisc/rtc.h:	return -EINVAL;
asm-parisc/rtc.h:	return -EINVAL;
asm-parisc/smp.h:#define smp_processor_id() (current->processor)
asm-parisc/tlb.h:#include <asm-generic/tlb.h>
asm-parisc/xor.h:#include <asm-generic/xor.h>
asm-parisc/signal.h:#define SIGRTMAX	(_NSIG-1) /* it's 44 under HP/UX */
asm-parisc/signal.h: * SA_INTERRUPT is a no-op, but left due to historical reasons. Use the
asm-parisc/signal.h:#define SA_INTERRUPT	0x20000000 /* dummy -- ignored */
asm-parisc/signal.h:#define SA_RESTORER	0x04000000 /* obsolete -- ignored */
asm-parisc/signal.h:/* bits-per-word, where word apparently means 'long' not 'int' */
asm-parisc/signal.h:#define SIG_ERR	((__sighandler_t)-1)	/* error return from signal */
asm-parisc/signal.h:/* function pointers on 64-bit parisc are pointers to little structs and the
asm-parisc/signal.h: * the function in the little struct.  This is really ugly -PB
asm-parisc/signal.h:	/* next_signal() assumes this is a long - no choice */
asm-parisc/spinlock_t.h:/* LDCW, the only atomic read-write operation PA-RISC has. *sigh*.
asm-parisc/spinlock_t.h: * Note that PA-RISC has to use `1' to mean unlocked and `0' to mean locked
asm-parisc/spinlock_t.h: * since it only has load-and-zero.
asm-parisc/spinlock_t.h:> Delivery-date: Wed, 29 Jan 2003 13:57:05 -0500
asm-parisc/spinlock_t.h:> 16-byte alignment requirement for ldcw and ldcd is relaxed, and instead
asm-parisc/spinlock_t.h:> they only require "natural" alignment (4-byte for ldcw, 8-byte for
asm-parisc/spinlock_t.h:#define spin_lock_init(x)       do { (x)->lock = 1; } while(0)
asm-parisc/spinlock_t.h:#define spin_is_locked(x)       ((x)->lock == 0)
asm-parisc/spinlock_t.h:#define spin_trylock(x)		(__ldcw(&(x)->lock) != 0)
asm-parisc/spinlock_t.h:	__asm__ __volatile__ ("stw,ma  %%sp,0(%0)" : : "r" (&(x)->lock) : "memory" )
asm-parisc/spinlock_t.h:#define spin_unlock_wait(x)     do { barrier(); } while(((volatile spinlock_t *)(x))->lock == 0)
asm-parisc/spinlock_t.h:	while (__ldcw (&(x)->lock) == 0) \
asm-parisc/spinlock_t.h:		while ((x)->lock == 0) ; \
asm-parisc/spinlock_t.h:#define spin_lock_init(x)       do { (x)->lock = 1; (x)->owner_cpu = 0; (x)->owner_pc = 0; } while(0)
asm-parisc/spinlock_t.h:#define spin_is_locked(x)       ((x)->lock == 0)
asm-parisc/spinlock_t.h:#define spin_unlock_wait(x)     do { barrier(); } while(((volatile spinlock_t *)(x))->lock == 0)
asm-parisc/hardirq.h:/* hardirq.h: PA-RISC hard IRQ support.
asm-parisc/hardirq.h: * The locking is really quite interesting.  There's a cpu-local
asm-parisc/hardirq.h: * all the per-cpu interrupt counts are all zero.  It's a specialised
asm-parisc/hardirq.h: * it's more locking for us.  This way is lock-free in the interrupt path.
asm-parisc/hardirq.h:#define irq_exit(cpu, irq)	(local_irq_count(cpu)--)
asm-parisc/hardirq.h:	--local_irq_count(cpu);
asm-parisc/eisa_eeprom.h: * eisa_eeprom.h - provide support for EISA adapters in PA-RISC machines
asm-parisc/assembly.h: * Copyright (C) 1999 Hewlett-Packard (Frank Rowand)
asm-parisc/assembly.h:/* the 64-bit pa gnu assembler unfortunately defaults to .level 1.1 or 2.0 so
asm-parisc/assembly.h:	addib,UV,n -1,1,.
asm-parisc/assembly.h:	addib,NUV,n -1,1,.+8
asm-parisc/assembly.h:	/* Shift Left - note the r and t can NOT be the same! */
asm-parisc/assembly.h:	dep,z	\r, 31-\sa, 32-\sa, \t
asm-parisc/assembly.h:	depw,z	\r, 31-\sa, 32-\sa, \t
asm-parisc/assembly.h:	depd,z	\r, 63-\sa, 64-\sa, \t
asm-parisc/assembly.h:	/* load 32-bit 'value' into 'reg' compensating for the ldil
asm-parisc/assembly.h:	 * sign-extension when running in wide mode.
asm-parisc/assembly.h:	fldd,mb	-8(\regs),       %fr30
asm-parisc/assembly.h:	fldd,mb	-8(\regs),       %fr29
asm-parisc/assembly.h:	fldd,mb	-8(\regs),       %fr28
asm-parisc/assembly.h:	fldd,mb	-8(\regs),       %fr27
asm-parisc/assembly.h:	fldd,mb	-8(\regs),       %fr26
asm-parisc/assembly.h:	fldd,mb	-8(\regs),       %fr25
asm-parisc/assembly.h:	fldd,mb	-8(\regs),       %fr24
asm-parisc/assembly.h:	fldd,mb	-8(\regs),       %fr23
asm-parisc/assembly.h:	fldd,mb	-8(\regs),       %fr22
asm-parisc/assembly.h:	fldd,mb	-8(\regs),       %fr21
asm-parisc/assembly.h:	fldd,mb	-8(\regs),       %fr20
asm-parisc/assembly.h:	fldd,mb	-8(\regs),       %fr19
asm-parisc/assembly.h:	fldd,mb	-8(\regs),       %fr18
asm-parisc/assembly.h:	fldd,mb	-8(\regs),       %fr17
asm-parisc/assembly.h:	fldd,mb	-8(\regs),       %fr16
asm-parisc/assembly.h:	fldd,mb	-8(\regs),       %fr15
asm-parisc/assembly.h:	fldd,mb	-8(\regs),       %fr14
asm-parisc/assembly.h:	fldd,mb	-8(\regs),       %fr13
asm-parisc/assembly.h:	fldd,mb	-8(\regs),       %fr12
asm-parisc/assembly.h:	fldd,mb	-8(\regs),       %fr11
asm-parisc/assembly.h:	fldd,mb	-8(\regs),       %fr10
asm-parisc/assembly.h:	fldd,mb	-8(\regs),       %fr9
asm-parisc/assembly.h:	fldd,mb	-8(\regs),       %fr8
asm-parisc/assembly.h:	fldd,mb	-8(\regs),       %fr7
asm-parisc/assembly.h:	fldd,mb	-8(\regs),       %fr6
asm-parisc/assembly.h:	fldd,mb	-8(\regs),       %fr5
asm-parisc/assembly.h:	fldd,mb	-8(\regs),       %fr4
asm-parisc/assembly.h:	fldd,mb	-8(\regs),       %fr3
asm-parisc/assembly.h:	fldd,mb	-8(\regs),       %fr2
asm-parisc/assembly.h:	fldd,mb	-8(\regs),       %fr1
asm-parisc/assembly.h:	fldd,mb	-8(\regs),       %fr0
asm-parisc/assembly.h:	std	  %r4,	-136(%r30)
asm-parisc/assembly.h:	std	  %r5,	-128(%r30)
asm-parisc/assembly.h:	std	  %r6,	-120(%r30)
asm-parisc/assembly.h:	std	  %r7,	-112(%r30)
asm-parisc/assembly.h:	std	  %r8,	-104(%r30)
asm-parisc/assembly.h:	std	  %r9,	 -96(%r30)
asm-parisc/assembly.h:	std	 %r10,	 -88(%r30)
asm-parisc/assembly.h:	std	 %r11,	 -80(%r30)
asm-parisc/assembly.h:	std	 %r12,	 -72(%r30)
asm-parisc/assembly.h:	std	 %r13,	 -64(%r30)
asm-parisc/assembly.h:	std	 %r14,	 -56(%r30)
asm-parisc/assembly.h:	std	 %r15,	 -48(%r30)
asm-parisc/assembly.h:	std	 %r16,	 -40(%r30)
asm-parisc/assembly.h:	std	 %r17,	 -32(%r30)
asm-parisc/assembly.h:	std	 %r18,	 -24(%r30)
asm-parisc/assembly.h:	std	  %r3,	 -16(%r30)
asm-parisc/assembly.h:	ldd	 -16(%r30),    %r3
asm-parisc/assembly.h:	ldd	 -24(%r30),   %r18
asm-parisc/assembly.h:	ldd	 -32(%r30),   %r17
asm-parisc/assembly.h:	ldd	 -40(%r30),   %r16
asm-parisc/assembly.h:	ldd	 -48(%r30),   %r15
asm-parisc/assembly.h:	ldd	 -56(%r30),   %r14
asm-parisc/assembly.h:	ldd	 -64(%r30),   %r13
asm-parisc/assembly.h:	ldd	 -72(%r30),   %r12
asm-parisc/assembly.h:	ldd	 -80(%r30),   %r11
asm-parisc/assembly.h:	ldd	 -88(%r30),   %r10
asm-parisc/assembly.h:	ldd	 -96(%r30),    %r9
asm-parisc/assembly.h:	ldd	-104(%r30),    %r8
asm-parisc/assembly.h:	ldd	-112(%r30),    %r7
asm-parisc/assembly.h:	ldd	-120(%r30),    %r6
asm-parisc/assembly.h:	ldd	-128(%r30),    %r5
asm-parisc/assembly.h:	ldd	-136(%r30),    %r4
asm-parisc/assembly.h:	ldd,mb	-144(%r30),    %r3
asm-parisc/assembly.h:	stw	 %r4,	-124(%r30)
asm-parisc/assembly.h:	stw	 %r5,	-120(%r30)
asm-parisc/assembly.h:	stw	 %r6,	-116(%r30)
asm-parisc/assembly.h:	stw	 %r7,	-112(%r30)
asm-parisc/assembly.h:	stw	 %r8,	-108(%r30)
asm-parisc/assembly.h:	stw	 %r9,	-104(%r30)
asm-parisc/assembly.h:	stw	 %r10,	-100(%r30)
asm-parisc/assembly.h:	stw	 %r11,	 -96(%r30)
asm-parisc/assembly.h:	stw	 %r12,	 -92(%r30)
asm-parisc/assembly.h:	stw	 %r13,	 -88(%r30)
asm-parisc/assembly.h:	stw	 %r14,	 -84(%r30)
asm-parisc/assembly.h:	stw	 %r15,	 -80(%r30)
asm-parisc/assembly.h:	stw	 %r16,	 -76(%r30)
asm-parisc/assembly.h:	stw	 %r17,	 -72(%r30)
asm-parisc/assembly.h:	stw	 %r18,	 -68(%r30)
asm-parisc/assembly.h:	stw	  %r3,	 -64(%r30)
asm-parisc/assembly.h:	ldw	 -64(%r30),    %r3
asm-parisc/assembly.h:	ldw	 -68(%r30),   %r18
asm-parisc/assembly.h:	ldw	 -72(%r30),   %r17
asm-parisc/assembly.h:	ldw	 -76(%r30),   %r16
asm-parisc/assembly.h:	ldw	 -80(%r30),   %r15
asm-parisc/assembly.h:	ldw	 -84(%r30),   %r14
asm-parisc/assembly.h:	ldw	 -88(%r30),   %r13
asm-parisc/assembly.h:	ldw	 -92(%r30),   %r12
asm-parisc/assembly.h:	ldw	 -96(%r30),   %r11
asm-parisc/assembly.h:	ldw	-100(%r30),   %r10
asm-parisc/assembly.h:	ldw	-104(%r30),   %r9
asm-parisc/assembly.h:	ldw	-108(%r30),   %r8
asm-parisc/assembly.h:	ldw	-112(%r30),   %r7
asm-parisc/assembly.h:	ldw	-116(%r30),   %r6
asm-parisc/assembly.h:	ldw	-120(%r30),   %r5
asm-parisc/assembly.h:	ldw	-124(%r30),   %r4
asm-parisc/assembly.h:	ldw,mb	-128(%r30),   %r3
asm-parisc/processor.h: * include/asm-parisc/processor.h
asm-parisc/processor.h:/* We cannot use MFIA as it was added for PA2.0 - prumpf
asm-parisc/processor.h:   PA-RISC.  This is no longer true, but this still seems like the
asm-parisc/processor.h:#define TASK_SIZE               (current->thread.task_size)
asm-parisc/processor.h:#define TASK_UNMAPPED_BASE      (current->thread.map_base)
asm-parisc/processor.h:** HP boxes are SMP - ie identical processors.
asm-parisc/processor.h:		char   sys_model_name[81]; /* PDC-ROM returnes this model name */
asm-parisc/processor.h:	char		*cpu_name;	/* e.g. "PA7300LC (PCX-L2)" */
asm-parisc/processor.h:** Per CPU data structure - ie varies per CPU.
asm-parisc/processor.h:	__u32 spaceid = (__u32)current->mm->context;	\
asm-parisc/processor.h:	regs->iasq[0] = spaceid;			\
asm-parisc/processor.h:	regs->iasq[1] = spaceid;			\
asm-parisc/processor.h:	regs->iaoq[0] = pc;				\
asm-parisc/processor.h:	regs->iaoq[1] = pc + 4;                         \
asm-parisc/processor.h:	regs->sr[2] = LINUX_GATEWAY_SPACE;              \
asm-parisc/processor.h:	regs->sr[3] = 0xffff;				\
asm-parisc/processor.h:	regs->sr[4] = spaceid;				\
asm-parisc/processor.h:	regs->sr[5] = spaceid;				\
asm-parisc/processor.h:	regs->sr[6] = spaceid;				\
asm-parisc/processor.h:	regs->sr[7] = spaceid;				\
asm-parisc/processor.h:	regs->gr[ 0] = USER_PSW;                        \
asm-parisc/processor.h:	regs->gr[30] = ((new_sp)+63)&~63;		\
asm-parisc/processor.h:	regs->gr[31] = pc;				\
asm-parisc/processor.h:	get_user(regs->gr[26],&sp[0]);			\
asm-parisc/processor.h:	get_user(regs->gr[25],&sp[-1]); 		\
asm-parisc/processor.h:	get_user(regs->gr[24],&sp[-2]); 		\
asm-parisc/processor.h:	get_user(regs->gr[23],&sp[-3]); 		\
asm-parisc/processor.h: * Duplicated from dl-machine.h for the benefit of readers:
asm-parisc/processor.h: *  due to the unique PA-RISC ABI.  As far as I know it looks like
asm-parisc/processor.h:   -----------------------------------  (user startup code creates this frame)
asm-parisc/processor.h:   |---------------------------------|
asm-parisc/processor.h:   |---------------------------------| (bprm->p)
asm-parisc/processor.h:   |---------------------------------|
asm-parisc/processor.h:   |---------------------------------|
asm-parisc/processor.h:   |---------------------------------|
asm-parisc/processor.h:   |---------------------------------|
asm-parisc/processor.h:   |---------------------------------| <- argv
asm-parisc/processor.h:   |---------------------------------| <- bprm->exec (HACK!)
asm-parisc/processor.h:   |---------------------------------|
asm-parisc/processor.h:   |---------------------------------| (mm->env_end)
asm-parisc/processor.h:   |---------------------------------| (mm->env_start, mm->arg_end)
asm-parisc/processor.h:   |---------------------------------|
asm-parisc/processor.h:   |---------------------------------| (mm->arg_start)
asm-parisc/processor.h:   stack base is at TASK_SIZE - rlim_max.
asm-parisc/processor.h:	__u32 spaceid = (__u32)current->mm->context;	\
asm-parisc/processor.h:	elf_caddr_t *argv = (elf_caddr_t *)bprm->exec + 1;	\
asm-parisc/processor.h:	regs->iasq[0] = spaceid;			\
asm-parisc/processor.h:	regs->iasq[1] = spaceid;			\
asm-parisc/processor.h:	regs->iaoq[0] = pc;				\
asm-parisc/processor.h:	regs->iaoq[1] = pc + 4;                         \
asm-parisc/processor.h:	regs->sr[2] = LINUX_GATEWAY_SPACE;              \
asm-parisc/processor.h:	regs->sr[3] = 0xffff;				\
asm-parisc/processor.h:	regs->sr[4] = spaceid;				\
asm-parisc/processor.h:	regs->sr[5] = spaceid;				\
asm-parisc/processor.h:	regs->sr[6] = spaceid;				\
asm-parisc/processor.h:	regs->sr[7] = spaceid;				\
asm-parisc/processor.h:	regs->gr[ 0] = USER_PSW;                        \
asm-parisc/processor.h:	regs->fr[ 0] = 0LL;                            	\
asm-parisc/processor.h:	regs->fr[ 1] = 0LL;                            	\
asm-parisc/processor.h:	regs->fr[ 2] = 0LL;                            	\
asm-parisc/processor.h:	regs->fr[ 3] = 0LL;                            	\
asm-parisc/processor.h:	regs->gr[30] = ((unsigned long)sp + 63) &~ 63;	\
asm-parisc/processor.h:	regs->gr[31] = pc;				\
asm-parisc/processor.h:	get_user(regs->gr[25], (argv - 1));		\
asm-parisc/processor.h:	regs->gr[24] = (long) argv;			\
asm-parisc/processor.h:	regs->gr[23] = 0;				\
asm-parisc/processor.h:					if (tsk->personality == PER_HPUX)  \
asm-parisc/processor.h:#define KSTK_EIP(tsk)	((tsk)->thread.regs.iaoq[0])
asm-parisc/processor.h:#define KSTK_ESP(tsk)	((tsk)->thread.regs.gr[30])
asm-parisc/processor.h:#define get_task_struct(tsk)	atomic_inc(&virt_to_page(tsk)->count)
asm-parisc/mmu_context.h:/* on PA-RISC, we actually have enough contexts to justify an allocator
asm-parisc/mmu_context.h:	if (atomic_read(&mm->mm_users) != 1)
asm-parisc/mmu_context.h:	mm->context = alloc_sid();
asm-parisc/mmu_context.h:	free_sid(mm->context);
asm-parisc/mmu_context.h:	mm->context = 0;
asm-parisc/mmu_context.h:		mtctl(__pa(next->pgd), 25);
asm-parisc/mmu_context.h:		load_context(next->context);
asm-parisc/mmu_context.h:	if (next->context == 0)
asm-parisc/mmu_context.h:	    next->context = alloc_sid();
asm-parisc/iosapic.h:**          they pack nicely for 64-bit compilation. (ie sizeof(long) == 8)
asm-parisc/iosapic.h:** virtualize pcidev->irq value. To be called by pci_fixup_bus().
asm-parisc/iosapic.h:	unsigned long           *lsi_id_eid;    /* point to IA-64 CPU id */
asm-parisc/rt_sigframe.h: * The 32-bit ABI wants at least 48 bytes for a function call frame:
asm-parisc/rt_sigframe.h: * 16 bytes for arg0-arg3, and 32 bytes for magic (the only part of
asm-parisc/rt_sigframe.h: * which Linux/parisc uses is sp-20 for the saved return pointer...)
asm-parisc/rt_sigframe.h:	(((sizeof(struct rt_sigframe) + 48) + 63) & -64)
asm-parisc/semaphore.h: * SMP- and interrupt-safe semaphores.
asm-parisc/semaphore.h: * PA-RISC version by Matthew Wilcox
asm-parisc/semaphore.h: * `count' is positive, the lock can be taken.  if it's 0, no-one is
asm-parisc/semaphore.h: * waiting on it.  if it's -1, at least one task is waiting.
asm-parisc/semaphore.h:	return sem->count;
asm-parisc/semaphore.h:	CHECK_MAGIC(sem->__magic);
asm-parisc/semaphore.h:	spin_lock_irq(&sem->sentry);
asm-parisc/semaphore.h:	if (sem->count > 0) {
asm-parisc/semaphore.h:		sem->count--;
asm-parisc/semaphore.h:	spin_unlock_irq(&sem->sentry);
asm-parisc/semaphore.h:	CHECK_MAGIC(sem->__magic);
asm-parisc/semaphore.h:	spin_lock_irq(&sem->sentry);
asm-parisc/semaphore.h:	if (sem->count > 0) {
asm-parisc/semaphore.h:		sem->count--;
asm-parisc/semaphore.h:	spin_unlock_irq(&sem->sentry);
asm-parisc/semaphore.h:	CHECK_MAGIC(sem->__magic);
asm-parisc/semaphore.h:	spin_lock_irqsave(&sem->sentry, flags);
asm-parisc/semaphore.h:	count = sem->count - 1;
asm-parisc/semaphore.h:		sem->count = count;
asm-parisc/semaphore.h:	spin_unlock_irqrestore(&sem->sentry, flags);
asm-parisc/semaphore.h:	CHECK_MAGIC(sem->__magic);
asm-parisc/semaphore.h:	spin_lock_irqsave(&sem->sentry, flags);
asm-parisc/semaphore.h:	if (sem->count < 0) {
asm-parisc/semaphore.h:		sem->count++;
asm-parisc/semaphore.h:	spin_unlock_irqrestore(&sem->sentry, flags);
asm-parisc/fcntl.h:/* open/fcntl - O_SYNC is only implemented on blocks devices and on files
asm-parisc/fcntl.h:#define O_DIRECT	00040000 /* direct disk access hint - currently ignored */
asm-parisc/mmzone.h:#define CHUNKMASK               (~(CHUNKSZ - 1))
asm-parisc/mmzone.h:#define NODE_MEM_MAP(nid)       (NODE_DATA(nid)->node_mem_map)
asm-parisc/mmzone.h:#define VALID_PAGE(page)	((page - mem_map) < max_mapnr)
asm-parisc/spinlock.h: * Read-write spinlocks, allowing multiple readers
asm-parisc/spinlock.h:	spin_lock_irqsave(&rw->lock, flags);
asm-parisc/spinlock.h:	rw->counter++;
asm-parisc/spinlock.h:	spin_unlock_irqrestore(&rw->lock, flags);
asm-parisc/spinlock.h:	spin_lock_irqsave(&rw->lock, flags);
asm-parisc/spinlock.h:	rw->counter--;
asm-parisc/spinlock.h:	spin_unlock_irqrestore(&rw->lock, flags);
asm-parisc/spinlock.h: * writers) in interrupt handlers someone fucked up and we'd dead-lock
asm-parisc/spinlock.h:	spin_lock(&rw->lock);
asm-parisc/spinlock.h:	if(rw->counter != 0) {
asm-parisc/spinlock.h:		spin_unlock(&rw->lock);
asm-parisc/spinlock.h:		while(rw->counter != 0);
asm-parisc/spinlock.h:/* write_unlock is absolutely trivial - we don't have to wait for anything */
asm-parisc/spinlock.h:	spin_unlock(&rw->lock);
asm-parisc/errno.h:#define	EXDEV		18	/* Cross-device link */
asm-parisc/errno.h:#define	EROFS		30	/* Read-only file system */
asm-parisc/errno.h:#define	ENOTSOCK	216	/* Socket operation on non-socket */
asm-parisc/superio.h:#define OCW2_EOI   0x20		/* Non-specific EOI */
asm-parisc/superio.h:	(((x)->vendor == PCI_VENDOR_ID_NS) && \
asm-parisc/superio.h:	(  ((x)->device == PCI_DEVICE_ID_NS_87415) \
asm-parisc/superio.h:	|| ((x)->device == PCI_DEVICE_ID_NS_87560_LIO) \
asm-parisc/superio.h:	|| ((x)->device == PCI_DEVICE_ID_NS_87560_USB) ) )
asm-parisc/byteorder.h:	__asm__("shd %0, %0, 16, %1\n\t"	/* shift abcdabcd -> cdab */
asm-parisc/byteorder.h:		"dep %1, 15, 8, %1\n\t"		/* deposit cdab -> cbab */
asm-parisc/byteorder.h:		"shd %0, %1, 8, %0"		/* shift abcdcbab -> dcba */
asm-parisc/byteorder.h:** From "PA-RISC 2.0 Architecture", HP Professional Books.
asm-parisc/byteorder.h:**      PERMH   01234567 -> 67452301 into %0
asm-parisc/byteorder.h:**      HSHL    67452301 -> 7*5*3*1* into %1
asm-parisc/byteorder.h:**      HSHR    67452301 -> *6*4*2*0 into %0
asm-parisc/byteorder.h:**      OR      %0 | %1  -> 76543210 into %0 (all done!)
asm-parisc/byteorder.h:	__asm__("dep %0, 15, 8, %0\n\t"		/* deposit 00ab -> 0bab */
asm-parisc/byteorder.h:		"shd %r0, %0, 8, %0"		/* shift 000000ab -> 00ba */
asm-parisc/softirq.h:#define cpu_bh_enable(cpu)	do { barrier(); local_bh_count(cpu)--; } while (0)
asm-parisc/hw_irq.h: *	<tomsoft@informatik.tu-chemnitz.de>
asm-parisc/timex.h: * linux/include/asm-parisc/timex.h
asm-parisc/bugs.h: *  include/asm-parisc/bugs.h
asm-parisc/bugs.h: * This is included by init/main.c to check for architecture-dependent bugs.
asm-parisc/namei.h: * linux/include/asm-parisc/namei.h
asm-parisc/namei.h: * Look at asm-sparc/namei.h for details.
asm-parisc/fixmap.h:#define TMPALIAS_MAP_START (__PAGE_OFFSET - 0x01000000)
asm-parisc/uaccess.h:#define get_fs()	(current->addr_limit)
asm-parisc/uaccess.h:#define set_fs(x)	(current->addr_limit = (x))
asm-parisc/uaccess.h: * r9 and 0x1 tells the exception handler to put -EFAULT in r8.
asm-parisc/uaccess.h:	long skip;           /* pcoq skip | r9 clear flag | r8 -EFAULT flag */
asm-parisc/uaccess.h:		 "\t.dword\t(2b-1b)+3\n"                \
asm-parisc/uaccess.h:		 "\t.dword\t(2b-1b)+3\n"                \
asm-parisc/uaccess.h:		 "\t.word\t(2b-1b)+3\n"                 \
asm-parisc/uaccess.h:		 "\t.word\t(2b-1b)+3\n"                 \
asm-parisc/uaccess.h:		 "\t.dword\t(2b-1b)+1\n"                    \
asm-parisc/uaccess.h:		 "\t.dword\t(2b-1b)+1\n"                    \
asm-parisc/uaccess.h:		 "\t.word\t(2b-1b)+1\n"                     \
asm-parisc/uaccess.h:		 "\t.word\t(2b-1b)+1\n"                     \
asm-parisc/uaccess.h:		 "\t.word\t(3b-1b)+1\n"
asm-parisc/uaccess.h:		 "\t.word\t(3b-2b)+1\n"
asm-parisc/uaccess.h:		 "\t.word\t(3b-1b)+1\n"
asm-parisc/uaccess.h:		 "\t.word\t(3b-2b)+1\n"
asm-parisc/uaccess.h: * Complex access routines -- external declarations
asm-parisc/uaccess.h: * Complex access routines -- macros
asm-parisc/asmregs.h: * Copyright (C) 1999 Hewlett-Packard (Frank Rowand)
asm-parisc/mman.h:#define MAP_GROWSDOWN	0x8000		/* stack-like segment */
asm-parisc/mman.h:/* The range 12-64 is reserved for page size specification. */
asm-parisc/posix_types.h: * This file is generally used by user-level software, so you need to
asm-parisc/posix_types.h:	__fdsetp->fds_bits[__tmp] |= (1UL<<__rem);
asm-parisc/posix_types.h:	__fdsetp->fds_bits[__tmp] &= ~(1UL<<__rem);
asm-parisc/posix_types.h:	return (__p->fds_bits[__tmp] & (1UL<<__rem)) != 0;
asm-parisc/posix_types.h: * for a 256-bit fd_set)
asm-parisc/posix_types.h:	unsigned long *__tmp = __p->fds_bits;
asm-parisc/posix_types.h:		__i--;
asm-parisc/scatterlist.h:	** arches to add this to 2.4.x. -ggg
asm-parisc/scatterlist.h:	/* an IOVA can be 64-bits on some PA-Risc platforms. */
asm-parisc/scatterlist.h:#define sg_virt_addr(sg) (((sg)->address) ? ((sg)->address) : \
asm-parisc/scatterlist.h:		(page_address((sg)->page) + (sg)->offset))
asm-parisc/scatterlist.h:#define sg_dma_address(sg) ((sg)->iova)
asm-parisc/scatterlist.h:#define sg_dma_len(sg)     ((sg)->iova_length)
asm-parisc/smplock.h:	if (task->lock_depth >= 0) \
asm-parisc/smplock.h: * Re-acquire the kernel lock
asm-parisc/smplock.h:	if (task->lock_depth >= 0) \
asm-parisc/smplock.h:	if (!++current->lock_depth)
asm-parisc/smplock.h:	if (--current->lock_depth < 0)
asm-parisc/page.h:#define PAGE_MASK	(~(PAGE_SIZE-1))
asm-parisc/page.h: * These are used to make use of C type-checking..
asm-parisc/page.h:	size = (size-1) >> (PAGE_SHIFT-1);
asm-parisc/page.h:	order = -1;
asm-parisc/page.h:#define PAGE_ALIGN(addr)	(((addr)+PAGE_SIZE-1)&PAGE_MASK)
asm-parisc/page.h:/* These macros don't work for 64-bit C code -- don't allow in C at all */
asm-parisc/page.h:#   define PA(x)	((x)-__PAGE_OFFSET)
asm-parisc/page.h:#define __pa(x)			((unsigned long)(x)-PAGE_OFFSET)
asm-parisc/page.h:#define VALID_PAGE(page)	((page - mem_map) < max_mapnr)
asm-parisc/poll.h:/* The rest seem to be more-or-less nonstandard. Check them! */
asm-parisc/rmap.h:#include <asm-generic/rmap.h>
asm-parisc/types.h:/* Dma addresses are 32-bits wide.  */
asm-parisc/sembuf.h: * - 64-bit time_t to solve y2038 problem
asm-parisc/sembuf.h: * - 2 miscellaneous 32-bit values
asm-parisc/system.h:/* these are here to de-mystefy the calling code, and to provide hooks */
asm-parisc/system.h:/* which I needed for debugging EIEM problems -PB */
asm-parisc/system.h:** PA-RISC architecture allows for weakly ordered memory accesses although
asm-parisc/system.h:** set in the O-bit of the page directory entry. Operating systems that
asm-parisc/system.h:** pages. The O-bit of the PSW should also be set to 1 (I don't believe any
asm-parisc/system.h:** of the processor implemented the PSW O-bit). The PCX-W ERS states that
asm-parisc/system.h:** the TLB O-bit is not implemented so the page directory does not need to
asm-parisc/system.h:** have the O-bit set when mapping pages (section 3.1). This section also
asm-parisc/system.h:** So it looks like nothing needs to be done for parisc-linux (yet).
asm-parisc/system.h:** (thanks to chada for the above comment -ggg)
asm-parisc/stat.h:/* This is the struct that 32-bit userspace applications are expecting.
asm-parisc/stat.h: * How 64-bit apps are going to be compiled, I have no idea.  But at least
asm-parisc/checksum.h: * and adds in "sum" (32-bit)
asm-parisc/checksum.h: * returns a 32-bit number suitable for feeding into itself
asm-parisc/checksum.h: * it's best to have buff aligned on a 32-bit boundary
asm-parisc/checksum.h: * here even more important to align src and dst on a 32-bit (or even
asm-parisc/checksum.h: * better 64-bit) boundary
asm-parisc/checksum.h:"	addib,<=	-4, %2, 2f\n"
asm-parisc/checksum.h:"	subi		-1, %0, %0\n"
asm-parisc/checksum.h:	/* add the swapped two 16-bit halves of sum,
asm-parisc/checksum.h:	   a possible carry from adding the two 16-bit halves,
asm-parisc/checksum.h: * computes the checksum of the TCP/UDP pseudo-header
asm-parisc/checksum.h: * returns a 16-bit checksum, already complemented
asm-parisc/checksum.h: * this routine is used for miscellaneous IP-like checksums, mainly
asm-parisc/checksum.h:"	add		%8, %3, %3\n"/* add 16-bit proto + len */
asm-parisc/checksum.h:"	add		%%r19, %0, %0\n"	/* fold into 32-bits */
asm-parisc/checksum.h:"	add		%8, %3, %3\n"	/* add 16-bit proto + len */
asm-parisc/checksum.h:	/* code stolen from include/asm-mips64 */
asm-parisc/checksum.h:		*err_ptr = -EFAULT;
asm-parisc/checksum.h:		return -1;
asm-parisc/termios.h:/* IRDA support - PA-RISC uses OUT1 as hardware flow control bit. */
asm-parisc/termios.h:#define N_IRDA		11	/* Linux IR - http://irda.sourceforge.net/ */
asm-parisc/termios.h:#define N_SMSBLOCK	12	/* SMS block mode - for talking to GSM data cards about SMS messages */
asm-parisc/termios.h:	get_user(__tmp,&(termio)->x); \
asm-parisc/termios.h:	*(unsigned short *) &(termios)->x = __tmp; \
asm-parisc/termios.h:	copy_from_user((termios)->c_cc, (termio)->c_cc, NCC); \
asm-parisc/termios.h:	put_user((termios)->c_iflag, &(termio)->c_iflag); \
asm-parisc/termios.h:	put_user((termios)->c_oflag, &(termio)->c_oflag); \
asm-parisc/termios.h:	put_user((termios)->c_cflag, &(termio)->c_cflag); \
asm-parisc/termios.h:	put_user((termios)->c_lflag, &(termio)->c_lflag); \
asm-parisc/termios.h:	put_user((termios)->c_line,  &(termio)->c_line); \
asm-parisc/termios.h:	copy_to_user((termio)->c_cc, (termios)->c_cc, NCC); \
asm-parisc/user.h:   dump format.  We are ELF-only, and so are our core dumps.  If we
asm-parisc/pdc_chassis.h: *		include/asm-parisc/pdc_chassis.h
asm-parisc/pdc_chassis.h: *      TODO:	- handle processor number on SMP systems (Reporting Entity ID)
asm-parisc/pdc_chassis.h: *      	- handle message ID
asm-parisc/pdc_chassis.h: *      	- handle timestamps
asm-parisc/pdc_chassis.h: * ----------
asm-parisc/pdc_chassis.h: * ----------
asm-parisc/pdc_chassis.h: * -----------------
asm-parisc/pdc_chassis.h: * -----------------
asm-parisc/pdc_chassis.h: * ------------
asm-parisc/pdc_chassis.h: * ------------
asm-parisc/pdc_chassis.h: * Set the three LEDs -- Run, Attn, and Fault.
asm-parisc/pdc_chassis.h:/* System running and unexpected reboot or non-critical error detected */
asm-parisc/pdc_chassis.h:/* Executing non-OS code */
asm-parisc/pdc_chassis.h:/* Boot failed - Executing non-OS code */
asm-parisc/pdc_chassis.h:/* Unexpected reboot occured - Executing non-OS code */
asm-parisc/pdc_chassis.h:/* Executing non-OS code - Non-critical error detected */
asm-parisc/pdc_chassis.h:/* Boot failed - Executing non-OS code - Non-critical error detected */
asm-parisc/pdc_chassis.h:/* Unexpected reboot/recovering - Executing non-OS code - Non-critical error detected */
asm-parisc/pdc_chassis.h:/* Boot failed - OS not up - PDC has detected a failure that prevents boot */
asm-parisc/pdc_chassis.h:/* No code running - Non-critical error detected (double fault situation) */
asm-parisc/pdc_chassis.h:/* Boot failed - OS not up - Fatal failure detected - Non-critical error detected */
asm-parisc/pdc_chassis.h: * --------------
asm-parisc/pdc_chassis.h: * --------------
asm-parisc/pdc_chassis.h:#define PDC_CHASSIS_ALERT_SERPROC	(1ULL << 36)	/* service proc - no failure */
asm-parisc/pdc_chassis.h:#define PDC_CHASSIS_ALERT_NURGENT	(2ULL << 36)	/* non-urgent operator attn */
asm-parisc/pdc_chassis.h:/* Source ID - platform dependent */
asm-parisc/pdc_chassis.h:/* Problem detail - problem source dependent */
asm-parisc/pdc_chassis.h:/* Activity status - implementation dependent */
asm-parisc/pdc_chassis.h:/* Caller subactivity - implementation dependent */
asm-parisc/pdc_chassis.h:#define PDC_CHASSIS_RET_IA64_NT		(13ULL << 52)	/* IA-64 NT */
asm-parisc/pdc_chassis.h:#define PDC_CHASSIS_RET_HPUX		(14ULL << 52)	/* HP-UX */
asm-parisc/pdc_chassis.h:/* System states - part of major changes in system state data field */
asm-parisc/pdc_chassis.h:/* EOM - separates log entries */
asm-parisc/serial.h: * include/asm-parisc/serial.h
asm-parisc/serial.h:	{ 0, LASI_BASE_BAUD, -1, 4, ASYNC_SKIP_TEST, 0, PORT_UNKNOWN,}, /* ttyS0 */
asm-parisc/pgtable.h: * we simulate an x86-style page table for the linux mm code
asm-parisc/pgtable.h: * require a hash-, or multi-level tree-lookup or something of that
asm-parisc/pgtable.h:#define MAX_ADDRBITS (PAGE_SHIFT + (PT_NLEVELS)*(PAGE_SHIFT - PT_NLEVELS))
asm-parisc/pgtable.h:#define SPACEID_SHIFT (MAX_ADDRBITS - 32)
asm-parisc/pgtable.h:#define PGDIR_SHIFT  (PAGE_SHIFT + (PT_NLEVELS - 1)*(PAGE_SHIFT - PT_NLEVELS))
asm-parisc/pgtable.h:#define PGDIR_MASK	(~(PGDIR_SIZE-1))
asm-parisc/pgtable.h:#define PTRS_PER_PGD    (1UL << (PAGE_SHIFT - PT_NLEVELS))
asm-parisc/pgtable.h:#define PMD_SHIFT       (PAGE_SHIFT + (PAGE_SHIFT - PT_NLEVELS))
asm-parisc/pgtable.h:#define PMD_MASK	(~(PMD_SIZE-1))
asm-parisc/pgtable.h:#define PTRS_PER_PMD    (1UL << (PAGE_SHIFT - PT_NLEVELS))
asm-parisc/pgtable.h:#define PTRS_PER_PTE    (1UL << (PAGE_SHIFT - PT_NLEVELS))
asm-parisc/pgtable.h:/*     of the following bits, so be careful (One example, bits 25-31  */
asm-parisc/pgtable.h:#define xlate_pabit(x) (31 - x)
asm-parisc/pgtable.h:   in the short term - dhd@linuxcare.com, 2000-08-08 */
asm-parisc/pgtable.h: * We could have an execute only page using "gateway - promote to priv
asm-parisc/pgtable.h:/* initial page tables for 0-8MB for kernel */
asm-parisc/pgtable.h: * for zero-mapped memory areas etc..
asm-parisc/pgtable.h: * The "pgd_xxx()" functions here are trivial for a folded two-level
asm-parisc/pgtable.h:		((((page)-(page)->zone->zone_mem_map) << PAGE_SHIFT) \
asm-parisc/pgtable.h:		+ ((page)->zone->zone_start_paddr))
asm-parisc/pgtable.h:#define PAGE_TO_PA(page) ((page - mem_map) << PAGE_SHIFT)
asm-parisc/pgtable.h:/* to find an entry in a page-table-directory */
asm-parisc/pgtable.h:((mm)->pgd + ((address) >> PGDIR_SHIFT))
asm-parisc/pgtable.h:/* to find an entry in a kernel page-table-directory */
asm-parisc/pgtable.h:/* Find an entry in the second-level page table.. */
asm-parisc/pgtable.h:((pmd_t *) pgd_page(*(dir)) + (((address)>>PMD_SHIFT) & (PTRS_PER_PMD-1)))
asm-parisc/pgtable.h:/* Find an entry in the third-level page table.. */ 
asm-parisc/pgtable.h:((pte_t *) pmd_page(*(pmd)) + (((address)>>PAGE_SHIFT) & (PTRS_PER_PTE-1)))
asm-parisc/pgtable.h:/* Encode and de-code a swap entry */
asm-parisc/unaligned.h:/* copied from asm-sparc/unaligned.h */
asm-parisc/param.h:#define NOGROUP		(-1)
asm-parisc/cache.h: * include/asm-parisc/cache.h
asm-parisc/cache.h: * PA 2.0 processors have 64-byte cachelines; PA 1.1 processors have
asm-parisc/cache.h: * 32-byte cachelines.  The default configuration is not for SMP anyway,
asm-parisc/cache.h:#define L1_CACHE_ALIGN(x)       (((x)+(L1_CACHE_BYTES-1))&~(L1_CACHE_BYTES-1))
asm-parisc/cache.h:extern void flush_data_cache_local(void);  /* flushes local data-cache only */
asm-parisc/cache.h:extern void flush_instruction_cache_local(void); /* flushes local code-cache only */
asm-parisc/cache.h:extern void flush_data_cache(void); /* flushes data-cache only (all processors) */
asm-parisc/cache.h:extern void cache_init(void);		/* initializes cache-flushing */
asm-parisc/siginfo.h:#define SI_PAD_SIZE	((SI_MAX_SIZE/sizeof(int)) - 3)
asm-parisc/siginfo.h: * Digital reserves positive values for kernel-generated signals.
asm-parisc/siginfo.h:#define SI_QUEUE	-1		/* sent by sigqueue */
asm-parisc/siginfo.h:#define SI_TIMER __SI_CODE(__SI_TIMER,-2) /* sent by timer expiration */
asm-parisc/siginfo.h:#define SI_MESGQ	-3		/* sent by real time mesq state change */
asm-parisc/siginfo.h:#define SI_ASYNCIO	-4		/* sent by AIO completion */
asm-parisc/siginfo.h:#define SI_SIGIO	-5		/* sent by queued SIGIO */
asm-parisc/siginfo.h:#define SI_TKILL	-6		/* sent by tkill system call */
asm-parisc/siginfo.h:#define SI_FROMUSER(siptr)	((siptr)->si_code <= 0)
asm-parisc/siginfo.h:#define SI_FROMKERNEL(siptr)	((siptr)->si_code > 0)
asm-parisc/siginfo.h:#define BUS_ADRERR	(__SI_FAULT|2)	/* non-existant physical address */
asm-parisc/siginfo.h:#define SIGEV_PAD_SIZE	((SIGEV_MAX_SIZE/sizeof(int)) - 3)
asm-parisc/siginfo.h:	if (from->si_code < 0)
asm-parisc/siginfo.h:		memcpy(to, from, 3*sizeof(int) + sizeof(from->_sifields._sigchld));
asm-parisc/floppy.h:(!vdma && ((unsigned long)(a)/K_64 != ((unsigned long)(a) + (s) - 1) / K_64))
asm-parisc/floppy.h:		    lcount; lcount--, lptr++) {
asm-parisc/floppy.h:		printk("DMA crossing 64-K boundary %p-%p\n", addr, addr+size);
asm-parisc/floppy.h:		return -1;
asm-parisc/floppy.h:static int FDC2 = -1;
asm-parisc/sockios.h:/* Socket-level I/O control calls. */
asm-parisc/keyboard.h: *  ---------------------------------------------------------------
asm-parisc/keyboard.h: *  linux/include/asm-parisc/keyboard.h
asm-parisc/keyboard.h: *  We try to keep the amount of generic code as low as possible -
asm-parisc/keyboard.h: *  careful or use a global flag or something - I strongly suggest
asm-parisc/keyboard.h:#define kbd_setkeycode		(*kbd_ops->setkeycode)
asm-parisc/keyboard.h:#define kbd_getkeycode		(*kbd_ops->getkeycode)
asm-parisc/keyboard.h:#define kbd_translate		(*kbd_ops->translate)
asm-parisc/keyboard.h:#define kbd_unexpected_up	(*kbd_ops->unexpected_up)
asm-parisc/keyboard.h:#define kbd_leds		(*kbd_ops->leds)
asm-parisc/keyboard.h:#define kbd_init_hw		(*kbd_ops->init_hw)
asm-parisc/keyboard.h:#define SYSRQ_KEY		(kbd_ops->sysrq_key)
asm-parisc/keyboard.h:#define	kbd_sysrq_xlate		(kbd_ops->sysrq_xlate)
asm-parisc/ioctl.h: * NOTE: This limits the max parameter size to 16kB -1 !
asm-parisc/ioctl.h:#define _IOC_NRMASK	((1 << _IOC_NRBITS)-1)
asm-parisc/ioctl.h:#define _IOC_TYPEMASK	((1 << _IOC_TYPEBITS)-1)
asm-parisc/ioctl.h:#define _IOC_SIZEMASK	((1 << _IOC_SIZEBITS)-1)
asm-parisc/ioctl.h:#define _IOC_DIRMASK	((1 << _IOC_DIRBITS)-1)
asm-parisc/ioctls.h:#define TIOCGPTN	_IOR('T',0x30, unsigned int) /* Get Pty Number (of pty-mux device) */
asm-parisc/msgbuf.h: * - 64-bit time_t to solve y2038 problem
asm-parisc/msgbuf.h: * - 2 miscellaneous 32-bit values
asm-parisc/grfioctl.h: * structures are HP-UX compatible for XFree86 usage 
asm-parisc/grfioctl.h:#define S9000_ID_A1439A		0x26D148EE	/* CRX24 = CRX+ (24-plane color) */
asm-parisc/grfioctl.h:#define S9000_ID_A1924A		0x26D1488C	/* GRX gray-scale */
asm-parisc/grfioctl.h:#define S9000_ID_TOMCAT		0x27FCCB6D	/* dual-headed ELK (Dual CRX) */
asm-parisc/grfioctl.h:#define CRT_ID_VISUALIZE_EG	0x2D08C0A7      /* Graffiti (built-in B132+/B160L) */
asm-parisc/grfioctl.h:#define GCTERM		_IOWR('G',20,int)	/* multi-headed Tomcat */ 
asm-parisc/socket.h:/* Security levels - as per NRL IPv6 - don't actually do anything */
asm-parisc/socket.h:#define SOCK_RDM	4	/* reliably-delivered message	*/
asm-ppc/dbdma.h: * Definitions for using the Apple Descriptor-Based DMA controller
asm-ppc/dbdma.h: * DBDMA control/status registers.  All little-endian.
asm-ppc/dbdma.h: * DBDMA command structure.  These fields are all little-endian!
asm-ppc/dbdma.h:    unsigned short command;	/* command word (has bit-fields) */
asm-ppc/dbdma.h:    unsigned int   cmd_dep;	/* command-dependent field */
asm-ppc/dbdma.h:#define KEY_STREAM2	0x200	/* device-dependent stream */
asm-ppc/dbdma.h:#define KEY_STREAM3	0x300	/* device-dependent stream */
asm-ppc/dbdma.h:#define KEY_SYSTEM	0x600	/* system memory-mapped space */
asm-ppc/dbdma.h:#define KEY_DEVICE	0x700	/* device memory-mapped space */
asm-ppc/dbdma.h:#define DBDMA_ALIGN(x)	(((unsigned)(x) + sizeof(struct dbdma_cmd) - 1) \
asm-ppc/dbdma.h:			 & -sizeof(struct dbdma_cmd))
asm-ppc/dbdma.h:	out_le32(&((regs)->control), (RUN|FLUSH)<<16);		\
asm-ppc/dbdma.h:	while(in_le32(&((regs)->status)) & (ACTIVE|FLUSH))	\
asm-ppc/io.h:#endif /* Platform-dependant I/O */
asm-ppc/io.h: * The insw/outsw/insl/outsl macros don't do byte-swapping.
asm-ppc/io.h: * are arrays of bytes, and byte-swapping is not appropriate in
asm-ppc/io.h: * that case.  - paulus
asm-ppc/io.h: * try to read data from a non-existent I/O port.  Because the
asm-ppc/io.h: * well-defined which instruction SRR0 will point to when the
asm-ppc/io.h:		"5:	li	%0,-1\n"		\
asm-ppc/io.h: * The *_ns versions below don't do byte-swapping.
asm-ppc/io.h: * The PCI bus is inherently Little-Endian.  The PowerPC is being
asm-ppc/io.h: * run Big-Endian.  Thus all values which cross the [PCI] barrier
asm-ppc/io.h: * must be endian-adjusted.  Also, the local DRAM has a different
asm-ppc/io.h:	return (unsigned long)address - KERNELBASE + PCI_DRAM_OFFSET;
asm-ppc/io.h:	return (void*) mm_ptov (address - PCI_DRAM_OFFSET);
asm-ppc/io.h:	return (void *)(address - PCI_DRAM_OFFSET + KERNELBASE);
asm-ppc/io.h:	return (unsigned long) address - KERNELBASE;
asm-ppc/io.h:#define page_to_phys(page)	(((page - mem_map) << PAGE_SHIFT) + PPC_MEMSTART)
asm-ppc/io.h: * Enforce In-order Execution of I/O:
asm-ppc/io.h:/* Enforce in-order execution of data I/O.
asm-ppc/io.h:		length--;
asm-ppc/io.h: * DMA-consistent mapping functions for PowerPCs that don't support
asm-ppc/residual.h:/*----------------------------------------------------------------------------*/
asm-ppc/residual.h:/*----------------------------------------------------------------------------*/
asm-ppc/residual.h:/* residual.h - Residual data structure passed in r3.                         */
asm-ppc/residual.h:/*----------------------------------------------------------------------------*/
asm-ppc/residual.h:/*----------------------------------------------------------------------------*/
asm-ppc/residual.h:  Enabled = 0x4000,                     /* 1 - PCI device is enabled          */
asm-ppc/residual.h:  Failed = 0x1000,                      /* 1 - device failed POST code tests  */
asm-ppc/residual.h:  Static = 0x0800,                      /* 0 - dynamically configurable
asm-ppc/residual.h:                                           1 - static                         */
asm-ppc/residual.h:  Dock = 0x0400,                        /* 0 - not a docking station device
asm-ppc/residual.h:                                           1 - is a docking station device    */
asm-ppc/residual.h:  Boot = 0x0200,                        /* 0 - device cannot be used for BOOT
asm-ppc/residual.h:                                           1 - can be a BOOT device           */
asm-ppc/residual.h:  Configurable = 0x0100,                /* 1 - device is configurable         */
asm-ppc/residual.h:  Disableable = 0x80,                   /* 1 - device can be disabled         */
asm-ppc/residual.h:  PowerManaged = 0x40,                  /* 0 - not managed; 1 - managed       */
asm-ppc/residual.h:  ReadOnly = 0x20,                      /* 1 - device is read only            */
asm-ppc/residual.h:  Removable = 0x10,                     /* 1 - device is removable            */
asm-ppc/residual.h:                                           PVR(0-15) = Version (e.g. 601)
asm-ppc/residual.h:                                           PVR(16-31 = EC Level               */
asm-ppc/residual.h:  unsigned long SIMMSize;               /* 0 - absent or bad
asm-ppc/atomic.h:#define atomic_read(v)		((v)->counter)
asm-ppc/atomic.h:#define atomic_set(v,i)		(((v)->counter) = (i))
asm-ppc/atomic.h:	bne-	1b"
asm-ppc/atomic.h:	: "=&r" (t), "=m" (v->counter)
asm-ppc/atomic.h:	: "r" (a), "r" (&v->counter), "m" (v->counter)
asm-ppc/atomic.h:	bne-	1b"
asm-ppc/atomic.h:	: "r" (a), "r" (&v->counter)
asm-ppc/atomic.h:	bne-	1b"
asm-ppc/atomic.h:	: "=&r" (t), "=m" (v->counter)
asm-ppc/atomic.h:	: "r" (a), "r" (&v->counter), "m" (v->counter)
asm-ppc/atomic.h:	bne-	1b"
asm-ppc/atomic.h:	: "r" (a), "r" (&v->counter)
asm-ppc/atomic.h:	bne-	1b"
asm-ppc/atomic.h:	: "=&r" (t), "=m" (v->counter)
asm-ppc/atomic.h:	: "r" (&v->counter), "m" (v->counter)
asm-ppc/atomic.h:	bne-	1b"
asm-ppc/atomic.h:	: "r" (&v->counter)
asm-ppc/atomic.h:	addic	%0,%0,-1\n"
asm-ppc/atomic.h:	bne-	1b"
asm-ppc/atomic.h:	: "=&r" (t), "=m" (v->counter)
asm-ppc/atomic.h:	: "r" (&v->counter), "m" (v->counter)
asm-ppc/atomic.h:	addic	%0,%0,-1\n"
asm-ppc/atomic.h:	bne-	1b"
asm-ppc/atomic.h:	: "r" (&v->counter)
asm-ppc/atomic.h:	addic.	%0,%0,-1\n\
asm-ppc/atomic.h:	blt-	2f\n"
asm-ppc/atomic.h:	bne-	1b"
asm-ppc/atomic.h:	: "r" (&v->counter)
asm-ppc/delay.h: * Thus we need usecs * HZ <= (2^32 - 1) / 19 = 226050910 and
asm-ppc/delay.h: * loops_per_jiffy <= (2^32 - 1) / 226 = 19004280
asm-ppc/delay.h: *  -- paulus
asm-ppc/raven.h: *  asm-ppc/raven.h -- Raven MPIC chip.
asm-ppc/ipcbuf.h: * - 1 32-bit value to fill up for 8-byte alignment
asm-ppc/ipcbuf.h: * - 2 miscellaneous 64-bit values (so that this structure matches
asm-ppc/ucontext.h:	/* glibc has 1024-bit signal masks, ours are 64-bit */
asm-ppc/parport.h: * parport.h: platform-specific PC-style parport initialisation
asm-ppc/ocp_ids.h: * strings might work better.  -- paulus
asm-ppc/ocp_ids.h:/* Vendor IDs 0x0001 - 0xFFFF copied from pci_ids.h */
asm-ppc/ocp_ids.h:/* system 0x0001 - 0x001F */
asm-ppc/ocp_ids.h:/* Timers 0x0020 - 0x002F */
asm-ppc/ocp_ids.h:/* Serial 0x0030 - 0x006F*/
asm-ppc/ocp_ids.h:/* Memory devices 0x0090 - 0x009F */
asm-ppc/ocp_ids.h:/* Display 0x00A0 - 0x00AF */
asm-ppc/ocp_ids.h:/* Sound 0x00B0 - 0x00BF */
asm-ppc/ocp_ids.h:/* Mass Storage 0x00C0 - 0xxCF */
asm-ppc/ocp_ids.h:/* Misc 0x00D0 - 0x00DF*/
asm-ppc/ocp_ids.h:/* Network 0x0200 - 0x02FF */
asm-ppc/ocp_ids.h:		int	zmii_idx;	/* ZMII device index or -1 */
asm-ppc/ocp_ids.h:		int	mdio_idx;	/* EMAC idx of MDIO master or -1 */
asm-ppc/ocp_ids.h:/* Bridge devices 0xE00 - 0xEFF */
asm-ppc/ibm44x.h: * include/asm-ppc/ibm44x.h
asm-ppc/ibm44x.h: * Copyright 2002-2003 MontaVista Software Inc.
asm-ppc/ibm44x.h: * 36-bit trap ranges
asm-ppc/ibm44x.h:#define UIC0_UIC1NC      30	/* UIC1 non-critical interrupt */
asm-ppc/ibm44x.h:#define MALESR_OEN		0x00080000	/* OPB Non-Fullword Error */
asm-ppc/ibm44x.h:#define MALESR_ONEI		0x00000008	/* OPB Non-Fullword Error Interrupt */
asm-ppc/ibm44x.h:#define MALIER_NE		0x00000008	/* OPB Non-word Transfer Int Enable */
asm-ppc/ibm44x.h: * PCI-X definitions
asm-ppc/bitops.h: * resulted in errors from egcs.  Things appear to be OK with gcc-2.95.
asm-ppc/bitops.h:	bne-	1b"
asm-ppc/bitops.h: * non-atomic version
asm-ppc/bitops.h:	bne-	1b"
asm-ppc/bitops.h: * non-atomic version
asm-ppc/bitops.h:	bne-	1b"
asm-ppc/bitops.h: * non-atomic version
asm-ppc/bitops.h: * non-atomic version
asm-ppc/bitops.h: * non-atomic version
asm-ppc/bitops.h: * non-atomic version
asm-ppc/bitops.h:	return 31 - lz;
asm-ppc/bitops.h:	return __ilog2(x & -x);
asm-ppc/bitops.h:	return __ilog2(x & -x) + 1;
asm-ppc/bitops.h: * of bits set) of a N-bit word
asm-ppc/bitops.h: * Linus' asm-alpha/bitops.h.
asm-ppc/bitops.h:	size -= result;
asm-ppc/bitops.h:		tmp |= ~0UL >> (32-offset);
asm-ppc/bitops.h:		size -= 32;
asm-ppc/bitops.h:		size -= 32;
asm-ppc/bitops.h: * Linus' asm-alpha/bitops.h and modified for a big-endian machine.
asm-ppc/bitops.h:	size -= result;
asm-ppc/bitops.h:		tmp |= ~0UL >> (32-offset);
asm-ppc/bitops.h:		size -= 32;
asm-ppc/bitops.h:		size -= 32;
asm-ppc/ibm4xx.h: *  0 - id should be probed
asm-ppc/ibm4xx.h: *  1 - id should be ignored
asm-ppc/ibm4xx.h: * Default value of 0x00000000 - will result in usual
asm-ppc/ibm4xx.h: * auto-detection logic.
asm-ppc/amipcmcia.h:#include <asm-m68k/amipcmcia.h>
asm-ppc/div64.h:		__r = (u32)__n - __q * __d;	\
asm-ppc/resource.h:#define RLIMIT_MEMLOCK	8		/* max locked-in-memory address space */
asm-ppc/ptrace.h: * since we can keep non-volatile in the thread_struct
asm-ppc/ptrace.h:	unsigned long dsisr;		/* used for ESR on 4xx/Book-E */
asm-ppc/ptrace.h:#define instruction_pointer(regs) ((regs)->nip)
asm-ppc/ptrace.h:#define user_mode(regs) (((regs)->msr & MSR_PR) != 0)
asm-ppc/pgalloc.h:/* 44x uses an 8kB pgdir because it has 8-byte Linux PTEs. */
asm-ppc/pgalloc.h: * as well - it gives us quite a speedup.
asm-ppc/pgalloc.h: * per cpu list of zero pages because we do the zero-ing with the cache
asm-ppc/pgalloc.h: * off and the access routines are lock-free but the pgt cache stuff
asm-ppc/pgalloc.h: * is per-cpu since it isn't done with any lock-free access routines
asm-ppc/pgalloc.h: * (although I think we need arch-specific routines so I can do lock-free).
asm-ppc/pgalloc.h: * -- Cort
asm-ppc/pgalloc.h:extern unsigned long *zero_cache;    /* head linked list of pre-zero'd pages */
asm-ppc/pgalloc.h:extern atomic_t zero_sz;	     /* # currently pre-zero'd pages */
asm-ppc/pgalloc.h:/* return a pre-zero'd page from the list, return NULL if none available -- Cort */
asm-ppc/pgalloc.h:                pgtable_cache_size--;
asm-ppc/pgalloc.h:                pgtable_cache_size--;
asm-ppc/unistd.h:		__sc_ret = -1;						\
asm-ppc/unistd.h:	return waitpid(-1,wait_stat,0);
asm-ppc/dma.h:/* in arch/ppc/kernel/setup.c -- Cort */
asm-ppc/dma.h: *  controller 1: channels 0-3, byte operations, ports 00-1F
asm-ppc/dma.h: *  controller 2: channels 4-7, word operations, ports C0-DF
asm-ppc/dma.h: *  - ALL registers are 8 bits only, regardless of transfer size
asm-ppc/dma.h: *  - channel 4 is not used - cascades 1 into 2.
asm-ppc/dma.h: *  - channels 0-3 are byte - addresses/counts are for physical bytes
asm-ppc/dma.h: *  - channels 5-7 are word - addresses/counts are for physical words
asm-ppc/dma.h: *  - transfers must not cross physical 64K (0-3) or 128K (5-7) boundaries
asm-ppc/dma.h: *  - transfer count loaded to registers is 1 less than actual count
asm-ppc/dma.h: *  - controller 2 offsets are all even (2x offsets for controller 1)
asm-ppc/dma.h: *  - page registers for 5-7 don't use data bit 0, represent 128K pages
asm-ppc/dma.h: *  - page registers for 0-3 use bit 0, represent 64K pages
asm-ppc/dma.h: *  Address mapping for channels 0-3:
asm-ppc/dma.h: *  Address mapping for channels 5-7:
asm-ppc/dma.h: * Again, channels 5-7 transfer _physical_ words (16 bits), so addresses
asm-ppc/dma.h: * and counts _must_ be word-aligned (the lowest address bit is _ignored_ at
asm-ppc/dma.h: * the hardware level, so odd-byte transfers aren't possible).
asm-ppc/dma.h: * count - 1 : 64K => 0xFFFF, 1 => 0x0000.  Thus, count is always 1 or more,
asm-ppc/dma.h: * and up to 128K bytes may be transferred on channels 5-7 in one operation.
asm-ppc/dma.h:#define SND_DMA1 -1
asm-ppc/dma.h:#define SND_DMA2 -1
asm-ppc/dma.h:#define DMA1_MASK_REG		0x0A	/* single-channel mask (w) */
asm-ppc/dma.h:#define DMA1_CLEAR_FF_REG	0x0C	/* clear pointer flip-flop (w) */
asm-ppc/dma.h:#define DMA1_MASK_ALL_REG	0x0F	/* all-channels mask (w) */
asm-ppc/dma.h:#define DMA2_MASK_REG		0xD4	/* single-channel mask (w) */
asm-ppc/dma.h:#define DMA2_CLEAR_FF_REG	0xD8	/* clear pointer flip-flop (w) */
asm-ppc/dma.h:#define DMA2_MASK_ALL_REG	0xDE	/* all-channels mask (w) */
asm-ppc/dma.h:#define DMA_MODE_CASCADE	0xC0	/* pass thru DREQ->HRQ, DACK<-HLDA only */
asm-ppc/dma.h: * After that, keep track of it. :-)
asm-ppc/dma.h: * --- In order to do that, the DMA routines below should ---
asm-ppc/dma.h: * --- only be used while interrupts are disabled! ---
asm-ppc/dma.h: * Assumes dma flip-flop is clear.
asm-ppc/dma.h: * NOTE 2: "count" represents _bytes_ and must be even for channels 5-7.
asm-ppc/dma.h:	count--;
asm-ppc/dma.h: * Assumes DMA flip-flop is clear.
asm-ppc/dma.h:	/* using short to get 16-bit wrap around */
asm-ppc/elf.h:#define elf_check_arch(x) ((x)->e_machine == EM_PPC)
asm-ppc/elf.h:#define ELF_HWCAP	(cur_cpu_spec[0]->cpu_user_features)
asm-ppc/elf.h: * - keep the final alignment of sp (sp & 0xf)
asm-ppc/elf.h: * - make sure the 32-bit value at the first 16 byte aligned position of
asm-ppc/elf.h: * - for compatibility with glibc ARCH_DLINFO must always be defined on PPC,
asm-ppc/elf.h:	sp -= DLINFO_ARCH_ITEMS * 2;					\
asm-ppc/elf.h:	sp -= 2*2;							\
asm-ppc/gg2.h: *  asm-ppc/gg2.h -- VLSI VAS96011/12 `Golden Gate 2' register definitions
asm-ppc/ide.h: *  linux/include/asm-ppc/ide.h
asm-ppc/ide.h: *  Copyright (C) 1994-1996 Linus Torvalds & authors */
asm-ppc/ide.h:		hw->io_ports[i] = reg++;
asm-ppc/ide.h:		hw->io_ports[IDE_CONTROL_OFFSET] = ctrl_port;
asm-ppc/ide.h:		hw->io_ports[IDE_CONTROL_OFFSET] =
asm-ppc/ide.h:			hw->io_ports[IDE_DATA_OFFSET] + 0x206;
asm-ppc/ide.h:	hw->io_ports[IDE_IRQ_OFFSET] = 0;
asm-ppc/ide.h: * The following are not needed for the non-m68k ports
asm-ppc/irq.h: * signal polarity and level/edge sensing to the low-level PIC chip
asm-ppc/irq.h:#define IRQ_POLARITY_POSITIVE	0x2	/* high level or low->high edge */
asm-ppc/irq.h:#define IRQ_POLARITY_NEGATIVE	0x0	/* low level or high->low edge */
asm-ppc/irq.h: * there are eight internal interrupts for the on-chip serial port
asm-ppc/irq.h: * interrupt pins and there are 17 internal interrupts for the on-chip
asm-ppc/irq.h: * serial port, DMA controller, on-chip Ethernet controller, PCI, etc.
asm-ppc/irq.h: * through the PCI and PCI-ISA bridges.
asm-ppc/irq.h:/* These values must be zero-based and map 1:1 with the SIU configuration.
asm-ppc/irq.h:/* Some internal interrupt registers use an 8-bit mask for the interrupt
asm-ppc/irq.h:#define	mk_int_int_mask(IL) (1 << (7 - (IL/2)))
asm-ppc/irq.h:/* always the same on 8xx -- Cort */
asm-ppc/irq.h: * date processor documentation -- Dan).
asm-ppc/irq.h:/* pedantic: these are long because they are used with set_bit --RR */
asm-ppc/mmu.h: * virtual/physical addressing like 32-bit virtual / 36-bit
asm-ppc/mmu.h: * physical need a larger than native word size type. -Matt
asm-ppc/mmu.h:	unsigned long w:1;	/* Write-thru cache mode */
asm-ppc/mmu.h:	unsigned long n:1;	/* No-execute */
asm-ppc/mmu.h:	unsigned long w:1;	/* Write-thru cache */
asm-ppc/mmu.h: * During software tablewalk, the registers used perform mask/shift-add
asm-ppc/mmu.h: * At present, all PowerPC 400-class processors share a similar TLB
asm-ppc/mmu.h: * 64-entry, fully-associative TLB which is maintained totally under
asm-ppc/mmu.h: * hardware-managed, 4-entry, fully- associative TLB which serves as a
asm-ppc/mmu.h: * portion.  On all architectures, the data portion is 32-bits.
asm-ppc/mmu.h: * writing, and searchoing using the 4xx-specific tlbre, tlbwr, and tlbsx
asm-ppc/mmu.h:#define TLB_W           0x00000008      /* Caching is write-through */
asm-ppc/mmu.h:#define PPC44x_TLB_W		0x00000800      /* Caching is write-through */
asm-ppc/ocp.h: *          Mipsys - France
asm-ppc/ocp.h: *  TODO: - Add get/put interface & fixup locking to provide same API for
asm-ppc/ocp.h: *	  - Rework PM callbacks
asm-ppc/ocp.h:#define OCP_IRQ_NA	-1	/* used when ocp device does not have an irq */
asm-ppc/ocp.h:#define OCP_IRQ_MUL	-2	/* used for ocp devices with multiply irqs */
asm-ppc/ocp.h:#define OCP_NULL_TYPE	-1	/* used to mark end of list */
asm-ppc/ocp.h:#define OCP_ANY_INDEX	-1
asm-ppc/ocp.h: *             given core. This is typically used for cross-driver
asm-ppc/ocp.h:	u32			current_state;	/* Current operating state. In ACPI-speak,
asm-ppc/ocp.h:						   this is D0-D3, D0 being fully functional,
asm-ppc/ocp.h:							   hot-plug capable driver) */
asm-ppc/ocp.h:/* Similar to the helpers above, these manipulate per-ocp_dev
asm-ppc/ocp.h: * driver-specific data.  Currently stored as ocp_dev::ocpdev,
asm-ppc/ocp.h:	return pdev->drvdata;
asm-ppc/ocp.h:	pdev->drvdata = data;
asm-ppc/ocp.h:	mtdcr(DCRN_CPMFR, mfdcr(DCRN_CPMFR) | odev->def->pm);
asm-ppc/ocp.h:	mtdcr(DCRN_CPMFR, mfdcr(DCRN_CPMFR) & ~odev->def->pm);
asm-ppc/pci.h: * Set this to 1 if you want the kernel to re-assign all PCI
asm-ppc/pci.h: * into a different address on the PCI bus.  On 32-bit cpus, we assume
asm-ppc/pci.h: * this mapping is 1-1, but on 64-bit systems it often isn't.
asm-ppc/pci.h: * Non-consistent cache support by Dan Malek
asm-ppc/pci.h: * NULL for PCI-like buses (ISA, EISA).
asm-ppc/pci.h: * Returns non-NULL cpu-view pointer to the buffer if successful and
asm-ppc/pci.h: * The 32-bit bus address to use is returned.
asm-ppc/pci.h:	return (page - mem_map) * PAGE_SIZE + PCI_DRAM_OFFSET + offset;
asm-ppc/pci.h: * mode for DMA.  This is the scather-gather version of the
asm-ppc/pci.h: * The same as pci_dma_sync_single but for a scatter-gather list,
asm-ppc/pci.h:		if (sg->address)
asm-ppc/pci.h:			consistent_sync(sg->address, sg->length, direction);
asm-ppc/pci.h:			consistent_sync_page(sg->page, sg->offset,
asm-ppc/pci.h:					sg->length, direction);
asm-ppc/pci.h: * only drive the low 24-bits during PCI bus mastering, then
asm-ppc/pci.h: * At present there are very few 32-bit PPC machines that can have
asm-ppc/m48t35.h: *  Registers for the SGS-Thomson M48T35 Timekeeper RAM chip
asm-ppc/m48t35.h: *  Registers for the SGS-Thomson M48T37 Timekeeper RAM chip
asm-ppc/m48t35.h:#define M48T35_RTC_FLAGS	(-8)	/* the negative regs are really T37 only */
asm-ppc/m48t35.h:#define M48T35_RTC_CENTURY	(-7)
asm-ppc/m48t35.h:#define M48T35_RTC_AL_SEC	(-6)
asm-ppc/m48t35.h:#define M48T35_RTC_AL_MIN	(-5)
asm-ppc/m48t35.h:#define M48T35_RTC_AL_HRS	(-4)
asm-ppc/m48t35.h:#define M48T35_RTC_AL_DOM	(-3)
asm-ppc/m48t35.h:#define M48T35_RTC_INTERRUPT	(-2)
asm-ppc/m48t35.h:#define M48T35_RTC_WATCHDOG	(-1)
asm-ppc/pnp.h:/*----------------------------------------------------------------------------*/
asm-ppc/pnp.h:/*----------------------------------------------------------------------------*/
asm-ppc/pnp.h:#define PNPmouse5    "PNP0F05"       /* Mousesystems 3 Button Mouse - COM2    */
asm-ppc/pnp.h:#define PNPmouse6    "PNP0F06"       /* Genius Mouse - COM1                   */
asm-ppc/pnp.h:#define PNPmouse7    "PNP0F07"       /* Genius Mouse - COM2                   */
asm-ppc/pnp.h:#define PNPscsi2     "PNPA002"       /* Future Domain 16-700 Compat SCSI Cntlr*/
asm-ppc/pnp.h:#define PNPLTmsp     "IBM001F"       /* Lightning/Terlingua Mini-SP           */
asm-ppc/pnp.h:#define L1_32bit_mem             0x18   /* 32-bit memory only                 */
asm-ppc/pnp.h:#define L1_8_16bit_mem           0x10   /* 8- and 16-bit supported            */
asm-ppc/pnp.h:#define L1_Cache                 0x02   /* read cacheable, write-through      */
asm-ppc/pnp.h:#define L6_Packet                0x86   /* 32-bit Fixed Loc Mem Range Desc    */
asm-ppc/pnp.h:  IndirectNVRAM24 = 2,                  /* Indirectly addressed - 24 bit      */
asm-ppc/pnp.h:  unsigned char VendorID2;              /* Product number - vendor assigned   */
asm-ppc/pnp.h:  unsigned char VendorID3;              /* Product number - vendor assigned   */
asm-ppc/pnp.h:/* Tag type - 0 = small; 1 = large */
asm-ppc/pnp.h:/* Small item name is 4 bits - one of PnPItemName enum above */
asm-ppc/pnp.h:/* Small item count is 3 bits - count of further bytes in packet */
asm-ppc/pnp.h:/* Large item name is 7 bits - one of PnPItemName enum above */
asm-ppc/pnp.h:                                        /* bit(7:1) cmd in range x31-x37      */
asm-ppc/pnp.h:                                        /* bit(7:0) cmd in range x28-x3f (opt)*/
asm-ppc/pnp.h:                                        /*  bit(0) - high true edge sensitive */
asm-ppc/pnp.h:                                        /*  bit(1) - low true edge sensitive  */
asm-ppc/pnp.h:                                        /*  bit(2) - high true level sensitive*/
asm-ppc/pnp.h:                                        /*  bit(3) - low true level sensitive */
asm-ppc/pnp.h:                                        /*  bit(7:4) - must be 0              */
asm-ppc/pnp.h:                                        /*  x02 = sub-optimal but functional  */
asm-ppc/pnp.h:    unsigned char Tag;                  /* small tag = 0x7m m = 1-7           */
asm-ppc/pnp.h:         unsigned char Type;            /* 00=non-IBM                         */
asm-ppc/pnp.h:    unsigned char Check;                /* optional - checksum                */
asm-ppc/pnp.h:         unsigned char Type;            /* 00=non-IBM                         */
asm-ppc/rtc.h: * inclue/asm-ppc/rtc.h
asm-ppc/rtc.h: * include/asm-m68k/rtc.h
asm-ppc/rtc.h:#define RTC_UIE 0x10		/* update-finished interrupt enable */
asm-ppc/rtc.h:#define RTC_SQWE 0x08		/* enable square-wave output */
asm-ppc/rtc.h:#define RTC_24H 0x02		/* 24 hour mode - else hours bit 7 means pm */
asm-ppc/rtc.h:#define RTC_DST_EN 0x01	        /* auto switch DST - works f. USA only */
asm-ppc/rtc.h:		time->tm_year -= 1900;
asm-ppc/rtc.h:		time->tm_mon -= 1; /* Make sure userland has a 0-based month */
asm-ppc/rtc.h:		nowtime = mktime(time->tm_year+1900, time->tm_mon+1,
asm-ppc/rtc.h:				time->tm_mday, time->tm_hour, time->tm_min,
asm-ppc/rtc.h:				time->tm_sec);
asm-ppc/rtc.h:		return -EINVAL;
asm-ppc/rtc.h:	return -EINVAL;
asm-ppc/rtc.h:	return -EINVAL;
asm-ppc/smp.h: * Copyright (C) 1996-2001 Cort Dougan <cort@fsmlabs.com>
asm-ppc/smp.h:/* 1 to 1 mapping on PPC -- Cort */
asm-ppc/smp.h:#define smp_processor_id() (current->processor)
asm-ppc/tlb.h:#include <asm-generic/tlb.h>
asm-ppc/xor.h:#include <asm-generic/xor.h>
asm-ppc/amigahw.h:#include <asm-m68k/amigahw.h>
asm-ppc/signal.h:#define SIGRTMAX	(_NSIG-1)
asm-ppc/signal.h: * SA_INTERRUPT is a no-op, but left due to historical reasons. Use the
asm-ppc/signal.h:#define SA_INTERRUPT	0x20000000 /* dummy -- ignored */
asm-ppc/signal.h:#define SIG_ERR	((__sighandler_t)-1)	/* error return from signal */
asm-ppc/keylargo.h:/* "Pangea" chipset has keylargo device-id 0x25 while core99
asm-ppc/keylargo.h: * has device-id 0x22. The rev. of the pangea one is 0, so we
asm-ppc/keylargo.h: * experimented... --BenH.
asm-ppc/setup.h:#include <asm-m68k/setup.h>
asm-ppc/8xx_immap.h: * functional files.....but anyone else is welcome to try.  -- Dan
asm-ppc/8xx_immap.h:/* The key to unlock registers maintained by keep-alive power.
asm-ppc/hardirq.h:#define hardirq_exit(cpu)	(local_irq_count(cpu)--)
asm-ppc/hardirq.h:		if (loops-- == 0) {
asm-ppc/hardirq.h:	--local_irq_count(cpu);
asm-ppc/sections.h:/* this is actually just common chrp/pmac code, not OF code -- Cort */
asm-ppc/processor.h: * now.  This whole thing needs regorganized (maybe per-core
asm-ppc/processor.h: * files) * so that it becomes readable. -Matt
asm-ppc/processor.h:#define FPSCR_ZX	0x04000000	/* Zero-devide exception summary */
asm-ppc/processor.h:#define FPSCR_VXISI	0x00800000	/* Invalid op for Inv - Inv */
asm-ppc/processor.h:#define FPSCR_NI	0x00000004	/* FPU non IEEE-Mode */
asm-ppc/processor.h:#define   DBCR0_IA12        0x00200000  /* Instr Addr 1-2 range enable     */
asm-ppc/processor.h:#define   DBCR0_IA12X       0x00100000  /* Instr Addr 1-2 range eXclusive  */
asm-ppc/processor.h:#define   DBCR0_IA34        0x00020000  /* Instr Addr 3-4 range Enable     */
asm-ppc/processor.h:#define   DBCR0_IA34X       0x00010000  /* Instr Addr 3-4 range eXclusive  */
asm-ppc/processor.h:#define   DBCR0_IA12T       0x00008000  /* Instr Addr 1-2 range Toggle     */
asm-ppc/processor.h:#define   DBCR0_IA34T       0x00004000  /* Instr Addr 3-4 range Toggle     */
asm-ppc/processor.h:#define	SPRN_DCWR	0x3BA	/* Data Cache Write-thru Register */
asm-ppc/processor.h:#define	  DCWR_COPY		0	/* Copy-back */
asm-ppc/processor.h:#define	  DCWR_WRITE		1	/* Write-through */
asm-ppc/processor.h:#define	  ESR_IMCP	0x80000000	/* Instr. Machine Check - Protection */
asm-ppc/processor.h:#define	  ESR_IMCN	0x40000000	/* Instr. Machine Check - Non-config */
asm-ppc/processor.h:#define	  ESR_IMCB	0x20000000	/* Instr. Machine Check - Bus error */
asm-ppc/processor.h:#define	  ESR_IMCT	0x10000000	/* Instr. Machine Check - Timeout */
asm-ppc/processor.h:#define	  ESR_PIL	0x08000000	/* Program Exception - Illegal */
asm-ppc/processor.h:#define	  ESR_PPR	0x04000000	/* Program Exception - Priveleged */
asm-ppc/processor.h:#define	  ESR_PTR	0x02000000	/* Program Exception - Trap */
asm-ppc/processor.h:#define	  ESR_DST	0x00800000	/* Storage Exception - Data miss */
asm-ppc/processor.h:#define	  ESR_DIZ	0x00400000	/* Storage Exception - Zone fault */
asm-ppc/processor.h:#define	  HID0_TBEN	(1<<26)		/* Timebase enable - 74xx and 82xx */
asm-ppc/processor.h:#define	  HID0_STEN	(1<<24)		/* Software table search enable - 745x */
asm-ppc/processor.h:#define	  HID0_HIGH_BAT	(1<<23)		/* Enable high BATs - 7455 */
asm-ppc/processor.h:#define	  HID0_BHTCLR	(1<<18)		/* Clear branch history table - 7450 */
asm-ppc/processor.h:#define	  HID0_XAEN	(1<<17)		/* Extended addressing enable - 7450 */
asm-ppc/processor.h:#define   HID0_NHR	(1<<16)		/* Not hard reset (software bit-7450)*/
asm-ppc/processor.h:#define   HID0_LRSTK	(1<<4)		/* Link register stack - 745x */
asm-ppc/processor.h:#define   HID0_FOLD	(1<<3)		/* Branch Folding enable - 745x */
asm-ppc/processor.h:#define	  HID0_NOPDST	(1<<1)		/* No-op dst, dstt, etc. instr. */
asm-ppc/processor.h:#define	  HID0_NOPTI	(1<<0)		/* No-op dcbt and dcbst instr. */
asm-ppc/processor.h:#define L2CR_L2WT		0x00080000	/* L2 write-through */
asm-ppc/processor.h:#define L3CR_L3PSP		0x0000e000	/* L3 P-clock sample point */
asm-ppc/processor.h:#define L3CR_L3NIRCA		0x00000080	/* L3 non-integer ratio clock adj. */
asm-ppc/processor.h:#define	SPRN_SLER	0x3BB	/* Little-endian real mode */
asm-ppc/processor.h:#define	SPRN_TBHU	0x3CC	/* Time Base High User-mode (4xx) */
asm-ppc/processor.h:#define	SPRN_TBLU	0x3CD	/* Time Base Low User-mode (4xx) */
asm-ppc/processor.h:#define  MCSR_ICP	0x04000000 /* I-Cache Parity Error */
asm-ppc/processor.h:#define  MCSR_DCSP	0x02000000 /* D-Cache Search Parity Error */
asm-ppc/processor.h:#define  MCSR_DCFP	0x01000000 /* D-Cache Flush Parity Error */
asm-ppc/processor.h:/* Short-hand versions for a number of the above SPRNs */
asm-ppc/processor.h: * IBM has further subdivided the standard PowerPC 16-bit version and
asm-ppc/processor.h: * This is currently limited to CONFIG_ALL_PPC and CHRP/PReP/PMac. -- Tom
asm-ppc/processor.h:#define _MACH_Pmac	0x00000002	/* pmac or pmac clone (non-chrp) */
asm-ppc/processor.h:        .stabs __stringify(n:F-1),N_FUN,0,0,n;\
asm-ppc/processor.h:/* Lazy FPU handling on uni-processor */
asm-ppc/processor.h: * to match the mac we can raise this. -- Cort
asm-ppc/processor.h:	void		*pgdir;		/* root of page-table tree */
asm-ppc/processor.h:	int		fpexc_mode;	/* floating-point exception mode */
asm-ppc/processor.h:	return (t->regs) ? t->regs->nip : 0;
asm-ppc/processor.h:#define KSTK_EIP(tsk)  ((tsk)->thread.regs? (tsk)->thread.regs->nip: 0)
asm-ppc/processor.h:#define KSTK_ESP(tsk)  ((tsk)->thread.regs? (tsk)->thread.regs->gpr[1]: 0)
asm-ppc/processor.h:/* Get/set floating-point exception mode */
asm-ppc/processor.h:#define get_task_struct(tsk)      atomic_inc(&virt_to_page(tsk)->count)
asm-ppc/processor.h:/* in process.c - for early bootup debug -- Cort */
asm-ppc/linux_logo.h: * include/asm-ppc/linux_logo.h: A linux logo to be displayed on boot
asm-ppc/cputable.h: *  include/asm-ppc/cputable.h
asm-ppc/mmu_context.h: * On 32-bit PowerPC 6xx/7xx/7xxx CPUs, we use a set of 16 VSIDs
asm-ppc/mmu_context.h: * hardware supports 24-bit VSIDs, and thus >1 million contexts,
asm-ppc/mmu_context.h: *  -- paulus.
asm-ppc/mmu_context.h: * of the 32-bit virtual address (the "effective segment ID") in order
asm-ppc/mmu_context.h:        -- Dan
asm-ppc/mmu_context.h:   	-- Dan
asm-ppc/mmu_context.h:#define NO_CONTEXT      	((mm_context_t) -1)
asm-ppc/mmu_context.h: * On 32-bit PowerPCs (other than the 8xx embedded chips), this is done by
asm-ppc/mmu_context.h:	if (mm->context != NO_CONTEXT)
asm-ppc/mmu_context.h:	mm->context = ctx;
asm-ppc/mmu_context.h:#define init_new_context(tsk,mm)	(((mm)->context = NO_CONTEXT), 0)
asm-ppc/mmu_context.h:	if (mm->context != NO_CONTEXT) {
asm-ppc/mmu_context.h:		clear_bit(mm->context, context_map);
asm-ppc/mmu_context.h:		mm->context = NO_CONTEXT;
asm-ppc/mmu_context.h:	tsk->thread.pgdir = next->pgd;
asm-ppc/mmu_context.h:	set_context(next->context, next->pgd);
asm-ppc/mmu_context.h: * After we have set current->mm to a new value, this activates
asm-ppc/mmu_context.h:	current->thread.pgdir = mm->pgd;
asm-ppc/mmu_context.h:	set_context(mm->context, mm->pgd);
asm-ppc/amigaints.h:** amigaints.h -- Amiga Linux interrupt handling structs and prototypes
asm-ppc/amigaints.h:/* auto-vector interrupts */
asm-ppc/amigaints.h:#endif /* asm-m68k/amigaints.h */
asm-ppc/semaphore.h: * Swiped from asm-sparc/semaphore.h and modified
asm-ppc/semaphore.h: * -- Cort (cort@cs.nmt.edu)
asm-ppc/semaphore.h: * Stole some rw spinlock-based semaphore stuff from asm-alpha/semaphore.h
asm-ppc/semaphore.h: * -- Ani Joshi (ajoshi@unixbox.com)
asm-ppc/semaphore.h: * Remove spinlock-based RW semaphores; RW semaphore definitions are
asm-ppc/semaphore.h: * -- Paul Mackerras (paulus@samba.org)
asm-ppc/semaphore.h:	atomic_set(&sem->count, val);
asm-ppc/semaphore.h:	init_waitqueue_head(&sem->wait);
asm-ppc/semaphore.h:	sem->__magic = (long)&sem->__magic;
asm-ppc/semaphore.h:	CHECK_MAGIC(sem->__magic);
asm-ppc/semaphore.h:	if (atomic_dec_return(&sem->count) < 0)
asm-ppc/semaphore.h:	CHECK_MAGIC(sem->__magic);
asm-ppc/semaphore.h:	if (atomic_dec_return(&sem->count) < 0)
asm-ppc/semaphore.h:	CHECK_MAGIC(sem->__magic);
asm-ppc/semaphore.h:	ret = atomic_dec_if_positive(&sem->count) < 0;
asm-ppc/semaphore.h:	CHECK_MAGIC(sem->__magic);
asm-ppc/semaphore.h:	if (atomic_inc_return(&sem->count) <= 0)
asm-ppc/semaphore.h:	return atomic_read(&sem->count);
asm-ppc/fcntl.h:/* open/fcntl - O_SYNC is only implemented on blocks devices and on files
asm-ppc/fcntl.h:#define F_GETFL		3	/* get file->f_flags */
asm-ppc/fcntl.h:#define F_SETFL		4	/* set file->f_flags */
asm-ppc/pmac_feature.h: * Note: I removed media-bay details from the feature stuff, I beleive it's
asm-ppc/pmac_feature.h: *       not worth it, the media-bay driver can directly use the mac-io
asm-ppc/pmac_feature.h: * all of the Grand-Central based machines. We currently don't
asm-ppc/pmac_feature.h: * to the device-tree. (Sawtooth is most tower G4s, FW_IMAC is most
asm-ppc/pmac_feature.h: * device-tree "model" or "compatible" property.
asm-ppc/pmac_feature.h:		return -ENODEV;
asm-ppc/pmac_feature.h: * enable/disable the swim3 (floppy) cell of a mac-io ASIC
asm-ppc/pmac_feature.h: * enable/disable the mesh (scsi) cell of a mac-io ASIC
asm-ppc/pmac_feature.h: * enable/disable an IDE port of a mac-io ASIC
asm-ppc/pmac_feature.h: * assert(1)/release(0) an IDE reset line (mac-io IDE only)
asm-ppc/pmac_feature.h: * enable/disable the bmac (ethernet) cell of a mac-io ASIC, also drive
asm-ppc/pmac_feature.h:/* -- add various tweaks related to sound routing -- */
asm-ppc/pmac_feature.h: * toggle the reset line of a CPU on an uninorth-based SMP machine
asm-ppc/pmac_feature.h: * Pass -1 as value to query for sleep capability
asm-ppc/pmac_feature.h: * selector: 0  - model id
asm-ppc/pmac_feature.h: *           1  - model flags (capabilities)
asm-ppc/pmac_feature.h: *           2  - model name (cast to const char *)
asm-ppc/pmac_feature.h: * read a GPIO from a mac-io controller of type KeyLargo or Pangea.
asm-ppc/pmac_feature.h: * write a GPIO of a mac-io controller of type KeyLargo or Pangea.
asm-ppc/rwsem.h: * include/asm-ppc/rwsem.h: R/W semaphores for PPC using the stuff
asm-ppc/rwsem.h: * in lib/rwsem.c.  Adapted largely from include/asm-i386/rwsem.h
asm-ppc/rwsem.h:	/* XXX this should be able to be an atomic_t  -- paulus */
asm-ppc/rwsem.h:#define RWSEM_WAITING_BIAS		(-0x00010000)
asm-ppc/rwsem.h:	sem->count = RWSEM_UNLOCKED_VALUE;
asm-ppc/rwsem.h:	spin_lock_init(&sem->wait_lock);
asm-ppc/rwsem.h:	INIT_LIST_HEAD(&sem->wait_list);
asm-ppc/rwsem.h:	sem->debug = 0;
asm-ppc/rwsem.h:	if (atomic_inc_return((atomic_t *)(&sem->count)) >= 0)
asm-ppc/rwsem.h:	while ((tmp = sem->count) >= 0) {
asm-ppc/rwsem.h:		if (tmp == cmpxchg(&sem->count, tmp,
asm-ppc/rwsem.h:				(atomic_t *)(&sem->count));
asm-ppc/rwsem.h:	tmp = cmpxchg(&sem->count, RWSEM_UNLOCKED_VALUE,
asm-ppc/rwsem.h:	tmp = atomic_dec_return((atomic_t *)(&sem->count));
asm-ppc/rwsem.h:	if (tmp < -1 && (tmp & RWSEM_ACTIVE_MASK) == 0)
asm-ppc/rwsem.h:			      (atomic_t *)(&sem->count)) < 0)
asm-ppc/rwsem.h:	atomic_add(delta, (atomic_t *)(&sem->count));
asm-ppc/rwsem.h:	return atomic_add_return(delta, (atomic_t *)(&sem->count));
asm-ppc/spinlock.h:#define spin_is_locked(x)	((x)->lock != 0)
asm-ppc/spinlock.h:	bne-	2b\n"
asm-ppc/spinlock.h:	bne-	2b\n\
asm-ppc/spinlock.h:	: "r"(&lock->lock), "r"(1)
asm-ppc/spinlock.h:	lock->lock = 0;
asm-ppc/spinlock.h: * Read-write spinlocks, allowing multiple readers
asm-ppc/spinlock.h: * can "mix" irq-safe locks - any writer needs to get a
asm-ppc/spinlock.h: * irq-safe write-lock, but readers can get non-irqsafe
asm-ppc/spinlock.h: * read-locks.
asm-ppc/spinlock.h:	ble-	1b\n"
asm-ppc/spinlock.h:	bne-	2b\n\
asm-ppc/spinlock.h:	: "r"(&rw->lock)
asm-ppc/spinlock.h:	addic	%0,%0,-1\n"
asm-ppc/spinlock.h:	bne-	1b"
asm-ppc/spinlock.h:	: "r"(&rw->lock)
asm-ppc/spinlock.h:	bne-	1b\n"
asm-ppc/spinlock.h:	bne-	2b\n\
asm-ppc/spinlock.h:	: "r"(&rw->lock), "r"(-1)
asm-ppc/spinlock.h:	rw->lock = 0;
asm-ppc/errno.h:#define	EXDEV		18	/* Cross-device link */
asm-ppc/errno.h:#define	EROFS		30	/* Read-only file system */
asm-ppc/errno.h:#define	ENOTSOCK	88	/* Socket operation on non-socket */
asm-ppc/mpc10x.h:#include <asm/pci-bridge.h>
asm-ppc/mpc10x.h: *   Processor: 0x80000000 - 0x807fffff -> PCI I/O: 0x00000000 - 0x007fffff
asm-ppc/mpc10x.h: *   Processor: 0xc0000000 - 0xdfffffff -> PCI MEM: 0x00000000 - 0x1fffffff
asm-ppc/mpc10x.h: *   PCI MEM:   0x80000000 -> Processor System Memory: 0x00000000
asm-ppc/mpc10x.h: *   EUMB mapped to: ioremap_base - 0x00100000 (ioremap_base - 1 MB)
asm-ppc/mpc10x.h: *   Processor: 0xfe000000 - 0xfebfffff -> PCI I/O: 0x00000000 - 0x00bfffff
asm-ppc/mpc10x.h: *   Processor: 0x80000000 - 0xbfffffff -> PCI MEM: 0x80000000 - 0xbfffffff
asm-ppc/mpc10x.h: *   PCI MEM:   0x00000000 -> Processor System Memory: 0x00000000
asm-ppc/mpc10x.h: *   EUMB mapped to: ioremap_base - 0x00100000 (ioremap_base - 1 MB)
asm-ppc/mpc10x.h: * Define the vendor/device IDs for the various bridges--should be added to
asm-ppc/mpc10x.h:#define	MPC10X_MAPA_PCI_IO_END	       (0x00800000 - 1)
asm-ppc/mpc10x.h:#define	MPC10X_MAPA_PCI_MEM_END	       (0x20000000 - 1)
asm-ppc/mpc10x.h:#define	MPC10X_MAPA_PCI_MEM_OFFSET	(MPC10X_MAPA_ISA_MEM_BASE -	\
asm-ppc/mpc10x.h:#define	MPC10X_MAPB_PCI_IO_END	       (0x00c00000 - 1)
asm-ppc/mpc10x.h:#define	MPC10X_MAPB_PCI_MEM_END	       (0xc0000000 - 1)
asm-ppc/mpc10x.h:#define	MPC10X_MAPB_PCI_MEM_OFFSET	(MPC10X_MAPB_ISA_MEM_BASE -	\
asm-ppc/mpc10x.h:	(hose)->pci_mem_offset = MPC10X_MAP##map##_PCI_MEM_OFFSET;	\
asm-ppc/mpc10x.h:	(hose)->io_space.start = MPC10X_MAP##map##_PCI_IO_START;	\
asm-ppc/mpc10x.h:	(hose)->io_space.end = MPC10X_MAP##map##_PCI_IO_END;		\
asm-ppc/mpc10x.h:	(hose)->mem_space.start = MPC10X_MAP##map##_PCI_MEM_START;	\
asm-ppc/mpc10x.h:	(hose)->mem_space.end = MPC10X_MAP##map##_PCI_MEM_END;		\
asm-ppc/mpc10x.h:	(hose)->io_base_virt = (void *)MPC10X_MAP##map##_ISA_IO_BASE;	\
asm-ppc/mpc10x.h:#define MPC10X_MCTLR_MEM_START_1	0x80	/* Banks 0-3 */
asm-ppc/mpc10x.h:#define MPC10X_MCTLR_MEM_START_2	0x84	/* Banks 4-7 */
asm-ppc/mpc10x.h:#define MPC10X_MCTLR_EXT_MEM_START_1	0x88	/* Banks 0-3 */
asm-ppc/mpc10x.h:#define MPC10X_MCTLR_EXT_MEM_START_2	0x8c	/* Banks 4-7 */
asm-ppc/mpc10x.h:#define MPC10X_MCTLR_MEM_END_1		0x90	/* Banks 0-3 */
asm-ppc/mpc10x.h:#define MPC10X_MCTLR_MEM_END_2		0x94	/* Banks 4-7 */
asm-ppc/mpc10x.h:#define MPC10X_MCTLR_EXT_MEM_END_1	0x98	/* Banks 0-3 */
asm-ppc/mpc10x.h:#define MPC10X_MCTLR_EXT_MEM_END_2	0x9c	/* Banks 4-7 */
asm-ppc/mpc10x.h:#define	MPC10X_MAPA_EUMB_BASE		(ioremap_base - MPC10X_EUMB_SIZE)
asm-ppc/mpc8xx.h: * must be defined in the board-specific header file for targets that
asm-ppc/softirq.h:	local_bh_count(smp_processor_id())--;	\
asm-ppc/softirq.h:	if (!--local_bh_count(smp_processor_id())	\
asm-ppc/hw_irq.h:#define mask_irq(irq) ({if (irq_desc[irq].handler && irq_desc[irq].handler->disable) irq_desc[irq].handler->disable(irq);})
asm-ppc/hw_irq.h:#define unmask_irq(irq) ({if (irq_desc[irq].handler && irq_desc[irq].handler->enable) irq_desc[irq].handler->enable(irq);})
asm-ppc/hw_irq.h:#define ack_irq(irq) ({if (irq_desc[irq].handler && irq_desc[irq].handler->ack) irq_desc[irq].handler->ack(irq);})
asm-ppc/hw_irq.h: * we do now ? --BenH.
asm-ppc/timex.h: * linux/include/asm-ppc/timex.h
asm-ppc/timex.h:#define FINETUNE ((((((long)LATCH * HZ - CLOCK_TICK_RATE) << SHIFT_HZ) * \
asm-ppc/timex.h:		<< (SHIFT_SCALE-SHIFT_HZ)) / HZ)
asm-ppc/namei.h:/* linux/include/asm-ppc/namei.h
asm-ppc/namei.h: * Adapted from linux/include/asm-alpha/namei.h
asm-ppc/namei.h: * Look at asm-sparc/namei.h for details.
asm-ppc/cpm2.h:/* Device sub-block and page codes.
asm-ppc/cpm2.h:#define CPM_DATAONLY_SIZE	((uint)(8 * 1024) - CPM_DATAONLY_BASE)
asm-ppc/cpm2.h:#define CPM_DATAONLY_SIZE	((uint)(16 * 1024) - CPM_DATAONLY_BASE)
asm-ppc/cpm2.h: * get some microcode patches :-).
asm-ppc/cpm2.h: * The parameter ram space for the SMCs is fifty-some bytes, and
asm-ppc/cpm2.h:	uint	sen_tbuf0data0;	/* Save area 0 - current frame */
asm-ppc/cpm2.h:	uint	sen_tbuf0data1;	/* Save area 1 - current frame */
asm-ppc/cpm2.h:	uint	sen_tbuf1data0;	/* Save area 0 - current frame */
asm-ppc/cpm2.h:	uint	sen_tbuf1data1;	/* Save area 1 - current frame */
asm-ppc/cpm2.h:	uint	fen_gaddrh;	/* Group address filter, high 32-bits */
asm-ppc/cpm2.h:	uint	fen_gaddrl;	/* Group address filter, low 32-bits */
asm-ppc/cpm2.h:#define FCC_PSMR_ENCRC	((uint)0x00000080)	/* Use 32-bit CRC */
asm-ppc/cpm2.h:#define SPMODE_LEN(x)	((((x)-1)&0xF)<<4)
asm-ppc/cpm2.h:	ushort ss_max;		/* steady-state maximum transfer size */
asm-ppc/cpm2.h:	u_char res1[20];	/* pad to 64-byte length */
asm-ppc/cpm2.h:#define IDMA_DCM_FB		((ushort)0x8000) /* fly-by mode */
asm-ppc/cpm2.h:#define IDMA_DCM_DMA_WRAP_64	((ushort)0x0000) /* 64-byte DMA xfer buffer */
asm-ppc/cpm2.h:#define IDMA_DCM_DMA_WRAP_128	((ushort)0x0040) /* 128-byte DMA xfer buffer */
asm-ppc/cpm2.h:#define IDMA_DCM_DMA_WRAP_256	((ushort)0x0080) /* 256-byte DMA xfer buffer */
asm-ppc/cpm2.h:#define IDMA_DCM_DMA_WRAP_512	((ushort)0x00c0) /* 512-byte DMA xfer buffer */
asm-ppc/cpm2.h:#define IDMA_DCM_DMA_WRAP_1024	((ushort)0x0100) /* 1024-byte DMA xfer buffer */
asm-ppc/cpm2.h:#define IDMA_DCM_DMA_WRAP_2048	((ushort)0x0140) /* 2048-byte DMA xfer buffer */
asm-ppc/cpm2.h:#define IDMA_DCM_SD_MEM2MEM	((ushort)0x0000) /* memory-to-memory xfer */
asm-ppc/cpm2.h:#define IDMA_DCM_SD_PER2MEM	((ushort)0x0002) /* peripheral-to-memory xfer */
asm-ppc/cpm2.h:#define IDMA_DCM_SD_MEM2PER	((ushort)0x0001) /* memory-to-peripheral xfer */
asm-ppc/cpm2.h:#define IDMA_BD_DBO_LE	((uint)0x00040000)	/* little-end dest byte order */
asm-ppc/cpm2.h:#define IDMA_BD_DBO_BE	((uint)0x00080000)	/* big-end dest byte order */
asm-ppc/cpm2.h:#define IDMA_BD_SBO_LE	((uint)0x00000800)	/* little-end src byte order */
asm-ppc/cpm2.h:#define IDMA_BD_SBO_BE	((uint)0x00001000)	/* big-end src byte order */
asm-ppc/cpm2.h:/* per-channel IDMA registers
asm-ppc/cpm2.h:/*-----------------------------------------------------------------------
asm-ppc/cpm2.h: * CMXFCR - CMX FCC Clock Route Register
asm-ppc/cpm2.h:/*-----------------------------------------------------------------------
asm-ppc/cpm2.h: * CMXSCR - CMX SCC Clock Route Register
asm-ppc/mk48t59.h: * Registers for the mk48t59 real-time-clock
asm-ppc/highmem.h: * Redesigned the x86 32-bit VM architecture to deal with
asm-ppc/highmem.h:#define LAST_PKMAP_MASK (LAST_PKMAP-1)
asm-ppc/highmem.h:#define PKMAP_NR(virt)  ((virt-PKMAP_BASE) >> PAGE_SHIFT)
asm-ppc/highmem.h: * The use of kmap_atomic/kunmap_atomic is discouraged - kmap/kunmap
asm-ppc/uaccess.h:#define get_fs()	(current->thread.fs)
asm-ppc/uaccess.h:#define set_fs(val)	(current->thread.fs = (val))
asm-ppc/uaccess.h:#define __user_ok(addr,size) (((size) <= TASK_SIZE)&&((addr) <= TASK_SIZE-(size)))
asm-ppc/uaccess.h:	return access_ok(type,addr,size) ? 0 : -EFAULT;
asm-ppc/uaccess.h: * These are the main single-value transfer routines.  They automatically
asm-ppc/uaccess.h: * allow access of 64-bit data. The "get_user" functions do not 
asm-ppc/uaccess.h: * properly handle 64-bit data because the value gets down cast to a long. 
asm-ppc/uaccess.h: * The "put_user" functions already handle 64-bit data properly but we add 
asm-ppc/uaccess.h:	long __pu_err = -EFAULT;				\
asm-ppc/uaccess.h:		: "r"(x), "b"(addr), "i"(-EFAULT), "0"(err))
asm-ppc/uaccess.h:		: "r"(x), "b"(addr), "i"(-EFAULT), "0"(err))
asm-ppc/uaccess.h:	long __gu_err = -EFAULT, __gu_val = 0;				\
asm-ppc/uaccess.h:	long __gu_err = -EFAULT;					\
asm-ppc/uaccess.h:		: "b"(addr), "i"(-EFAULT), "0"(err))
asm-ppc/uaccess.h:		: "b"(addr), "i"(-EFAULT), "0"(err))
asm-ppc/uaccess.h:		over = (unsigned long)from + n - TASK_SIZE;
asm-ppc/uaccess.h:		return __copy_tofrom_user(to, from, n - over) + over;
asm-ppc/uaccess.h:		over = (unsigned long)to + n - TASK_SIZE;
asm-ppc/uaccess.h:		return __copy_tofrom_user(to, from, n - over) + over;
asm-ppc/uaccess.h:		unsigned long over = (unsigned long)addr + size - TASK_SIZE;
asm-ppc/uaccess.h:		return __clear_user(addr, size - over) + over;
asm-ppc/uaccess.h:	return -EFAULT;
asm-ppc/uaccess.h:	unsigned long top = __kernel_ok? ~0UL: TASK_SIZE - 1;
asm-ppc/traps.h:#include <asm-m68k/traps.h>
asm-ppc/kgdb.h: * external low-level support routines (ie macserial.c)
asm-ppc/mediabay.h:/* called by pmac-ide.c to register IDE controller for media bay */
asm-ppc/mman.h:#define MAP_GROWSDOWN	0x0100		/* stack-like segment */
asm-ppc/mman.h:#define MADV_NORMAL	0x0		/* default page-in behavior */
asm-ppc/mman.h:#define MADV_RANDOM	0x1		/* page-in minimum required */
asm-ppc/mman.h:#define MADV_SEQUENTIAL	0x2		/* read-ahead aggressively */
asm-ppc/mman.h:#define MADV_WILLNEED	0x3		/* pre-fault pages */
asm-ppc/posix_types.h: * This file is generally used by user-level software, so you need to
asm-ppc/posix_types.h:#define	__FD_SET(d, set)	((set)->fds_bits[__FDELT(d)] |= __FDMASK(d))
asm-ppc/posix_types.h:#define	__FD_CLR(d, set)	((set)->fds_bits[__FDELT(d)] &= ~__FDMASK(d))
asm-ppc/posix_types.h:#define	__FD_ISSET(d, set)	((set)->fds_bits[__FDELT(d)] & __FDMASK(d))
asm-ppc/posix_types.h:	fdsetp->fds_bits[_tmp] |= (1UL<<_rem);
asm-ppc/posix_types.h:	fdsetp->fds_bits[_tmp] &= ~(1UL<<_rem);
asm-ppc/posix_types.h:	return (p->fds_bits[_tmp] & (1UL<<_rem)) != 0;
asm-ppc/posix_types.h: * for a 256-bit fd_set)
asm-ppc/posix_types.h:	unsigned int *tmp = (unsigned int *)p->fds_bits;
asm-ppc/posix_types.h:		i--;
asm-ppc/scatterlist.h:#define sg_dma_address(sg)      ((sg)->dma_address)
asm-ppc/scatterlist.h:#define sg_dma_len(sg)          ((sg)->dma_length)
asm-ppc/smplock.h:	if (task->lock_depth >= 0) \
asm-ppc/smplock.h: * Re-acquire the kernel lock
asm-ppc/smplock.h:	if (task->lock_depth >= 0) \
asm-ppc/smplock.h:	if (!++current->lock_depth)
asm-ppc/smplock.h:	if (--current->lock_depth < 0)
asm-ppc/page.h: * gets extended to 64 bits the way want (i.e. with 1s).  -- paulus
asm-ppc/page.h:#define PAGE_MASK	(~((1 << PAGE_SHIFT) - 1))
asm-ppc/page.h: * The basic type of a PTE - 64 bits for those CPUs with > 32 bit
asm-ppc/page.h:#define PTE_SHIFT	(PAGE_SHIFT - 3)	/* 512 ptes per page */
asm-ppc/page.h:#define PTE_SHIFT	(PAGE_SHIFT - 2)	/* 1024 ptes per page */
asm-ppc/page.h: * These are used to make use of C type-checking..
asm-ppc/page.h:/* align addr on a size boundry - adjust address up if needed -- Cort */
asm-ppc/page.h:#define _ALIGN(addr,size)	(((addr)+(size)-1)&(~((size)-1)))
asm-ppc/page.h:#define PAGE_ALIGN(addr)	(((addr)+PAGE_SIZE-1)&PAGE_MASK)
asm-ppc/page.h:/* map phys->virtual and virtual->phys for RAM pages */
asm-ppc/page.h:		      : "b" (v), "K" (((-PAGE_OFFSET) >> 16) & 0xffff));
asm-ppc/page.h:#define ___pa(vaddr) ((vaddr)-PPC_MEMOFFSET)
asm-ppc/page.h:#define virt_to_page(kaddr)	(mem_map + (((unsigned long)(kaddr)-PAGE_OFFSET) >> PAGE_SHIFT))
asm-ppc/page.h:#define VALID_PAGE(page)	(((page) - mem_map) < max_mapnr)
asm-ppc/page.h:	size = (size-1) >> (PAGE_SHIFT-1);
asm-ppc/page.h:	order = -1;
asm-ppc/pci-bridge.h: * PCI <-> OF matching functions
asm-ppc/pci-bridge.h:	return (((pin-1) + idsel) % 4) + 1;
asm-ppc/pci-bridge.h:/* FIXME - double check this */
asm-ppc/pci-bridge.h:({ long _ctl_ = -1; 							    \
asm-ppc/pci-bridge.h:     _ctl_ = pci_irq_table[idsel - min_idsel][pin-1];			    \
asm-ppc/ppc4xx_dma.h: * include/asm-ppc/ppc4xx_dma.h
asm-ppc/ppc4xx_dma.h: * Copyright 2000-2003 MontaVista Software Inc.
asm-ppc/ppc4xx_dma.h:/* in arch/ppc/kernel/setup.c -- Cort */
asm-ppc/ppc4xx_dma.h:#define SET_DMA_PW(x)     (((x)&0x3)<<(26-DMA_CR_OFFSET))	/* Peripheral Width */
asm-ppc/ppc4xx_dma.h:#define GET_DMA_PW(x)     (((x)&DMA_PW_MASK)>>(26-DMA_CR_OFFSET))
asm-ppc/ppc4xx_dma.h:#define DMA_DAI           (1<<(25-DMA_CR_OFFSET))	/* Destination Address Increment */
asm-ppc/ppc4xx_dma.h:#define SET_DMA_DAI(x)    (((x)&0x1)<<(25-DMA_CR_OFFSET))
asm-ppc/ppc4xx_dma.h:#define DMA_SAI           (1<<(24-DMA_CR_OFFSET))	/* Source Address Increment */
asm-ppc/ppc4xx_dma.h:#define SET_DMA_SAI(x)    (((x)&0x1)<<(24-DMA_CR_OFFSET))
asm-ppc/ppc4xx_dma.h:#define DMA_BEN           (1<<(23-DMA_CR_OFFSET))	/* Buffer Enable */
asm-ppc/ppc4xx_dma.h:#define SET_DMA_BEN(x)    (((x)&0x1)<<(23-DMA_CR_OFFSET))
asm-ppc/ppc4xx_dma.h:#define SET_DMA_TM(x)     (((x)&0x3)<<(21-DMA_CR_OFFSET))	/* Transfer Mode */
asm-ppc/ppc4xx_dma.h:#define GET_DMA_TM(x)     (((x)&DMA_TM_MASK)>>(21-DMA_CR_OFFSET))
asm-ppc/ppc4xx_dma.h:#define SET_DMA_PSC(x)    (((x)&0x3)<<(19-DMA_CR_OFFSET))	/* Peripheral Setup Cycles */
asm-ppc/ppc4xx_dma.h:#define GET_DMA_PSC(x)    (((x)&DMA_PSC_MASK)>>(19-DMA_CR_OFFSET))
asm-ppc/ppc4xx_dma.h:#define SET_DMA_PWC(x)    (((x)&0x3F)<<(13-DMA_CR_OFFSET))	/* Peripheral Wait Cycles */
asm-ppc/ppc4xx_dma.h:#define GET_DMA_PWC(x)    (((x)&DMA_PWC_MASK)>>(13-DMA_CR_OFFSET))
asm-ppc/ppc4xx_dma.h:#define SET_DMA_PHC(x)    (((x)&0x7)<<(10-DMA_CR_OFFSET))	/* Peripheral Hold Cycles */
asm-ppc/ppc4xx_dma.h:#define GET_DMA_PHC(x)    (((x)&DMA_PHC_MASK)>>(10-DMA_CR_OFFSET))
asm-ppc/ppc4xx_dma.h:#define DMA_ETD_OUTPUT     (1<<(9-DMA_CR_OFFSET))	/* EOT pin is a TC output */
asm-ppc/ppc4xx_dma.h:#define SET_DMA_ETD(x)     (((x)&0x1)<<(9-DMA_CR_OFFSET))
asm-ppc/ppc4xx_dma.h:#define DMA_TCE_ENABLE     (1<<(8-DMA_CR_OFFSET))
asm-ppc/ppc4xx_dma.h:#define SET_DMA_TCE(x)     (((x)&0x1)<<(8-DMA_CR_OFFSET))
asm-ppc/ppc4xx_dma.h:				/* Device-paced memory to memory, */
asm-ppc/ppc4xx_dma.h:				/* Device-paced memory to memory,      */
asm-ppc/ppc4xx_dma.h:#define SET_DMA_PREFETCH(x)   (((x)&0x3)<<(4-DMA_CR_OFFSET))	/* Memory Read Prefetch */
asm-ppc/ppc4xx_dma.h:#define GET_DMA_PREFETCH(x) (((x)&DMA_PREFETCH_MASK)>>(4-DMA_CR_OFFSET))
asm-ppc/ppc4xx_dma.h:#define DMA_PCE            (1<<(3-DMA_CR_OFFSET))	/* Parity Check Enable */
asm-ppc/ppc4xx_dma.h:#define SET_DMA_PCE(x)     (((x)&0x1)<<(3-DMA_CR_OFFSET))
asm-ppc/ppc4xx_dma.h:#define GET_DMA_PCE(x)     (((x)&DMA_PCE)>>(3-DMA_CR_OFFSET))
asm-ppc/ppc4xx_dma.h:#define SET_DMA_PRIORITY(x)   (((x)&0x3)<<(6-DMA_CR_OFFSET))	/* DMA Channel Priority */
asm-ppc/ppc4xx_dma.h:#define GET_DMA_PRIORITY(x) (((x)&DMA_PRIORITY_MASK)>>(6-DMA_CR_OFFSET))
asm-ppc/ppc4xx_dma.h: 		(SET_DMA_CIE_ENABLE(p_init->int_enable) | /* interrupt enable         */ \
asm-ppc/ppc4xx_dma.h: 		SET_DMA_BEN(p_init->buffer_enable)     | /* buffer enable            */\
asm-ppc/ppc4xx_dma.h:		SET_DMA_ETD(p_init->etd_output)        | /* end of transfer pin      */ \
asm-ppc/ppc4xx_dma.h:	       	SET_DMA_TCE(p_init->tce_enable)        | /* terminal count enable    */ \
asm-ppc/ppc4xx_dma.h:                SET_DMA_PL(p_init->pl)                 | /* peripheral location      */ \
asm-ppc/ppc4xx_dma.h:                SET_DMA_DAI(p_init->dai)               | /* dest addr increment      */ \
asm-ppc/ppc4xx_dma.h:                SET_DMA_SAI(p_init->sai)               | /* src addr increment       */ \
asm-ppc/ppc4xx_dma.h:                SET_DMA_PRIORITY(p_init->cp)           |  /* channel priority        */ \
asm-ppc/ppc4xx_dma.h:                SET_DMA_PW(p_init->pwidth)             |  /* peripheral/bus width    */ \
asm-ppc/ppc4xx_dma.h:                SET_DMA_PSC(p_init->psc)               |  /* peripheral setup cycles */ \
asm-ppc/ppc4xx_dma.h:                SET_DMA_PWC(p_init->pwc)               |  /* peripheral wait cycles  */ \
asm-ppc/ppc4xx_dma.h:                SET_DMA_PHC(p_init->phc)               |  /* peripheral hold cycles  */ \
asm-ppc/ppc4xx_dma.h:                SET_DMA_PREFETCH(p_init->pf)              /* read prefetch           */)
asm-ppc/ppc4xx_dma.h:       		(SET_DMA_CIE_ENABLE(p_init->int_enable) |  /* interrupt enable         */ \
asm-ppc/ppc4xx_dma.h:		SET_DMA_ETD(p_init->etd_output)        |  /* end of transfer pin      */ \
asm-ppc/ppc4xx_dma.h:		SET_DMA_TCE(p_init->tce_enable)        |  /* terminal count enable    */ \
asm-ppc/ppc4xx_dma.h:		SET_DMA_PL(p_init->pl)                 |  /* peripheral location      */ \
asm-ppc/ppc4xx_dma.h:		SET_DMA_DAI(p_init->dai)               |  /* dest addr increment      */ \
asm-ppc/ppc4xx_dma.h:		SET_DMA_SAI(p_init->sai)               |  /* src addr increment       */ \
asm-ppc/ppc4xx_dma.h:		SET_DMA_PRIORITY(p_init->cp)           |  /* channel priority        */  \
asm-ppc/ppc4xx_dma.h:		SET_DMA_PW(p_init->pwidth)             |  /* peripheral/bus width    */ \
asm-ppc/ppc4xx_dma.h:		SET_DMA_PSC(p_init->psc)               |  /* peripheral setup cycles */ \
asm-ppc/ppc4xx_dma.h:		SET_DMA_PWC(p_init->pwc)               |  /* peripheral wait cycles  */ \
asm-ppc/ppc4xx_dma.h:		SET_DMA_PHC(p_init->phc)               |  /* peripheral hold cycles  */ \
asm-ppc/ppc4xx_dma.h:		SET_DMA_TCD(p_init->tcd_disable)	  |  /* TC chain mode disable   */ \
asm-ppc/ppc4xx_dma.h:		SET_DMA_ECE(p_init->ece_enable)	  |  /* ECE chanin mode enable  */ \
asm-ppc/ppc4xx_dma.h:		SET_DMA_CH(p_init->ch_enable)	|    /* Chain enable 	        */ \
asm-ppc/ppc4xx_dma.h:	 * Valid psc settings: 0-3
asm-ppc/ppc4xx_dma.h:	 * 0-63
asm-ppc/ppc4xx_dma.h:	 * 0-7
asm-ppc/ppc4xx_dma.h: * change to 64-bit addresses and link pointer. I don't
asm-ppc/hdreg.h: *  linux/include/asm-ppc/hdreg.h
asm-ppc/hdreg.h: *  Copyright (C) 1994-1996  Linus Torvalds & authors
asm-ppc/prom.h:	int	sense;		/* +ve/-ve logic, edge or level, etc. */
asm-ppc/ppc4xx_pic.h: *      Interrupt controller driver for PowerPC 4xx-based processors.
asm-ppc/ppc4xx_pic.h: * definitions from <asm-ppc/irq.h>.  -- paulus
asm-ppc/types.h:/* DMA addresses are 32-bits wide */
asm-ppc/types.h: * a proper set of asm headers of its own.  -- paulus
asm-ppc/system.h: * loads and stores to non-cacheable memory (e.g. I/O devices).
asm-ppc/system.h:	bne-	1b"
asm-ppc/system.h:#if 0	/* xchg_u64 doesn't exist on 32-bit PPC */
asm-ppc/system.h:	bne-	1b\n"
asm-ppc/system.h:#if 0	/* we don't have __cmpxchg_u64 on 32-bit PPC */
asm-ppc/stat.h:	long long st_blocks;		/* Number 512-byte blocks allocated. */
asm-ppc/time.h: * in auto-reload mode.  The problem is PIT stops counting when it
asm-ppc/time.h:	return;		/* Have to let it auto-reload */
asm-ppc/time.h:		int delta = get_rtcl() - tstamp;
asm-ppc/time.h:        	return get_tbl() - tstamp;
asm-ppc/time.h:      bne-    1b\n"
asm-ppc/checksum.h: * and adds in "sum" (32-bit)
asm-ppc/checksum.h: * returns a 32-bit number suitable for feeding into itself
asm-ppc/checksum.h: * it's best to have buff aligned on a 32-bit boundary
asm-ppc/checksum.h: * and adds in "sum" (32-bit), while copying the block to dst.
asm-ppc/checksum.h: * If an access exception occurs on src or dst, it stores -EFAULT
asm-ppc/checksum.h:/* FIXME: this needs to be written to really do no check -- Cort */
asm-ppc/checksum.h: * turns a 32-bit partial checksum (e.g. from csum_partial) into a
asm-ppc/checksum.h: * 1's complement 16-bit checksum.
asm-ppc/checksum.h:	/* swap the two 16-bit halves of sum */
asm-ppc/checksum.h:	/* if there is a carry from adding the two 16-bit halves,
asm-ppc/checksum.h: * this routine is used for miscellaneous IP-like checksums, mainly
asm-ppc/checksum.h: * It may not be correct.  -- Cort
asm-ppc/checksum.h: * of 32-bit words and is always >= 5.
asm-ppc/checksum.h: * computes the checksum of the TCP/UDP pseudo-header
asm-ppc/checksum.h: * returns a 16-bit checksum, already complemented
asm-ppc/uninorth.h: * Uni-N config space reg. definitions
asm-ppc/uninorth.h: * This word contains, in little-endian format (!!!), the physical address
asm-ppc/uninorth.h: * Uni-N memory mapped reg. definitions
asm-ppc/uninorth.h: * Those registers are Big-Endian !!
asm-ppc/uninorth.h:#define UNI_N_CLOCK_CNTL_ATA100		0x00000010	/* ATA-100 clock control (U2) */
asm-ppc/uninorth.h: *  to do on a non-recoverable reset (powerup or wakeup)
asm-ppc/uninorth.h:/* Uninorth 1.5 rev. has additional perf. monitor registers at 0xf00-0xf50 */
asm-ppc/todc.h: * include/asm-ppc/todc.h
asm-ppc/todc.h:	 * of these chips.  Note that these are board-specific.
asm-ppc/todc.h: * 'if (todc_info->rtc_type ==  TODC_TYPE_XXX)' so you won't break
asm-ppc/todc.h:	todc_info->rtc_type = clock_type;				\
asm-ppc/todc.h:	todc_info->nvram_as0  = (unsigned char *)(as0);			\
asm-ppc/todc.h:	todc_info->nvram_as1  = (unsigned char *)(as1);			\
asm-ppc/todc.h:	todc_info->nvram_data = (unsigned char *)(data);		\
asm-ppc/todc.h:	todc_info->as0_bits = (bits);					\
asm-ppc/todc.h:	todc_info->nvram_size     = clock_type ##_NVRAM_SIZE;		\
asm-ppc/todc.h:	todc_info->sw_flags       = clock_type ##_SW_FLAGS;		\
asm-ppc/todc.h:	todc_info->year           = clock_type ##_YEAR;			\
asm-ppc/todc.h:	todc_info->month          = clock_type ##_MONTH;		\
asm-ppc/todc.h:	todc_info->day_of_month   = clock_type ##_DOM;			\
asm-ppc/todc.h:	todc_info->day_of_week    = clock_type ##_DOW;			\
asm-ppc/todc.h:	todc_info->hours          = clock_type ##_HOURS;		\
asm-ppc/todc.h:	todc_info->minutes        = clock_type ##_MINUTES;		\
asm-ppc/todc.h:	todc_info->seconds        = clock_type ##_SECONDS;		\
asm-ppc/todc.h:	todc_info->control_b      = clock_type ##_CNTL_B;		\
asm-ppc/todc.h:	todc_info->control_a      = clock_type ##_CNTL_A;		\
asm-ppc/todc.h:	todc_info->watchdog       = clock_type ##_WATCHDOG;		\
asm-ppc/todc.h:	todc_info->interrupts     = clock_type ##_INTERRUPTS;		\
asm-ppc/todc.h:	todc_info->alarm_date     = clock_type ##_ALARM_DATE;		\
asm-ppc/todc.h:	todc_info->alarm_hour     = clock_type ##_ALARM_HOUR;		\
asm-ppc/todc.h:	todc_info->alarm_minutes  = clock_type ##_ALARM_MINUTES;	\
asm-ppc/todc.h:	todc_info->alarm_seconds  = clock_type ##_ALARM_SECONDS;	\
asm-ppc/todc.h:	todc_info->century        = clock_type ##_CENTURY;		\
asm-ppc/todc.h:	todc_info->flags          = clock_type ##_FLAGS;		\
asm-ppc/todc.h:	todc_info->nvram_addr_reg = clock_type ##_NVRAM_ADDR_REG;	\
asm-ppc/todc.h:	todc_info->nvram_data_reg = clock_type ##_NVRAM_DATA_REG;	\
asm-ppc/termios.h:#define N_IRDA		11	/* Linux IrDa - http://irda.sourceforge.net/ */
asm-ppc/termios.h:#define N_SMSBLOCK	12	/* SMS block mode - for talking to GSM data cards about SMS messages */
asm-ppc/termios.h:	get_user(__tmp,&(termio)->x); \
asm-ppc/termios.h:	(termios)->x = (0xffff0000 & (termios)->x) | __tmp; \
asm-ppc/termios.h:	copy_from_user((termios)->c_cc, (termio)->c_cc, NCC); \
asm-ppc/termios.h:	put_user((termios)->c_iflag, &(termio)->c_iflag); \
asm-ppc/termios.h:	put_user((termios)->c_oflag, &(termio)->c_oflag); \
asm-ppc/termios.h:	put_user((termios)->c_cflag, &(termio)->c_cflag); \
asm-ppc/termios.h:	put_user((termios)->c_lflag, &(termio)->c_lflag); \
asm-ppc/termios.h:	put_user((termios)->c_line,  &(termio)->c_line); \
asm-ppc/termios.h:	copy_to_user((termio)->c_cc, (termios)->c_cc, NCC); \
asm-ppc/user.h:/* Adapted from <asm-alpha/user.h> */
asm-ppc/user.h: * linux we use the `trad-core' bfd, NOT the osf-core).  The file contents
asm-ppc/user.h: *  data: The data segment follows next.  We use current->end_text to
asm-ppc/user.h: *	current->brk to pick up all of the user variables, plus any memory
asm-ppc/user.h: *	page is demand-zero or if a page is totally unused, we just cover
asm-ppc/user.h: *	current->start_stack, so we round each of these in order to be able
asm-ppc/ppc_asm.h: * include/asm-ppc/ppc_asm.h
asm-ppc/ppc_asm.h: * Definitions used by various bits of low-level assembly code on PowerPC.
asm-ppc/ppc_asm.h: * Copyright (C) 1995-1999 Gary Thomas, Paul Mackerras, Cort Dougan.
asm-ppc/ppc_asm.h: * is freely available, we can do this the normal way...  - paulus
asm-ppc/ppc_asm.h:0:	addis	rd,rs,-KERNELBASE@h;		\
asm-ppc/ppc_asm.h: * On 64-bit cpus, we use the rfid instruction instead of rfi, but
asm-ppc/ppc_asm.h: * the 64-bit mode bit, which we clear.
asm-ppc/ppc_asm.h:	clrldi	ra,ra,1;		/* turn off 64-bit mode */ \
asm-ppc/serial.h: * include/asm-ppc/serial.h
asm-ppc/serial.h: * XXX Assume for now it has PC-style ISA serial ports.
asm-ppc/pgtable.h: * hash-table miss exception.
asm-ppc/pgtable.h: * This is called in munmap when we have freed up some page-table
asm-ppc/pgtable.h: * about our page-table pages.  -- paulus
asm-ppc/pgtable.h: * addressed.  -- paulus
asm-ppc/pgtable.h: * BATs and PTEs.  -- Cort
asm-ppc/pgtable.h: * a set of 16 segment registers (on 32-bit implementations), to define
asm-ppc/pgtable.h: * active mappings.  We maintain a two-level page table tree, much
asm-ppc/pgtable.h: * management code.  Low-level assembler code in hashtable.S
asm-ppc/pgtable.h: * At present, all PowerPC 400-class processors share a similar TLB
asm-ppc/pgtable.h: * 64-entry, fully-associative TLB which is maintained totally under
asm-ppc/pgtable.h: * hardware-managed, 4-entry, fully-associative TLB which serves as a
asm-ppc/pgtable.h: * The normal case is that PTEs are 32-bits and we have a 1-page
asm-ppc/pgtable.h: * 1024-entry pgdir pointing to 1-page 1024-entry PTE pages.  -- paulus
asm-ppc/pgtable.h: * For any >32-bit physical address platform, we can use the following
asm-ppc/pgtable.h: * level has 2048 entries and the second level has 512 64-bit PTE entries.
asm-ppc/pgtable.h: * -Matt
asm-ppc/pgtable.h:#define PMD_MASK	(~(PMD_SIZE-1))
asm-ppc/pgtable.h:/* PGDIR_SHIFT determines what a top-level page table entry can map */
asm-ppc/pgtable.h:#define PGDIR_MASK	(~(PGDIR_SIZE-1))
asm-ppc/pgtable.h: * entries per page directory level: our page-table tree is two-level, so
asm-ppc/pgtable.h:#define PTRS_PER_PGD	(1 << (32 - PGDIR_SHIFT))
asm-ppc/pgtable.h:#define KERNEL_PGD_PTRS (PTRS_PER_PGD-USER_PGD_PTRS)
asm-ppc/pgtable.h: * Bits in a linux-style PTE.  These match the bits in the
asm-ppc/pgtable.h: * (hardware-defined) PowerPC PTE as closely as possible.
asm-ppc/pgtable.h:   - bits 20 and 21 must be cleared, because we use 4k pages (4xx can
asm-ppc/pgtable.h:   - We use only zones 0 (for kernel pages) and 1 (for user pages)
asm-ppc/pgtable.h:     of the 16 available.  Bit 24-26 of the TLB are cleared in the TLB
asm-ppc/pgtable.h:   - PRESENT *must* be in the bottom two bits because swap cache
asm-ppc/pgtable.h:   - All other bits of the PTE are loaded into TLBLO without
asm-ppc/pgtable.h:#define	_PAGE_WRITETHRU	0x008	/* W: caching is write-through */
asm-ppc/pgtable.h: * Because of the 3 word TLB entries to support 36-bit addressing,
asm-ppc/pgtable.h: * ERPN fields in the TLB. -Matt
asm-ppc/pgtable.h:#define _PAGE_EXEC	0x0008	/* software: i-cache coherency required */
asm-ppc/pgtable.h: * _PAGE_ACCESSED is 2, which it isn't, or unless you have 8xx-specific
asm-ppc/pgtable.h: *  -- paulus
asm-ppc/pgtable.h:#define _PAGE_WRITETHRU	0x040	/* W: cache write-through */
asm-ppc/pgtable.h:#define _PAGE_EXEC	0x200	/* software: i-cache coherency required */
asm-ppc/pgtable.h: * another purpose.  -- paulus.
asm-ppc/pgtable.h: * Allegedly that doesn't hurt performance.  -- paulus
asm-ppc/pgtable.h: * for zero-mapped memory areas etc..
asm-ppc/pgtable.h:#define pte_page(x)		(mem_map+(unsigned long)((pte_val(x)-PPC_MEMSTART) >> PAGE_SHIFT))
asm-ppc/pgtable.h: * The "pgd_xxx()" functions here are trivial for a folded two-level
asm-ppc/pgtable.h:	pte_val(pte) = (((page - mem_map) << PAGE_SHIFT) + PPC_MEMSTART) | pgprot_val(pgprot); \
asm-ppc/pgtable.h: * The ((unsigned long)(p+1) - 4) hack is to get to the least-significant
asm-ppc/pgtable.h:	bne-	1b"
asm-ppc/pgtable.h:	: "r" ((unsigned long)(p+1) - 4), "r" (clr), "r" (set), "m" (*p)
asm-ppc/pgtable.h:/* to find an entry in a kernel page-table-directory */
asm-ppc/pgtable.h:/* to find an entry in a page-table-directory */
asm-ppc/pgtable.h:#define pgd_offset(mm, address)	 ((mm)->pgd + pgd_index(address))
asm-ppc/pgtable.h:/* Find an entry in the second-level page table.. */
asm-ppc/pgtable.h:/* Find an entry in the third-level page table.. */
asm-ppc/pgtable.h:	return (pte_t *) pmd_page(*dir) + ((address >> PAGE_SHIFT) & (PTRS_PER_PTE - 1));
asm-ppc/pgtable.h: * (if used).  -- paulus
asm-ppc/open_pic.h: *  include/asm-ppc/open_pic.h -- OpenPIC Interrupt Handling
asm-ppc/open_pic.h: *  Non-offset'ed vector numbers
asm-ppc/ppcboot.h: * MA 02111-1307 USA
asm-ppc/ppcboot.h: * include/asm-ppc/ppcboot.h
asm-ppc/param.h:#define NOGROUP		(-1)
asm-ppc/prep_nvram.h:/* Corey Minyard (minyard@acm.org) - Stolen from PReP book.   Per the
asm-ppc/prep_nvram.h:  endian or they are big-endian numbers.
asm-ppc/prep_nvram.h:  big-endian. These are stored in UT (GMT).
asm-ppc/prep_nvram.h:  unsigned char Revision;    /* Structure map the same -may
asm-ppc/prep_nvram.h:  unsigned char GEArea[NVSIZE-CONFSIZE-OSAREASIZE-sizeof(HEADER)];
asm-ppc/bootinfo.h: * Non-machine dependent bootinfo structure.  Basic idea
asm-ppc/bootinfo.h:#include <asm-m68k/bootinfo.h>
asm-ppc/bootinfo.h:#define BI_FIRST		0x1010  /* first record - marker */
asm-ppc/bootinfo.h:#define BI_LAST			0x1011	/* last record - marker */
asm-ppc/cache.h: * include/asm-ppc/cache.h
asm-ppc/cache.h:#define	L1_CACHE_ALIGN(x)       (((x)+(L1_CACHE_BYTES-1))&~(L1_CACHE_BYTES-1))
asm-ppc/cache.h:#define IC_DAT		562	/* Read-only data register */
asm-ppc/cache.h:#define DC_DAT		570	/* Read-only data register */
asm-ppc/siginfo.h:#define SI_PAD_SIZE	((SI_MAX_SIZE/sizeof(int)) - 3)
asm-ppc/siginfo.h: * Digital reserves positive values for kernel-generated signals.
asm-ppc/siginfo.h:#define SI_QUEUE	-1		/* sent by sigqueue */
asm-ppc/siginfo.h:#define SI_TIMER __SI_CODE(__SI_TIMER,-2) /* sent by timer expiration */
asm-ppc/siginfo.h:#define SI_MESGQ	-3		/* sent by real time mesq state change */
asm-ppc/siginfo.h:#define SI_ASYNCIO	-4		/* sent by AIO completion */
asm-ppc/siginfo.h:#define SI_SIGIO	-5		/* sent by queued SIGIO */
asm-ppc/siginfo.h:#define SI_TKILL	-6		/* sent by tkill system call */
asm-ppc/siginfo.h:#define SI_FROMUSER(siptr)	((siptr)->si_code <= 0)
asm-ppc/siginfo.h:#define SI_FROMKERNEL(siptr)	((siptr)->si_code > 0)
asm-ppc/siginfo.h:#define BUS_ADRERR	(__SI_FAULT|2)	/* non-existant physical address */
asm-ppc/siginfo.h:#define SIGEV_PAD_SIZE	((SIGEV_MAX_SIZE/sizeof(int)) - 3)
asm-ppc/siginfo.h:	if (from->si_code < 0)
asm-ppc/siginfo.h:		memcpy(to, from, 3*sizeof(int) + sizeof(from->_sifields._sigchld));
asm-ppc/amigappc.h:** asm-m68k/amigappc.h -- This header defines some values and pointers for
asm-ppc/floppy.h:static int FDC2 = -1;
asm-ppc/amigayle.h:#include <asm-m68k/amigayle.h>
asm-ppc/vc_ioctl.h:#define VC_POWERMODE_INQUIRY	(-1)
asm-ppc/sockios.h:#if 0 /* These are defined this way on Alpha - maybe later. */
asm-ppc/sockios.h:/* Socket-level I/O control calls. */
asm-ppc/sockios.h:#define SIOCGSTAMP	0x8906		/* Get stamp - linux-specific */
asm-ppc/hydra.h: *  asm-ppc/hydra.h -- Mac I/O `Hydra' definitions
asm-ppc/hydra.h: *  Francisco, CA 94104. Reference ISBN 1-55860-393-X.
asm-ppc/keyboard.h: *  linux/include/asm-ppc/keyboard.h
asm-ppc/keyboard.h: * This file contains the ppc architecture specific keyboard definitions -
asm-ppc/bootx.h:   the map is optional and current BootX will only build it for pre-PCI
asm-ppc/bootx.h:     * On pre-PCI macintosh (BOOT_ARCH_PCI bit set to 0 in architecture), this
asm-ppc/bootx.h:       (non-PCI) only. On PCI, memory is contiguous and it's size is in the
asm-ppc/bootx.h:       device-tree. */
asm-ppc/bootx.h: * Later versions may contain the gamma table for direct-color devices here.
asm-ppc/ioctl.h: *                         -- Cort
asm-ppc/ioctl.h:#define _IOC_NRMASK	((1 << _IOC_NRBITS)-1)
asm-ppc/ioctl.h:#define _IOC_TYPEMASK	((1 << _IOC_TYPEBITS)-1)
asm-ppc/ioctl.h:#define _IOC_SIZEMASK	((1 << _IOC_SIZEBITS)-1)
asm-ppc/ioctl.h:#define _IOC_DIRMASK	((1 << _IOC_DIRBITS)-1)
asm-ppc/pc_serial.h: * include/asm-ppc/pc_serial.h
asm-ppc/pc_serial.h: * This is basically a copy of include/asm-i386/serial.h.
asm-ppc/pc_serial.h: * to have PC-style serial ports at the legacy I/O port addresses.
asm-ppc/pc_serial.h: * anyone using any of those on a PPC platform.  -- paulus
asm-ppc/ioctls.h:#define TIOCGPTN	_IOR('T',0x30, unsigned int) /* Get Pty Number (of pty-mux device) */
asm-ppc/commproc.h: * are needed.  -- Dan
asm-ppc/commproc.h: * On the MBX board, EPPC-Bug loads CPM microcode into the first 512
asm-ppc/commproc.h:/* The dual ported RAM is multi-functional.  Some areas can be (and are
asm-ppc/commproc.h:	uint	sen_tbuf0data0;	/* Save area 0 - current frame */
asm-ppc/commproc.h:	uint	sen_tbuf0data1;	/* Save area 1 - current frame */
asm-ppc/commproc.h:	uint	sen_tbuf1data0;	/* Save area 0 - current frame */
asm-ppc/commproc.h:	uint	sen_tbuf1data1;	/* Save area 1 - current frame */
asm-ppc/commproc.h: * this may be unique to the RPX-Lite configuration.
asm-ppc/commproc.h: * This is unique to the BSE ip-Engine board.
asm-ppc/commproc.h:/***  D-BOX2  ***********************************************/
asm-ppc/commproc.h:#define CICR_HP_MASK		((uint)0x00001f00)	/* Hi-pri int. */
asm-ppc/pplus.h:#include <asm/pci-bridge.h>
asm-ppc/machdep.h:#include <asm-m68k/machdep.h>
asm-ppc/machdep.h:	/* this is for modules, since _machine can be a define -- Cort */
asm-ppc/machdep.h:	/* Hook for board-specific info passed by the bootloader */
asm-ppc/socket.h:/* Socket-level I/O control calls. */
asm-ppc/socket.h:/* Security levels - as per NRL IPv6 - don't actually do anything */
asm-ppc/socket.h:/* Nast libc5 fixup - bletch */
asm-ppc/socket.h:#define SOCK_RDM	4		/* reliably-delivered message	*/
asm-ppc64/io.h: * The __raw_read/write macros don't do byte-swapping. 
asm-ppc64/io.h: * The insw/outsw/insl/outsl macros don't do byte-swapping.
asm-ppc64/io.h: * are arrays of bytes, and byte-swapping is not appropriate in
asm-ppc64/io.h: * that case.  - paulus */
asm-ppc64/io.h: * The *_ns versions below don't do byte-swapping.
asm-ppc64/io.h:	printk("virt_to_phys: 0x%08lx -> 0x%08lx\n", 
asm-ppc64/io.h:	printk("phys_to_virt: 0x%08lx -> 0x%08lx\n", address, __va(address));
asm-ppc64/io.h:#define page_to_phys(page)      ((page - mem_map) << PAGE_SHIFT)
asm-ppc64/io.h:/* Enforce in-order execution of data I/O. 
asm-ppc64/io.h:		length--;
asm-ppc64/atomic.h:#define atomic_read(v)		((v)->counter)
asm-ppc64/atomic.h:#define atomic_set(v,i)		(((v)->counter) = (i))
asm-ppc64/atomic.h:	bne-	1b"
asm-ppc64/atomic.h:	: "=&r" (t), "=m" (v->counter)
asm-ppc64/atomic.h:	: "r" (a), "r" (&v->counter), "m" (v->counter)
asm-ppc64/atomic.h:	bne-	1b"
asm-ppc64/atomic.h:	: "r" (a), "r" (&v->counter)
asm-ppc64/atomic.h:	bne-	1b"
asm-ppc64/atomic.h:	: "=&r" (t), "=m" (v->counter)
asm-ppc64/atomic.h:	: "r" (a), "r" (&v->counter), "m" (v->counter)
asm-ppc64/atomic.h:	bne-	1b"
asm-ppc64/atomic.h:	: "r" (a), "r" (&v->counter)
asm-ppc64/atomic.h:	bne-	1b"
asm-ppc64/atomic.h:	: "=&r" (t), "=m" (v->counter)
asm-ppc64/atomic.h:	: "r" (&v->counter), "m" (v->counter)
asm-ppc64/atomic.h:	bne-	1b"
asm-ppc64/atomic.h:	: "r" (&v->counter)
asm-ppc64/atomic.h:	addic	%0,%0,-1\n\
asm-ppc64/atomic.h:	bne-	1b"
asm-ppc64/atomic.h:	: "=&r" (t), "=m" (v->counter)
asm-ppc64/atomic.h:	: "r" (&v->counter), "m" (v->counter)
asm-ppc64/atomic.h:	addic	%0,%0,-1\n\
asm-ppc64/atomic.h:	bne-	1b"
asm-ppc64/atomic.h:	: "r" (&v->counter)
asm-ppc64/atomic.h:	addic.	%0,%0,-1\n\
asm-ppc64/atomic.h:	blt-	2f\n\
asm-ppc64/atomic.h:	bne-	1b"
asm-ppc64/atomic.h:	: "r" (&v->counter)
asm-ppc64/delay.h:	while((__get_tb()-start) < loops)
asm-ppc64/ipcbuf.h: * as we have always had 32-bit UIDs and GIDs in the kernel.
asm-ppc64/parport.h: * parport.h: platform-specific PC-style parport initialisation
asm-ppc64/shmbuf.h: * - 2 miscellaneous 64-bit values
asm-ppc64/bitops.h: * Bitops are odd when viewed on big-endian systems.  They were designed
asm-ppc64/bitops.h:	bne-	1b"
asm-ppc64/bitops.h:	bne-	1b"
asm-ppc64/bitops.h:	bne-	1b"
asm-ppc64/bitops.h:	bne-	1b"
asm-ppc64/bitops.h:	bne-	1b"
asm-ppc64/bitops.h:	bne-	1b"
asm-ppc64/bitops.h: * non-atomic versions
asm-ppc64/bitops.h: * Return the zero-based bit position (from RIGHT TO LEFT, 63 -> 0) of the
asm-ppc64/bitops.h: * most significant (left-most) 1-bit in a double word.
asm-ppc64/bitops.h:	return 63 - lz;
asm-ppc64/bitops.h:/* Return the zero-based bit position
asm-ppc64/bitops.h: *  from RIGHT TO LEFT  63 --> 0
asm-ppc64/bitops.h: *   of the most significant (left-most) 1-bit in an 8-byte area.
asm-ppc64/bitops.h:"	addi	%0,%1,-1	\n\
asm-ppc64/bitops.h: * in the specified double word. The returned bit position will be zero-based,
asm-ppc64/bitops.h: * starting from the right side (63 - 0).
asm-ppc64/bitops.h:	 * '0' bit in * the original x).  Note: (x & -x) gives us a mask that
asm-ppc64/bitops.h:	 * is the least significant * (RIGHT-most) 1-bit of the value in x.
asm-ppc64/bitops.h:	return __ilog2(x & -x);
asm-ppc64/bitops.h:	return __ilog2(x & -x);
asm-ppc64/bitops.h:	return __ilog2(i & -i) + 1;
asm-ppc64/bitops.h: * fls: find last (most-significant) bit set.
asm-ppc64/bitops.h: * of bits set) of a N-bit word
asm-ppc64/bitops.h: * non-atomic versions
asm-ppc64/resource.h:#define RLIMIT_MEMLOCK	8		/* max locked-in-memory address space */
asm-ppc64/ptrace.h: * since we can keep non-volatile in the thread_struct
asm-ppc64/ptrace.h:#define instruction_pointer(regs) ((regs)->nip)
asm-ppc64/ptrace.h:#define user_mode(regs) ((((regs)->msr) >> MSR_PR_LG) & 0x1)
asm-ppc64/ptrace.h:/* Kernel and userspace will both use this PT_FPSCR value.  32-bit apps will have
asm-ppc64/ptrace.h: * visibility to the asm-ppc/ptrace.h header instead of this one.
asm-ppc64/ptrace.h:#define PT_FPSCR (PT_FPR0 + 32)	  /* each FP reg occupies 1 slot in 64-bit space */
asm-ppc64/ptrace.h:#define PT_FPSCR32 (PT_FPR0 + 2*32 + 1)	  /* each FP reg occupies 2 32-bit userspace slots */
asm-ppc64/ptrace.h:#define PPC_PTRACE_GETREGS	      0x99  /* Get GPRs 0 - 31 */
asm-ppc64/ptrace.h:#define PPC_PTRACE_SETREGS	      0x98  /* Set GPRs 0 - 31 */
asm-ppc64/ptrace.h:#define PPC_PTRACE_GETFPREGS	    0x97  /* Get FPRs 0 - 31 */
asm-ppc64/ptrace.h:#define PPC_PTRACE_SETFPREGS	    0x96  /* Set FPRs 0 - 31 */
asm-ppc64/ptrace.h:#define PPC_PTRACE_PEEKTEXT_3264  0x95  /* Read word at location ADDR on a 64-bit process from a 32-bit process. */
asm-ppc64/ptrace.h:#define PPC_PTRACE_PEEKDATA_3264  0x94  /* Read word at location ADDR on a 64-bit process from a 32-bit process. */
asm-ppc64/ptrace.h:#define PPC_PTRACE_POKETEXT_3264  0x93  /* Write word at location ADDR on a 64-bit process from a 32-bit process. */
asm-ppc64/ptrace.h:#define PPC_PTRACE_POKEDATA_3264  0x92  /* Write word at location ADDR on a 64-bit process from a 32-bit process. */
asm-ppc64/ptrace.h:#define PPC_PTRACE_PEEKUSR_3264   0x91  /* Read a register (specified by ADDR) out of the "user area" on a 64-bit process from a 32-bit process. */
asm-ppc64/ptrace.h:#define PPC_PTRACE_POKEUSR_3264   0x90  /* Write DATA into location ADDR within the "user area" on a 64-bit process from a 32-bit process. */
asm-ppc64/pgalloc.h:#define pgd_quicklist 		(quicklists->pgd_cache)
asm-ppc64/pgalloc.h:#define pmd_quicklist 		(quicklists->pmd_cache)
asm-ppc64/pgalloc.h:#define pte_quicklist 		(quicklists->pte_cache)
asm-ppc64/pgalloc.h:#define pgtable_cache_size 	(quicklists->pgtable_cache_sz)
asm-ppc64/pgalloc.h:		--pgtable_cache_size;
asm-ppc64/pgalloc.h:		--pgtable_cache_size;
asm-ppc64/pgalloc.h:		--pgtable_cache_size;
asm-ppc64/unistd.h:		__sc_ret = -1;						\
asm-ppc64/unistd.h:	return waitpid(-1,wait_stat,0);
asm-ppc64/dma.h: *  controller 1: channels 0-3, byte operations, ports 00-1F
asm-ppc64/dma.h: *  controller 2: channels 4-7, word operations, ports C0-DF
asm-ppc64/dma.h: *  - ALL registers are 8 bits only, regardless of transfer size
asm-ppc64/dma.h: *  - channel 4 is not used - cascades 1 into 2.
asm-ppc64/dma.h: *  - channels 0-3 are byte - addresses/counts are for physical bytes
asm-ppc64/dma.h: *  - channels 5-7 are word - addresses/counts are for physical words
asm-ppc64/dma.h: *  - transfers must not cross physical 64K (0-3) or 128K (5-7) boundaries
asm-ppc64/dma.h: *  - transfer count loaded to registers is 1 less than actual count
asm-ppc64/dma.h: *  - controller 2 offsets are all even (2x offsets for controller 1)
asm-ppc64/dma.h: *  - page registers for 5-7 don't use data bit 0, represent 128K pages
asm-ppc64/dma.h: *  - page registers for 0-3 use bit 0, represent 64K pages
asm-ppc64/dma.h: *  Address mapping for channels 0-3:
asm-ppc64/dma.h: *  Address mapping for channels 5-7:
asm-ppc64/dma.h: * Again, channels 5-7 transfer _physical_ words (16 bits), so addresses
asm-ppc64/dma.h: * and counts _must_ be word-aligned (the lowest address bit is _ignored_ at
asm-ppc64/dma.h: * the hardware level, so odd-byte transfers aren't possible).
asm-ppc64/dma.h: * count - 1 : 64K => 0xFFFF, 1 => 0x0000.  Thus, count is always 1 or more,
asm-ppc64/dma.h: * and up to 128K bytes may be transferred on channels 5-7 in one operation. 
asm-ppc64/dma.h:#define DMA1_MASK_REG		0x0A	/* single-channel mask (w) */
asm-ppc64/dma.h:#define DMA1_CLEAR_FF_REG	0x0C	/* clear pointer flip-flop (w) */
asm-ppc64/dma.h:#define DMA1_MASK_ALL_REG       0x0F    /* all-channels mask (w) */
asm-ppc64/dma.h:#define DMA2_MASK_REG		0xD4	/* single-channel mask (w) */
asm-ppc64/dma.h:#define DMA2_CLEAR_FF_REG	0xD8	/* clear pointer flip-flop (w) */
asm-ppc64/dma.h:#define DMA2_MASK_ALL_REG       0xDE    /* all-channels mask (w) */
asm-ppc64/dma.h:#define DMA_MODE_CASCADE 0xC0   /* pass thru DREQ->HRQ, DACK<-HLDA only */
asm-ppc64/dma.h: * After that, keep track of it. :-)
asm-ppc64/dma.h: * --- In order to do that, the DMA routines below should ---
asm-ppc64/dma.h: * --- only be used while interrupts are disabled! ---
asm-ppc64/dma.h: * Assumes dma flip-flop is clear.
asm-ppc64/dma.h: * NOTE 2: "count" represents _bytes_ and must be even for channels 5-7.
asm-ppc64/dma.h:        count--;
asm-ppc64/dma.h: * Assumes DMA flip-flop is clear.
asm-ppc64/dma.h:	/* using short to get 16-bit wrap around */
asm-ppc64/eeh.h: * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
asm-ppc64/eeh.h: * never actually mapped.  Translation between IO <-> EEH region is 1 to 1.
asm-ppc64/eeh.h:/* EEH_POSSIBLE_ERROR() -- test for possible MMIO failure.
asm-ppc64/elf.h:#define elf_check_arch(x) ((x)->e_machine == ELF_ARCH)
asm-ppc64/elf.h:/* Common routine for both 32-bit and 64-bit processes */
asm-ppc64/elf.h:#define ELF_HWCAP	(cur_cpu_spec->cpu_user_features)
asm-ppc64/elf.h:	memset(_r->gpr, 0, sizeof(_r->gpr)); \
asm-ppc64/elf.h:	_r->ctr = _r->link = _r->xer = _r->ccr = 0; \
asm-ppc64/elf.h:	_r->gpr[2] = interp_load_addr; \
asm-ppc64/elf.h:		current->thread.flags |= PPC_FLAG_32BIT;	\
asm-ppc64/elf.h:		current->thread.flags &= ~PPC_FLAG_32BIT;	\
asm-ppc64/elf.h:	else if (current->personality != PER_LINUX32)		\
asm-ppc64/elf.h: * - keep the final alignment of sp (sp & 0xf)
asm-ppc64/elf.h: * - make sure the 32-bit value at the first 16 byte aligned position of
asm-ppc64/elf.h: * - for compatibility with glibc ARCH_DLINFO must always be defined on PPC,
asm-ppc64/elf.h:	sp -= DLINFO_ARCH_ITEMS * 2;					\
asm-ppc64/elf.h:	sp -= 2*2;							\
asm-ppc64/ide.h: *  linux/include/asm-ppc/ide.h
asm-ppc64/ide.h: *  Copyright (C) 1994-1996 Linus Torvalds & authors
asm-ppc64/ide.h:		hw->io_ports[i] = reg;
asm-ppc64/ide.h:		hw->io_ports[IDE_CONTROL_OFFSET] = ctrl_port;
asm-ppc64/ide.h:		hw->io_ports[IDE_CONTROL_OFFSET] = hw->io_ports[IDE_DATA_OFFSET] + 0x206;
asm-ppc64/ide.h:	hw->io_ports[IDE_IRQ_OFFSET] = 0;
asm-ppc64/irq.h: * interrupts to take values 0 - 15, and shift up the remaining
asm-ppc64/irq.h:	return(irq - NUM_ISA_INTERRUPTS);
asm-ppc64/lmb.h:	unsigned long base1 = rgn->region[r1].base;
asm-ppc64/lmb.h:        unsigned long size1 = rgn->region[r1].size;
asm-ppc64/lmb.h:	unsigned long base2 = rgn->region[r2].base;
asm-ppc64/lmb.h:        unsigned long size2 = rgn->region[r2].size;
asm-ppc64/lmb.h:		return -1;
asm-ppc64/lmb.h:	unsigned long base1 = rgn->region[r1].base;
asm-ppc64/lmb.h:        unsigned long size1 = rgn->region[r1].size;
asm-ppc64/lmb.h:        unsigned long type1 = rgn->region[r1].type;
asm-ppc64/lmb.h:	unsigned long base2 = rgn->region[r2].base;
asm-ppc64/lmb.h:        unsigned long size2 = rgn->region[r2].size;
asm-ppc64/lmb.h:        unsigned long type2 = rgn->region[r2].type;
asm-ppc64/mmu.h:	unsigned long n:     1; /* No-execute if n=1 */
asm-ppc64/mmu.h:	unsigned long n:     1; /* No-execute if n=1 */
asm-ppc64/mmu.h:	unsigned long :     6; /* unused - padding */
asm-ppc64/mmu.h:	unsigned long w:	1; /* Write-thru cache mode */
asm-ppc64/mmu.h:	unsigned long n:	1; /* No-execute */
asm-ppc64/mmu.h:	unsigned long w:	1; /* Write-thru cache mode */
asm-ppc64/mmu.h:	unsigned long n:	1; /* No-execute */
asm-ppc64/pci.h: * already-configured bus numbers - to be used for buggy BIOSes
asm-ppc64/pci.h: * only drive the low 24-bits during PCI bus mastering, then
asm-ppc64/pci.h:#define sg_dma_address(sg)	((sg)->dma_address)
asm-ppc64/pci.h:#define sg_dma_len(sg)		((sg)->dma_length)
asm-ppc64/pci.h:	((PTR)->ADDR_NAME)
asm-ppc64/pci.h:	(((PTR)->ADDR_NAME) = (VAL))
asm-ppc64/pci.h:	((PTR)->LEN_NAME)
asm-ppc64/pci.h:	(((PTR)->LEN_NAME) = (VAL))
asm-ppc64/pmc.h: * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
asm-ppc64/pmc.h:/* To find an entry in the bolted page-table-directory */
asm-ppc64/pmc.h:#define BTMALLOC_END   0xB0000000ffffffff /* 4 GB Max-more or less arbitrary */
asm-ppc64/smp.h: * Copyright (C) 1996-2001 Cort Dougan <cort@fsmlabs.com>
asm-ppc64/smp.h:/* 1 to 1 mapping on PPC -- Cort */
asm-ppc64/smp.h:#define smp_processor_id() (get_paca()->xPacaIndex)
asm-ppc64/smp.h:#define hard_smp_processor_id() (get_paca()->xHwProcNum)
asm-ppc64/smp.h: * in /proc/interrupts will be wrong!!! --Troy */
asm-ppc64/tlb.h:#include <asm-generic/tlb.h>
asm-ppc64/vio.h: * Architecture-specific constants for drivers to
asm-ppc64/vio.h:#define VETH_MAC_ADDR "local-mac-address"
asm-ppc64/vio.h:#define VETH_MCAST_FILTER_SIZE "ibm,mac-address-filters"
asm-ppc64/vio.h:/* End architecture-specific constants */
asm-ppc64/vio.h:	void (*remove) (struct vio_dev *dev);	/* Device removed (NULL if not a hot-plug capable driver) */
asm-ppc64/vio.h:		rc = -ENODEV;
asm-ppc64/xor.h:#include <asm-generic/xor.h>
asm-ppc64/syscall.h: * Prototypes for architecture-specific Linux syscalls.
asm-ppc64/signal.h:#define SIGRTMAX	(_NSIG-1)
asm-ppc64/signal.h: * SA_INTERRUPT is a no-op, but left due to historical reasons. Use the
asm-ppc64/signal.h:#define SA_INTERRUPT	0x20000000 /* dummy -- ignored */
asm-ppc64/signal.h:#define SIG_ERR	((__sighandler_t)-1)	/* error return from signal */
asm-ppc64/hardirq.h:#define irq_exit(cpu)		(local_irq_count(cpu)--)
asm-ppc64/processor.h:#define FPSCR_ZX	0x04000000	/* Zero-divide exception summary */
asm-ppc64/processor.h:#define FPSCR_VXISI	0x00800000	/* Invalid op for Inv - Inv */
asm-ppc64/processor.h:#define FPSCR_NI	0x00000004	/* FPU non IEEE-Mode */
asm-ppc64/processor.h:#define	SPRN_DCWR	0x3BA	/* Data Cache Write-thru Register */
asm-ppc64/processor.h:#define	  DCWR_COPY		0	/* Copy-back */
asm-ppc64/processor.h:#define	  DCWR_WRITE		1	/* Write-through */
asm-ppc64/processor.h:#define	  ESR_IMCP	0x80000000	/* Instr. Machine Check - Protection */
asm-ppc64/processor.h:#define	  ESR_IMCN	0x40000000	/* Instr. Machine Check - Non-config */
asm-ppc64/processor.h:#define	  ESR_IMCB	0x20000000	/* Instr. Machine Check - Bus error */
asm-ppc64/processor.h:#define	  ESR_IMCT	0x10000000	/* Instr. Machine Check - Timeout */
asm-ppc64/processor.h:#define	  ESR_PIL	0x08000000	/* Program Exception - Illegal */
asm-ppc64/processor.h:#define	  ESR_PPR	0x04000000	/* Program Exception - Privileged */
asm-ppc64/processor.h:#define	  ESR_PTR	0x02000000	/* Program Exception - Trap */
asm-ppc64/processor.h:#define	  ESR_DST	0x00800000	/* Storage Exception - Data miss */
asm-ppc64/processor.h:#define	  ESR_DIZ	0x00400000	/* Storage Exception - Zone fault */
asm-ppc64/processor.h:#define	SPRN_TBHU	0x3CC	/* Time Base High User-mode */
asm-ppc64/processor.h:#define	SPRN_TBLU	0x3CD	/* Time Base Low User-mode */
asm-ppc64/processor.h:/* Short-hand versions for a number of the above SPRNs */
asm-ppc64/processor.h:#define	  BESR_DSES    	0x80000000	/* Data-Side Error Status */
asm-ppc64/processor.h:	.long GLUE(.LT,NAME)-GLUE(.,NAME) ;\
asm-ppc64/processor.h:	.short GLUE(GLUE(.LT,NAME),_procname_end)-GLUE(GLUE(.LT,NAME),_procname_start) ;\
asm-ppc64/processor.h:/* Lazy FPU handling on uni-processor */
asm-ppc64/processor.h:/* 64-bit user address space is 41-bits (2TBs user VM) */
asm-ppc64/processor.h:#define TASK_SIZE_USER64 (0x0000020000000000UL - PGDIR_SIZE)
asm-ppc64/processor.h: * 32-bit user address space is 4GB - 1 page 
asm-ppc64/processor.h:#define TASK_SIZE_USER32 (0x0000000100000000UL - (1*PAGE_SIZE))
asm-ppc64/processor.h:#define TASK_SIZE ((current->thread.flags & PPC_FLAG_32BIT) ? \
asm-ppc64/processor.h:#define TASK_UNMAPPED_BASE (((current->thread.flags & PPC_FLAG_32BIT)||(ppcdebugset(PPCDBG_BINFMT_32ADDR))) ? \
asm-ppc64/processor.h:	void		*pgdir;		/* root of page-table tree */
asm-ppc64/processor.h:	unsigned long	fpexc_mode;	/* Floating-point exception mode */
asm-ppc64/processor.h:	(struct pt_regs *)INIT_SP - 1, /* regs */ \
asm-ppc64/processor.h:	return (t->regs) ? t->regs->nip : 0;
asm-ppc64/processor.h:#define KSTK_EIP(tsk)  ((tsk)->thread.regs? (tsk)->thread.regs->nip: 0)
asm-ppc64/processor.h:#define KSTK_ESP(tsk)  ((tsk)->thread.regs? (tsk)->thread.regs->gpr[1]: 0)
asm-ppc64/processor.h:/* Get/set floating-point exception mode */
asm-ppc64/processor.h:#define get_task_struct(tsk)	atomic_inc(&virt_to_page(tsk)->count)
asm-ppc64/linux_logo.h: * include/asm-ppc64/linux_logo.h: A linux logo to be displayed on boot
asm-ppc64/linux_logo.h:#define linux_logo_banner "Linux/PPC-64 version " UTS_RELEASE
asm-ppc64/cputable.h: *  include/asm-ppc64/cputable.h
asm-ppc64/cputable.h:/* Exposed to userland CPU features - Must match ppc32 definitions */
asm-ppc64/cputable.h:/* Retain the 32b definitions for the time being - use bottom half of word */
asm-ppc64/mmu_context.h:#define NUM_USER_CONTEXT	(LAST_USER_CONTEXT-FIRST_USER_CONTEXT)
asm-ppc64/mmu_context.h:		return -ENOMEM;
asm-ppc64/mmu_context.h:	mm->context = mmu_context_queue.elements[head];
asm-ppc64/mmu_context.h:	head = (head < LAST_USER_CONTEXT-1) ? head+1 : 0;
asm-ppc64/mmu_context.h:	mmu_context_queue.size = size-1;
asm-ppc64/mmu_context.h:	index = (index > 0) ? index-1 : LAST_USER_CONTEXT-1;
asm-ppc64/mmu_context.h:	index = (index < LAST_USER_CONTEXT-1) ? index+1 : 0;
asm-ppc64/mmu_context.h:	mmu_context_queue.elements[index] = mm->context;
asm-ppc64/mmu_context.h: * After we have set current->mm to a new value, this activates
asm-ppc64/semaphore.h: * Remove spinlock-based RW semaphores; RW semaphore definitions are
asm-ppc64/semaphore.h: * -- Paul Mackerras (paulus@samba.org)
asm-ppc64/semaphore.h:	atomic_set(&sem->count, val);
asm-ppc64/semaphore.h:	init_waitqueue_head(&sem->wait);
asm-ppc64/semaphore.h:	sem->__magic = (long)&sem->__magic;
asm-ppc64/semaphore.h:	CHECK_MAGIC(sem->__magic);
asm-ppc64/semaphore.h:	if (atomic_dec_return(&sem->count) < 0)
asm-ppc64/semaphore.h:	CHECK_MAGIC(sem->__magic);
asm-ppc64/semaphore.h:	if (atomic_dec_return(&sem->count) < 0)
asm-ppc64/semaphore.h:	CHECK_MAGIC(sem->__magic);
asm-ppc64/semaphore.h:	ret = atomic_dec_if_positive(&sem->count) < 0;
asm-ppc64/semaphore.h:	CHECK_MAGIC(sem->__magic);
asm-ppc64/semaphore.h:	if (atomic_inc_return(&sem->count) <= 0)
asm-ppc64/semaphore.h:	return atomic_read(&sem->count);
asm-ppc64/fcntl.h:/* open/fcntl - O_SYNC is only implemented on blocks devices and on files
asm-ppc64/fcntl.h:#define F_GETFL		3	/* get file->f_flags */
asm-ppc64/fcntl.h:#define F_SETFL		4	/* set file->f_flags */
asm-ppc64/hvcall.h:#define H_Busy		1	/* Hardware busy -- retry later */
asm-ppc64/hvcall.h:#define H_Hardware	-1	/* Hardware error */
asm-ppc64/hvcall.h:#define H_Function	-2	/* Function not supported */
asm-ppc64/hvcall.h:#define H_Privilege	-3	/* Caller not privileged */
asm-ppc64/hvcall.h:#define H_Parameter	-4	/* Parameter invalid, out-of-range or conflicting */
asm-ppc64/hvcall.h:#define H_Bad_Mode	-5	/* Illegal msr value */
asm-ppc64/hvcall.h:#define H_PTEG_Full	-6	/* PTEG is full */
asm-ppc64/hvcall.h:#define H_Not_Found	-7	/* PTE was not found" */
asm-ppc64/hvcall.h:#define H_Reserved_DABR	-8	/* DABR address is reserved by the hypervisor on this processor" */
asm-ppc64/hvcall.h:#define H_NoMem                 -9
asm-ppc64/hvcall.h:#define H_Authority            -10
asm-ppc64/hvcall.h:#define H_Permission           -11
asm-ppc64/hvcall.h:#define H_Dropped              -12
asm-ppc64/hvcall.h:#define H_SourceParm           -13
asm-ppc64/hvcall.h:#define H_DestParm             -14
asm-ppc64/hvcall.h:#define H_RemoteParm           -15
asm-ppc64/hvcall.h:#define H_Resource             -16
asm-ppc64/hvcall.h:#define H_LARGE_PAGE		(1UL<<(63-16))
asm-ppc64/hvcall.h:#define H_EXACT		    (1UL<<(63-24))	/* Use exact PTE or return H_PTEG_FULL */
asm-ppc64/hvcall.h:#define H_R_XLATE		(1UL<<(63-25))	/* include a valid logical page num in the pte if the valid bit is set */
asm-ppc64/hvcall.h:#define H_READ_4		(1UL<<(63-26))	/* Return 4 PTEs */
asm-ppc64/hvcall.h:#define H_AVPN			(1UL<<(63-32))	/* An avpn is provided as a sanity test */
asm-ppc64/hvcall.h:#define H_ANDCOND		(1UL<<(63-33))
asm-ppc64/hvcall.h:#define H_ICACHE_INVALIDATE	(1UL<<(63-40))	/* icbi, etc.  (ignored for IO pages) */
asm-ppc64/hvcall.h:#define H_ICACHE_SYNCHRONIZE	(1UL<<(63-41))	/* dcbst, icbi, etc (ignored for IO pages */
asm-ppc64/hvcall.h:#define H_ZERO_PAGE		(1UL<<(63-48))	/* zero the page before mapping (ignored for IO pages) */
asm-ppc64/hvcall.h:#define H_COPY_PAGE		(1UL<<(63-49))
asm-ppc64/hvcall.h:#define H_N			(1UL<<(63-61))
asm-ppc64/hvcall.h:#define H_PP1			(1UL<<(63-62))
asm-ppc64/hvcall.h:#define H_PP2			(1UL<<(63-63))
asm-ppc64/hvcall.h:/* plpar_hcall() -- Generic call interface using above opcodes
asm-ppc64/hvcall.h: * the opcode in R3 and input args in R4-R7.
asm-ppc64/hvcall.h: * Status is returned in R3 with variable output values in R4-R11.
asm-ppc64/hvcall.h: * Only H_PTE_READ with H_READ_4 uses R6-R11 so we ignore it for now
asm-ppc64/rwsem.h: * include/asm-ppc/rwsem.h: R/W semaphores for PPC using the stuff
asm-ppc64/rwsem.h: * in lib/rwsem.c.  Adapted largely from include/asm-i386/rwsem.h
asm-ppc64/rwsem.h:	/* XXX this should be able to be an atomic_t  -- paulus */
asm-ppc64/rwsem.h:#define RWSEM_WAITING_BIAS		(-0x00010000)
asm-ppc64/rwsem.h:	sem->count = RWSEM_UNLOCKED_VALUE;
asm-ppc64/rwsem.h:	spin_lock_init(&sem->wait_lock);
asm-ppc64/rwsem.h:	INIT_LIST_HEAD(&sem->wait_list);
asm-ppc64/rwsem.h:	sem->debug = 0;
asm-ppc64/rwsem.h:	if (atomic_inc_return((atomic_t *)(&sem->count)) >= 0)
asm-ppc64/rwsem.h:	while ((tmp = sem->count) >= 0) {
asm-ppc64/rwsem.h:		if (tmp == cmpxchg(&sem->count, tmp,
asm-ppc64/rwsem.h:				(atomic_t *)(&sem->count));
asm-ppc64/rwsem.h:	tmp = cmpxchg(&sem->count, RWSEM_UNLOCKED_VALUE,
asm-ppc64/rwsem.h:	tmp = atomic_dec_return((atomic_t *)(&sem->count));
asm-ppc64/rwsem.h:	if (tmp < -1 && (tmp & RWSEM_ACTIVE_MASK) == 0)
asm-ppc64/rwsem.h:			      (atomic_t *)(&sem->count)) < 0)
asm-ppc64/rwsem.h:	atomic_add(delta, (atomic_t *)(&sem->count));
asm-ppc64/rwsem.h:	return atomic_add_return(delta, (atomic_t *)(&sem->count));
asm-ppc64/spinlock.h:#define spin_is_locked(x)	((x)->lock != 0)
asm-ppc64/spinlock.h:	bne-		2f\n\
asm-ppc64/spinlock.h:	bne-		1b\n\
asm-ppc64/spinlock.h:	: "r"(&lock->lock)
asm-ppc64/spinlock.h:	beq-		2f\n\
asm-ppc64/spinlock.h:	li              3,0x25          # yield hcall 0x8-12 \n\
asm-ppc64/spinlock.h:	or              5,5,4           # r5 has yield cnt - or it in\n\
asm-ppc64/spinlock.h:	li              0,-1            # indicate an hcall\n\
asm-ppc64/spinlock.h:	bne-		1b\n\
asm-ppc64/spinlock.h:	bne-		2b\n\
asm-ppc64/spinlock.h:	: "r"(&lock->lock)
asm-ppc64/spinlock.h:	beq-		2f\n\
asm-ppc64/spinlock.h:	bne-		1b\n\
asm-ppc64/spinlock.h:	bne-		2b\n\
asm-ppc64/spinlock.h:	: "r"(&lock->lock)
asm-ppc64/spinlock.h:	bne-		1b\n\
asm-ppc64/spinlock.h:	bne-		2b\n\
asm-ppc64/spinlock.h:	: "r"(&lock->lock)
asm-ppc64/spinlock.h:	lock->lock = 0;
asm-ppc64/spinlock.h: * Read-write spinlocks, allowing multiple readers
asm-ppc64/spinlock.h: * can "mix" irq-safe locks - any writer needs to get a
asm-ppc64/spinlock.h: * irq-safe write-lock, but readers can get non-irqsafe
asm-ppc64/spinlock.h: * read-locks.
asm-ppc64/spinlock.h:	ble-		2f\n\
asm-ppc64/spinlock.h:	bne-		1b\n\
asm-ppc64/spinlock.h:	: "r"(&rw->lock)
asm-ppc64/spinlock.h:	bge-		2f\n\
asm-ppc64/spinlock.h:	li              3,0x25          # yield hcall 0x8-12 \n\
asm-ppc64/spinlock.h:	or              5,5,4           # r5 has yield cnt - or it in\n\
asm-ppc64/spinlock.h:	li              0,-1            # indicate an hcall\n\
asm-ppc64/spinlock.h:	ble-		1b\n\
asm-ppc64/spinlock.h:	bne-		2b\n\
asm-ppc64/spinlock.h:	: "r"(&rw->lock)
asm-ppc64/spinlock.h:	bge-		2f\n\
asm-ppc64/spinlock.h:	ble-		1b\n\
asm-ppc64/spinlock.h:	bne-		2b\n\
asm-ppc64/spinlock.h:	: "r"(&rw->lock)
asm-ppc64/spinlock.h:	ble-		1b\n\
asm-ppc64/spinlock.h:	bne-		2b\n\
asm-ppc64/spinlock.h:	: "r"(&rw->lock)
asm-ppc64/spinlock.h:	addic		%0,%0,-1\n\
asm-ppc64/spinlock.h:	bne-		1b"
asm-ppc64/spinlock.h:	: "r"(&rw->lock)
asm-ppc64/spinlock.h:	bne-		2f\n\
asm-ppc64/spinlock.h:	bne-		1b\n\
asm-ppc64/spinlock.h:	: "r"(&rw->lock)
asm-ppc64/spinlock.h:	beq-		2f\n\
asm-ppc64/spinlock.h:	bgt             1b              # negative(0xc..)->cycles to holder\n"
asm-ppc64/spinlock.h:	or              5,5,4           # r5 has yield cnt - or it in\n\
asm-ppc64/spinlock.h:	li              3,0x25          # yield hcall 0x8-12 \n\
asm-ppc64/spinlock.h:	li              0,-1            # indicate an hcall\n\
asm-ppc64/spinlock.h:	bne-		1b\n\
asm-ppc64/spinlock.h:	bne-		2b\n\
asm-ppc64/spinlock.h:	: "r"(&rw->lock)
asm-ppc64/spinlock.h:	beq-		2f\n\
asm-ppc64/spinlock.h:	blt             3f              # negative(0xc..)->confer to holder\n\
asm-ppc64/spinlock.h:	bne-		1b\n\
asm-ppc64/spinlock.h:	bne-		2b\n\
asm-ppc64/spinlock.h:	: "r"(&rw->lock)
asm-ppc64/spinlock.h:	bne-		1b\n\
asm-ppc64/spinlock.h:	bne-		2b\n\
asm-ppc64/spinlock.h:	: "r"(&rw->lock)
asm-ppc64/spinlock.h:	rw->lock = 0;
asm-ppc64/spinlock.h:	return rw->lock > 0;
asm-ppc64/spinlock.h:	return rw->lock < 0;
asm-ppc64/errno.h:#define	EXDEV		18	/* Cross-device link */
asm-ppc64/errno.h:#define	EROFS		30	/* Read-only file system */
asm-ppc64/errno.h:#define	ENOTSOCK	88	/* Socket operation on non-socket */
asm-ppc64/softirq.h:#define __local_bh_enable()	do { barrier(); local_bh_count(smp_processor_id())--; } while (0)
asm-ppc64/softirq.h:        if (!--local_bh_count(smp_processor_id())       \
asm-ppc64/hw_irq.h: * Use inline IRQs where possible - Anton Blanchard <anton@au.ibm.com>
asm-ppc64/hw_irq.h:	if (desc->handler && desc->handler->disable)	\
asm-ppc64/hw_irq.h:		desc->handler->disable(irq);		\
asm-ppc64/hw_irq.h:	if (desc->handler && desc->handler->enable)	\
asm-ppc64/hw_irq.h:		desc->handler->enable(irq);		\
asm-ppc64/hw_irq.h:	if (desc->handler && desc->handler->ack)	\
asm-ppc64/hw_irq.h:		desc->handler->ack(irq);		\
asm-ppc64/hw_irq.h: * we do now ? --BenH.
asm-ppc64/timex.h: * linux/include/asm-ppc/timex.h
asm-ppc64/timex.h:#define FINETUNE ((((((long)LATCH * HZ - CLOCK_TICK_RATE) << SHIFT_HZ) * \
asm-ppc64/timex.h:		<< (SHIFT_SCALE-SHIFT_HZ)) / HZ)
asm-ppc64/bugs.h: * This file is included by 'init/main.c' to check for architecture-dependent
asm-ppc64/namei.h: * linux/include/asm-ppc/namei.h
asm-ppc64/namei.h: * Adapted from linux/include/asm-alpha/namei.h
asm-ppc64/namei.h: * Look at asm-sparc/namei.h for details.
asm-ppc64/dump.h: *  Function: This is the header for architecture-specific stuff.  It
asm-ppc64/dump.h:        /* the dump magic number -- unique to verify dump is valid */
asm-ppc64/ppcdebug.h: * -- When adding new values, please enter them into trace names below -- 
asm-ppc64/ppcdebug.h:#define PPCDBG_BINFMT ((current->thread.flags & PPC_FLAG_32BIT) ? PPCDBG_BINFMT32 : PPCDBG_BINFMT64)
asm-ppc64/abs_addr.h:	return chunk << _msChunks->chunk_shift;
asm-ppc64/abs_addr.h:	return addr >> _msChunks->chunk_shift;
asm-ppc64/abs_addr.h:	return addr & _msChunks->chunk_mask;
asm-ppc64/abs_addr.h:	if ( pchunk >= _msChunks->num_chunks ) {
asm-ppc64/abs_addr.h:	return PTRRELOC(_msChunks->abs)[pchunk];
asm-ppc64/iSeries/mf.h: * all partitions in the iSeries.  It also provides miscellaneous low-level
asm-ppc64/iSeries/mf.h: * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
asm-ppc64/iSeries/iSeries_dma.h: * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
asm-ppc64/iSeries/iSeries_dma.h:#define NO_TCE ((dma_addr_t)-1)
asm-ppc64/iSeries/iSeries_dma.h:		u64	cacheBits	:6;	/* Cache hash bits - not used */
asm-ppc64/iSeries/iSeries_pci.h:/* Boston, MA  02111-1307  USA                                          */
asm-ppc64/iSeries/iSeries_pci.h:#define ISERIES_BUS(DevPtr)    DevPtr->DsaAddr.busNumber
asm-ppc64/iSeries/iSeries_pci.h:#define ISERIES_SUBBUS(DevPtr) DevPtr->DsaAddr.subBusNumber
asm-ppc64/iSeries/iSeries_pci.h:#define ISERIES_DEVICE(DevPtr) DevPtr->DsaAddr.deviceId
asm-ppc64/iSeries/iSeries_pci.h:#define ISERIES_DEVFUN(DevPtr) DevPtr->DevFn
asm-ppc64/iSeries/iSeries_pci.h:#define ISERIES_DSA(DevPtr)   (*(u64*)&DevPtr->DsaAddr)
asm-ppc64/iSeries/iSeries_pci.h:#define ISERIES_DEVNODE(PciDev) ((struct iSeries_Device_Node*)PciDev->sysdata)
asm-ppc64/iSeries/HvCallSc.h: * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
asm-ppc64/iSeries/HvCallSm.h: * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
asm-ppc64/iSeries/HvCallSm.h://-------------------------------------------------------------------
asm-ppc64/iSeries/HvCallSm.h://-------------------------------------------------------------------
asm-ppc64/iSeries/HvCallSm.h://-----------------------------------------------------------------------------
asm-ppc64/iSeries/HvCallSm.h://-----------------------------------------------------------------------------
asm-ppc64/iSeries/HvCallSm.h:	// getPaca()->adjustHmtForNoOfSpinLocksHeld();
asm-ppc64/iSeries/HvCallXm.h://-------------------------------------------------------------------
asm-ppc64/iSeries/HvCallXm.h://-------------------------------------------------------------------
asm-ppc64/iSeries/HvCallXm.h://-------------------------------------------------------------------
asm-ppc64/iSeries/HvCallXm.h://-------------------------------------------------------------------
asm-ppc64/iSeries/HvCallXm.h://-------------------------------------------------------------------
asm-ppc64/iSeries/HvCallXm.h://-------------------------------------------------------------------
asm-ppc64/iSeries/HvCallXm.h://-----------------------------------------------------------------------------
asm-ppc64/iSeries/HvCallXm.h://-----------------------------------------------------------------------------
asm-ppc64/iSeries/HvCallXm.h:	// getPaca()->adjustHmtForNoOfSpinLocksHeld();
asm-ppc64/iSeries/HvCallXm.h:	// getPaca()->adjustHmtForNoOfSpinLocksHeld();
asm-ppc64/iSeries/HvCallXm.h:	// getPaca()->adjustHmtForNoOfSpinLocksHeld();
asm-ppc64/iSeries/HvCallXm.h:	// getPaca()->adjustHmtForNoOfSpinLocksHeld();
asm-ppc64/iSeries/HvCallXm.h:	// getPaca()->adjustHmtForNoOfSpinLocksHeld();
asm-ppc64/iSeries/HvCallXm.h:	// getPaca()->adjustHmtForNoOfSpinLocksHeld();
asm-ppc64/iSeries/HvCallXm.h:	// getPaca()->adjustHmtForNoOfSpinLocksHeld();
asm-ppc64/iSeries/veth-proc.h: * veth-proc.h
asm-ppc64/iSeries/veth-proc.h: * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
asm-ppc64/iSeries/veth-proc.h:#endif /* _VETH-PROC_H */
asm-ppc64/iSeries/vio.h:/* -*- linux-c -*-
asm-ppc64/iSeries/vio.h: * Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
asm-ppc64/iSeries/ItVpdAreas.h: * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
asm-ppc64/iSeries/ItVpdAreas.h:// VPD Entry index is carved in stone - cannot be changed (easily).
asm-ppc64/iSeries/ItVpdAreas.h:	u32	xSlicDesc;		// Descriptor				000-003
asm-ppc64/iSeries/ItVpdAreas.h:	u16	xSlicSize;		// Size of this control block		004-005
asm-ppc64/iSeries/ItVpdAreas.h:	u16	xPlicAdjustVpdLens:1;	// Flag to indicate new interface 	006-007
asm-ppc64/iSeries/ItVpdAreas.h:	u16	xSlicVpdEntries;	// Number of VPD entries		008-009
asm-ppc64/iSeries/ItVpdAreas.h:	u16	xSlicDmaEntries;	// Number of DMA entries		00A-00B
asm-ppc64/iSeries/ItVpdAreas.h:	u16	xSlicMaxLogicalProcs;	// Maximum logical processors		00C-00D
asm-ppc64/iSeries/ItVpdAreas.h:	u16	xSlicMaxPhysicalProcs;	// Maximum physical processors		00E-00F
asm-ppc64/iSeries/ItVpdAreas.h:	u16	xSlicDmaToksOffset;	// Offset into this of array		010-011
asm-ppc64/iSeries/ItVpdAreas.h:	u16	xSlicVpdAdrsOffset;	// Offset into this of array		012-013
asm-ppc64/iSeries/ItVpdAreas.h:	u16	xSlicDmaLensOffset;	// Offset into this of array		014-015
asm-ppc64/iSeries/ItVpdAreas.h:	u16	xSlicVpdLensOffset;	// Offset into this of array		016-017
asm-ppc64/iSeries/ItVpdAreas.h:	u16	xSlicMaxSlotLabels;	// Maximum number of slot labels	018-019
asm-ppc64/iSeries/ItVpdAreas.h:	u16	xSlicMaxLpQueues;	// Maximum number of LP Queues		01A-01B
asm-ppc64/iSeries/ItVpdAreas.h:	u8	xRsvd2[4];		// Reserved				01C-01F
asm-ppc64/iSeries/ItVpdAreas.h:	u64	xRsvd3[12];		// Reserved				020-07F
asm-ppc64/iSeries/ItVpdAreas.h:	u32	xPlicDmaLens[ItDmaMaxEntries];// Array of DMA lengths		080-0A7
asm-ppc64/iSeries/ItVpdAreas.h:	u32	xPlicDmaToks[ItDmaMaxEntries];// Array of DMA tokens		0A8-0CF
asm-ppc64/iSeries/ItVpdAreas.h:	u32	xSlicVpdLens[ItVpdMaxEntries];// Array of VPD lengths		0D0-12F
asm-ppc64/iSeries/ItVpdAreas.h:	void * xSlicVpdAdrs[ItVpdMaxEntries];// Array of VPD buffers	130-1EF
asm-ppc64/iSeries/ItLpRegSave.h: * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
asm-ppc64/iSeries/ItLpRegSave.h:	u32	xDesc;		// Eye catcher  "LpRS" ebcdic	000-003
asm-ppc64/iSeries/ItLpRegSave.h:	u16	xSize;		// Size of this class		004-005
asm-ppc64/iSeries/ItLpRegSave.h:	u8	xInUse;         // Area is live                 006-007
asm-ppc64/iSeries/ItLpRegSave.h:	u8	xRsvd1[9]; 	// Reserved			007-00F
asm-ppc64/iSeries/ItLpRegSave.h:	u8      xFixedRegSave[352]; // Fixed Register Save Area 010-16F 
asm-ppc64/iSeries/ItLpRegSave.h:	u32	xCTRL;		// Control Register		170-173
asm-ppc64/iSeries/ItLpRegSave.h:	u32	xDEC;		// Decrementer			174-177    
asm-ppc64/iSeries/ItLpRegSave.h:	u32	xFPSCR;		// FP Status and Control Reg	178-17B
asm-ppc64/iSeries/ItLpRegSave.h:	u32	xPVR;		// Processor Version Number	17C-17F
asm-ppc64/iSeries/ItLpRegSave.h:	u64	xMMCR0;		// Monitor Mode Control Reg 0	180-187
asm-ppc64/iSeries/ItLpRegSave.h:	u32	xPMC1;		// Perf Monitor Counter 1	188-18B
asm-ppc64/iSeries/ItLpRegSave.h:	u32	xPMC2;		// Perf Monitor Counter 2	18C-18F
asm-ppc64/iSeries/ItLpRegSave.h:	u32	xPMC3;		// Perf Monitor Counter 3	190-193
asm-ppc64/iSeries/ItLpRegSave.h:	u32	xPMC4;		// Perf Monitor Counter 4	194-197
asm-ppc64/iSeries/ItLpRegSave.h:	u32	xPIR;		// Processor ID Reg		198-19B
asm-ppc64/iSeries/ItLpRegSave.h:	u32	xMMCR1;		// Monitor Mode Control Reg 1	19C-19F
asm-ppc64/iSeries/ItLpRegSave.h:	u32	xMMCRA;		// Monitor Mode Control Reg A	1A0-1A3
asm-ppc64/iSeries/ItLpRegSave.h:	u32	xPMC5;		// Perf Monitor Counter 5	1A4-1A7
asm-ppc64/iSeries/ItLpRegSave.h:	u32	xPMC6;		// Perf Monitor Counter 6	1A8-1AB
asm-ppc64/iSeries/ItLpRegSave.h:	u32	xPMC7;		// Perf Monitor Counter 7	1AC-1AF
asm-ppc64/iSeries/ItLpRegSave.h:	u32	xPMC8;		// Perf Monitor Counter 8	1B0-1B3
asm-ppc64/iSeries/ItLpRegSave.h:	u32	xTSC;		// Thread Switch Control	1B4-1B7
asm-ppc64/iSeries/ItLpRegSave.h:	u32	xTST;		// Thread Switch Timeout	1B8-1BB
asm-ppc64/iSeries/ItLpRegSave.h:	u32	xRsvd;          // Reserved                     1BC-1BF
asm-ppc64/iSeries/ItLpRegSave.h:	u64	xACCR;		// Address Compare Control Reg	1C0-1C7
asm-ppc64/iSeries/ItLpRegSave.h:	u64	xIMR;		// Instruction Match Register	1C8-1CF    
asm-ppc64/iSeries/ItLpRegSave.h:	u64	xSDR1;		// Storage Description Reg 1	1D0-1D7    
asm-ppc64/iSeries/ItLpRegSave.h:	u64	xSPRG0;		// Special Purpose Reg General0	1D8-1DF
asm-ppc64/iSeries/ItLpRegSave.h:	u64	xSPRG1;		// Special Purpose Reg General1	1E0-1E7
asm-ppc64/iSeries/ItLpRegSave.h:	u64	xSPRG2;		// Special Purpose Reg General2	1E8-1EF
asm-ppc64/iSeries/ItLpRegSave.h:	u64	xSPRG3;		// Special Purpose Reg General3	1F0-1F7
asm-ppc64/iSeries/ItLpRegSave.h:	u64	xTB;		// Time Base Register		1F8-1FF
asm-ppc64/iSeries/ItLpRegSave.h:	u64	xFPR[32];	// Floating Point Registers	200-2FF
asm-ppc64/iSeries/ItLpRegSave.h:	u64	xMSR;		// Machine State Register  	300-307
asm-ppc64/iSeries/ItLpRegSave.h:	u64	xNIA;		// Next Instruction Address	308-30F
asm-ppc64/iSeries/ItLpRegSave.h:	u64	xDABR;		// Data Address Breakpoint Reg	310-317
asm-ppc64/iSeries/ItLpRegSave.h:	u64	xIABR;		// Inst Address Breakpoint Reg	318-31F
asm-ppc64/iSeries/ItLpRegSave.h:	u64	xHID0;		// HW Implementation Dependent0	320-327
asm-ppc64/iSeries/ItLpRegSave.h:	u64	xHID4;		// HW Implementation Dependent4	328-32F
asm-ppc64/iSeries/ItLpRegSave.h:	u64	xSCOMd;		// SCON Data Reg (SPRG4)       	330-337
asm-ppc64/iSeries/ItLpRegSave.h:	u64	xSCOMc;		// SCON Command Reg (SPRG5)    	338-33F
asm-ppc64/iSeries/ItLpRegSave.h:	u64	xSDAR;		// Sample Data Address Register	340-347
asm-ppc64/iSeries/ItLpRegSave.h:	u64	xSIAR;		// Sample Inst Address Register	348-34F
asm-ppc64/iSeries/ItLpRegSave.h:	u8	xRsvd3[176];	// Reserved			350-3FF
asm-ppc64/iSeries/HvCallEvent.h: * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
asm-ppc64/iSeries/HvCallEvent.h://-------------------------------------------------------------------
asm-ppc64/iSeries/HvCallEvent.h://-------------------------------------------------------------------
asm-ppc64/iSeries/HvCallEvent.h://-------------------------------------------------------------------
asm-ppc64/iSeries/HvCallEvent.h://-------------------------------------------------------------------
asm-ppc64/iSeries/HvCallEvent.h://-------------------------------------------------------------------
asm-ppc64/iSeries/HvCallEvent.h://-------------------------------------------------------------------
asm-ppc64/iSeries/HvCallEvent.h:	// getPaca()->adjustHmtForNoOfSpinLocksHeld();
asm-ppc64/iSeries/HvCallEvent.h:	// getPaca()->adjustHmtForNoOfSpinLocksHeld();
asm-ppc64/iSeries/HvCallEvent.h:	// getPaca()->adjustHmtForNoOfSpinLocksHeld();
asm-ppc64/iSeries/HvCallEvent.h:	// getPaca()->adjustHmtForNoOfSpinLocksHeld();
asm-ppc64/iSeries/HvCallEvent.h:	// getPaca()->adjustHmtForNoOfSpinLocksHeld();
asm-ppc64/iSeries/HvCallEvent.h:	// getPaca()->adjustHmtForNoOfSpinLocksHeld();
asm-ppc64/iSeries/HvCallEvent.h:	// getPaca()->adjustHmtForNoOfSpinLocksHeld();
asm-ppc64/iSeries/HvCallEvent.h:	// getPaca()->adjustHmtForNoOfSpinLocksHeld();
asm-ppc64/iSeries/HvCallEvent.h:	// getPaca()->adjustHmtForNoOfSpinLocksHeld();
asm-ppc64/iSeries/HvCallEvent.h:	// getPaca()->adjustHmtForNoOfSpinLocksHeld();
asm-ppc64/iSeries/HvCallEvent.h:	// getPaca()->adjustHmtForNoOfSpinLocksHeld();
asm-ppc64/iSeries/HvCallEvent.h:	// getPaca()->adjustHmtForNoOfSpinLocksHeld();
asm-ppc64/iSeries/HvCallEvent.h:	// getPaca()->adjustHmtForNoOfSpinLocksHeld();
asm-ppc64/iSeries/HvCallEvent.h:	// getPaca()->adjustHmtForNoOfSpinLocksHeld();
asm-ppc64/iSeries/HvCallEvent.h:	// getPaca()->adjustHmtForNoOfSpinLocksHeld();
asm-ppc64/iSeries/ItLpQueue.h: * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
asm-ppc64/iSeries/ItLpQueue.h:// The first 16-bytes are known by both the OS and PLIC.  The remainder of the
asm-ppc64/iSeries/ItLpQueue.h:	u8	xSlicRsvd[3];		// 0x29-2b
asm-ppc64/iSeries/ItLpQueue.h:	u64	xLpIntCountByType[9];	// 0x38-0x7F Event counts by type
asm-ppc64/iSeries/ItLpNaca.h: * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
asm-ppc64/iSeries/ItLpNaca.h:// CACHE_LINE_1 0x0000 - 0x007F Contains read-only data
asm-ppc64/iSeries/ItLpNaca.h:	u32	xDesc;			// Eye catcher			x00-x03
asm-ppc64/iSeries/ItLpNaca.h:	u16	xSize;			// Size of this class		x04-x05
asm-ppc64/iSeries/ItLpNaca.h:	u16	xIntHdlrOffset;		// Offset to IntHdlr array	x06-x07
asm-ppc64/iSeries/ItLpNaca.h:	u8	xMaxIntHdlrEntries;	// Number of entries in array	x08-x08
asm-ppc64/iSeries/ItLpNaca.h:	u8	xPrimaryLpIndex;	// LP Index of Primary		x09-x09
asm-ppc64/iSeries/ItLpNaca.h:	u8	xServiceLpIndex;	// LP Ind of Service Focal Pointx0A-x0A
asm-ppc64/iSeries/ItLpNaca.h:	u8	xLpIndex;		// LP Index			x0B-x0B
asm-ppc64/iSeries/ItLpNaca.h:	u16	xMaxLpQueues;		// Number of allocated queues	x0C-x0D
asm-ppc64/iSeries/ItLpNaca.h:	u16	xLpQueueOffset;		// Offset to start of LP queues	x0E-x0F
asm-ppc64/iSeries/ItLpNaca.h:	u8	xPirEnvironMode:8;	// Piranha or hardware		x10-x10
asm-ppc64/iSeries/ItLpNaca.h:	u8	xPirConsoleMode:8;	// Piranha console indicator	x11-x11
asm-ppc64/iSeries/ItLpNaca.h:	u8	xPirDasdMode:8;		// Piranha dasd indicator	x12-x12
asm-ppc64/iSeries/ItLpNaca.h:	u8	xRsvd1_0[5];		// Reserved for Piranha related	x13-x17
asm-ppc64/iSeries/ItLpNaca.h:	u8	xLparInstalled:1;	// Is LPAR installed on system	x18-x1F
asm-ppc64/iSeries/ItLpNaca.h:	u16	xRsvd1_3;		// Reserved			x20-x21
asm-ppc64/iSeries/ItLpNaca.h:	u16	xPlicVrmIndex;		// VRM index of PLIC		x22-x23
asm-ppc64/iSeries/ItLpNaca.h:	u16	xMinSupportedSlicVrmInd;// Min supported OS VRM index	x24-x25
asm-ppc64/iSeries/ItLpNaca.h:	u16	xMinCompatableSlicVrmInd;// Min compatable OS VRM index x26-x27
asm-ppc64/iSeries/ItLpNaca.h:	u64	xLoadAreaAddr;		// ER address of load area	x28-x2F
asm-ppc64/iSeries/ItLpNaca.h:	u32	xLoadAreaChunks;	// Chunks for the load area	x30-x33
asm-ppc64/iSeries/ItLpNaca.h:	u32	xPaseSysCallCRMask;	// Mask used to test CR before  x34-x37
asm-ppc64/iSeries/ItLpNaca.h:	u64	xSlicSegmentTablePtr;   // Pointer to Slic seg table.   x38-x3f
asm-ppc64/iSeries/ItLpNaca.h:	u8	xRsvd1_4[64];		//         			x40-x7F 
asm-ppc64/iSeries/ItLpNaca.h:// CACHE_LINE_2 0x0080 - 0x00FF Contains local read-write data
asm-ppc64/iSeries/ItLpNaca.h:	u8	xRsvd2_0[128];		// Reserved			x00-x7F
asm-ppc64/iSeries/ItLpNaca.h:// CACHE_LINE_3-6 0x0100 - 0x02FF Contains LP Queue indicators
asm-ppc64/iSeries/ItLpNaca.h:	u8	xOldLpQueue[128];	// LP Queue needed for v4r4	100-17F
asm-ppc64/iSeries/ItLpNaca.h:	u8	xRsvd3_0[384];		// Reserved			180-2FF
asm-ppc64/iSeries/ItLpNaca.h:// CACHE_LINE_7-8 0x0300 - 0x03FF Contains the address of the OS interrupt
asm-ppc64/iSeries/ItLpNaca.h:	u64	xInterruptHdlr[32];	// Interrupt handlers		300-x3FF
asm-ppc64/iSeries/HvLpEvent.h: * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
asm-ppc64/iSeries/HvLpEvent.h:	u8	xValid:1;		// Indicates a valid request	x00-x00
asm-ppc64/iSeries/HvLpEvent.h:	struct HvEventFlags xFlags;	// Event flags			x00-x00
asm-ppc64/iSeries/HvLpEvent.h:	u8	xType;			// Type of message		x01-x01
asm-ppc64/iSeries/HvLpEvent.h:	u16	xSubtype;		// Subtype for event		x02-x03
asm-ppc64/iSeries/HvLpEvent.h:	u8	xSourceLp;		// Source LP			x04-x04
asm-ppc64/iSeries/HvLpEvent.h:	u8	xTargetLp;		// Target LP			x05-x05
asm-ppc64/iSeries/HvLpEvent.h:	u8	xSizeMinus1;		// Size of Derived class - 1	x06-x06
asm-ppc64/iSeries/HvLpEvent.h:	u8	xRc;			// RC for Ack flows		x07-x07
asm-ppc64/iSeries/HvLpEvent.h:	u16	xSourceInstanceId;	// Source sides instance id	x08-x09
asm-ppc64/iSeries/HvLpEvent.h:	u16	xTargetInstanceId;	// Target sides instance id	x0A-x0B
asm-ppc64/iSeries/HvLpEvent.h:		u32	xSubtypeData;	// Data usable by the subtype	x0C-x0F
asm-ppc64/iSeries/HvLpEvent.h:	u64	xCorrelationToken;	// Unique value for source/type x10-x17
asm-ppc64/iSeries/ItLpPaca.h: * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
asm-ppc64/iSeries/ItLpPaca.h://----------------------------------------------------------------------------
asm-ppc64/iSeries/ItLpPaca.h:// CACHE_LINE_1 0x0000 - 0x007F Contains read-only data
asm-ppc64/iSeries/ItLpPaca.h:	u32	xDesc;			// Eye catcher 0xD397D781	x00-x03
asm-ppc64/iSeries/ItLpPaca.h:	u16	xSize;			// Size of this struct		x04-x05
asm-ppc64/iSeries/ItLpPaca.h:	u16	xRsvd1_0;		// Reserved			x06-x07
asm-ppc64/iSeries/ItLpPaca.h:	u16	xRsvd1_1:14;		// Reserved			x08-x09
asm-ppc64/iSeries/ItLpPaca.h:	volatile u8 xDynProcStatus:8;	// Dynamic Status of this proc	x0A-x0A
asm-ppc64/iSeries/ItLpPaca.h:	u8	xSecondaryThreadCnt;	// Secondary thread count	x0B-x0B
asm-ppc64/iSeries/ItLpPaca.h:	volatile u16 xDynHvPhysicalProcIndex;// Dynamic HV Physical Proc Index0C-x0D
asm-ppc64/iSeries/ItLpPaca.h:	volatile u16 xDynHvLogicalProcIndex;// Dynamic HV Logical Proc Indexx0E-x0F
asm-ppc64/iSeries/ItLpPaca.h:	u32	xDecrVal;   		// Value for Decr programming 	x10-x13
asm-ppc64/iSeries/ItLpPaca.h:	u32	xPMCVal;       		// Value for PMC regs         	x14-x17
asm-ppc64/iSeries/ItLpPaca.h:	volatile u32 xDynHwNodeId;	// Dynamic Hardware Node id	x18-x1B
asm-ppc64/iSeries/ItLpPaca.h:	volatile u32 xDynHwProcId;	// Dynamic Hardware Proc Id	x1C-x1F
asm-ppc64/iSeries/ItLpPaca.h:	volatile u32 xDynPIR;		// Dynamic ProcIdReg value	x20-x23
asm-ppc64/iSeries/ItLpPaca.h:	u32	xDseiData;           	// DSEI data                  	x24-x27
asm-ppc64/iSeries/ItLpPaca.h:	u64	xSPRG3;               	// SPRG3 value                	x28-x2F
asm-ppc64/iSeries/ItLpPaca.h:	u8	xRsvd1_3[80];		// Reserved			x30-x7F
asm-ppc64/iSeries/ItLpPaca.h:// CACHE_LINE_2 0x0080 - 0x00FF Contains local read-write data
asm-ppc64/iSeries/ItLpPaca.h:			u16	xRsvd;		// Reserved - cleared by #mpasmbl
asm-ppc64/iSeries/ItLpPaca.h:	// 4-bytes of this Dword is upto SLIC - PLIC just checks whether the 
asm-ppc64/iSeries/ItLpPaca.h:	// entire Dword is zero or not.  A non-zero value in the low order 
asm-ppc64/iSeries/ItLpPaca.h:	// 2-bytes will result in SLIC being granted the highest thread 
asm-ppc64/iSeries/ItLpPaca.h:	u64     xSavedSrr0;             // Saved SRR0                   x10-x17
asm-ppc64/iSeries/ItLpPaca.h:	u64     xSavedSrr1;             // Saved SRR1                   x18-x1F
asm-ppc64/iSeries/ItLpPaca.h:	u64     xSavedGpr3;             // Saved GPR3                   x20-x27
asm-ppc64/iSeries/ItLpPaca.h:	u64     xSavedGpr4;             // Saved GPR4                   x28-x2F
asm-ppc64/iSeries/ItLpPaca.h:	u64     xSavedGpr5;             // Saved GPR5                   x30-x37
asm-ppc64/iSeries/ItLpPaca.h:	u8	xRsvd2_1;		// Reserved			x38-x38
asm-ppc64/iSeries/ItLpPaca.h:	u8      xCpuCtlsTaskAttributes; // Task attributes for cpuctls  x39-x39
asm-ppc64/iSeries/ItLpPaca.h:	u8      xFPRegsInUse;           // FP regs in use               x3A-x3A
asm-ppc64/iSeries/ItLpPaca.h:	u8      xPMCRegsInUse;          // PMC regs in use              x3B-x3B
asm-ppc64/iSeries/ItLpPaca.h:	volatile u32  xSavedDecr;	// Saved Decr Value             x3C-x3F
asm-ppc64/iSeries/ItLpPaca.h:	volatile u64  xEmulatedTimeBase;// Emulated TB for this thread  x40-x47
asm-ppc64/iSeries/ItLpPaca.h:	volatile u64  xCurPLICLatency;	// Unaccounted PLIC latency     x48-x4F
asm-ppc64/iSeries/ItLpPaca.h:	u64     xTotPLICLatency;        // Accumulated PLIC latency     x50-x57   
asm-ppc64/iSeries/ItLpPaca.h:	u64     xWaitStateCycles;       // Wait cycles for this proc    x58-x5F
asm-ppc64/iSeries/ItLpPaca.h:	u64     xEndOfQuantum;          // TB at end of quantum         x60-x67
asm-ppc64/iSeries/ItLpPaca.h:	u64     xPDCSavedSPRG1;         // Saved SPRG1 for PMC int      x68-x6F
asm-ppc64/iSeries/ItLpPaca.h:	u64     xPDCSavedSRR0;          // Saved SRR0 for PMC int       x70-x77
asm-ppc64/iSeries/ItLpPaca.h:	volatile u32 xVirtualDecr;	// Virtual DECR for shared procsx78-x7B
asm-ppc64/iSeries/ItLpPaca.h:	u16     xSLBCount;              // # of SLBs to maintain        x7C-x7D
asm-ppc64/iSeries/ItLpPaca.h:// CACHE_LINE_3 0x0100 - 0x007F: This line is shared with other processors
asm-ppc64/iSeries/ItLpPaca.h:	volatile u32 xYieldCount;	// PLIC increments each dispatchx00-x03
asm-ppc64/iSeries/ItLpPaca.h:	u8	xRsvd3_0[124];		// Reserved                     x04-x7F         
asm-ppc64/iSeries/ItLpPaca.h:// CACHE_LINE_4-5 0x0100 - 0x01FF Contains PMC interrupt data
asm-ppc64/iSeries/ItLpPaca.h:	u8      xPmcSaveArea[256];	// PMC interrupt Area           x00-xFF
asm-ppc64/iSeries/iSeries_FlightRecorder.h:/* Boston, MA  02111-1307  USA                                          */
asm-ppc64/iSeries/iSeries_FlightRecorder.h:/*          PciFr->logEntry(PciFr,"In Main");                           */
asm-ppc64/iSeries/iSeries_FlightRecorder.h:#define ISERIES_PCI_FR(buffer)      PciFr->logEntry(PciFr,buffer);
asm-ppc64/iSeries/iSeries_FlightRecorder.h:#define ISERIES_PCI_FR_TIME(buffer) PciFr->logTime(PciFr,buffer);
asm-ppc64/iSeries/iSeries_FlightRecorder.h:#define ISERIES_PCI_FR_DATE(buffer) PciFr->logDate(PciFr,buffer);
asm-ppc64/iSeries/HvTypes.h: * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
asm-ppc64/iSeries/HvTypes.h://-------------------------------------------------------------------
asm-ppc64/iSeries/HvTypes.h://-------------------------------------------------------------------
asm-ppc64/iSeries/HvTypes.h://--------------------------------------------------------------------
asm-ppc64/iSeries/HvTypes.h:// Enums for the sub-components under PLIC
asm-ppc64/iSeries/HvTypes.h://--------------------------------------------------------------------
asm-ppc64/iSeries/iSeries_proc.h: * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
asm-ppc64/iSeries/mf_proc.h: * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
asm-ppc64/iSeries/HvCall.h: * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
asm-ppc64/iSeries/HvCall.h://-------------------------------------------------------------------
asm-ppc64/iSeries/HvCall.h://-------------------------------------------------------------------
asm-ppc64/iSeries/HvCall.h://-------------------------------------------------------------------
asm-ppc64/iSeries/HvCall.h://-------------------------------------------------------------------
asm-ppc64/iSeries/HvCall.h:	/* Ignore any error return codes - most likely means that the target value for the
asm-ppc64/iSeries/HvCall.h:	HvCall1( HvCallBaseSendIPI, targetPaca->xPacaIndex );
asm-ppc64/iSeries/HvCallCfg.h: * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
asm-ppc64/iSeries/HvCallCfg.h://-------------------------------------------------------------------
asm-ppc64/iSeries/HvCallCfg.h://-------------------------------------------------------------------
asm-ppc64/iSeries/HvCallCfg.h://-------------------------------------------------------------------------------------
asm-ppc64/iSeries/HvCallCfg.h://-------------------------------------------------------------------------------------
asm-ppc64/iSeries/HvCallCfg.h:	// getPaca()->adjustHmtForNoOfSpinLocksHeld();
asm-ppc64/iSeries/HvCallCfg.h:	// getPaca()->adjustHmtForNoOfSpinLocksHeld();
asm-ppc64/iSeries/HvCallCfg.h:	// getPaca()->adjustHmtForNoOfSpinLocksHeld();
asm-ppc64/iSeries/HvCallCfg.h:	// getPaca()->adjustHmtForNoOfSpinLocksHeld();
asm-ppc64/iSeries/HvCallCfg.h:	// getPaca()->adjustHmtForNoOfSpinLocksHeld();
asm-ppc64/iSeries/HvCallCfg.h:	// hypervisors will return -1
asm-ppc64/iSeries/HvCallCfg.h:	if(retVal == -1)
asm-ppc64/iSeries/HvCallCfg.h:	// getPaca()->adjustHmtForNoOfSpinLocksHeld();
asm-ppc64/iSeries/HvCallCfg.h:	// getPaca()->adjustHmtForNoOfSpinLocksHeld();
asm-ppc64/iSeries/HvCallCfg.h:	// getPaca()->adjustHmtForNoOfSpinLocksHeld();
asm-ppc64/iSeries/HvCallCfg.h:	// NOTE: This function was added in v5r1 so older hypervisors will return a -1 value
asm-ppc64/iSeries/HvCallCfg.h:	// getPaca()->adjustHmtForNoOfSpinLocksHeld();
asm-ppc64/iSeries/HvCallCfg.h:	// getPaca()->adjustHmtForNoOfSpinLocksHeld();
asm-ppc64/iSeries/HvCallCfg.h:	// getPaca()->adjustHmtForNoOfSpinLocksHeld();
asm-ppc64/iSeries/HvCallCfg.h:	// getPaca()->adjustHmtForNoOfSpinLocksHeld();
asm-ppc64/iSeries/HvCallCfg.h:	// getPaca()->adjustHmtForNoOfSpinLocksHeld();
asm-ppc64/iSeries/HvCallCfg.h:	// getPaca()->adjustHmtForNoOfSpinLocksHeld();
asm-ppc64/iSeries/HvCallCfg.h:	// getPaca()->adjustHmtForNoOfSpinLocksHeld();
asm-ppc64/iSeries/HvCallCfg.h:	// getPaca()->adjustHmtForNoOfSpinLocksHeld();
asm-ppc64/iSeries/HvCallCfg.h:	// getPaca()->adjustHmtForNoOfSpinLocksHeld();
asm-ppc64/iSeries/HvCallHpt.h: * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
asm-ppc64/iSeries/HvCallHpt.h://-------------------------------------------------------------------
asm-ppc64/iSeries/HvCallHpt.h://-------------------------------------------------------------------
asm-ppc64/iSeries/HvCallHpt.h://-------------------------------------------------------------------
asm-ppc64/iSeries/HvCallHpt.h://-------------------------------------------------------------------
asm-ppc64/iSeries/HvCallHpt.h://-----------------------------------------------------------------------------
asm-ppc64/iSeries/HvCallHpt.h://-----------------------------------------------------------------------------
asm-ppc64/iSeries/HvCallHpt.h:	// getPaca()->adjustHmtForNoOfSpinLocksHeld();
asm-ppc64/iSeries/HvCallHpt.h:	// getPaca()->adjustHmtForNoOfSpinLocksHeld();
asm-ppc64/iSeries/HvCallHpt.h:	// getPaca()->adjustHmtForNoOfSpinLocksHeld();
asm-ppc64/iSeries/HvCallHpt.h:	// getPaca()->adjustHmtForNoOfSpinLocksHeld();
asm-ppc64/iSeries/HvCallHpt.h:	// getPaca()->adjustHmtForNoOfSpinLocksHeld();
asm-ppc64/iSeries/HvCallHpt.h:	// getPaca()->adjustHmtForNoOfSpinLocksHeld();
asm-ppc64/iSeries/HvCallHpt.h:	// getPaca()->adjustHmtForNoOfSpinLocksHeld();
asm-ppc64/iSeries/HvCallHpt.h:	// getPaca()->adjustHmtForNoOfSpinLocksHeld();
asm-ppc64/iSeries/HvCallHpt.h:	// getPaca()->adjustHmtForNoOfSpinLocksHeld();
asm-ppc64/iSeries/HvCallHpt.h:	// getPaca()->adjustHmtForNoOfSpinLocksHeld();
asm-ppc64/iSeries/iSeries_VpdInfo.h:/* Boston, MA  02111-1307  USA                                          */
asm-ppc64/iSeries/HvCallPci.h:/* Boston, MA  02111-1307  USA                                          */
asm-ppc64/iSeries/HvCallPci.h://-------------------------------------------------------------------
asm-ppc64/iSeries/HvCallPci.h://-------------------------------------------------------------------
asm-ppc64/iSeries/HvCallPci.h://-------------------------------------------------------------------
asm-ppc64/iSeries/HvCallPci.h://-------------------------------------------------------------------
asm-ppc64/iSeries/HvCallPci.h://-------------------------------------------------------------------
asm-ppc64/iSeries/HvCallPci.h://-------------------------------------------------------------------
asm-ppc64/iSeries/HvCallPci.h://-----------------------------------------------------------------------------
asm-ppc64/iSeries/HvCallPci.h://-----------------------------------------------------------------------------
asm-ppc64/iSeries/HvCallPci.h:struct HvCallPci_DsaAddr { // make sure this struct size is 64-bits total
asm-ppc64/iSeries/HvCallPci.h:	// getPaca()->adjustHmtForNoOfSpinLocksHeld();
asm-ppc64/iSeries/HvCallPci.h:	// getPaca()->adjustHmtForNoOfSpinLocksHeld();
asm-ppc64/iSeries/HvCallPci.h:	// getPaca()->adjustHmtForNoOfSpinLocksHeld();
asm-ppc64/iSeries/HvCallPci.h:	// getPaca()->adjustHmtForNoOfSpinLocksHeld();
asm-ppc64/iSeries/HvCallPci.h:	// getPaca()->adjustHmtForNoOfSpinLocksHeld();
asm-ppc64/iSeries/HvCallPci.h:	// getPaca()->adjustHmtForNoOfSpinLocksHeld();
asm-ppc64/iSeries/HvCallPci.h:	// getPaca()->adjustHmtForNoOfSpinLocksHeld();
asm-ppc64/iSeries/HvCallPci.h:	// getPaca()->adjustHmtForNoOfSpinLocksHeld();
asm-ppc64/iSeries/HvCallPci.h:	// getPaca()->adjustHmtForNoOfSpinLocksHeld();
asm-ppc64/iSeries/HvCallPci.h:	// getPaca()->adjustHmtForNoOfSpinLocksHeld();
asm-ppc64/iSeries/HvCallPci.h:	// getPaca()->adjustHmtForNoOfSpinLocksHeld();
asm-ppc64/iSeries/HvCallPci.h:	// getPaca()->adjustHmtForNoOfSpinLocksHeld();
asm-ppc64/iSeries/HvCallPci.h:	// getPaca()->adjustHmtForNoOfSpinLocksHeld();
asm-ppc64/iSeries/HvCallPci.h:	// getPaca()->adjustHmtForNoOfSpinLocksHeld();
asm-ppc64/iSeries/HvCallPci.h:	// getPaca()->adjustHmtForNoOfSpinLocksHeld();
asm-ppc64/iSeries/HvCallPci.h:	// getPaca()->adjustHmtForNoOfSpinLocksHeld();
asm-ppc64/iSeries/HvCallPci.h:	// getPaca()->adjustHmtForNoOfSpinLocksHeld();
asm-ppc64/iSeries/HvCallPci.h:	// getPaca()->adjustHmtForNoOfSpinLocksHeld();
asm-ppc64/iSeries/HvCallPci.h:	// getPaca()->adjustHmtForNoOfSpinLocksHeld();
asm-ppc64/iSeries/HvCallPci.h:	// getPaca()->adjustHmtForNoOfSpinLocksHeld();
asm-ppc64/iSeries/HvCallPci.h:	// getPaca()->adjustHmtForNoOfSpinLocksHeld();
asm-ppc64/iSeries/HvCallPci.h:	// getPaca()->adjustHmtForNoOfSpinLocksHeld();
asm-ppc64/iSeries/HvCallPci.h:	// getPaca()->adjustHmtForNoOfSpinLocksHeld();
asm-ppc64/iSeries/HvCallPci.h:	// getPaca()->adjustHmtForNoOfSpinLocksHeld();
asm-ppc64/iSeries/HvCallPci.h:	if (xRc == -1)
asm-ppc64/iSeries/HvCallPci.h:		xRetSize = -1;
asm-ppc64/iSeries/HvCallPci.h:	// getPaca()->adjustHmtForNoOfSpinLocksHeld();
asm-ppc64/iSeries/HvCallPci.h:	if (xRc == -1)
asm-ppc64/iSeries/HvCallPci.h:		xRetSize = -1;
asm-ppc64/iSeries/IoHriProcessorVpd.h: * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
asm-ppc64/iSeries/IoHriProcessorVpd.h:	u8	xFormat;		// VPD format indicator		x00-x00
asm-ppc64/iSeries/IoHriProcessorVpd.h:	u8	xProcStatus:8;		// Processor State		x01-x01
asm-ppc64/iSeries/IoHriProcessorVpd.h:	u8	xSecondaryThreadCount;	// Secondary thread cnt		x02-x02
asm-ppc64/iSeries/IoHriProcessorVpd.h:	u8	xSrcType:1;		// Src Type			x03-x03
asm-ppc64/iSeries/IoHriProcessorVpd.h:	u16	xHvPhysicalProcIndex;	// Hypervisor physical proc index04-x05
asm-ppc64/iSeries/IoHriProcessorVpd.h:	u16	xRsvd2;			// Reserved			x06-x07
asm-ppc64/iSeries/IoHriProcessorVpd.h:	u32	xHwNodeId;		// Hardware node id		x08-x0B
asm-ppc64/iSeries/IoHriProcessorVpd.h:	u32	xHwProcId;		// Hardware processor id	x0C-x0F
asm-ppc64/iSeries/IoHriProcessorVpd.h:	u32	xTypeNum;		// Card Type/CCIN number	x10-x13
asm-ppc64/iSeries/IoHriProcessorVpd.h:	u32	xModelNum;		// Model/Feature number		x14-x17
asm-ppc64/iSeries/IoHriProcessorVpd.h:	u64	xSerialNum;		// Serial number		x18-x1F
asm-ppc64/iSeries/IoHriProcessorVpd.h:	char xPartNum[12];		// Book Part or FPU number	x20-x2B
asm-ppc64/iSeries/IoHriProcessorVpd.h:	char xMfgID[4];			// Manufacturing ID		x2C-x2F
asm-ppc64/iSeries/IoHriProcessorVpd.h:	u32	xProcFreq;		// Processor Frequency		x30-x33
asm-ppc64/iSeries/IoHriProcessorVpd.h:	u32	xTimeBaseFreq;		// Time Base Frequency		x34-x37
asm-ppc64/iSeries/IoHriProcessorVpd.h:	u32	xChipEcLevel;		// Chip EC Levels		x38-x3B
asm-ppc64/iSeries/IoHriProcessorVpd.h:	u32	xProcIdReg;		// PIR SPR value		x3C-x3F
asm-ppc64/iSeries/IoHriProcessorVpd.h:	u32	xPVR;			// PVR value			x40-x43
asm-ppc64/iSeries/IoHriProcessorVpd.h:	u8	xRsvd3[12];		// Reserved			x44-x4F
asm-ppc64/iSeries/IoHriProcessorVpd.h:	u32	xInstCacheSize;		// Instruction cache size in KB	x50-x53
asm-ppc64/iSeries/IoHriProcessorVpd.h:	u32	xInstBlockSize;		// Instruction cache block size	x54-x57
asm-ppc64/iSeries/IoHriProcessorVpd.h:	u32	xDataCacheOperandSize;	// Data cache operand size	x58-x5B
asm-ppc64/iSeries/IoHriProcessorVpd.h:	u32	xInstCacheOperandSize;	// Inst cache operand size	x5C-x5F
asm-ppc64/iSeries/IoHriProcessorVpd.h:	u32	xDataL1CacheSizeKB;	// L1 data cache size in KB	x60-x63
asm-ppc64/iSeries/IoHriProcessorVpd.h:	u32	xDataL1CacheLineSize;	// L1 data cache block size	x64-x67
asm-ppc64/iSeries/IoHriProcessorVpd.h:	u64	xRsvd4;			// Reserved			x68-x6F
asm-ppc64/iSeries/IoHriProcessorVpd.h:	u32	xDataL2CacheSizeKB;	// L2 data cache size in KB	x70-x73
asm-ppc64/iSeries/IoHriProcessorVpd.h:	u32	xDataL2CacheLineSize;	// L2 data cache block size	x74-x77
asm-ppc64/iSeries/IoHriProcessorVpd.h:	u64	xRsvd5;			// Reserved			x78-x7F
asm-ppc64/iSeries/IoHriProcessorVpd.h:	u32	xDataL3CacheSizeKB;	// L3 data cache size in KB	x80-x83
asm-ppc64/iSeries/IoHriProcessorVpd.h:	u32	xDataL3CacheLineSize;	// L3 data cache block size	x84-x87
asm-ppc64/iSeries/IoHriProcessorVpd.h:	u64	xRsvd6;			// Reserved			x88-x8F
asm-ppc64/iSeries/IoHriProcessorVpd.h:	u64	xFruLabel;		// Card Location Label		x90-x97
asm-ppc64/iSeries/IoHriProcessorVpd.h:	u8	xSlotsOnCard;		// Slots on card (0=no slots)	x98-x98
asm-ppc64/iSeries/IoHriProcessorVpd.h:	u8	xPartLocFlag;		// Location flag (0-pluggable 1-imbedded) x99-x99
asm-ppc64/iSeries/IoHriProcessorVpd.h:	u16	xSlotMapIndex;		// Index in slot map table	x9A-x9B
asm-ppc64/iSeries/IoHriProcessorVpd.h:	u8	xSmartCardPortNo;	// Smart card port number	x9C-x9C
asm-ppc64/iSeries/IoHriProcessorVpd.h:	u8	xRsvd7;			// Reserved			x9D-x9D
asm-ppc64/iSeries/IoHriProcessorVpd.h:	u16	xFrameIdAndRackUnit;	// Frame ID and rack unit adr	x9E-x9F
asm-ppc64/iSeries/IoHriProcessorVpd.h:	u8	xRsvd8[24];		// Reserved			xA0-xB7
asm-ppc64/iSeries/IoHriProcessorVpd.h:	char xProcSrc[72];		// CSP format SRC		xB8-xFF
asm-ppc64/iSeries/LparData.h: * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
asm-ppc64/iSeries/HvLpConfig.h: * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
asm-ppc64/iSeries/HvLpConfig.h://-------------------------------------------------------------------
asm-ppc64/iSeries/HvLpConfig.h://-------------------------------------------------------------------
asm-ppc64/iSeries/HvLpConfig.h:	return HvCallCfg_getSystemPhysicalProcessors() * (/*getPaca()->getSecondaryThreadCount() +*/ 1);
asm-ppc64/iSeries/HvLpConfig.h:	return HvCallCfg_getPhysicalProcessors(HvLpConfig_getLpIndex(),HvCallCfg_Cur) * (/*getPaca()->getSecondaryThreadCount() +*/ 1);
asm-ppc64/iSeries/HvLpConfig.h:	return HvCallCfg_getPhysicalProcessors(HvLpConfig_getLpIndex(),HvCallCfg_Min) * (/*getPaca()->getSecondaryThreadCount() +*/ 1);
asm-ppc64/iSeries/HvLpConfig.h:	return HvCallCfg_getPhysicalProcessors(HvLpConfig_getLpIndex(),HvCallCfg_Max) * (/*getPaca()->getSecondaryThreadCount() +*/ 1);
asm-ppc64/iSeries/HvLpConfig.h:	return HvCallCfg_getPhysicalProcessors(HvLpConfig_getLpIndex(),HvCallCfg_Init) * (/*getPaca()->getSecondaryThreadCount() +*/ 1);
asm-ppc64/iSeries/iSeries_io.h:/* Boston, MA  02111-1307  USA                                          */
asm-ppc64/iSeries/IoHriMainStore.h: * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
asm-ppc64/iSeries/ItIplParmsReal.h: * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
asm-ppc64/iSeries/ItIplParmsReal.h://-------------------------------------------------------------------
asm-ppc64/iSeries/ItIplParmsReal.h://-------------------------------------------------------------------
asm-ppc64/iSeries/ItIplParmsReal.h:	u8	xFormat;		// Defines format of IplParms		x00-x00
asm-ppc64/iSeries/ItIplParmsReal.h:	u8	xRsvd01:6;		// Reserved				x01-x01
asm-ppc64/iSeries/ItIplParmsReal.h:	u8	xLsUaFormat;		// Format byte for UA			x02-x02
asm-ppc64/iSeries/ItIplParmsReal.h:	u8	xRsvd02;		// Reserved				x03-x03
asm-ppc64/iSeries/ItIplParmsReal.h:	u32	xLsUa;			// LS UA				x04-x07
asm-ppc64/iSeries/ItIplParmsReal.h:	u32	xUnusedLsLid;		// First OS LID to load			x08-x0B
asm-ppc64/iSeries/ItIplParmsReal.h:	u16	xLsBusNumber;		// LS Bus Number			x0C-x0D
asm-ppc64/iSeries/ItIplParmsReal.h:	u8	xLsCardAdr;		// LS Card Address			x0E-x0E
asm-ppc64/iSeries/ItIplParmsReal.h:	u8	xLsBoardAdr;		// LS Board Address			x0F-x0F
asm-ppc64/iSeries/ItIplParmsReal.h:	u32	xRsvd03;		// Reserved				x10-x13
asm-ppc64/iSeries/ItIplParmsReal.h:	u8	xSpcnPresent:1;		// SPCN present				x14-x14
asm-ppc64/iSeries/ItIplParmsReal.h:	u8	xRsvd05:4;		// Reserved				x15-x15
asm-ppc64/iSeries/ItIplParmsReal.h:	u8	xRsvd06:6;		// Reserved				x16-x16
asm-ppc64/iSeries/ItIplParmsReal.h:	u8	xHwIplType;		// Fast v slow v slow EC HW IPL		x17-x17
asm-ppc64/iSeries/ItIplParmsReal.h:	u16	xCpmEnabledIpl:1;	// CPM in effect when IPL initiated	x18-x19
asm-ppc64/iSeries/ItIplParmsReal.h:	u16	xIplSource:16;		// Ipl source				x1A-x1B
asm-ppc64/iSeries/ItIplParmsReal.h:	u8	xIplReason:8;		// Reason for this IPL			x1C-x1C
asm-ppc64/iSeries/ItIplParmsReal.h:	u8	xRsvd08;		// Reserved				x1D-x1D
asm-ppc64/iSeries/ItIplParmsReal.h:	u16	xRsvd09;		// Reserved				x1E-x1F
asm-ppc64/iSeries/ItIplParmsReal.h:	u16	xSysBoxType;		// System Box Type			x20-x21
asm-ppc64/iSeries/ItIplParmsReal.h:	u16	xSysProcType;		// System Processor Type		x22-x23
asm-ppc64/iSeries/ItIplParmsReal.h:	u32	xRsvd10;		// Reserved				x24-x27
asm-ppc64/iSeries/ItIplParmsReal.h:	u64	xRsvd11;		// Reserved				x28-x2F
asm-ppc64/iSeries/ItIplParmsReal.h:	u64	xRsvd12;		// Reserved				x30-x37
asm-ppc64/iSeries/ItIplParmsReal.h:	u64	xRsvd13;		// Reserved				x38-x3F
asm-ppc64/iSeries/ItExtVpdPanel.h: * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
asm-ppc64/iSeries/ItExtVpdPanel.h:/*-------------------------------------------------------------------
asm-ppc64/iSeries/ItExtVpdPanel.h: *------------------------------------------------------------------- 
asm-ppc64/iSeries/HvReleaseData.h: * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
asm-ppc64/iSeries/HvReleaseData.h://-----------------------------------------------------------------------------
asm-ppc64/iSeries/HvReleaseData.h://-----------------------------------------------------------------------------
asm-ppc64/iSeries/HvReleaseData.h:	u32	xDesc;			// Descriptor	"HvRD" ebcdic	x00-x03
asm-ppc64/iSeries/HvReleaseData.h:	u16	xSize;			// Size of this control block	x04-x05
asm-ppc64/iSeries/HvReleaseData.h:	u16	xVpdAreasPtrOffset;	// Offset in NACA of ItVpdAreas	x06-x07
asm-ppc64/iSeries/HvReleaseData.h:	struct  naca_struct * xSlicNacaAddr; // Virt addr of SLIC NACA  x08-x0F
asm-ppc64/iSeries/HvReleaseData.h:	u32	xMsNucDataOffset;	// Offset of Linux Mapping Data x10-x13
asm-ppc64/iSeries/HvReleaseData.h:	u32	xRsvd1;			// Reserved			x14-x17
asm-ppc64/iSeries/HvReleaseData.h:	u16	xAddressSize:1;		// 0 == 64-bit, 1 == 32-bit
asm-ppc64/iSeries/HvReleaseData.h:	u16	xRsvd2:12;		// Reserved			x18-x19
asm-ppc64/iSeries/HvReleaseData.h:	u16	xVrmIndex;		// VRM Index of OS image	x1A-x1B
asm-ppc64/iSeries/HvReleaseData.h:	u16	xMinSupportedPlicVrmIndex;// Min PLIC level  (soft)	x1C-x1D
asm-ppc64/iSeries/HvReleaseData.h:	u16	xMinCompatablePlicVrmIndex;// Min PLIC levelP (hard)	x1E-x1F
asm-ppc64/iSeries/HvReleaseData.h:	char	xVrmName[12];		// Displayable name  		x20-x2B
asm-ppc64/iSeries/HvReleaseData.h:	char	xRsvd3[20];		// Reserved			x2C-x3F
asm-ppc64/iSeries/LparMap.h: * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
asm-ppc64/iSeries/LparMap.h: * We will have the hypervisor set up the ESID->VSID mapping
asm-ppc64/iSeries/LparMap.h: * for the four kernel segments (C-F).  With shared processors,
asm-ppc64/iSeries/LparMap.h: * In 32-bit mode, the hypervisor will load all four of the
asm-ppc64/iSeries/LparMap.h: * segment registers (identified by the low-order four bits of the 
asm-ppc64/iSeries/LparMap.h: * Esid field.  In 64-bit mode, the hypervisor will load one SLB
asm-ppc64/iSeries/ItSpCommArea.h: * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
asm-ppc64/iSeries/ItSpCommArea.h:	u32	xDesc;			// Descriptor (only in new formats)	000-003
asm-ppc64/iSeries/ItSpCommArea.h:	u8	xFormat;		// Format (only in new formats)		004-004
asm-ppc64/iSeries/ItSpCommArea.h:	u8	xRsvd1[11];		// Reserved				005-00F
asm-ppc64/iSeries/ItSpCommArea.h:	u64	xRawTbAtIplStart;	// Raw HW TB value when IPL is started	010-017
asm-ppc64/iSeries/ItSpCommArea.h:	u64	xRawTodAtIplStart;	// Raw HW TOD value when IPL is started	018-01F
asm-ppc64/iSeries/ItSpCommArea.h:	u64	xBcdTimeAtIplStart;	// BCD time when IPL is started		020-027
asm-ppc64/iSeries/ItSpCommArea.h:	u64	xBcdTimeAtOsStart;	// BCD time when OS passed control	028-02F
asm-ppc64/iSeries/ItSpCommArea.h:	u8	xRsvd2[80];		// Reserved				030-07F
asm-ppc64/init.h:/* this is actually just common chrp/pmac code, not OF code -- Cort */
asm-ppc64/uaccess.h:#define get_fs()	(current->thread.fs)
asm-ppc64/uaccess.h:#define set_fs(val)	(current->thread.fs = (val))
asm-ppc64/uaccess.h:#define __user_ok(addr,size) (((size) <= TASK_SIZE)&&((addr) <= TASK_SIZE-(size)))
asm-ppc64/uaccess.h:	return access_ok(type,addr,size) ? 0 : -EFAULT;
asm-ppc64/uaccess.h: * These are the main single-value transfer routines.  They automatically
asm-ppc64/uaccess.h:	long __pu_err = -EFAULT;				\
asm-ppc64/uaccess.h:		: "r"(x), "b"(addr), "i"(-EFAULT), "0"(err))
asm-ppc64/uaccess.h:	long __gu_err = -EFAULT, __gu_val = 0;				\
asm-ppc64/uaccess.h:		: "b"(addr), "i"(-EFAULT), "0"(err))
asm-ppc64/uaccess.h:		over = (unsigned long)from + n - TASK_SIZE;
asm-ppc64/uaccess.h:		return __copy_tofrom_user(to, from, n - over) + over;
asm-ppc64/uaccess.h:		over = (unsigned long)to + n - TASK_SIZE;
asm-ppc64/uaccess.h:		return __copy_tofrom_user(to, from, n - over) + over;
asm-ppc64/uaccess.h:		unsigned long over = (unsigned long)addr + size - TASK_SIZE;
asm-ppc64/uaccess.h:		return __clear_user(addr, size - over) + over;
asm-ppc64/uaccess.h:	return -EFAULT;
asm-ppc64/uaccess.h:	unsigned long top = __kernel_ok? ~0UL: TASK_SIZE - 1;
asm-ppc64/kgdb.h: * external low-level support routines (ie macserial.c)
asm-ppc64/proc_pmc.h: * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
asm-ppc64/naca.h:	 * Cache line 1: 0x0000 - 0x007F
asm-ppc64/naca.h:	 * Kernel only data - undefined for user space
asm-ppc64/naca.h:	u32 dCacheL1LogLineSize;	/* L1 d-cache line size Log2 0x60 */
asm-ppc64/naca.h:	u32 dCacheL1LinesPerPage;	/* L1 d-cache lines / page   0x64 */
asm-ppc64/naca.h:	u32 iCacheL1LogLineSize;	/* L1 i-cache line size Log2 0x68 */
asm-ppc64/naca.h:	u32 iCacheL1LinesPerPage;	/* L1 i-cache lines / page   0x6c */
asm-ppc64/naca.h:	u8  resv0[7];                   /* Reserved           0x79 - 0x7F */
asm-ppc64/mman.h:#define MAP_GROWSDOWN	0x0100		/* stack-like segment */
asm-ppc64/mman.h:#define MADV_NORMAL	0x0		/* default page-in behavior */
asm-ppc64/mman.h:#define MADV_RANDOM	0x1		/* page-in minimum required */
asm-ppc64/mman.h:#define MADV_SEQUENTIAL	0x2		/* read-ahead aggressively */
asm-ppc64/mman.h:#define MADV_WILLNEED	0x3		/* pre-fault pages */
asm-ppc64/posix_types.h: * This file is generally used by user-level software, so you need to
asm-ppc64/posix_types.h:#define	__FD_SET(d, set)	((set)->fds_bits[__FDELT(d)] |= __FDMASK(d))
asm-ppc64/posix_types.h:#define	__FD_CLR(d, set)	((set)->fds_bits[__FDELT(d)] &= ~__FDMASK(d))
asm-ppc64/posix_types.h:#define	__FD_ISSET(d, set)	((set)->fds_bits[__FDELT(d)] & __FDMASK(d))
asm-ppc64/posix_types.h:	fdsetp->fds_bits[_tmp] |= (1UL<<_rem);
asm-ppc64/posix_types.h:	fdsetp->fds_bits[_tmp] &= ~(1UL<<_rem);
asm-ppc64/posix_types.h:	return (p->fds_bits[_tmp] & (1UL<<_rem)) != 0;
asm-ppc64/posix_types.h: * for a 256-bit fd_set)
asm-ppc64/posix_types.h:	unsigned long *tmp = (unsigned long *)p->fds_bits;
asm-ppc64/posix_types.h:		i--;
asm-ppc64/smplock.h:	if (task->lock_depth >= 0) \
asm-ppc64/smplock.h: * Re-acquire the kernel lock
asm-ppc64/smplock.h:	if (task->lock_depth >= 0) \
asm-ppc64/smplock.h:	if (!++current->lock_depth)
asm-ppc64/smplock.h:	if (--current->lock_depth < 0)
asm-ppc64/paca.h:/*-----------------------------------------------------------------------------
asm-ppc64/paca.h: *-----------------------------------------------------------------------------
asm-ppc64/paca.h: * that support hardware multi-threading, this is equal to twice the
asm-ppc64/paca.h: * CACHE_LINE_1 0x0000 - 0x007F
asm-ppc64/paca.h:	u8 resv1[4];			/*					0x7B-0x7F */
asm-ppc64/paca.h: * CACHE_LINE_2 0x0080 - 0x00FF
asm-ppc64/paca.h:	u8  rsvd2[128-5*8-1*4-1];	/*					0x68 */
asm-ppc64/paca.h: * CACHE_LINE_3 0x0100 - 0x017F
asm-ppc64/paca.h:  					/* xProcStart becomes non-zero. */
asm-ppc64/paca.h: * CACHE_LINE_4-8  0x0180 - 0x03FF Contains ItLpPaca
asm-ppc64/paca.h: * CACHE_LINE_9-16 0x0400 - 0x07FF Contains ItLpRegSave
asm-ppc64/paca.h: * CACHE_LINE_17-18 0x0800 - 0x0EFF Reserved
asm-ppc64/paca.h:	u8 rsvd5[256-16-sizeof(struct rtas_args)];
asm-ppc64/paca.h: * CACHE_LINE_19 - 20 Profile Data
asm-ppc64/paca.h:	u32 prof_len;			/* iSeries length of profile buffer -1	 */
asm-ppc64/paca.h:	u8  rsvd5c[256-8*26];
asm-ppc64/paca.h: * CACHE_LINE_20-30
asm-ppc64/paca.h:	u8  rsvd6[0x400 - 0x8];
asm-ppc64/paca.h: * CACHE_LINE_31 0x0F00 - 0x0F7F Exception stack
asm-ppc64/paca.h: * CACHE_LINE_32 0x0F80 - 0x0FFF Reserved
asm-ppc64/page.h:#define PAGE_MASK	(~(PAGE_SIZE-1))
asm-ppc64/page.h:#define PAGE_OFFSET_MASK (PAGE_SIZE-1)
asm-ppc64/page.h:#define REGION_MASK   (((1UL<<REGION_SIZE)-1UL)<<REGION_SHIFT)
asm-ppc64/page.h:                unsigned long off : OFFSET_SIZE;  /* intra-region offset */
asm-ppc64/page.h:	line_size = systemcfg->dCacheL1LineSize; 
asm-ppc64/page.h:	lines = naca->dCacheL1LinesPerPage;
asm-ppc64/page.h: * These are used to make use of C type-checking.  
asm-ppc64/page.h:	size = (size-1) >> (PAGE_SHIFT-1);
asm-ppc64/page.h:	order = -1;
asm-ppc64/page.h:#define __pa(x) ((unsigned long)(x)-PAGE_OFFSET)
asm-ppc64/page.h:/* align addr on a size boundry - adjust address up/down if needed */
asm-ppc64/page.h:#define _ALIGN_UP(addr,size)	(((addr)+((size)-1))&(~((size)-1)))
asm-ppc64/page.h:#define _ALIGN_DOWN(addr,size)	((addr)&(~((size)-1)))
asm-ppc64/page.h:/* align addr on a size boundry - adjust address up if needed */
asm-ppc64/page.h:/* This must match the -Ttext linker address            */
asm-ppc64/page.h:/* Given that physical addresses do not map 1-1 to absolute addresses, we
asm-ppc64/page.h: * initialized in prom.c.  -Peter
asm-ppc64/page.h:#define VALID_PAGE(page)    ((page - mem_map) < max_mapnr)
asm-ppc64/pci-bridge.h:/* This version handles the new Uni-N host bridge, the iobase is now
asm-ppc64/pci-bridge.h: * a per-device thing. I also added the memory base so PReP can
asm-ppc64/pci-bridge.h: * a physical address. In-kernel clients will use logical while the
asm-ppc64/pci-bridge.h:/* Returns the root-bridge number (Uni-N number) of a device */
asm-ppc64/pci-bridge.h: * It returns 0 if OK, -1 on error.
asm-ppc64/hdreg.h: *  linux/include/asm-ppc/hdreg.h
asm-ppc64/hdreg.h: *  Copyright (C) 1994-1996  Linus Torvalds & authors
asm-ppc64/prom.h:#define PTRRELOC(x)     ((typeof(x))((unsigned long)(x) - offset))
asm-ppc64/prom.h:	int	sense;		/* +ve/-ve logic, edge or level, etc. */
asm-ppc64/prom.h:	int	status;			/* Current device status (non-zero is bad) */
asm-ppc64/current.h:#define get_current()   ((struct task_struct *)(get_paca()->xCurrent))
asm-ppc64/types.h: * application is Linux specific so (user-) name space pollution is
asm-ppc64/types.h:/* PCI dma addresses are 32-bits wide.  Ignore PCI64 for now, since
asm-ppc64/sembuf.h: * - 2 miscellaneous 64-bit values
asm-ppc64/rtas.h:#define RTAS_UNKNOWN_SERVICE (-1)
asm-ppc64/rtas.h: * an RTAS token for the given string (e.g. "event-scan").
asm-ppc64/rtas.h: * may be safely used for one-shot calls to RTAS.
asm-ppc64/rtas.h:/* event-scan returns */
asm-ppc64/rtas.h:#define FLASH_BLOCKS_PER_NODE ((PAGE_SIZE - 16) / sizeof(struct flash_block))
asm-ppc64/rtas.h:#define ERR_TYPE_RTAS_LOG	0x2	/* from rtas event-scan */
asm-ppc64/rtas.h:#define LOG_NUMBER_MASK		(LOG_NUMBER-1)
asm-ppc64/system.h: * loads and stores to non-cacheable memory (e.g. I/O devices).
asm-ppc64/system.h:2:	bne- 1b"
asm-ppc64/system.h:2:	bne- 1b"
asm-ppc64/system.h:	bne-	2f\n\
asm-ppc64/system.h:	bne-	1b"
asm-ppc64/system.h:	bne-	2f\n\
asm-ppc64/system.h:	bne-	1b"
asm-ppc64/stat.h:	long st_blocks;			/* Number 512-byte blocks allocated. */
asm-ppc64/time.h:	if (lpaca->xLpPaca.xSharedProc) {
asm-ppc64/time.h:		lpaca->xLpPaca.xVirtualDecr = val;
asm-ppc64/time.h:		lpaca->xLpPaca.xSavedDecr = cur_dec;
asm-ppc64/time.h:	return get_tb() - tstamp;
asm-ppc64/checksum.h: * of 32-bit words and is always >= 5.
asm-ppc64/checksum.h: * computes the checksum of the TCP/UDP pseudo-header
asm-ppc64/checksum.h: * returns a 16-bit checksum, already complemented
asm-ppc64/checksum.h: * and adds in "sum" (32-bit)
asm-ppc64/checksum.h: * returns a 32-bit number suitable for feeding into itself
asm-ppc64/checksum.h: * it's best to have buff aligned on a 32-bit boundary
asm-ppc64/checksum.h: * turns a 32-bit partial checksum (e.g. from csum_partial) into a
asm-ppc64/checksum.h: * 1's complement 16-bit checksum.
asm-ppc64/checksum.h:	/* swap the two 16-bit halves of sum */
asm-ppc64/checksum.h:	/* if there is a carry from adding the two 16-bit halves,
asm-ppc64/checksum.h: * this routine is used for miscellaneous IP-like checksums, mainly
asm-ppc64/termios.h:#define N_IRDA		11	/* Linux IrDa - http://www.cs.uit.no/~dagb/irda/irda.html */
asm-ppc64/termios.h:#define N_SMSBLOCK	12	/* SMS block mode - for talking to GSM data cards about SMS messages */
asm-ppc64/termios.h:	get_user(__tmp,&(termio)->x); \
asm-ppc64/termios.h:	(termios)->x = (0xffff0000 & (termios)->x) | __tmp; \
asm-ppc64/termios.h:	copy_from_user((termios)->c_cc, (termio)->c_cc, NCC); \
asm-ppc64/termios.h:	put_user((termios)->c_iflag, &(termio)->c_iflag); \
asm-ppc64/termios.h:	put_user((termios)->c_oflag, &(termio)->c_oflag); \
asm-ppc64/termios.h:	put_user((termios)->c_cflag, &(termio)->c_cflag); \
asm-ppc64/termios.h:	put_user((termios)->c_lflag, &(termio)->c_lflag); \
asm-ppc64/termios.h:	put_user((termios)->c_line,  &(termio)->c_line); \
asm-ppc64/termios.h:	copy_to_user((termio)->c_cc, (termios)->c_cc, NCC); \
asm-ppc64/proc_fs.h: * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
asm-ppc64/proc_fs.h:/* tgall -- merge of iSeries/iSeries_proc.h and proc_pmc.h */
asm-ppc64/user.h:/* Adapted from <asm-alpha/user.h> 
asm-ppc64/user.h: * linux we use the `trad-core' bfd, NOT the osf-core).  The file contents
asm-ppc64/user.h: *  data: The data segment follows next.  We use current->end_text to
asm-ppc64/user.h: *	current->brk to pick up all of the user variables, plus any memory
asm-ppc64/user.h: *	page is demand-zero or if a page is totally unused, we just cover
asm-ppc64/user.h: *	current->start_stack, so we round each of these in order to be able
asm-ppc64/pci_dma.h: * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
asm-ppc64/pci_dma.h:#define NO_TCE ((dma_addr_t)-1)
asm-ppc64/pci_dma.h:		u64 cacheBits	:6;	/* Cache hash bits - not used */
asm-ppc64/serial.h: * include/asm-ppc/serial.h
asm-ppc64/pgtable.h:/* PMD_SHIFT determines what a second-level page table entry can map */
asm-ppc64/pgtable.h:#define PMD_SHIFT	(PAGE_SHIFT + PAGE_SHIFT - 3)
asm-ppc64/pgtable.h:#define PMD_MASK	(~(PMD_SIZE-1))
asm-ppc64/pgtable.h:/* PGDIR_SHIFT determines what a third-level page table entry can map */
asm-ppc64/pgtable.h:#define PGDIR_SHIFT	(PAGE_SHIFT + (PAGE_SHIFT - 3) + (PAGE_SHIFT - 2))
asm-ppc64/pgtable.h:#define PGDIR_MASK	(~(PGDIR_SIZE-1))
asm-ppc64/pgtable.h: * Define the address range mapped virt <-> physical
asm-ppc64/pgtable.h: * Bits in a linux-style PTE.  These match the bits in the
asm-ppc64/pgtable.h: * (hardware-defined) PowerPC PTE as closely as possible.
asm-ppc64/pgtable.h:#define _PAGE_WRITETHRU	0x040UL	/* W: cache write-through */
asm-ppc64/pgtable.h:#define _PAGE_EXEC	0x800UL	/* software: i-cache coherence required */
asm-ppc64/pgtable.h:/* __pgprot defined in asm-ppc64/page.h */
asm-ppc64/pgtable.h: * for zero-mapped memory areas etc..
asm-ppc64/pgtable.h:	pte_val(pte) = (((physpage)<<(PTE_SHIFT-PAGE_SHIFT)) | pgprot_val(pgprot)); \
asm-ppc64/pgtable.h:	pte_val(pte) = ((unsigned long)((page) - mem_map) << PTE_SHIFT) |   \
asm-ppc64/pgtable.h: * Find an entry in a page-table-directory.  We combine the address region 
asm-ppc64/pgtable.h:#define pgd_index(address) (((address) >> (PGDIR_SHIFT)) & (PTRS_PER_PGD -1))
asm-ppc64/pgtable.h:#define pgd_offset(mm, address)	 ((mm)->pgd + pgd_index(address))
asm-ppc64/pgtable.h:/* Find an entry in the second-level page table.. */
asm-ppc64/pgtable.h:  ((pmd_t *) pgd_page(*(dir)) + (((addr) >> PMD_SHIFT) & (PTRS_PER_PMD - 1)))
asm-ppc64/pgtable.h:/* Find an entry in the third-level page table.. */
asm-ppc64/pgtable.h:  ((pte_t *) pmd_page(*(dir)) + (((addr) >> PAGE_SHIFT) & (PTRS_PER_PTE - 1)))
asm-ppc64/pgtable.h:/* to find an entry in a kernel page-table-directory */
asm-ppc64/pgtable.h:/* to find an entry in the ioremap page-table-directory */
asm-ppc64/pgtable.h:#define pages_to_mb(x)		((x) >> (20-PAGE_SHIFT))
asm-ppc64/pgtable.h:	bne-	1b"
asm-ppc64/pgtable.h:#define KERNEL_PGD_PTRS (PTRS_PER_PGD-USER_PGD_PTRS)
asm-ppc64/pgtable.h: * as entries are faulted into the hash table by the low-level
asm-ppc64/pgtable.h:/* Encode and de-code a swap entry */
asm-ppc64/pgtable.h: * kernel address.  Most 32-bit archs define it as always true (like this)
asm-ppc64/pgtable.h: * but most 64-bit archs actually perform a test.  What should we do here?
asm-ppc64/param.h:#define NOGROUP		(-1)
asm-ppc64/systemcfg.h:	__u32 dCacheL1Size;		/* L1 d-cache size		0x60 */
asm-ppc64/systemcfg.h:	__u32 dCacheL1LineSize;		/* L1 d-cache line size		0x64 */
asm-ppc64/systemcfg.h:	__u32 iCacheL1Size;		/* L1 i-cache size		0x68 */
asm-ppc64/systemcfg.h:	__u32 iCacheL1LineSize;		/* L1 i-cache line size		0x6C */
asm-ppc64/systemcfg.h:	if (fd == -1)
asm-ppc64/systemcfg.h:	if (ret->version.major != SYSTEMCFG_MAJOR || ret->version.minor < SYSTEMCFG_MINOR) {
asm-ppc64/user_exports.h:	 * Cache line 1: 0x0000 - 0x007F
asm-ppc64/user_exports.h:	 * Kernel only data - undefined for user space
asm-ppc64/user_exports.h:	 * Cache line 2: 0x0080 - 0x00FF
asm-ppc64/user_exports.h:	u16 dCacheL1Size;	 /* L1 d-cache size           0x18 */
asm-ppc64/user_exports.h:	u16 dCacheL1LineSize;	 /* L1 d-cache line size      0x1A */
asm-ppc64/user_exports.h:	u16 dCacheL1LogLineSize; /* L1 d-cache line size Log2 0x1C */
asm-ppc64/user_exports.h:	u16 dCacheL1LinesPerPage;/* L1 d-cache lines / page   0x1E */
asm-ppc64/user_exports.h:	u16 dCacheL1Assoc;       /* L1 d-cache associativity  0x20 */
asm-ppc64/user_exports.h:	u16 iCacheL1Size;	 /* L1 i-cache size           0x22 */
asm-ppc64/user_exports.h:	u16 iCacheL1LineSize;	 /* L1 i-cache line size      0x24 */
asm-ppc64/user_exports.h:	u16 iCacheL1LogLineSize; /* L1 i-cache line size Log2 0x26 */
asm-ppc64/user_exports.h:	u16 iCacheL1LinesPerPage;/* L1 i-cache lines / page   0x28 */
asm-ppc64/user_exports.h:	u16 iCacheL1Assoc;       /* L1 i-cache associativity  0x2A */
asm-ppc64/user_exports.h:	u64 resv1[4];            /* Reserverd          0x60 - 0x7F */
asm-ppc64/bootinfo.h: * Non-machine dependent bootinfo structure.  Basic idea
asm-ppc64/bootinfo.h: * the bootloader which is a 32-bit process and read by the kernel
asm-ppc64/bootinfo.h: * which is a 64-bit process.  This way they can both agree on the
asm-ppc64/bootinfo.h:#define BI_FIRST		0x1010  /* first record - marker */
asm-ppc64/bootinfo.h:#define BI_LAST			0x1011	/* last record - marker */
asm-ppc64/bootinfo.h:	bi_recs->size = 0;
asm-ppc64/bootinfo.h:	rec = (struct bi_record *)((unsigned long)rec + rec->size);
asm-ppc64/bootinfo.h:	rec->size = sizeof(struct bi_record) + args*sizeof(bi_rec_field);
asm-ppc64/bootinfo.h:	rec = (struct bi_record *)((unsigned long)rec + rec->size);
asm-ppc64/bootinfo.h:	rec->size = sizeof(struct bi_record) + bytes;
asm-ppc64/bootinfo.h:	return (struct bi_record *)((unsigned long)rec + rec->size);
asm-ppc64/siginfo.h:#define SI_PAD_SIZE	((SI_MAX_SIZE/sizeof(int)) - 4)
asm-ppc64/siginfo.h:#define SI_PAD_SIZE32	((SI_MAX_SIZE/sizeof(int)) - 3)
asm-ppc64/siginfo.h: * Digital reserves positive values for kernel-generated signals.
asm-ppc64/siginfo.h:#define SI_QUEUE	-1		/* sent by sigqueue */
asm-ppc64/siginfo.h:#define SI_TIMER __SI_CODE(__SI_TIMER,-2) /* sent by timer expiration */
asm-ppc64/siginfo.h:#define SI_MESGQ	-3		/* sent by real time mesq state change */
asm-ppc64/siginfo.h:#define SI_ASYNCIO	-4		/* sent by AIO completion */
asm-ppc64/siginfo.h:#define SI_SIGIO	-5		/* sent by queued SIGIO */
asm-ppc64/siginfo.h:#define SI_TKILL	-6		/* sent by tkill system call */
asm-ppc64/siginfo.h:#define SI_DETHREAD	-7		/* sent by execve() killing subsidiary threads */
asm-ppc64/siginfo.h:#define SI_FROMUSER(siptr)	((siptr)->si_code <= 0)
asm-ppc64/siginfo.h:#define SI_FROMKERNEL(siptr)	((siptr)->si_code > 0)
asm-ppc64/siginfo.h:#define BUS_ADRERR	(__SI_FAULT|2)	/* non-existant physical address */
asm-ppc64/siginfo.h:#define SIGEV_PAD_SIZE	((SIGEV_MAX_SIZE/sizeof(int)) - 3)
asm-ppc64/siginfo.h:	if (from->si_code < 0)
asm-ppc64/siginfo.h:		memcpy(to, from, 3*sizeof(int) + sizeof(from->_sifields._sigchld));
asm-ppc64/floppy.h:		/* different from last time -- unmap prev */
asm-ppc64/floppy.h:static int FDC2 = -1;
asm-ppc64/vc_ioctl.h:#define VC_POWERMODE_INQUIRY	(-1)
asm-ppc64/sockios.h:/* Socket-level I/O control calls. */
asm-ppc64/flight_recorder.h: * Boston, MA  02111-1307  USA                                          *
asm-ppc64/keyboard.h: *  linux/include/asm-ppc/keyboard.h
asm-ppc64/keyboard.h: * This file contains the ppc architecture specific keyboard definitions -
asm-ppc64/a.out.h:/* 64-bit user address space is less PGDIR_SIZE due to pgd_index() bug. */
asm-ppc64/a.out.h:/* Give 32-bit user space a full 4G address space to live in. */
asm-ppc64/a.out.h:#define STACK_TOP (((current->thread.flags & PPC_FLAG_32BIT)||(ppcdebugset(PPCDBG_BINFMT_32ADDR))) ? \
asm-ppc64/ioctl.h: *                         -- Cort
asm-ppc64/ioctl.h:#define _IOC_NRMASK	((1 << _IOC_NRBITS)-1)
asm-ppc64/ioctl.h:#define _IOC_TYPEMASK	((1 << _IOC_TYPEBITS)-1)
asm-ppc64/ioctl.h:#define _IOC_SIZEMASK	((1 << _IOC_SIZEBITS)-1)
asm-ppc64/ioctl.h:#define _IOC_DIRMASK	((1 << _IOC_DIRBITS)-1)
asm-ppc64/ioctls.h:#define TIOCGPTN	_IOR('T',0x30, unsigned int) /* Get Pty Number (of pty-mux device) */
asm-ppc64/ppc32.h:/* Use this to get at 32-bit user passed pointers. */
asm-ppc64/ppc32.h:/* Things to consider: the low-level assembly stub does
asm-ppc64/ppc32.h:   -
asm-ppc64/ppc32.h:/* These are here to support 32-bit syscalls on a 64-bit kernel. */
asm-ppc64/machdep.h:	/* this is for modules, since _machine can be a define -- Cort */
asm-ppc64/machdep.h:/* Print a termination message (print only -- does not stop the kernel) */
asm-ppc64/socket.h:/* Security levels - as per NRL IPv6 - don't actually do anything */
asm-ppc64/socket.h:/* Nast libc5 fixup - bletch */
asm-ppc64/socket.h:#define SOCK_RDM	4		/* reliably-delivered message	*/
asm-ppc64/memory.h:/* Macros for adjusting thread priority (hardware multi-threading) */
asm-s390/io.h: *  include/asm-s390/io.h
asm-s390/io.h: *  Derived from "include/asm-i386/io.h"
asm-s390/io.h:#define page_to_phys(page)	((page - mem_map) << PAGE_SHIFT)
asm-s390/atomic.h: *  include/asm-s390/atomic.h
asm-s390/atomic.h: *  Derived from "include/asm-i386/bitops.h"
asm-s390/atomic.h:#define atomic_read(v)          ((v)->counter)
asm-s390/atomic.h:#define atomic_set(v,i)         (((v)->counter) = (i))
asm-s390/debug.h: *  include/asm-s390/debug.h
asm-s390/debug.h: * in order to allow a user program to analyze the 'raw'-view.
asm-s390/debug.h:#define DEBUG_OFF_LEVEL            -1 /* level where debug is switched off */
asm-s390/debug.h:#define DEBUG_FLUSH_ALL            -1 /* parameter to flush all areas */
asm-s390/debug.h:	if ((!id) || (level > id->level)) return NULL;
asm-s390/debug.h:	if ((!id) || (level > id->level)) return NULL;
asm-s390/debug.h:	if ((!id) || (level > id->level)) return NULL;
asm-s390/debug.h:	if ((!id) || (level > id->level)) return NULL;
asm-s390/debug.h:	if ((!id) || (level > id->level)) return NULL;
asm-s390/debug.h:	if ((!id) || (level > id->level)) return NULL;
asm-s390/debug.h:	if ((!id) || (level > id->level)) return NULL;
asm-s390/debug.h:	if ((!id) || (level > id->level)) return NULL;
asm-s390/debug.h:   - 0 No debugging output to console or syslog
asm-s390/debug.h:   - 1 Log internal errors to syslog, ignore check conditions 
asm-s390/debug.h:   - 2 Log internal errors and check conditions to syslog
asm-s390/debug.h:   - 3 Log internal errors to console, log check conditions to syslog
asm-s390/debug.h:   - 4 Log internal errors and check conditions to console
asm-s390/debug.h:   - 5 panic on internal errors, log check conditions to console
asm-s390/debug.h:   - 6 panic on both, internal errors and check conditions
asm-s390/delay.h: *  include/asm-s390/delay.h
asm-s390/delay.h: *  Derived from "include/asm-i386/delay.h"
asm-s390/ipcbuf.h: * - 32-bit mode_t and seq
asm-s390/ipcbuf.h: * - 2 miscellaneous 32-bit values
asm-s390/ucontext.h: *  include/asm-s390/ucontext.h
asm-s390/ucontext.h: *  Derived from "include/asm-i386/ucontext.h"
asm-s390/shmbuf.h: * - 64-bit time_t to solve y2038 problem
asm-s390/shmbuf.h: * - 2 miscellaneous 32-bit values
asm-s390/sfp-machine.h:/* Machine-dependent software floating-point definitions.
asm-s390/sfp-machine.h:   59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
asm-s390/sfp-machine.h:#define _FP_NANFRAC_S		((_FP_QNANBIT_S << 1) - 1)
asm-s390/sfp-machine.h:#define _FP_NANFRAC_D		((_FP_QNANBIT_D << 1) - 1), -1
asm-s390/sfp-machine.h:#define _FP_NANFRAC_Q		((_FP_QNANBIT_Q << 1) - 1), -1, -1, -1
asm-s390/sfp-machine.h:	unsigned int __r2 = (x2) - (y2);			\
asm-s390/sfp-machine.h:		 "   ahi %0,-1\n"				\
asm-s390/bitops.h: *  include/asm-s390/bitops.h
asm-s390/bitops.h: *  Derived from "include/asm-i386/bitops.h"
asm-s390/bitops.h:        static const int minusone = -1;
asm-s390/bitops.h:        static const int minusone = -1;
asm-s390/bitops.h: * fast, non-SMP set_bit routine
asm-s390/bitops.h: * fast, non-SMP clear_bit routine
asm-s390/bitops.h: * fast, non-SMP change_bit routine 
asm-s390/bitops.h: * fast, non-SMP test_and_set_bit routine
asm-s390/bitops.h: * fast, non-SMP test_and_clear_bit routine
asm-s390/bitops.h: * fast, non-SMP test_and_change_bit routine
asm-s390/bitops.h: * Find-bit routines..
asm-s390/bitops.h:        __asm__("   lhi  %1,-1\n"
asm-s390/bitops.h:                if (set < (32 - bit))
asm-s390/bitops.h:                offset += 32 - bit;
asm-s390/bitops.h:        res = find_first_zero_bit (p, size - 32 * (p - (unsigned long *) addr));
asm-s390/bitops.h: * of bits set) of a N-bit word
asm-s390/bitops.h:        __asm__("   lhi  %1,-1\n"
asm-s390/bitops.h:                "   ahi  %0,-16\n"
asm-s390/bitops.h:                "   ahi  %0,-8\n"
asm-s390/bitops.h:			return (p - addr)*32 + res;
asm-s390/bitops.h:        res = ext2_find_first_zero_bit (p, size - 32 * (p - addr));
asm-s390/bitops.h:        return (p - addr) * 32 + res;
asm-s390/div64.h:/* for do_div "base" needs to be smaller than 2^31-1 */
asm-s390/resource.h: *  include/asm-s390/resource.h
asm-s390/resource.h: *  Derived from "include/asm-i386/resources.h"
asm-s390/resource.h:#define RLIMIT_MEMLOCK	8		/* max locked-in-memory address space */
asm-s390/ptrace.h: *  include/asm-s390/ptrace.h
asm-s390/ptrace.h:#define PT_ENDREGS  0x140-1
asm-s390/ptrace.h: * gdb/hppab-nat.c
asm-s390/ptrace.h:#define user_mode(regs) (((regs)->psw.mask & PSW_PROBLEM_STATE) != 0)
asm-s390/ptrace.h:#define instruction_pointer(regs) ((regs)->psw.addr)
asm-s390/pgalloc.h: *  include/asm-s390/pgalloc.h
asm-s390/pgalloc.h: *  Derived from "include/asm-i386/pgalloc.h"
asm-s390/pgalloc.h: * used to allocate a kernel page table - this turns on ASN bits
asm-s390/pgalloc.h:                pgtable_cache_size -= 2;
asm-s390/pgalloc.h:                pgtable_cache_size--;
asm-s390/pgalloc.h: * vmalloc call).  Since s390-esame uses a separate kernel page table,
asm-s390/pgalloc.h: *  - flush_tlb() flushes the current mm struct TLBs
asm-s390/pgalloc.h: *  - flush_tlb_all() flushes all processes TLBs 
asm-s390/pgalloc.h: *  - flush_tlb_mm(mm) flushes the specified mm context TLB's
asm-s390/pgalloc.h: *  - flush_tlb_page(vma, vmaddr) flushes one page
asm-s390/pgalloc.h: *  - flush_tlb_range(mm, start, end) flushes a range of pages
asm-s390/pgalloc.h: *  - flush_tlb_pgtables(mm, start, end) flushes a range of page tables
asm-s390/pgalloc.h: * If we have threads (mm->count > 1) we always do a global flush, 
asm-s390/pgalloc.h:	if (mm->cpu_vm_mask != (1UL << smp_processor_id())) {
asm-s390/pgalloc.h:		if (mm == current->active_mm &&
asm-s390/pgalloc.h:		    atomic_read(&mm->mm_users) == 1)
asm-s390/pgalloc.h:			mm->cpu_vm_mask = 1UL << smp_processor_id();
asm-s390/pgalloc.h:	__flush_tlb_mm(current->mm);
asm-s390/pgalloc.h:	__flush_tlb_mm(vma->vm_mm);
asm-s390/unistd.h: *  include/asm-s390/unistd.h
asm-s390/unistd.h: *  Derived from "include/asm-i386/unistd.h"
asm-s390/unistd.h: * Numbers 224-235 are reserved for posix acl
asm-s390/unistd.h:/* user-visible error numbers are in the range -1 - -122: see <asm-s390/errno.h> */
asm-s390/unistd.h:        if ((unsigned long)(res) >= (unsigned long)(-125)) { \
asm-s390/unistd.h:                errno = -(res);                              \
asm-s390/unistd.h:                res = -1;                                    \
asm-s390/unistd.h: * we need this inline - forking from kernel space will result
asm-s390/unistd.h: * calls - which means inline code for fork too, as otherwise we
asm-s390/unistd.h:        return waitpid(-1,wait_stat,0);
asm-s390/dma.h: *  include/asm-s390/dma.h
asm-s390/elf.h: *  include/asm-s390/elf.h
asm-s390/elf.h: *  Derived from "include/asm-i386/elf.h"
asm-s390/elf.h:	(((x)->e_machine == EM_S390 || (x)->e_machine == EM_S390_OLD) \
asm-s390/elf.h:         && (x)->e_ident[EI_CLASS] == ELF_CLASS) 
asm-s390/elf.h:	_r->gprs[14] = 0
asm-s390/ide.h: *  linux/include/asm-arm/ide.h
asm-s390/ide.h: *  Copyright (C) 1994-1996  Linus Torvalds & authors
asm-s390/ipc.h: *  include/asm-s390/ipc.h
asm-s390/ipc.h: *  Derived from "include/asm-i386/ipc.h"
asm-s390/irq.h:#define INVALID_STORAGE_AREA ((void *)(-1 - 0x3FFF ))
asm-s390/irq.h:      __u32 mme  : 2;     /* measurement-mode enable */
asm-s390/irq.h:      __u16 mbi;          /* measurement-block index */
asm-s390/irq.h:      __u8  chpid[8];     /* CHPID 0-7 (if available) */
asm-s390/irq.h:      __u32 isic : 1; /* initial-status interruption control */
asm-s390/irq.h:      __u32 alcc : 1; /* address-limit checking control */
asm-s390/irq.h:      __u32 ssi  : 1; /* supress-suspended interruption */
asm-s390/irq.h:      __u32 isic : 1; /* initial-status-interruption control */
asm-s390/irq.h:      __u32 alcc : 1; /* address-limit-checking control */
asm-s390/irq.h:      __u32 ssic : 1; /* suppress-suspended-interr. control */
asm-s390/irq.h:      __u32 pvrf  : 1;  /* path-verification-required flag */
asm-s390/irq.h:      __u32 cpt   : 1;  /* channel-path timeout */
asm-s390/irq.h:      __u32 cons  : 1;  /* concurrent-sense */
asm-s390/irq.h:      __u32 fvf   : 5;  /* field-validity flags */
asm-s390/irq.h:      __u32 devsc : 1;  /* device-status check */
asm-s390/irq.h:      __u32 ioerr : 1;  /* i/o-error alert */
asm-s390/irq.h:      __u16 dcti;     /* device-connect-time interval */
asm-s390/irq.h:// sense-id response buffer layout
asm-s390/irq.h:				/* word 6-102 */
asm-s390/irq.h:				__u32 ccdf[96];   /* content-code dependent field */
asm-s390/irq.h:				/* words 4-5 */
asm-s390/irq.h:				__u8 chpid[8];    /* chpids 0-7 */
asm-s390/irq.h:				/* words 6-9 */
asm-s390/irq.h:				__u16 fla[8];     /* full link addresses 0-7 */
asm-s390/irq.h:				/* words 10-102 */
asm-s390/irq.h:     __u8          cstat;    /* channel status - accumulated */
asm-s390/irq.h:     __u8          dstat;    /* device status - accumulated */
asm-s390/irq.h:     __u8          unused;   /* not used - reserved */
asm-s390/irq.h: *  IRQ handler is called, either immediately, delayed (dev-end missing,
asm-s390/irq.h: *  or sense required) or never (no IRQ handler registered -
asm-s390/irq.h: *  taken, do_IO() returns :  0      - Success
asm-s390/irq.h: *                           -EIO    - Status pending
asm-s390/irq.h: *                                        see : action->dev_id->cstat
asm-s390/irq.h: *                                              action->dev_id->dstat
asm-s390/irq.h: *                           -EBUSY  - Device busy
asm-s390/irq.h: *                           -ENODEV - Device not operational
asm-s390/irq.h:int get_dev_info( int irq, s390_dev_info_t *);   /* to be eliminated - don't use */
asm-s390/irq.h: * Various low-level irq details needed by irq.c, process.c,
asm-s390/irq.h:#define irq_exit(cpu, irq)      (--local_irq_count(cpu))
asm-s390/irq.h:        if (prof_buffer && current->pid) {
asm-s390/irq.h:                addr -= (unsigned long) &_stext;
asm-s390/irq.h:                 * Don't ignore out-of-bounds EIP values silently,
asm-s390/irq.h:                if (addr > prof_len-1)
asm-s390/irq.h:                        addr = prof_len-1;
asm-s390/irq.h:#define get_irq_lock(irq) &ioinfo[irq]->irq_lock
asm-s390/irq.h:        spin_lock(&(ioinfo[irq]->irq_lock))
asm-s390/irq.h:        spin_unlock(&(ioinfo[irq]->irq_lock))
asm-s390/irq.h:        spin_lock_irqsave(&(ioinfo[irq]->irq_lock), flags)
asm-s390/irq.h:        spin_unlock_irqrestore(&(ioinfo[irq]->irq_lock), flags)
asm-s390/smp.h: *  include/asm-s390/smp.h
asm-s390/smp.h:#define smp_processor_id() (current->processor)
asm-s390/tlb.h:#include <asm-generic/tlb.h>
asm-s390/queue.h: *  include/asm-s390/queue.h
asm-s390/queue.h:		queue *tail=qhead->tail;
asm-s390/queue.h:			tail->next=member;
asm-s390/queue.h:			qhead->head=member;
asm-s390/queue.h:		qhead->tail=member;
asm-s390/queue.h:		member->next=NULL;
asm-s390/queue.h:	queue *head=qhead->head,*next_head;
asm-s390/queue.h:		next_head=head->next;
asm-s390/queue.h:		qhead->head=next_head;
asm-s390/queue.h:			qhead->tail=NULL;
asm-s390/queue.h:	member->next=*lhead;
asm-s390/queue.h:		*lhead=(*lhead)->next;
asm-s390/queue.h:		for(curr=(*lhead)->next;curr!=NULL;curr=curr->next)
asm-s390/queue.h:		prev->next=member;
asm-s390/queue.h:	member->next=NULL;
asm-s390/queue.h:	for(curr=lhead;curr!=NULL;curr=curr->next)
asm-s390/queue.h:	for(curr=lhead;curr!=NULL;curr=curr->next)
asm-s390/queue.h:			prev->next=member->next;
asm-s390/queue.h:			*lhead=member->next;
asm-s390/queue.h:	if(get_prev(qhead->head,(list *)member,(list **)&prev))
asm-s390/queue.h:			prev->next=member->next;
asm-s390/queue.h:			if(prev->next==NULL)
asm-s390/queue.h:				qhead->tail=prev;
asm-s390/queue.h:			if(qhead->head==qhead->tail)
asm-s390/queue.h:				qhead->tail=NULL;
asm-s390/queue.h:			qhead->head=member->next;
asm-s390/s390_ext.h: *  include/asm-s390/s390_ext.h
asm-s390/xor.h:#include <asm-generic/xor.h>
asm-s390/signal.h: *  include/asm-s390/signal.h
asm-s390/signal.h: *  Derived from "include/asm-i386/signal.h"
asm-s390/signal.h:#define SIGRTMAX        (_NSIG-1)
asm-s390/signal.h: * SA_INTERRUPT is a no-op, but left due to historical reasons. Use the
asm-s390/signal.h:#define SA_INTERRUPT    0x20000000 /* dummy -- ignored */
asm-s390/signal.h:#define SIG_ERR ((__sighandler_t)-1)    /* error return from signal */
asm-s390/ioctl32.h: * include/asm-s390/ioctl32.h
asm-s390/ioctl32.h: * include/asm-s390x/ioctl32.h
asm-s390/setup.h: *  include/asm-s390/setup.h
asm-s390/chandev.h: *  include/asm-s390/chandev.h
asm-s390/chandev.h:	u8      chpid[8];     /* CHPID 0-7 (if available) */
asm-s390/chandev.h:	/* buffers -1 means use the driver default the driver should set this field to the */
asm-s390/chandev.h:/* devif_num=-1 implies don't care,0 implies tr0, info used by chandev_initnetdevice */
asm-s390/chandev.h: * I subsequently found that reprobing failed in certain cases :-(,
asm-s390/chandev.h: * This returns the number of devices found or -ENOMEM if the code didn't
asm-s390/chandev.h: * or -EPERM if a duplicate entry is found.
asm-s390/hardirq.h: *  include/asm-s390/hardirq.h
asm-s390/hardirq.h: *  Derived from "include/asm-i386/hardirq.h"
asm-s390/hardirq.h:#define hardirq_exit(cpu)	(local_irq_count(cpu)--)
asm-s390/hardirq.h:        --local_irq_count(cpu);
asm-s390/shmparam.h: *  include/asm-s390/shmparam.h
asm-s390/shmparam.h: *  Derived from "include/asm-i386/shmparam.h"
asm-s390/sigcontext.h: *  include/asm-s390/sigcontext.h
asm-s390/processor.h: *  include/asm-s390/processor.h
asm-s390/processor.h: *  Derived from "include/asm-i386/processor.h"
asm-s390/processor.h:/* Lazy FPU handling on uni-processor */
asm-s390/processor.h:        __u32   error_code;            /* error-code of last prog-excep.   */
asm-s390/processor.h:        __u32   prot_addr;             /* address of protection-excep.     */
asm-s390/processor.h:        regs->psw.mask  = _USER_PSW_MASK;                       \
asm-s390/processor.h:        regs->psw.addr  = new_psw | 0x80000000;                 \
asm-s390/processor.h:        regs->gprs[15]  = new_stackp ;                          \
asm-s390/processor.h: * just stores the registers %r6-%r15 to the frame given by
asm-s390/processor.h:	bc = *((unsigned long *) t->ksp);
asm-s390/processor.h:	(((unsigned long) tsk + THREAD_SIZE - sizeof(struct pt_regs)) & -8L))
asm-s390/processor.h:#define KSTK_EIP(tsk)	(__KSTK_PTREGS(tsk)->psw.addr)
asm-s390/processor.h:#define KSTK_ESP(tsk)	(__KSTK_PTREGS(tsk)->gprs[15])
asm-s390/processor.h:#define get_task_struct(tsk)      atomic_inc(&virt_to_page(tsk)->count)
asm-s390/processor.h:		"0:  ahi  %0,1f-0b\n"
asm-s390/processor.h:		"0:  la   %0,1f-0b(%0)\n"
asm-s390/processor.h:        psw_t *dw_psw = (psw_t *)(((unsigned long) &psw_buffer+sizeof(psw_t)-1)
asm-s390/processor.h:                                  & -sizeof(psw_t));
asm-s390/processor.h:        dw_psw->mask = 0x000a0000;
asm-s390/processor.h:        dw_psw->addr = code;
asm-s390/mmu_context.h: *  include/asm-s390/mmu_context.h
asm-s390/mmu_context.h: *  Derived from "include/asm-i386/mmu_context.h"
asm-s390/mmu_context.h:	        pgd = (__pa(next->pgd)&PAGE_MASK) | 
asm-s390/mmu_context.h:	set_bit(cpu, &next->cpu_vm_mask);
asm-s390/semaphore.h: *  include/asm-s390/semaphore.h
asm-s390/semaphore.h: *  Derived from "include/asm-i386/semaphore.h"
asm-s390/semaphore.h:	if (atomic_dec_return(&sem->count) < 0)
asm-s390/semaphore.h:	if (atomic_dec_return(&sem->count) < 0)
asm-s390/semaphore.h:	if (atomic_dec_return(&sem->count) < 0)
asm-s390/semaphore.h:	if (atomic_inc_return(&sem->count) <= 0)
asm-s390/semaphore.h:	return atomic_read(&sem->count);
asm-s390/fcntl.h: *  include/asm-s390/fcntl.h
asm-s390/fcntl.h: *  Derived from "include/asm-i386/fcntl.h"
asm-s390/fcntl.h:/* open/fcntl - O_SYNC is only implemented on blocks devices and on files
asm-s390/fcntl.h:#define F_GETFL		3	/* get file->f_flags */
asm-s390/fcntl.h:#define F_SETFL		4	/* set file->f_flags */
asm-s390/s390mach.h:	__u32   pd              :  1; /* 01 instruction-processing damage */
asm-s390/s390mach.h:	__u32   to_be_defined_1 :  4; /* 03-06 */
asm-s390/s390mach.h:	__u32   cp              :  1; /* 09 channel-report pending */
asm-s390/s390mach.h:	__u32   to_be_defined_2 :  6; /* 10-15 */
asm-s390/s390mach.h:	__u32   ke              :  1; /* 18 storage-key error uncorrected */
asm-s390/s390mach.h:	__u32	to_be_defined_3 :  4; /* 20-23 */
asm-s390/s390mach.h:	__u32   to_be_defined_4 :  7; /* 25-31 */
asm-s390/s390mach.h:	__u32	to_be_defined_5 : 31; /* 33-63 */
asm-s390/s390mach.h:// machine-check-interruption code
asm-s390/s390mach.h:      __u64 mcl;	/* machine check int. code - long info */	
asm-s390/s390mach.h:      mci_t mcd;  /* machine check int. code - details   */
asm-s390/s390mach.h:	__u32 erc     :  6;   /* error-recovery code */
asm-s390/s390mach.h:	__u32 rsid    : 16;   /* reporting-source ID */
asm-s390/s390mach.h:#define CRW_RSC_CONFIG   0x9  /* configuration-alert facility */
asm-s390/rwsem.h: *  include/asm-s390/rwsem.h
asm-s390/rwsem.h: *  Based on asm-alpha/semaphore.h and asm-i386/rwsem.h
asm-s390/rwsem.h: * This should be totally fair - if anything is waiting, a process that wants a
asm-s390/rwsem.h:#define RWSEM_WAITING_BIAS	(-0x00010000)
asm-s390/rwsem.h:	sem->count = RWSEM_UNLOCKED_VALUE;
asm-s390/rwsem.h:	spin_lock_init(&sem->wait_lock);
asm-s390/rwsem.h:	INIT_LIST_HEAD(&sem->wait_list);
asm-s390/rwsem.h:		: "a" (&sem->count), "i" (RWSEM_ACTIVE_READ_BIAS)
asm-s390/rwsem.h: * trylock for reading -- returns 1 if successful, 0 if contention
asm-s390/rwsem.h:		: "a" (&sem->count), "i" (RWSEM_ACTIVE_READ_BIAS)
asm-s390/rwsem.h:		: "a" (&sem->count), "m" (tmp)
asm-s390/rwsem.h: * trylock for writing -- returns 1 if successful, 0 if contention
asm-s390/rwsem.h:		: "a" (&sem->count), "d" (RWSEM_ACTIVE_WRITE_BIAS)
asm-s390/rwsem.h:		: "a" (&sem->count), "i" (-RWSEM_ACTIVE_READ_BIAS)
asm-s390/rwsem.h:	tmp = -RWSEM_ACTIVE_WRITE_BIAS;
asm-s390/rwsem.h:		: "a" (&sem->count), "m" (tmp)
asm-s390/rwsem.h:		: "a" (&sem->count), "d" (delta)
asm-s390/rwsem.h:		: "a" (&sem->count), "d" (delta)
asm-s390/spinlock.h: *  include/asm-s390/spinlock.h
asm-s390/spinlock.h: *  Derived from "include/asm-i386/spinlock.h"
asm-s390/spinlock.h:#define spin_lock_init(lp) do { (lp)->lock = 0; } while(0)
asm-s390/spinlock.h:#define spin_unlock_wait(lp)	do { barrier(); } while(((volatile spinlock_t *)(lp))->lock)
asm-s390/spinlock.h:#define spin_is_locked(x) ((x)->lock != 0)
asm-s390/spinlock.h:			   : "a" (&lp->lock) : "cc", "memory" );
asm-s390/spinlock.h:			   : "a" (&lp->lock) : "cc", "memory" );
asm-s390/spinlock.h:			   : : "a" (&lp->lock) : "memory", "cc" );
asm-s390/spinlock.h: * Read-write spinlocks, allowing multiple readers
asm-s390/spinlock.h: * can "mix" irq-safe locks - any writer needs to get a
asm-s390/spinlock.h: * irq-safe write-lock, but readers can get non-irqsafe
asm-s390/spinlock.h: * read-locks.
asm-s390/spinlock.h:                     : : "a" (&(rw)->lock) : "2", "3", "cc", "memory" )
asm-s390/spinlock.h:                     "   ahi   3,-1\n"    /* one less reader */ \
asm-s390/spinlock.h:                     : : "a" (&(rw)->lock) : "2", "3", "cc", "memory" )
asm-s390/spinlock.h:                     : : "a" (&(rw)->lock) : "2", "3", "cc", "memory" )
asm-s390/spinlock.h:                     : : "a" (&(rw)->lock) : "2", "3", "cc", "memory" )
asm-s390/errno.h: *  include/asm-s390/errno.h
asm-s390/errno.h: *  Derived from "include/asm-i386/errno.h"
asm-s390/errno.h:#define	EXDEV		18	/* Cross-device link */
asm-s390/errno.h:#define	EROFS		30	/* Read-only file system */
asm-s390/errno.h:#define	ENOTSOCK	88	/* Socket operation on non-socket */
asm-s390/byteorder.h: *  include/asm-s390/byteorder.h
asm-s390/softirq.h: *  include/asm-s390/softirq.h
asm-s390/softirq.h: *  Derived from "include/asm-i386/softirq.h"
asm-s390/softirq.h:                do { barrier(); local_bh_count(cpu)--; } while (0)
asm-s390/softirq.h:        if (!--*ptr)							\
asm-s390/timex.h: *  include/asm-s390/timex.h
asm-s390/timex.h: *  Derived from "include/asm-i386/timex.h"
asm-s390/timex.h:#define FINETUNE ((((((long)LATCH * HZ - CLOCK_TICK_RATE) << SHIFT_HZ) * \
asm-s390/timex.h:		<< (SHIFT_SCALE-SHIFT_HZ)) / HZ)
asm-s390/bugs.h: *  include/asm-s390/bugs.h
asm-s390/bugs.h: *  Derived from "include/asm-i386/bugs.h"
asm-s390/bugs.h: * This is included by init/main.c to check for architecture-dependent bugs.
asm-s390/namei.h: *  include/asm-s390/namei.h
asm-s390/namei.h: *  Derived from "include/asm-i386/namei.h"
asm-s390/namei.h: * Look at asm-sparc/namei.h for details.
asm-s390/dasd.h: * to userspace by the DASDAPIVER-ioctl
asm-s390/dasd.h: * 12/06/01 DASD_API_VERSION 2 - binary compatible to 0 (new BIODASDINFO2)
asm-s390/dasd.h: * 01/23/02 DASD_API_VERSION 3 - added BIODASDPSRD IOCTL
asm-s390/dasd.h: * 02/15/02 DASD_API_VERSION 4 - added BIODASDSATTR IOCTL
asm-s390/dasd.h: * 06/07/02 DASD_API_VERSION 5 - added 'boxed DASD' support
asm-s390/dasd.h: * Read Subsystem Data - Perfomance Statistics
asm-s390/dasd.h: * Here ist how the ioctl-nr should be used:
asm-s390/dasd.h: *    0 -   31   DASD driver itself
asm-s390/dasd.h: *   32 -  239   still open
asm-s390/dasd.h: *  240 -  255   reserved for EMC 
asm-s390/dasd.h: * ---------------------------------------------------------------------------
asm-s390/dasd.h: * c-indent-level: 4 
asm-s390/dasd.h: * c-brace-imaginary-offset: 0
asm-s390/dasd.h: * c-brace-offset: -4
asm-s390/dasd.h: * c-argdecl-indent: 4
asm-s390/dasd.h: * c-label-offset: -4
asm-s390/dasd.h: * c-continued-statement-offset: 4
asm-s390/dasd.h: * c-continued-brace-offset: 0
asm-s390/dasd.h: * indent-tabs-mode: nil
asm-s390/dasd.h: * tab-width: 8
asm-s390/termbits.h: *  include/asm-s390/termbits.h
asm-s390/termbits.h: *  Derived from "include/asm-i386/termbits.h"
asm-s390/ccwcache.h: * File...........: linux/include/asm-s390/ccwcache.h
asm-s390/ccwcache.h:	unsigned long long buildclk;	/* TOD-clock of request generation */
asm-s390/ccwcache.h:	unsigned long long startclk;	/* TOD-clock of request start */
asm-s390/ccwcache.h:	unsigned long long stopclk;	/* TOD-clock of request interrupt */
asm-s390/ccwcache.h:	unsigned long long endclk;	/* TOD-clock of request termination */
asm-s390/ccwcache.h: * ccw_req_t -> status can be:
asm-s390/init.h: *  include/asm-s390/init.h
asm-s390/uaccess.h: *  include/asm-s390/uaccess.h
asm-s390/uaccess.h: *  Derived from "include/asm-i386/uaccess.h"
asm-s390/uaccess.h:#define get_fs()        (current->addr_limit)
asm-s390/uaccess.h:                         current->addr_limit = (x);})
asm-s390/uaccess.h:        return access_ok(type,addr,size)?0:-EFAULT;
asm-s390/uaccess.h: * These are the main single-value transfer routines.  They automatically
asm-s390/uaccess.h:                                : "m" (x), "K" (-EFAULT)
asm-s390/uaccess.h:                                : "d" (x), "K" (-EFAULT)
asm-s390/uaccess.h:                                : "d" (x), "K" (-EFAULT)
asm-s390/uaccess.h:                                : "d" (x), "K" (-EFAULT)
asm-s390/uaccess.h:                                : "m" (*(const __u64*)(ptr)),"K" (-EFAULT) \
asm-s390/uaccess.h:                                : "m" (*(const __u32*)(ptr)),"K" (-EFAULT) \
asm-s390/uaccess.h:                                : "m" (*(const __u16*)(ptr)),"K" (-EFAULT) \
asm-s390/uaccess.h:                                : "m" (*(const __u8*)(ptr)),"K" (-EFAULT) \
asm-s390/uaccess.h:                                "   l     3,4f-.(3)\n"
asm-s390/uaccess.h:                                  "K" (-EFAULT)
asm-s390/uaccess.h:        long res = -EFAULT;
asm-s390/mman.h: *  include/asm-s390/mman.h
asm-s390/mman.h: *  Derived from "include/asm-i386/mman.h"
asm-s390/mman.h:#define MAP_GROWSDOWN	0x0100		/* stack-like segment */
asm-s390/mman.h:#define MADV_NORMAL    0x0              /* default page-in behavior */
asm-s390/mman.h:#define MADV_RANDOM    0x1              /* page-in minimum required */
asm-s390/mman.h:#define MADV_SEQUENTIAL        0x2             /* read-ahead aggressively */
asm-s390/mman.h:#define MADV_WILLNEED  0x3              /* pre-fault pages */
asm-s390/posix_types.h: *  include/asm-s390/posix_types.h
asm-s390/posix_types.h: *  Derived from "include/asm-i386/posix_types.h"
asm-s390/posix_types.h: * This file is generally used by user-level software, so you need to
asm-s390/smplock.h: *  include/asm-s390/smplock.h
asm-s390/smplock.h: *  Derived from "include/asm-i386/smplock.h"
asm-s390/smplock.h:	if (task->lock_depth >= 0)         \
asm-s390/smplock.h: * Re-acquire the kernel lock
asm-s390/smplock.h:	if (task->lock_depth >= 0)         \
asm-s390/smplock.h:        if (!++current->lock_depth)
asm-s390/smplock.h:        if (--current->lock_depth < 0)
asm-s390/page.h: *  include/asm-s390/page.h
asm-s390/page.h:#define PAGE_MASK       (~(PAGE_SIZE-1))
asm-s390/page.h:        size = (size-1) >> (PAGE_SHIFT-1);
asm-s390/page.h:        order = -1;
asm-s390/page.h: * These are used to make use of C type-checking..
asm-s390/page.h:#define PAGE_ALIGN(addr)        (((addr)+PAGE_SIZE-1)&PAGE_MASK)
asm-s390/page.h:#define VALID_PAGE(page)	((page - mem_map) < max_mapnr)
asm-s390/lowcore.h: *  include/asm-s390/lowcore.h
asm-s390/lowcore.h:#define _USER_PSW_MASK       0x070DC000/* DAT, IO, EXT, Home-space         */
asm-s390/lowcore.h:#define _WAIT_PSW_MASK       0x070E0000/* DAT, IO, EXT, Wait, Home-space   */
asm-s390/lowcore.h:	__u8         pad1[0x58-0x40];          /* 0x040 */
asm-s390/lowcore.h:	__u8         pad2[0xB8-0xA2];          /* 0x0a2 */
asm-s390/lowcore.h:        __u8         pad3[0xD8-0xC4];          /* 0x0c4 */
asm-s390/lowcore.h:	__u8         pad4[0xf4-0xf0];          /* 0x0f0 */
asm-s390/lowcore.h:	__u8         pad5[0x100-0xfc];         /* 0x0fc */
asm-s390/lowcore.h:	__u8         pad6[0x120-0x110];        /* 0x110 */
asm-s390/lowcore.h:	__u8         pad8[0x400-0x208];        /* 0x208 */
asm-s390/lowcore.h:        __u8         pad9[0xc00-0x404];        /* 0x404 */
asm-s390/lowcore.h:	__u8         pad10[0xc60-0xc48];       /* 0xc5c */
asm-s390/lowcore.h:        __u8         pad11[0xe00-0xc94];       /* 0xc94 */
asm-s390/lowcore.h:	__u8         pad12[0x1000-0xe04];      /* 0xe04 */
asm-s390/s390io.h:           unsigned int  unknown   : 1;  /* unknown device - if SenseID failed */
asm-s390/s390io.h:           unsigned int  unused    : (sizeof(unsigned int)*8 - 26); /* unused */
asm-s390/hdreg.h: *  linux/include/asm-arm/hdreg.h
asm-s390/hdreg.h: *  Copyright (C) 1994-1996  Linus Torvalds & authors
asm-s390/qdio.h:#define QDIO_MAX_BUFFERS_PER_Q 128 /* must be a power of 2 (%x=&(x-1)*/
asm-s390/qdio.h:/* unfortunately this can't be (QDIO_MAX_BUFFERS_PER_Q*4/3) or so -- as
asm-s390/qdio.h:#define QDIO_IRQ_STATE_FRESH 0 /* must be 0 -> memset has set it to 0 */
asm-s390/qdio.h:#define QDIO_DBF_TRACE_LEVEL 4 /* -------- could be even more verbose here */
asm-s390/qdio.h: * QDIO device commands returned by extended Sense-ID
asm-s390/qdio.h: * additional CIWs returned by extended Sense-ID
asm-s390/qdio.h:	unsigned long sliba;            /* storage-list-information-block
asm-s390/qdio.h:	unsigned long sla;              /* storage-list address */
asm-s390/qdio.h:	unsigned long slsba;            /* storage-list-state-block address */
asm-s390/qdio.h: * Queue-Description record (QDR)
asm-s390/qdio.h:	unsigned int  iqdcnt  :  8;     /* input-queue-descriptor count */
asm-s390/qdio.h:	unsigned int  oqdcnt  :  8;     /* output-queue-descriptor count */
asm-s390/qdio.h:	unsigned int  iqdsz   :  8;     /* input-queue-descriptor size */
asm-s390/qdio.h:	unsigned int  oqdsz   :  8;     /* output-queue-descriptor size */
asm-s390/qdio.h:	unsigned long qiba;             /* queue-information-block address */
asm-s390/qdio.h:	unsigned int  qkey    :  4;     /* queue-informatio-block key */
asm-s390/qdio.h: * storage-list-information block element (SLIBE)
asm-s390/qdio.h: * storage-list-information block (SLIB)
asm-s390/qdio.h:	unsigned char sbtype: 2;   /* storage-block type (FCP) */
asm-s390/qdio.h: * strorage-block access-list (SBAL)
asm-s390/qdio.h: * storage-list (SL)
asm-s390/qdio.h: * storage-list-state block (SLSB)
asm-s390/qdio.h:				/* word 12-1015 */
asm-s390/qdio.h:				/* word 7-1015 */
asm-s390/poll.h: *  include/asm-s390/poll.h
asm-s390/poll.h: *  Derived from "include/asm-i386/poll.h"
asm-s390/poll.h:/* The rest seem to be more-or-less nonstandard. Check them! */
asm-s390/ebcdic.h: *  include/asm-s390/ebcdic.h
asm-s390/ebcdic.h: *    EBCDIC -> ASCII, ASCII -> EBCDIC conversion routines.
asm-s390/ebcdic.h:extern __u8 _ascebc_500[];   /* ASCII -> EBCDIC 500 conversion table */
asm-s390/ebcdic.h:extern __u8 _ebcasc_500[];   /* EBCDIC 500 -> ASCII conversion table */
asm-s390/ebcdic.h:extern __u8 _ascebc[];   /* ASCII -> EBCDIC conversion table */
asm-s390/ebcdic.h:extern __u8 _ebcasc[];   /* EBCDIC -> ASCII conversion table */
asm-s390/ebcdic.h:extern __u8 _ebc_tolower[]; /* EBCDIC -> lowercase */
asm-s390/ebcdic.h:extern __u8 _ebc_toupper[]; /* EBCDIC -> uppercase */
asm-s390/ebcdic.h:	if (nr-- <= 0)
asm-s390/ebcdic.h:		"1: ahi  %1,-256\n"
asm-s390/current.h: *  include/asm-s390/current.h
asm-s390/current.h: *  Derived from "include/asm-i386/current.h"
asm-s390/current.h:        __asm__("lhi   %0,-8192\n\t"
asm-s390/types.h: *  include/asm-s390/types.h
asm-s390/types.h: *  Derived from "include/asm-i386/types.h"
asm-s390/sembuf.h: * - 64-bit time_t to solve y2038 problem
asm-s390/sembuf.h: * - 2 miscellaneous 32-bit values
asm-s390/sigp.h: *  include/asm-s390/sigp.h
asm-s390/system.h: *  include/asm-s390/system.h
asm-s390/system.h: *  Derived from "include/asm-i386/system.h"
asm-s390/system.h:	save_fp_regs1(&prev->thread.fp_regs);                                \
asm-s390/system.h:	restore_fp_regs1(&next->thread.fp_regs);              		     \
asm-s390/system.h: * all memory ops have completed wrt other CPU's ( see 7-15 POP  DJB ).
asm-s390/stat.h: *  include/asm-s390/stat.h
asm-s390/stat.h: *  Derived from "include/asm-i386/stat.h"
asm-s390/stat.h:        unsigned long   st_blocks;  /* Number 512-byte blocks allocated. */
asm-s390/checksum.h: *  include/asm-s390/checksum.h
asm-s390/checksum.h: * and adds in "sum" (32-bit)
asm-s390/checksum.h: * returns a 32-bit number suitable for feeding into itself
asm-s390/checksum.h: * it's best to have buff aligned on a 32-bit boundary
asm-s390/checksum.h: * here even more important to align src and dst on a 32-bit (or even
asm-s390/checksum.h: * better 64-bit) boundary
asm-s390/checksum.h: * here even more important to align src and dst on a 32-bit (or even
asm-s390/checksum.h: * better 64-bit) boundary
asm-s390/checksum.h:		memset(dst + len - missing, 0, missing);
asm-s390/checksum.h:		*err_ptr = -EFAULT;
asm-s390/checksum.h: * computes the checksum of the TCP/UDP pseudo-header
asm-s390/checksum.h: * returns a 32-bit checksum
asm-s390/checksum.h: * computes the checksum of the TCP/UDP pseudo-header
asm-s390/checksum.h: * returns a 16-bit checksum, already complemented
asm-s390/checksum.h: * this routine is used for miscellaneous IP-like checksums, mainly
asm-s390/termios.h: *  include/asm-s390/termios.h
asm-s390/termios.h: *  Derived from "include/asm-i386/termios.h"
asm-s390/termios.h:#define N_IRDA		11	/* Linux IR - http://irda.sourceforge.net/ */
asm-s390/termios.h:#define N_SMSBLOCK	12	/* SMS block mode - for talking to GSM data cards about SMS messages */
asm-s390/termios.h:        get_user(tmp, &(termio)->c_iflag); \
asm-s390/termios.h:        (termios)->c_iflag = (0xffff0000 & ((termios)->c_iflag)) | tmp; \
asm-s390/termios.h:        get_user(tmp, &(termio)->c_oflag); \
asm-s390/termios.h:        (termios)->c_oflag = (0xffff0000 & ((termios)->c_oflag)) | tmp; \
asm-s390/termios.h:        get_user(tmp, &(termio)->c_cflag); \
asm-s390/termios.h:        (termios)->c_cflag = (0xffff0000 & ((termios)->c_cflag)) | tmp; \
asm-s390/termios.h:        get_user(tmp, &(termio)->c_lflag); \
asm-s390/termios.h:        (termios)->c_lflag = (0xffff0000 & ((termios)->c_lflag)) | tmp; \
asm-s390/termios.h:        get_user((termios)->c_line, &(termio)->c_line); \
asm-s390/termios.h:	copy_from_user((termios)->c_cc, (termio)->c_cc, NCC); \
asm-s390/termios.h:	put_user((termios)->c_iflag, &(termio)->c_iflag); \
asm-s390/termios.h:	put_user((termios)->c_oflag, &(termio)->c_oflag); \
asm-s390/termios.h:	put_user((termios)->c_cflag, &(termio)->c_cflag); \
asm-s390/termios.h:	put_user((termios)->c_lflag, &(termio)->c_lflag); \
asm-s390/termios.h:	put_user((termios)->c_line,  &(termio)->c_line); \
asm-s390/termios.h:	copy_to_user((termio)->c_cc, (termios)->c_cc, NCC); \
asm-s390/user.h: *  include/asm-s390/user.h
asm-s390/user.h: *  Derived from "include/asm-i386/usr.h"
asm-s390/user.h:   linux we use the 'trad-core' bfd).  There are quite a number of
asm-s390/user.h:   DATA: The data area is stored.  We use current->end_text to
asm-s390/user.h:   current->brk to pick up all of the user variables, plus any memory
asm-s390/user.h:   is demand-zero or if a page is totally unused, we just cover the entire
asm-s390/user.h:   current->start_stack, so we round each of these off in order to be able
asm-s390/user.h:/* When the kernel dumps core, it starts by dumping the user struct -
asm-s390/statfs.h: *  include/asm-s390/statfs.h
asm-s390/statfs.h: *  Derived from "include/asm-i386/statfs.h"
asm-s390/vtoc.h:        char cisize[4];	        /* CI-size for FBA,...                       */
asm-s390/vtoc.h:        __u8  DS4DEVI;            /* non-last keyed record overhead          */
asm-s390/vtoc.h:        __u8  DS4DEVK;            /* non-keyed record overhead differential  */
asm-s390/vtoc.h:        __u8 DS4EFLVL;            /* extended free-space management level    */
asm-s390/vtoc.h:        cchhb_t DS4EFPTR;         /* pointer to extended free-space info     */
asm-s390/vtoc.h:	ds5ext_t DS5AVEXT;        /* first available (free-space) extent.    */
asm-s390/pgtable.h: *  include/asm-s390/pgtable.h
asm-s390/pgtable.h: *  Derived from "include/asm-i386/pgtable.h"
asm-s390/pgtable.h: * The Linux memory management assumes a three-level page table setup. On
asm-s390/pgtable.h: * the S390, we use that, but "fold" the mid level into the top-level page
asm-s390/pgtable.h: * table, so that we physically have the same two-level page table as the
asm-s390/pgtable.h: * The "pgd_xxx()" functions are trivial for a folded two-level
asm-s390/pgtable.h:/* Caches aren't brain-dead on S390. */
asm-s390/pgtable.h: * for zero-mapped memory areas etc..
asm-s390/pgtable.h: * PMD_SHIFT determines the size of the area a second-level page
asm-s390/pgtable.h:#define PMD_MASK        (~(PMD_SIZE-1))
asm-s390/pgtable.h:/* PGDIR_SHIFT determines what a third-level page table entry can map */
asm-s390/pgtable.h:#define PGDIR_MASK      (~(PGDIR_SIZE-1))
asm-s390/pgtable.h: * entries per page directory level: the S390 is two-level, so
asm-s390/pgtable.h: * for S390 segment-table entries are combined to one PGD
asm-s390/pgtable.h: * any out-of-bounds memory accesses will hopefully be caught.
asm-s390/pgtable.h:			 & ~(VMALLOC_OFFSET-1))
asm-s390/pgtable.h: * I Page-Invalid Bit:    Page is not available for address-translation
asm-s390/pgtable.h: * P Page-Protection Bit: Store access not possible for page
asm-s390/pgtable.h: *  |   P-table origin      |  |PTL
asm-s390/pgtable.h: * I Segment-Invalid Bit:    Segment is not available for address-translation
asm-s390/pgtable.h: * C Common-Segment Bit:     Segment is not private (PoP 3-30)
asm-s390/pgtable.h: * PTL Page-Table-Length:    Page-table length (PTL+1*16 entries -> up to 256)
asm-s390/pgtable.h: *  |S-table origin   |     | STL |
asm-s390/pgtable.h: * X Space-Switch event:
asm-s390/pgtable.h: * G Segment-Invalid Bit:     *
asm-s390/pgtable.h: * P Private-Space Bit:       Segment is not private (PoP 3-30)
asm-s390/pgtable.h: * S Storage-Alteration:
asm-s390/pgtable.h: * STL Segment-Table-Length:  Segment-table length (STL+1*16 entries -> up to 2048)
asm-s390/pgtable.h:#define _PAGE_RO        0x200          /* HW read-only                     */
asm-s390/pgtable.h:#define _PAGE_TABLE_LEN 0xf            /* only full page-tables            */
asm-s390/pgtable.h:#define _PAGE_TABLE_COM 0x10           /* common page-table                */
asm-s390/pgtable.h:#define _PAGE_TABLE_INV 0x20           /* invalid page-table               */
asm-s390/pgtable.h:#define _USER_SEG_TABLE_LEN    0x7f    /* user-segment-table up to 2 GB    */
asm-s390/pgtable.h:#define _KERNEL_SEG_TABLE_LEN  0x7f    /* kernel-segment-table up to 2 GB  */
asm-s390/pgtable.h: * The Kernel segment-tables includes the User segment-table
asm-s390/pgtable.h:#define pages_to_mb(x) ((x) >> (20-PAGE_SHIFT))
asm-s390/pgtable.h:	unsigned long __physpage = __pa((__page-mem_map) << PAGE_SHIFT);  \
asm-s390/pgtable.h:		if (!test_and_set_bit(PG_uptodate, &__page->flags))	  \
asm-s390/pgtable.h:			      "a" (__pa((__page-mem_map) << PAGE_SHIFT)));\
asm-s390/pgtable.h:/* to find an entry in a page-table-directory */
asm-s390/pgtable.h:#define pgd_index(address) ((address >> PGDIR_SHIFT) & (PTRS_PER_PGD-1))
asm-s390/pgtable.h:#define pgd_offset(mm, address) ((mm)->pgd+pgd_index(address))
asm-s390/pgtable.h:/* to find an entry in a kernel page-table-directory */
asm-s390/pgtable.h:/* Find an entry in the second-level page table.. */
asm-s390/pgtable.h:/* Find an entry in the third-level page table.. */
asm-s390/pgtable.h:        ((pte_t *) (pmd_page(*pmd) + ((address>>10) & ((PTRS_PER_PTE-1)<<2))))
asm-s390/pgtable.h: * A page-table entry has some bits we have to treat in a special way.
asm-s390/pgtable.h: * This leaves the bits 1-19 and bits 24-30 to store type and offset.
asm-s390/pgtable.h: * We use the 7 bits from 24-30 for the type and the 19 bits from 1-19
asm-s390/unaligned.h: *  include/asm-s390/unaligned.h
asm-s390/unaligned.h: *  Derived from "include/asm-i386/unaligned.h"
asm-s390/idals.h: * File...........: linux/include/asm-s390x/idals.h
asm-s390/idals.h:		return ((__pa(vaddr) & (IDA_BLOCK_SIZE-1)) + length + 
asm-s390/idals.h:			(IDA_BLOCK_SIZE-1)) >> IDA_SIZE_LOG;
asm-s390/idals.h:	cidaw = ((paddr & (IDA_BLOCK_SIZE-1)) + length + 
asm-s390/idals.h:		 (IDA_BLOCK_SIZE-1)) >> IDA_SIZE_LOG;
asm-s390/idals.h:	paddr &= -IDA_BLOCK_SIZE;
asm-s390/idals.h:	while (--cidaw > 0) {
asm-s390/idals.h:	if (ccw->flags & CCW_FLAG_IDA)
asm-s390/idals.h:		return -EINVAL;
asm-s390/idals.h:	nridaws = idal_nr_words(vaddr, ccw->count);
asm-s390/idals.h:			return -ENOMEM;
asm-s390/idals.h:		idal_create_words(idal, vaddr, ccw->count);
asm-s390/idals.h:		ccw->flags |= CCW_FLAG_IDA;
asm-s390/idals.h:	ccw->cda = (__u32)(unsigned long) vaddr;
asm-s390/idals.h:	if (ccw->flags & CCW_FLAG_IDA) {
asm-s390/idals.h:		kfree((void *)(unsigned long) ccw->cda);
asm-s390/idals.h:		ccw->flags &= ~CCW_FLAG_IDA;
asm-s390/idals.h:	ccw->cda = 0;
asm-s390/idals.h:	nr_ptrs = (size + IDA_BLOCK_SIZE - 1) >> IDA_SIZE_LOG;
asm-s390/idals.h:		return ERR_PTR(-ENOMEM);
asm-s390/idals.h:	ib->size = size;
asm-s390/idals.h:	ib->page_order = page_order;
asm-s390/idals.h:		if ((i & (nr_chunks - 1)) != 0) {
asm-s390/idals.h:			ib->data[i] = ib->data[i-1] + IDA_BLOCK_SIZE;
asm-s390/idals.h:		ib->data[i] = (void *)
asm-s390/idals.h:		if (ib->data[i] != NULL)
asm-s390/idals.h:			i -= nr_chunks;
asm-s390/idals.h:			free_pages((unsigned long) ib->data[i],
asm-s390/idals.h:				   ib->page_order);
asm-s390/idals.h:		return ERR_PTR(-ENOMEM);
asm-s390/idals.h:	nr_ptrs = (ib->size + IDA_BLOCK_SIZE - 1) >> IDA_SIZE_LOG;
asm-s390/idals.h:	nr_chunks = (4096 << ib->page_order) >> IDA_SIZE_LOG;
asm-s390/idals.h:		free_pages((unsigned long) ib->data[i], ib->page_order);
asm-s390/idals.h:	return ib->size > (4096 << ib->page_order) ||
asm-s390/idals.h:		idal_is_needed(ib->data[0], ib->size);
asm-s390/idals.h:	return ib->size > (4096 << ib->page_order);
asm-s390/idals.h:		ccw->cda = (u32)(addr_t) ib->data;
asm-s390/idals.h:		ccw->flags |= CCW_FLAG_IDA;
asm-s390/idals.h:		// we do not need idals - use direct addressing
asm-s390/idals.h:		ccw->cda = (u32)(addr_t) ib->data[0];
asm-s390/idals.h:	ccw->count = ib->size;
asm-s390/idals.h:	if (count > ib->size)
asm-s390/idals.h:		left = copy_to_user(to, ib->data[i], IDA_BLOCK_SIZE);
asm-s390/idals.h:			return left + count - IDA_BLOCK_SIZE;
asm-s390/idals.h:		count -= IDA_BLOCK_SIZE;
asm-s390/idals.h:	return copy_to_user(to, ib->data[i], count);
asm-s390/idals.h:	if (count > ib->size)
asm-s390/idals.h:		left = copy_from_user(ib->data[i], from, IDA_BLOCK_SIZE);
asm-s390/idals.h:			return left + count - IDA_BLOCK_SIZE;
asm-s390/idals.h:		count -= IDA_BLOCK_SIZE;
asm-s390/idals.h:	return copy_from_user(ib->data[i], from, count);
asm-s390/param.h: *  include/asm-s390/param.h
asm-s390/param.h: *  Derived from "include/asm-i386/param.h"
asm-s390/param.h:#define NOGROUP		(-1)
asm-s390/gdb-stub.h: *  include/asm-s390/gdb-stub.h
asm-s390/cache.h: *  include/asm-s390/cache.h
asm-s390/cache.h: *  Derived from "include/asm-i386/cache.h"
asm-s390/siginfo.h: *  include/asm-s390/siginfo.h
asm-s390/siginfo.h: *  Derived from "include/asm-i386/siginfo.h"
asm-s390/siginfo.h:#define SI_PAD_SIZE	((SI_MAX_SIZE/sizeof(int)) - 3)
asm-s390/siginfo.h: * Digital reserves positive values for kernel-generated signals.
asm-s390/siginfo.h:#define SI_QUEUE	-1	/* sent by sigqueue */
asm-s390/siginfo.h:#define SI_TIMER __SI_CODE(__SI_TIMER,-2) /* sent by timer expiration */
asm-s390/siginfo.h:#define SI_MESGQ	-3	/* sent by real time mesq state change */
asm-s390/siginfo.h:#define SI_ASYNCIO	-4	/* sent by AIO completion */
asm-s390/siginfo.h:#define SI_SIGIO	-5	/* sent by queued SIGIO */
asm-s390/siginfo.h:#define SI_TKILL	-6	/* sent by tkill system call */
asm-s390/siginfo.h:#define SI_FROMUSER(siptr)	((siptr)->si_code <= 0)
asm-s390/siginfo.h:#define SI_FROMKERNEL(siptr)	((siptr)->si_code > 0)
asm-s390/siginfo.h:#define BUS_ADRERR	(__SI_FAULT|2)	/* non-existant physical address */
asm-s390/siginfo.h:#define SIGEV_PAD_SIZE	((SIGEV_MAX_SIZE/sizeof(int)) - 3)
asm-s390/siginfo.h:	if (from->si_code < 0)
asm-s390/siginfo.h:		memcpy(to, from, 3*sizeof(int) + sizeof(from->_sifields._sigchld));
asm-s390/sockios.h: *  include/asm-s390/sockios.h
asm-s390/sockios.h: *  Derived from "include/asm-i386/sockios.h"
asm-s390/sockios.h:/* Socket-level I/O control calls. */
asm-s390/a.out.h: *  include/asm-s390/a.out.h
asm-s390/a.out.h: *  Derived from "include/asm-i386/a.out.h"
asm-s390/ioctl.h: *  include/asm-s390/ioctl.h
asm-s390/ioctl.h: *  Derived from "include/asm-i386/ioctl.h"
asm-s390/ioctl.h: * NOTE: This limits the max parameter size to 16kB -1 !
asm-s390/ioctl.h:#define _IOC_NRMASK	((1 << _IOC_NRBITS)-1)
asm-s390/ioctl.h:#define _IOC_TYPEMASK	((1 << _IOC_TYPEBITS)-1)
asm-s390/ioctl.h:#define _IOC_SIZEMASK	((1 << _IOC_SIZEBITS)-1)
asm-s390/ioctl.h:#define _IOC_DIRMASK	((1 << _IOC_DIRBITS)-1)
asm-s390/string.h: *  include/asm-s390/string.h
asm-s390/ioctls.h: *  include/asm-s390/ioctls.h
asm-s390/ioctls.h: *  Derived from "include/asm-i386/ioctls.h"
asm-s390/ioctls.h:#define TIOCGPTN	_IOR('T',0x30, unsigned int) /* Get Pty Number (of pty-mux device) */
asm-s390/msgbuf.h: * - 64-bit time_t to solve y2038 problem
asm-s390/msgbuf.h: * - 2 miscellaneous 32-bit values
asm-s390/socket.h: *  include/asm-s390/socket.h
asm-s390/socket.h: *  Derived from "include/asm-i386/socket.h"
asm-s390/socket.h:/* Security levels - as per NRL IPv6 - don't actually do anything */
asm-s390/socket.h:/* Nast libc5 fixup - bletch */
asm-s390/socket.h:#define SOCK_RDM	4		/* reliably-delivered message	*/
asm-s390x/io.h: *  include/asm-s390/io.h
asm-s390x/io.h: *  Derived from "include/asm-i386/io.h"
asm-s390x/io.h:#define page_to_phys(page)	((page - mem_map) << PAGE_SHIFT)
asm-s390x/atomic.h: *  include/asm-s390x/atomic.h
asm-s390x/atomic.h: *  Derived from "include/asm-i386/bitops.h"
asm-s390x/atomic.h:#define atomic_read(v)          ((v)->counter)
asm-s390x/atomic.h:#define atomic_set(v,i)         (((v)->counter) = (i))
asm-s390x/debug.h: *  include/asm-s390/debug.h
asm-s390x/debug.h: * in order to allow a user program to analyze the 'raw'-view.
asm-s390x/debug.h:#define DEBUG_OFF_LEVEL            -1 /* level where debug is switched off */
asm-s390x/debug.h:#define DEBUG_FLUSH_ALL            -1 /* parameter to flush all areas */
asm-s390x/debug.h:	if ((!id) || (level > id->level)) return NULL;
asm-s390x/debug.h:	if ((!id) || (level > id->level)) return NULL;
asm-s390x/debug.h:	if ((!id) || (level > id->level)) return NULL;
asm-s390x/debug.h:	if ((!id) || (level > id->level)) return NULL;
asm-s390x/debug.h:	if ((!id) || (level > id->level)) return NULL;
asm-s390x/debug.h:	if ((!id) || (level > id->level)) return NULL;
asm-s390x/debug.h:	if ((!id) || (level > id->level)) return NULL;
asm-s390x/debug.h:	if ((!id) || (level > id->level)) return NULL;
asm-s390x/debug.h:   - 0 No debugging output to console or syslog
asm-s390x/debug.h:   - 1 Log internal errors to syslog, ignore check conditions 
asm-s390x/debug.h:   - 2 Log internal errors and check conditions to syslog
asm-s390x/debug.h:   - 3 Log internal errors to console, log check conditions to syslog
asm-s390x/debug.h:   - 4 Log internal errors and check conditions to console
asm-s390x/debug.h:   - 5 panic on internal errors, log check conditions to console
asm-s390x/debug.h:   - 6 panic on both, internal errors and check conditions
asm-s390x/delay.h: *  include/asm-s390/delay.h
asm-s390x/delay.h: *  Derived from "include/asm-i386/delay.h"
asm-s390x/ipcbuf.h: * - 32-bit mode_t and seq
asm-s390x/ipcbuf.h: * - 2 miscellaneous 32-bit values
asm-s390x/ucontext.h: *  include/asm-s390/ucontext.h
asm-s390x/ucontext.h: *  Derived from "include/asm-i386/ucontext.h"
asm-s390x/shmbuf.h: * - 2 miscellaneous 32-bit values
asm-s390x/bitops.h: *  include/asm-s390/bitops.h
asm-s390x/bitops.h: *  Derived from "include/asm-i386/bitops.h"
asm-s390x/bitops.h:             "   lghi  %3,-2\n"
asm-s390x/bitops.h:             "   lghi  %3,-2\n"
asm-s390x/bitops.h:             "   lghi  %3,-2\n"
asm-s390x/bitops.h: * fast, non-SMP set_bit routine
asm-s390x/bitops.h: * fast, non-SMP clear_bit routine
asm-s390x/bitops.h: * fast, non-SMP change_bit routine 
asm-s390x/bitops.h: * fast, non-SMP test_and_set_bit routine
asm-s390x/bitops.h: * fast, non-SMP test_and_clear_bit routine
asm-s390x/bitops.h: * fast, non-SMP test_and_change_bit routine
asm-s390x/bitops.h: * Find-bit routines..
asm-s390x/bitops.h:        __asm__("   lghi  %1,-1\n"
asm-s390x/bitops.h:                __asm__("   lhi  %2,-1\n"
asm-s390x/bitops.h:                if (set < (64 - bit))
asm-s390x/bitops.h:                offset += 64 - bit;
asm-s390x/bitops.h:        res = find_first_zero_bit (p, size - 64 * (p - (unsigned long *) addr));
asm-s390x/bitops.h:        __asm__("   lhi  %2,-1\n"
asm-s390x/bitops.h: * of bits set) of a N-bit word
asm-s390x/bitops.h:        __asm__("   lghi  %1,-1\n"
asm-s390x/bitops.h:                "   aghi  %0,-16\n"
asm-s390x/bitops.h:                "   aghi  %0,-8\n"
asm-s390x/bitops.h:			return (p - addr)*64 + res;
asm-s390x/bitops.h:        res = ext2_find_first_zero_bit (p, size - 64 * (p - addr));
asm-s390x/bitops.h:        return (p - addr) * 64 + res;
asm-s390x/resource.h: *  include/asm-s390/resource.h
asm-s390x/resource.h: *  Derived from "include/asm-i386/resources.h"
asm-s390x/resource.h:#define RLIMIT_MEMLOCK	8		/* max locked-in-memory address space */
asm-s390x/ptrace.h: *  include/asm-s390/ptrace.h
asm-s390x/ptrace.h:#define PT_ENDREGS  0x1B0-1
asm-s390x/ptrace.h: * gdb/hppab-nat.c
asm-s390x/ptrace.h:#define user_mode(regs) (((regs)->psw.mask & PSW_PROBLEM_STATE) != 0)
asm-s390x/ptrace.h:#define instruction_pointer(regs) ((regs)->psw.addr)
asm-s390x/pgalloc.h: *  include/asm-s390/pgalloc.h
asm-s390x/pgalloc.h: *  Derived from "include/asm-i386/pgalloc.h"
asm-s390x/pgalloc.h: * used to allocate a kernel page table - this turns on ASN bits
asm-s390x/pgalloc.h:		pgtable_cache_size -= 2;
asm-s390x/pgalloc.h:		pgtable_cache_size -= 2;
asm-s390x/pgalloc.h:	if (test_bit(PG_arch_1, &virt_to_page(pmd)->flags) == 0) {
asm-s390x/pgalloc.h:                pgtable_cache_size--;
asm-s390x/pgalloc.h: * vmalloc call).  Since s390-esame uses a separate kernel page table,
asm-s390x/pgalloc.h: *  - flush_tlb() flushes the current mm struct TLBs
asm-s390x/pgalloc.h: *  - flush_tlb_all() flushes all processes TLBs 
asm-s390x/pgalloc.h: *  - flush_tlb_mm(mm) flushes the specified mm context TLB's
asm-s390x/pgalloc.h: *  - flush_tlb_page(vma, vmaddr) flushes one page
asm-s390x/pgalloc.h: *  - flush_tlb_range(mm, start, end) flushes a range of pages
asm-s390x/pgalloc.h: *  - flush_tlb_pgtables(mm, start, end) flushes a range of page tables
asm-s390x/pgalloc.h: * If we have threads (mm->count > 1) we always do a global flush, 
asm-s390x/pgalloc.h:	if (mm->cpu_vm_mask != (1UL << smp_processor_id())) {
asm-s390x/pgalloc.h:		if (mm == current->active_mm &&
asm-s390x/pgalloc.h:		    atomic_read(&mm->mm_users) == 1)
asm-s390x/pgalloc.h:			mm->cpu_vm_mask = 1UL << smp_processor_id();
asm-s390x/pgalloc.h:	__flush_tlb_mm(current->mm);
asm-s390x/pgalloc.h:	__flush_tlb_mm(vma->vm_mm);
asm-s390x/unistd.h: *  include/asm-s390/unistd.h
asm-s390x/unistd.h: *  Derived from "include/asm-i386/unistd.h"
asm-s390x/unistd.h: * Numbers 224-235 are reserved for posix acl
asm-s390x/unistd.h:/* user-visible error numbers are in the range -1 - -122: see <asm-s390/errno.h> */
asm-s390x/unistd.h:        if ((unsigned long)(res) >= (unsigned long)(-125)) { \
asm-s390x/unistd.h:                errno = -(res);                              \
asm-s390x/unistd.h:                res = -1;                                    \
asm-s390x/unistd.h: * we need this inline - forking from kernel space will result
asm-s390x/unistd.h: * calls - which means inline code for fork too, as otherwise we
asm-s390x/unistd.h:        return waitpid(-1,wait_stat,0);
asm-s390x/dma.h: *  include/asm-s390x/dma.h
asm-s390x/elf.h: *  include/asm-s390/elf.h
asm-s390x/elf.h: *  Derived from "include/asm-i386/elf.h"
asm-s390x/elf.h:        (((x)->e_machine == EM_S390 || (x)->e_machine == EM_S390_OLD) \
asm-s390x/elf.h:         && (x)->e_ident[EI_CLASS] == ELF_CLASS)
asm-s390x/elf.h:	_r->gprs[14] = 0; \
asm-s390x/elf.h:	current->thread.flags = 0; \
asm-s390x/elf.h:	else if (current->personality != PER_LINUX32)	\
asm-s390x/ide.h: *  linux/include/asm-arm/ide.h
asm-s390x/ide.h: *  Copyright (C) 1994-1996  Linus Torvalds & authors
asm-s390x/ipc.h: *  include/asm-s390/ipc.h
asm-s390x/ipc.h: *  Derived from "include/asm-i386/ipc.h"
asm-s390x/irq.h:#define INVALID_STORAGE_AREA ((void *)(-1 - 0x3FFF ))
asm-s390x/irq.h:      __u32 mme  : 2;     /* measurement-mode enable */
asm-s390x/irq.h:      __u16 mbi;          /* measurement-block index */
asm-s390x/irq.h:      __u8  chpid[8];     /* CHPID 0-7 (if available) */
asm-s390x/irq.h:      __u32 isic : 1; /* initial-status interruption control */
asm-s390x/irq.h:      __u32 alcc : 1; /* address-limit checking control */
asm-s390x/irq.h:      __u32 ssi  : 1; /* supress-suspended interruption */
asm-s390x/irq.h:      __u32 isic : 1; /* initial-status-interruption control */
asm-s390x/irq.h:      __u32 alcc : 1; /* address-limit-checking control */
asm-s390x/irq.h:      __u32 ssic : 1; /* suppress-suspended-interr. control */
asm-s390x/irq.h:      __u32 pvrf  : 1;  /* path-verification-required flag */
asm-s390x/irq.h:      __u32 cpt   : 1;  /* channel-path timeout */
asm-s390x/irq.h:      __u32 cons  : 1;  /* concurrent-sense */
asm-s390x/irq.h:      __u32 fvf   : 5;  /* field-validity flags */
asm-s390x/irq.h:      __u32 devsc : 1;  /* device-status check */
asm-s390x/irq.h:      __u32 ioerr : 1;  /* i/o-error alert */
asm-s390x/irq.h:      __u16 dcti;     /* device-connect-time interval */
asm-s390x/irq.h:// sense-id response buffer layout
asm-s390x/irq.h:				/* word 6-102 */
asm-s390x/irq.h:				__u32 ccdf[96];   /* content-code dependent field */
asm-s390x/irq.h:				/* words 4-5 */
asm-s390x/irq.h:				__u8 chpid[8];    /* chpids 0-7 */
asm-s390x/irq.h:				/* words 6-9 */
asm-s390x/irq.h:				__u16 fla[8];     /* full link addresses 0-7 */
asm-s390x/irq.h:				/* words 10-102 */
asm-s390x/irq.h:     __u8          cstat;    /* channel status - accumulated */
asm-s390x/irq.h:     __u8          dstat;    /* device status - accumulated */
asm-s390x/irq.h:     __u8          unused;   /* not used - reserved */
asm-s390x/irq.h: *  IRQ handler is called, either immediately, delayed (dev-end missing,
asm-s390x/irq.h: *  or sense required) or never (no IRQ handler registered -
asm-s390x/irq.h: *  taken, do_IO() returns :  0      - Success
asm-s390x/irq.h: *                           -EIO    - Status pending
asm-s390x/irq.h: *                                        see : action->dev_id->cstat
asm-s390x/irq.h: *                                              action->dev_id->dstat
asm-s390x/irq.h: *                           -EBUSY  - Device busy
asm-s390x/irq.h: *                           -ENODEV - Device not operational
asm-s390x/irq.h:int get_dev_info( int irq, s390_dev_info_t *);   /* to be eliminated - don't use */
asm-s390x/irq.h: * Various low-level irq details needed by irq.c, process.c,
asm-s390x/irq.h:#define irq_exit(cpu, irq)      (--local_irq_count(cpu))
asm-s390x/irq.h:        if (prof_buffer && current->pid) {
asm-s390x/irq.h:                addr -= (unsigned long) &_stext;
asm-s390x/irq.h:                 * Don't ignore out-of-bounds EIP values silently,
asm-s390x/irq.h:                if (addr > prof_len-1)
asm-s390x/irq.h:                        addr = prof_len-1;
asm-s390x/irq.h:#define get_irq_lock(irq) &ioinfo[irq]->irq_lock
asm-s390x/irq.h:        spin_lock(&(ioinfo[irq]->irq_lock))
asm-s390x/irq.h:        spin_unlock(&(ioinfo[irq]->irq_lock))
asm-s390x/irq.h:        spin_lock_irqsave(&(ioinfo[irq]->irq_lock), flags)
asm-s390x/irq.h:        spin_unlock_irqrestore(&(ioinfo[irq]->irq_lock), flags)
asm-s390x/smp.h: *  include/asm-s390/smp.h
asm-s390x/smp.h:#define smp_processor_id() (current->processor)
asm-s390x/tlb.h:#include <asm-generic/tlb.h>
asm-s390x/queue.h: *  include/asm-s390/queue.h
asm-s390x/queue.h:		queue *tail=qhead->tail;
asm-s390x/queue.h:			tail->next=member;
asm-s390x/queue.h:			qhead->head=member;
asm-s390x/queue.h:		qhead->tail=member;
asm-s390x/queue.h:		member->next=NULL;
asm-s390x/queue.h:	queue *head=qhead->head,*next_head;
asm-s390x/queue.h:		next_head=head->next;
asm-s390x/queue.h:		qhead->head=next_head;
asm-s390x/queue.h:			qhead->tail=NULL;
asm-s390x/queue.h:	member->next=*lhead;
asm-s390x/queue.h:		*lhead=(*lhead)->next;
asm-s390x/queue.h:		for(curr=(*lhead)->next;curr!=NULL;curr=curr->next)
asm-s390x/queue.h:		prev->next=member;
asm-s390x/queue.h:	member->next=NULL;
asm-s390x/queue.h:	for(curr=lhead;curr!=NULL;curr=curr->next)
asm-s390x/queue.h:	for(curr=lhead;curr!=NULL;curr=curr->next)
asm-s390x/queue.h:			prev->next=member->next;
asm-s390x/queue.h:			*lhead=member->next;
asm-s390x/queue.h:	if(get_prev(qhead->head,(list *)member,(list **)&prev))
asm-s390x/queue.h:			prev->next=member->next;
asm-s390x/queue.h:			if(prev->next==NULL)
asm-s390x/queue.h:				qhead->tail=prev;
asm-s390x/queue.h:			if(qhead->head==qhead->tail)
asm-s390x/queue.h:				qhead->tail=NULL;
asm-s390x/queue.h:			qhead->head=member->next;
asm-s390x/s390_ext.h: *  include/asm-s390/s390_ext.h
asm-s390x/xor.h:#include <asm-generic/xor.h>
asm-s390x/signal.h: *  include/asm-s390/signal.h
asm-s390x/signal.h: *  Derived from "include/asm-i386/signal.h"
asm-s390x/signal.h:#define SIGRTMAX        (_NSIG-1)
asm-s390x/signal.h: * SA_INTERRUPT is a no-op, but left due to historical reasons. Use the
asm-s390x/signal.h:#define SA_INTERRUPT    0x20000000 /* dummy -- ignored */
asm-s390x/signal.h:#define SIG_ERR ((__sighandler_t)-1)    /* error return from signal */
asm-s390x/ioctl32.h: * include/asm-s390/ioctl32.h
asm-s390x/ioctl32.h: * include/asm-s390x/ioctl32.h
asm-s390x/setup.h: *  include/asm-s390/setup.h
asm-s390x/chandev.h: *  include/asm-s390/chandev.h
asm-s390x/chandev.h:	u8      chpid[8];     /* CHPID 0-7 (if available) */
asm-s390x/chandev.h:	/* buffers -1 means use the driver default the driver should set this field to the */
asm-s390x/chandev.h:/* devif_num=-1 implies don't care,0 implies tr0, info used by chandev_initnetdevice */
asm-s390x/chandev.h: * I subsequently found that reprobing failed in certain cases :-(,
asm-s390x/chandev.h: * This returns the number of devices found or -ENOMEM if the code didn't
asm-s390x/chandev.h: * or -EPERM if a duplicate entry is found.
asm-s390x/hardirq.h: *  include/asm-s390/hardirq.h
asm-s390x/hardirq.h: *  Derived from "include/asm-i386/hardirq.h"
asm-s390x/hardirq.h:#define hardirq_exit(cpu)	(local_irq_count(cpu)--)
asm-s390x/hardirq.h:        --local_irq_count(cpu);
asm-s390x/shmparam.h: *  include/asm-s390/shmparam.h
asm-s390x/shmparam.h: *  Derived from "include/asm-i386/shmparam.h"
asm-s390x/sigcontext.h: *  include/asm-s390/sigcontext.h
asm-s390x/processor.h: *  include/asm-s390/processor.h
asm-s390x/processor.h: *  Derived from "include/asm-i386/processor.h"
asm-s390x/processor.h:/* Lazy FPU handling on uni-processor */
asm-s390x/processor.h:#define TASK_UNMAPPED_BASE      ((current->thread.flags & S390_FLAG_31BIT) ? \
asm-s390x/processor.h:        addr_t  prot_addr;             /* address of protection-excep.     */
asm-s390x/processor.h:        __u32   error_code;            /* error-code of last prog-excep.   */
asm-s390x/processor.h:        regs->psw.mask  = _USER_PSW_MASK;                       \
asm-s390x/processor.h:        regs->psw.addr  = new_psw;                              \
asm-s390x/processor.h:        regs->gprs[15]  = new_stackp;                           \
asm-s390x/processor.h:	regs->psw.mask  = _USER_PSW_MASK & ~(1L << 32);		\
asm-s390x/processor.h:        regs->psw.addr  = new_psw;                              \
asm-s390x/processor.h:        regs->gprs[15]  = new_stackp;                           \
asm-s390x/processor.h: * just stores the registers %r6-%r15 to the frame given by
asm-s390x/processor.h:	bc = *((unsigned long *) t->ksp);
asm-s390x/processor.h:        (((unsigned long) tsk + THREAD_SIZE - sizeof(struct pt_regs)) & -8L))
asm-s390x/processor.h:#define KSTK_EIP(tsk)	(__KSTK_PTREGS(tsk)->psw.addr)
asm-s390x/processor.h:#define KSTK_ESP(tsk)	(__KSTK_PTREGS(tsk)->gprs[15])
asm-s390x/processor.h:        psw_t *dw_psw = (psw_t *)(((unsigned long) &psw_buffer+sizeof(psw_t)-1)
asm-s390x/processor.h:                                  & -sizeof(psw_t));
asm-s390x/processor.h:        dw_psw->mask = 0x0002000180000000;
asm-s390x/processor.h:        dw_psw->addr = code;
asm-s390x/mmu_context.h: *  include/asm-s390/mmu_context.h
asm-s390x/mmu_context.h: *  Derived from "include/asm-i386/mmu_context.h"
asm-s390x/mmu_context.h:                pgd = (__pa(next->pgd)&PAGE_MASK) | (_REGION_TABLE|USER_STD_MASK);
asm-s390x/mmu_context.h:	set_bit(cpu, &next->cpu_vm_mask);
asm-s390x/semaphore.h: *  include/asm-s390/semaphore.h
asm-s390x/semaphore.h: *  Derived from "include/asm-i386/semaphore.h"
asm-s390x/semaphore.h:	if (atomic_dec_return(&sem->count) < 0)
asm-s390x/semaphore.h:	if (atomic_dec_return(&sem->count) < 0)
asm-s390x/semaphore.h:	if (atomic_dec_return(&sem->count) < 0)
asm-s390x/semaphore.h:	if (atomic_inc_return(&sem->count) <= 0)
asm-s390x/semaphore.h:	return atomic_read(&sem->count);
asm-s390x/fcntl.h: *  include/asm-s390/fcntl.h
asm-s390x/fcntl.h: *  Derived from "include/asm-i386/fcntl.h"
asm-s390x/fcntl.h:/* open/fcntl - O_SYNC is only implemented on blocks devices and on files
asm-s390x/fcntl.h:#define F_GETFL		3	/* get file->f_flags */
asm-s390x/fcntl.h:#define F_SETFL		4	/* set file->f_flags */
asm-s390x/s390mach.h:	__u32   pd              :  1; /* 01 instruction-processing damage */
asm-s390x/s390mach.h:	__u32   to_be_defined_1 :  4; /* 03-06 */
asm-s390x/s390mach.h:	__u32   cp              :  1; /* 09 channel-report pending */
asm-s390x/s390mach.h:	__u32   to_be_defined_2 :  6; /* 10-15 */
asm-s390x/s390mach.h:	__u32   ke              :  1; /* 18 storage-key error uncorrected */
asm-s390x/s390mach.h:	__u32	to_be_defined_3 :  4; /* 20-23 */
asm-s390x/s390mach.h:	__u32   to_be_defined_4 :  7; /* 25-31 */
asm-s390x/s390mach.h:	__u32	to_be_defined_5 : 31; /* 33-63 */
asm-s390x/s390mach.h:// machine-check-interruption code
asm-s390x/s390mach.h:      __u64 mcl;	/* machine check int. code - long info */	
asm-s390x/s390mach.h:      mci_t mcd;  /* machine check int. code - details   */
asm-s390x/s390mach.h:	__u32 erc     :  6;   /* error-recovery code */
asm-s390x/s390mach.h:	__u32 rsid    : 16;   /* reporting-source ID */
asm-s390x/s390mach.h:#define CRW_RSC_CONFIG   0x9  /* configuration-alert facility */
asm-s390x/rwsem.h: *  include/asm-s390x/rwsem.h
asm-s390x/rwsem.h: *  Based on asm-alpha/semaphore.h and asm-i386/rwsem.h
asm-s390x/rwsem.h: * This should be totally fair - if anything is waiting, a process that wants a
asm-s390x/rwsem.h:#define RWSEM_WAITING_BIAS	(-0x0000000100000000L)
asm-s390x/rwsem.h:	sem->count = RWSEM_UNLOCKED_VALUE;
asm-s390x/rwsem.h:	spin_lock_init(&sem->wait_lock);
asm-s390x/rwsem.h:	INIT_LIST_HEAD(&sem->wait_list);
asm-s390x/rwsem.h:		: "a" (&sem->count), "i" (RWSEM_ACTIVE_READ_BIAS)
asm-s390x/rwsem.h: * trylock for reading -- returns 1 if successful, 0 if contention
asm-s390x/rwsem.h:		: "a" (&sem->count), "i" (RWSEM_ACTIVE_READ_BIAS)
asm-s390x/rwsem.h:		: "a" (&sem->count), "m" (tmp)
asm-s390x/rwsem.h: * trylock for writing -- returns 1 if successful, 0 if contention
asm-s390x/rwsem.h:		: "a" (&sem->count), "d" (RWSEM_ACTIVE_WRITE_BIAS)
asm-s390x/rwsem.h:		: "a" (&sem->count), "i" (-RWSEM_ACTIVE_READ_BIAS)
asm-s390x/rwsem.h:	tmp = -RWSEM_ACTIVE_WRITE_BIAS;
asm-s390x/rwsem.h:		: "a" (&sem->count), "m" (tmp)
asm-s390x/rwsem.h:		: "a" (&sem->count), "d" (delta)
asm-s390x/rwsem.h:		: "a" (&sem->count), "d" (delta)
asm-s390x/spinlock.h: *  include/asm-s390/spinlock.h
asm-s390x/spinlock.h: *  Derived from "include/asm-i386/spinlock.h"
asm-s390x/spinlock.h:#define spin_lock_init(lp) do { (lp)->lock = 0; } while(0)
asm-s390x/spinlock.h:#define spin_unlock_wait(lp)	do { barrier(); } while(((volatile spinlock_t *)(lp))->lock)
asm-s390x/spinlock.h:#define spin_is_locked(x) ((x)->lock != 0)
asm-s390x/spinlock.h:                           : "a" (&lp->lock), "i" (__DIAG44_OPERAND)
asm-s390x/spinlock.h:			   : "a" (&lp->lock) : "cc", "memory" );
asm-s390x/spinlock.h:			   : : "a" (&lp->lock) : "memory", "cc" );
asm-s390x/spinlock.h: * Read-write spinlocks, allowing multiple readers
asm-s390x/spinlock.h: * can "mix" irq-safe locks - any writer needs to get a
asm-s390x/spinlock.h: * irq-safe write-lock, but readers can get non-irqsafe
asm-s390x/spinlock.h: * read-locks.
asm-s390x/spinlock.h:                     : : "a" (&(rw)->lock), "i" (__DIAG44_OPERAND) \
asm-s390x/spinlock.h:                     : : "a" (&(rw)->lock), "i" (__DIAG44_OPERAND) \
asm-s390x/spinlock.h:                     : : "a" (&(rw)->lock), "i" (__DIAG44_OPERAND) \
asm-s390x/spinlock.h:                     : : "a" (&(rw)->lock), "i" (__DIAG44_OPERAND) \
asm-s390x/errno.h: *  include/asm-s390/errno.h
asm-s390x/errno.h: *  Derived from "include/asm-i386/errno.h"
asm-s390x/errno.h:#define	EXDEV		18	/* Cross-device link */
asm-s390x/errno.h:#define	EROFS		30	/* Read-only file system */
asm-s390x/errno.h:#define	ENOTSOCK	88	/* Socket operation on non-socket */
asm-s390x/byteorder.h: *  include/asm-s390/byteorder.h
asm-s390x/softirq.h: *  include/asm-s390/softirq.h
asm-s390x/softirq.h: *  Derived from "include/asm-i386/softirq.h"
asm-s390x/softirq.h:                do { barrier(); local_bh_count(cpu)--; } while (0)
asm-s390x/softirq.h:        if (!--*ptr)							\
asm-s390x/timex.h: *  include/asm-s390/timex.h
asm-s390x/timex.h: *  Derived from "include/asm-i386/timex.h"
asm-s390x/timex.h:#define FINETUNE ((((((long)LATCH * HZ - CLOCK_TICK_RATE) << SHIFT_HZ) * \
asm-s390x/timex.h:		<< (SHIFT_SCALE-SHIFT_HZ)) / HZ)
asm-s390x/bugs.h: *  include/asm-s390/bugs.h
asm-s390x/bugs.h: *  Derived from "include/asm-i386/bugs.h"
asm-s390x/bugs.h: * This is included by init/main.c to check for architecture-dependent bugs.
asm-s390x/namei.h: *  include/asm-s390/namei.h
asm-s390x/namei.h: *  Derived from "include/asm-i386/namei.h"
asm-s390x/namei.h: * Look at asm-sparc/namei.h for details.
asm-s390x/dasd.h: * to userspace by the DASDAPIVER-ioctl
asm-s390x/dasd.h: * 12/06/01 DASD_API_VERSION 2 - binary compatible to 0 (new BIODASDINFO2)
asm-s390x/dasd.h: * 01/23/02 DASD_API_VERSION 3 - added BIODASDPSRD IOCTL
asm-s390x/dasd.h: * 02/15/02 DASD_API_VERSION 4 - added BIODASDSATTR IOCTL
asm-s390x/dasd.h: * 06/07/02 DASD_API_VERSION 5 - added 'boxed DASD' support
asm-s390x/dasd.h: * Read Subsystem Data - Perfomance Statistics
asm-s390x/dasd.h: * Here ist how the ioctl-nr should be used:
asm-s390x/dasd.h: *    0 -   31   DASD driver itself
asm-s390x/dasd.h: *   32 -  239   still open
asm-s390x/dasd.h: *  240 -  255   reserved for EMC 
asm-s390x/dasd.h: * ---------------------------------------------------------------------------
asm-s390x/dasd.h: * c-indent-level: 4 
asm-s390x/dasd.h: * c-brace-imaginary-offset: 0
asm-s390x/dasd.h: * c-brace-offset: -4
asm-s390x/dasd.h: * c-argdecl-indent: 4
asm-s390x/dasd.h: * c-label-offset: -4
asm-s390x/dasd.h: * c-continued-statement-offset: 4
asm-s390x/dasd.h: * c-continued-brace-offset: 0
asm-s390x/dasd.h: * indent-tabs-mode: nil
asm-s390x/dasd.h: * tab-width: 8
asm-s390x/termbits.h: *  include/asm-s390/termbits.h
asm-s390x/termbits.h: *  Derived from "include/asm-i386/termbits.h"
asm-s390x/ccwcache.h: * File...........: linux/include/asm-s390/ccwcache.h
asm-s390x/ccwcache.h:	unsigned long long buildclk;	/* TOD-clock of request generation */
asm-s390x/ccwcache.h:	unsigned long long startclk;	/* TOD-clock of request start */
asm-s390x/ccwcache.h:	unsigned long long stopclk;	/* TOD-clock of request interrupt */
asm-s390x/ccwcache.h:	unsigned long long endclk;	/* TOD-clock of request termination */
asm-s390x/ccwcache.h: * ccw_req_t -> status can be:
asm-s390x/init.h: *  include/asm-s390/init.h
asm-s390x/uaccess.h: *  include/asm-s390/uaccess.h
asm-s390x/uaccess.h: *  Derived from "include/asm-i386/uaccess.h"
asm-s390x/uaccess.h:#define get_fs()	(current->addr_limit)
asm-s390x/uaccess.h:                          current->addr_limit = (x);})
asm-s390x/uaccess.h:        return access_ok(type,addr,size)?0:-EFAULT;
asm-s390x/uaccess.h: * These are the main single-value transfer routines.  They automatically
asm-s390x/uaccess.h:                                : "d" (x), "K" (-EFAULT)
asm-s390x/uaccess.h:                                : "d" (x), "K" (-EFAULT)
asm-s390x/uaccess.h:                                : "d" (x), "K" (-EFAULT)
asm-s390x/uaccess.h:                                : "d" (x), "K" (-EFAULT)
asm-s390x/uaccess.h:                                : "m" (*(const __u64*)(ptr)),"K" (-EFAULT) \
asm-s390x/uaccess.h:                                : "m" (*(const __u32*)(ptr)),"K" (-EFAULT) \
asm-s390x/uaccess.h:                                : "m" (*(const __u16*)(ptr)),"K" (-EFAULT) \
asm-s390x/uaccess.h:                                : "m" (*(const __u8*)(ptr)),"K" (-EFAULT) \
asm-s390x/uaccess.h:                                  "K" (-EFAULT)
asm-s390x/uaccess.h:        long res = -EFAULT;
asm-s390x/mman.h: *  include/asm-s390/mman.h
asm-s390x/mman.h: *  Derived from "include/asm-i386/mman.h"
asm-s390x/mman.h:#define MAP_GROWSDOWN	0x0100		/* stack-like segment */
asm-s390x/mman.h:#define MADV_NORMAL    0x0              /* default page-in behavior */
asm-s390x/mman.h:#define MADV_RANDOM    0x1              /* page-in minimum required */
asm-s390x/mman.h:#define MADV_SEQUENTIAL        0x2             /* read-ahead aggressively */
asm-s390x/mman.h:#define MADV_WILLNEED  0x3              /* pre-fault pages */
asm-s390x/posix_types.h: *  include/asm-s390/posix_types.h
asm-s390x/posix_types.h: *  Derived from "include/asm-i386/posix_types.h"
asm-s390x/posix_types.h: * This file is generally used by user-level software, so you need to
asm-s390x/smplock.h: *  include/asm-s390/smplock.h
asm-s390x/smplock.h: *  Derived from "include/asm-i386/smplock.h"
asm-s390x/smplock.h:	if (task->lock_depth >= 0)         \
asm-s390x/smplock.h: * Re-acquire the kernel lock
asm-s390x/smplock.h:	if (task->lock_depth >= 0)         \
asm-s390x/smplock.h:        if (!++current->lock_depth)
asm-s390x/smplock.h:        if (--current->lock_depth < 0)
asm-s390x/page.h: *  include/asm-s390/page.h
asm-s390x/page.h:#define PAGE_MASK       (~(PAGE_SIZE-1))
asm-s390x/page.h:        size = (size-1) >> (PAGE_SHIFT-1);
asm-s390x/page.h:        order = -1;
asm-s390x/page.h: * These are used to make use of C type-checking..
asm-s390x/page.h:	unsigned long *pgd_slot = (unsigned long *) (addr & -8);
asm-s390x/page.h:#define PAGE_ALIGN(addr)        (((addr)+PAGE_SIZE-1)&PAGE_MASK)
asm-s390x/page.h:#define VALID_PAGE(page)	((page - mem_map) < max_mapnr)
asm-s390x/lowcore.h: *  include/asm-s390/lowcore.h
asm-s390x/lowcore.h:	__u8         pad1[0x80-0x18];          /* 0x018 */
asm-s390x/lowcore.h:	__u8         pad2[0xA8-0xA4];          /* 0x0a4 */
asm-s390x/lowcore.h:	__u8         pad3[0xc8-0xc4];          /* 0x0c4 */
asm-s390x/lowcore.h:	__u8         pad4[0xe8-0xcc];          /* 0x0cc */
asm-s390x/lowcore.h:	__u8         pad5[0xf4-0xf0];          /* 0x0f0 */
asm-s390x/lowcore.h:	__u8         pad6[0x120-0x100];        /* 0x100 */
asm-s390x/lowcore.h:	__u8         pad7[0x1a0-0x180];        /* 0x180 */
asm-s390x/lowcore.h:        __u8         pad8[0xc00-0x218];        /* 0x218 */
asm-s390x/lowcore.h:        __u8         pad9[0xd40-0xc80];        /* 0xc80 */
asm-s390x/lowcore.h:	__u8         pad10[0xd80-0xd50];       /* 0xd64 */
asm-s390x/lowcore.h:        __u8         pad12[0xe00-0xdd8];       /* 0xdd8 */
asm-s390x/lowcore.h:	__u8         pad13[0x1200-0xe04];      /* 0xe04 */
asm-s390x/lowcore.h:	__u8         pad14[0x1318-0x1310];      /* 0x1310 */
asm-s390x/lowcore.h:	__u8         pad15[0x1324-0x1320];      /* 0x1320 */
asm-s390x/lowcore.h:	__u8         pad16[0x1340-0x1338];      /* 0x1338 */ 
asm-s390x/lowcore.h:	__u8         pad17[0x2000-0x1400];      /* 0x1400 */
asm-s390x/s390io.h:           unsigned int  unknown   : 1;  /* unknown device - if SenseID failed */
asm-s390x/s390io.h:           unsigned int  unused    : (sizeof(unsigned int)*8 - 26); /* unused */
asm-s390x/hdreg.h: *  linux/include/asm-arm/hdreg.h
asm-s390x/hdreg.h: *  Copyright (C) 1994-1996  Linus Torvalds & authors
asm-s390x/qdio.h:#define QDIO_MAX_BUFFERS_PER_Q 128 /* must be a power of 2 (%x=&(x-1)*/
asm-s390x/qdio.h:/* unfortunately this can't be (QDIO_MAX_BUFFERS_PER_Q*4/3) or so -- as
asm-s390x/qdio.h:#define QDIO_IRQ_STATE_FRESH 0 /* must be 0 -> memset has set it to 0 */
asm-s390x/qdio.h:#define QDIO_DBF_TRACE_LEVEL 4 /* -------- could be even more verbose here */
asm-s390x/qdio.h: * QDIO device commands returned by extended Sense-ID
asm-s390x/qdio.h: * additional CIWs returned by extended Sense-ID
asm-s390x/qdio.h:	unsigned long sliba;            /* storage-list-information-block
asm-s390x/qdio.h:	unsigned long sla;              /* storage-list address */
asm-s390x/qdio.h:	unsigned long slsba;            /* storage-list-state-block address */
asm-s390x/qdio.h: * Queue-Description record (QDR)
asm-s390x/qdio.h:	unsigned int  iqdcnt  :  8;     /* input-queue-descriptor count */
asm-s390x/qdio.h:	unsigned int  oqdcnt  :  8;     /* output-queue-descriptor count */
asm-s390x/qdio.h:	unsigned int  iqdsz   :  8;     /* input-queue-descriptor size */
asm-s390x/qdio.h:	unsigned int  oqdsz   :  8;     /* output-queue-descriptor size */
asm-s390x/qdio.h:	unsigned long qiba;             /* queue-information-block address */
asm-s390x/qdio.h:	unsigned int  qkey    :  4;     /* queue-informatio-block key */
asm-s390x/qdio.h: * storage-list-information block element (SLIBE)
asm-s390x/qdio.h: * storage-list-information block (SLIB)
asm-s390x/qdio.h:	unsigned char sbtype: 2;   /* storage-block type (FCP) */
asm-s390x/qdio.h: * strorage-block access-list (SBAL)
asm-s390x/qdio.h: * storage-list (SL)
asm-s390x/qdio.h: * storage-list-state block (SLSB)
asm-s390x/qdio.h:				/* word 12-1015 */
asm-s390x/qdio.h:				/* word 7-1015 */
asm-s390x/poll.h: *  include/asm-s390/poll.h
asm-s390x/poll.h: *  Derived from "include/asm-i386/poll.h"
asm-s390x/poll.h:/* The rest seem to be more-or-less nonstandard. Check them! */
asm-s390x/ebcdic.h: *  include/asm-s390/ebcdic.h
asm-s390x/ebcdic.h: *    EBCDIC -> ASCII, ASCII -> EBCDIC conversion routines.
asm-s390x/ebcdic.h:extern __u8 _ascebc_500[];   /* ASCII -> EBCDIC 500 conversion table */
asm-s390x/ebcdic.h:extern __u8 _ebcasc_500[];   /* EBCDIC 500 -> ASCII conversion table */
asm-s390x/ebcdic.h:extern __u8 _ascebc[];   /* ASCII -> EBCDIC conversion table */
asm-s390x/ebcdic.h:extern __u8 _ebcasc[];   /* EBCDIC -> ASCII conversion table */
asm-s390x/ebcdic.h:extern __u8 _ebc_tolower[]; /* EBCDIC -> lowercase */
asm-s390x/ebcdic.h:extern __u8 _ebc_toupper[]; /* EBCDIC -> uppercase */
asm-s390x/ebcdic.h:	if (nr-- <= 0)
asm-s390x/ebcdic.h:		"1: ahi   %1,-256\n"
asm-s390x/current.h: *  include/asm-s390/current.h
asm-s390x/current.h: *  Derived from "include/asm-i386/current.h"
asm-s390x/current.h:        __asm__("lghi  %0,-16384\n\t"
asm-s390x/types.h: *  include/asm-s390/types.h
asm-s390x/types.h: *  Derived from "include/asm-i386/types.h"
asm-s390x/sembuf.h: * - 2 miscellaneous 32-bit values
asm-s390x/sigp.h: *  include/asm-s390/sigp.h
asm-s390x/system.h: *  include/asm-s390/system.h
asm-s390x/system.h: *  Derived from "include/asm-i386/system.h"
asm-s390x/system.h:	save_fp_regs(&prev->thread.fp_regs);                                 \
asm-s390x/system.h:	restore_fp_regs(&next->thread.fp_regs);              		     \
asm-s390x/system.h: * all memory ops have completed wrt other CPU's ( see 7-15 POP  DJB ).
asm-s390x/stat.h: *  include/asm-s390x/stat.h
asm-s390x/stat.h: *  Derived from "include/asm-i386/stat.h"
asm-s390x/checksum.h: *  include/asm-s390/checksum.h
asm-s390x/checksum.h: * and adds in "sum" (32-bit)
asm-s390x/checksum.h: * returns a 32-bit number suitable for feeding into itself
asm-s390x/checksum.h: * it's best to have buff aligned on a 32-bit boundary
asm-s390x/checksum.h: * here even more important to align src and dst on a 32-bit (or even
asm-s390x/checksum.h: * better 64-bit) boundary
asm-s390x/checksum.h: * here even more important to align src and dst on a 32-bit (or even
asm-s390x/checksum.h: * better 64-bit) boundary
asm-s390x/checksum.h:		memset(dst + len - missing, 0, missing);
asm-s390x/checksum.h:		*err_ptr = -EFAULT;
asm-s390x/checksum.h: * computes the checksum of the TCP/UDP pseudo-header
asm-s390x/checksum.h: * returns a 32-bit checksum
asm-s390x/checksum.h: * computes the checksum of the TCP/UDP pseudo-header
asm-s390x/checksum.h: * returns a 16-bit checksum, already complemented
asm-s390x/checksum.h: * this routine is used for miscellaneous IP-like checksums, mainly
asm-s390x/termios.h: *  include/asm-s390/termios.h
asm-s390x/termios.h: *  Derived from "include/asm-i386/termios.h"
asm-s390x/termios.h:#define N_IRDA		11	/* Linux IR - http://irda.sourceforge.net/ */
asm-s390x/termios.h:#define N_SMSBLOCK	12	/* SMS block mode - for talking to GSM data cards about SMS messages */
asm-s390x/termios.h:        get_user(tmp, &(termio)->c_iflag); \
asm-s390x/termios.h:        (termios)->c_iflag = (0xffff0000 & ((termios)->c_iflag)) | tmp; \
asm-s390x/termios.h:        get_user(tmp, &(termio)->c_oflag); \
asm-s390x/termios.h:        (termios)->c_oflag = (0xffff0000 & ((termios)->c_oflag)) | tmp; \
asm-s390x/termios.h:        get_user(tmp, &(termio)->c_cflag); \
asm-s390x/termios.h:        (termios)->c_cflag = (0xffff0000 & ((termios)->c_cflag)) | tmp; \
asm-s390x/termios.h:        get_user(tmp, &(termio)->c_lflag); \
asm-s390x/termios.h:        (termios)->c_lflag = (0xffff0000 & ((termios)->c_lflag)) | tmp; \
asm-s390x/termios.h:        get_user((termios)->c_line, &(termio)->c_line); \
asm-s390x/termios.h:	copy_from_user((termios)->c_cc, (termio)->c_cc, NCC); \
asm-s390x/termios.h:	put_user((termios)->c_iflag, &(termio)->c_iflag); \
asm-s390x/termios.h:	put_user((termios)->c_oflag, &(termio)->c_oflag); \
asm-s390x/termios.h:	put_user((termios)->c_cflag, &(termio)->c_cflag); \
asm-s390x/termios.h:	put_user((termios)->c_lflag, &(termio)->c_lflag); \
asm-s390x/termios.h:	put_user((termios)->c_line,  &(termio)->c_line); \
asm-s390x/termios.h:	copy_to_user((termio)->c_cc, (termios)->c_cc, NCC); \
asm-s390x/user.h: *  include/asm-s390/user.h
asm-s390x/user.h: *  Derived from "include/asm-i386/usr.h"
asm-s390x/user.h:   linux we use the 'trad-core' bfd).  There are quite a number of
asm-s390x/user.h:   DATA: The data area is stored.  We use current->end_text to
asm-s390x/user.h:   current->brk to pick up all of the user variables, plus any memory
asm-s390x/user.h:   is demand-zero or if a page is totally unused, we just cover the entire
asm-s390x/user.h:   current->start_stack, so we round each of these off in order to be able
asm-s390x/user.h:/* When the kernel dumps core, it starts by dumping the user struct -
asm-s390x/statfs.h: *  include/asm-s390/statfs.h
asm-s390x/statfs.h: *  Derived from "include/asm-i386/statfs.h"
asm-s390x/vtoc.h:        char cisize[4];	        /* CI-size for FBA,...                       */
asm-s390x/vtoc.h:        __u8  DS4DEVI;            /* non-last keyed record overhead          */
asm-s390x/vtoc.h:        __u8  DS4DEVK;            /* non-keyed record overhead differential  */
asm-s390x/vtoc.h:        __u8 DS4EFLVL;            /* extended free-space management level    */
asm-s390x/vtoc.h:        cchhb_t DS4EFPTR;         /* pointer to extended free-space info     */
asm-s390x/vtoc.h:	ds5ext_t DS5AVEXT;        /* first available (free-space) extent.    */
asm-s390x/pgtable.h: *  include/asm-s390/pgtable.h
asm-s390x/pgtable.h: *  Derived from "include/asm-i386/pgtable.h"
asm-s390x/pgtable.h: * The Linux memory management assumes a three-level page table setup. On
asm-s390x/pgtable.h: * the S390, we use that, but "fold" the mid level into the top-level page
asm-s390x/pgtable.h: * table, so that we physically have the same two-level page table as the
asm-s390x/pgtable.h:/* Caches aren't brain-dead on S390. */
asm-s390x/pgtable.h: * for zero-mapped memory areas etc..
asm-s390x/pgtable.h: * PMD_SHIFT determines the size of the area a second-level page
asm-s390x/pgtable.h:#define PMD_MASK        (~(PMD_SIZE-1))
asm-s390x/pgtable.h:/* PGDIR_SHIFT determines what a third-level page table entry can map */
asm-s390x/pgtable.h:#define PGDIR_MASK      (~(PGDIR_SIZE-1))
asm-s390x/pgtable.h: * entries per page directory level: the S390 is two to five-level,
asm-s390x/pgtable.h: * any out-of-bounds memory accesses will hopefully be caught.
asm-s390x/pgtable.h:                         & ~(VMALLOC_OFFSET-1))
asm-s390x/pgtable.h: * I Page-Invalid Bit:    Page is not available for address-translation
asm-s390x/pgtable.h: * P Page-Protection Bit: Store access not possible for page
asm-s390x/pgtable.h: * |        P-table origin                              |      TT
asm-s390x/pgtable.h: * I Segment-Invalid Bit:    Segment is not available for address-translation
asm-s390x/pgtable.h: * C Common-Segment Bit:     Segment is not private (PoP 3-30)
asm-s390x/pgtable.h: * P Page-Protection Bit: Store access not possible for page
asm-s390x/pgtable.h: * |        S-table origin                             |   TF  TTTL
asm-s390x/pgtable.h: * I Segment-Invalid Bit:    Segment is not available for address-translation
asm-s390x/pgtable.h: * X Space-Switch event:
asm-s390x/pgtable.h: * G Segment-Invalid Bit:  
asm-s390x/pgtable.h: * P Private-Space Bit:    
asm-s390x/pgtable.h: * S Storage-Alteration:
asm-s390x/pgtable.h: * TL Table-Length:
asm-s390x/pgtable.h:#define _PAGE_RO        0x200          /* HW read-only                     */
asm-s390x/pgtable.h:#define pages_to_mb(x) ((x) >> (20-PAGE_SHIFT))
asm-s390x/pgtable.h:	unsigned long *pgd_slot = (unsigned long *) (addr & -8);
asm-s390x/pgtable.h:	unsigned long *pgd_slot = (unsigned long *) (addr & -8);
asm-s390x/pgtable.h:	unsigned long *pgd_slot = (unsigned long *) (addr & -8);
asm-s390x/pgtable.h:	unsigned long __physpage = __pa((__page-mem_map) << PAGE_SHIFT);  \
asm-s390x/pgtable.h:		if (!test_and_set_bit(PG_uptodate, &__page->flags))	  \
asm-s390x/pgtable.h:			      "a" (__pa((__page-mem_map) << PAGE_SHIFT)));\
asm-s390x/pgtable.h:/* to find an entry in a page-table-directory */
asm-s390x/pgtable.h:#define pgd_index(address) ((address >> PGDIR_SHIFT) & (PTRS_PER_PGD-1))
asm-s390x/pgtable.h:#define pgd_offset(mm, address) ((mm)->pgd+pgd_index(address))
asm-s390x/pgtable.h:/* to find an entry in a kernel page-table-directory */
asm-s390x/pgtable.h:/* Find an entry in the second-level page table.. */
asm-s390x/pgtable.h:	((pmd_t *) pgd_page(dir) + (((addr) >> PMD_SHIFT) & (PTRS_PER_PMD - 1)))
asm-s390x/pgtable.h:/* Find an entry in the third-level page table.. */
asm-s390x/pgtable.h:	((pte_t *) pmd_page(*(dir)) + (((addr) >> PAGE_SHIFT) & (PTRS_PER_PTE - 1)))
asm-s390x/pgtable.h: * A page-table entry has some bits we have to treat in a special way.
asm-s390x/pgtable.h: * This leaves the bits 0-51 and bits 56-62 to store type and offset.
asm-s390x/pgtable.h: * We use the 7 bits from 56-62 for the type and the 52 bits from 0-51
asm-s390x/unaligned.h: *  include/asm-s390/unaligned.h
asm-s390x/unaligned.h: *  Derived from "include/asm-i386/unaligned.h"
asm-s390x/idals.h: * File...........: linux/include/asm-s390x/idals.h
asm-s390x/idals.h:		return ((__pa(vaddr) & (IDA_BLOCK_SIZE-1)) + length + 
asm-s390x/idals.h:			(IDA_BLOCK_SIZE-1)) >> IDA_SIZE_LOG;
asm-s390x/idals.h:	cidaw = ((paddr & (IDA_BLOCK_SIZE-1)) + length + 
asm-s390x/idals.h:		 (IDA_BLOCK_SIZE-1)) >> IDA_SIZE_LOG;
asm-s390x/idals.h:	paddr &= -IDA_BLOCK_SIZE;
asm-s390x/idals.h:	while (--cidaw > 0) {
asm-s390x/idals.h:	if (ccw->flags & CCW_FLAG_IDA)
asm-s390x/idals.h:		return -EINVAL;
asm-s390x/idals.h:	nridaws = idal_nr_words(vaddr, ccw->count);
asm-s390x/idals.h:			return -ENOMEM;
asm-s390x/idals.h:		idal_create_words(idal, vaddr, ccw->count);
asm-s390x/idals.h:		ccw->flags |= CCW_FLAG_IDA;
asm-s390x/idals.h:	ccw->cda = (__u32)(unsigned long) vaddr;
asm-s390x/idals.h:	if (ccw->flags & CCW_FLAG_IDA) {
asm-s390x/idals.h:		kfree((void *)(unsigned long) ccw->cda);
asm-s390x/idals.h:		ccw->flags &= ~CCW_FLAG_IDA;
asm-s390x/idals.h:	ccw->cda = 0;
asm-s390x/idals.h:	nr_ptrs = (size + IDA_BLOCK_SIZE - 1) >> IDA_SIZE_LOG;
asm-s390x/idals.h:		return ERR_PTR(-ENOMEM);
asm-s390x/idals.h:	ib->size = size;
asm-s390x/idals.h:	ib->page_order = page_order;
asm-s390x/idals.h:		if ((i & (nr_chunks - 1)) != 0) {
asm-s390x/idals.h:			ib->data[i] = ib->data[i-1] + IDA_BLOCK_SIZE;
asm-s390x/idals.h:		ib->data[i] = (void *)
asm-s390x/idals.h:		if (ib->data[i] != NULL)
asm-s390x/idals.h:			i -= nr_chunks;
asm-s390x/idals.h:			free_pages((unsigned long) ib->data[i],
asm-s390x/idals.h:				   ib->page_order);
asm-s390x/idals.h:		return ERR_PTR(-ENOMEM);
asm-s390x/idals.h:	nr_ptrs = (ib->size + IDA_BLOCK_SIZE - 1) >> IDA_SIZE_LOG;
asm-s390x/idals.h:	nr_chunks = (4096 << ib->page_order) >> IDA_SIZE_LOG;
asm-s390x/idals.h:		free_pages((unsigned long) ib->data[i], ib->page_order);
asm-s390x/idals.h:	return ib->size > (4096 << ib->page_order) ||
asm-s390x/idals.h:		idal_is_needed(ib->data[0], ib->size);
asm-s390x/idals.h:	return ib->size > (4096 << ib->page_order);
asm-s390x/idals.h:		ccw->cda = (u32)(addr_t) ib->data;
asm-s390x/idals.h:		ccw->flags |= CCW_FLAG_IDA;
asm-s390x/idals.h:		// we do not need idals - use direct addressing
asm-s390x/idals.h:		ccw->cda = (u32)(addr_t) ib->data[0];
asm-s390x/idals.h:	ccw->count = ib->size;
asm-s390x/idals.h:	if (count > ib->size)
asm-s390x/idals.h:		left = copy_to_user(to, ib->data[i], IDA_BLOCK_SIZE);
asm-s390x/idals.h:			return left + count - IDA_BLOCK_SIZE;
asm-s390x/idals.h:		count -= IDA_BLOCK_SIZE;
asm-s390x/idals.h:	return copy_to_user(to, ib->data[i], count);
asm-s390x/idals.h:	if (count > ib->size)
asm-s390x/idals.h:		left = copy_from_user(ib->data[i], from, IDA_BLOCK_SIZE);
asm-s390x/idals.h:			return left + count - IDA_BLOCK_SIZE;
asm-s390x/idals.h:		count -= IDA_BLOCK_SIZE;
asm-s390x/idals.h:	return copy_from_user(ib->data[i], from, count);
asm-s390x/param.h: *  include/asm-s390/param.h
asm-s390x/param.h: *  Derived from "include/asm-i386/param.h"
asm-s390x/param.h:#define NOGROUP		(-1)
asm-s390x/gdb-stub.h: *  include/asm-s390/gdb-stub.h
asm-s390x/gdb-stub.h:#include <asm/s390-gdbregs.h>
asm-s390x/cache.h: *  include/asm-s390/cache.h
asm-s390x/cache.h: *  Derived from "include/asm-i386/cache.h"
asm-s390x/siginfo.h: *  include/asm-s390/siginfo.h
asm-s390x/siginfo.h: *  Derived from "include/asm-i386/siginfo.h"
asm-s390x/siginfo.h:#define SI_PAD_SIZE	((SI_MAX_SIZE/sizeof(int)) - 4)
asm-s390x/siginfo.h: * Digital reserves positive values for kernel-generated signals.
asm-s390x/siginfo.h:#define SI_QUEUE	-1	/* sent by sigqueue */
asm-s390x/siginfo.h:#define SI_TIMER __SI_CODE(__SI_TIMER,-2) /* sent by timer expiration */
asm-s390x/siginfo.h:#define SI_MESGQ	-3	/* sent by real time mesq state change */
asm-s390x/siginfo.h:#define SI_ASYNCIO	-4	/* sent by AIO completion */
asm-s390x/siginfo.h:#define SI_SIGIO	-5	/* sent by queued SIGIO */
asm-s390x/siginfo.h:#define SI_TKILL	-6	/* sent by tkill system call */
asm-s390x/siginfo.h:#define SI_FROMUSER(siptr)	((siptr)->si_code <= 0)
asm-s390x/siginfo.h:#define SI_FROMKERNEL(siptr)	((siptr)->si_code > 0)
asm-s390x/siginfo.h:#define BUS_ADRERR	(__SI_FAULT|2)	/* non-existant physical address */
asm-s390x/siginfo.h:#define SIGEV_PAD_SIZE	((SIGEV_MAX_SIZE/sizeof(int)) - 3)
asm-s390x/siginfo.h:	if (from->si_code < 0)
asm-s390x/siginfo.h:		memcpy(to, from, 3*sizeof(int) + sizeof(from->_sifields._sigchld));
asm-s390x/sockios.h: *  include/asm-s390/sockios.h
asm-s390x/sockios.h: *  Derived from "include/asm-i386/sockios.h"
asm-s390x/sockios.h:/* Socket-level I/O control calls. */
asm-s390x/a.out.h: *  include/asm-s390/a.out.h
asm-s390x/a.out.h: *  Derived from "include/asm-i386/a.out.h"
asm-s390x/ioctl.h: *  include/asm-s390/ioctl.h
asm-s390x/ioctl.h: *  Derived from "include/asm-i386/ioctl.h"
asm-s390x/ioctl.h: * NOTE: This limits the max parameter size to 16kB -1 !
asm-s390x/ioctl.h:#define _IOC_NRMASK	((1 << _IOC_NRBITS)-1)
asm-s390x/ioctl.h:#define _IOC_TYPEMASK	((1 << _IOC_TYPEBITS)-1)
asm-s390x/ioctl.h:#define _IOC_SIZEMASK	((1 << _IOC_SIZEBITS)-1)
asm-s390x/ioctl.h:#define _IOC_DIRMASK	((1 << _IOC_DIRBITS)-1)
asm-s390x/string.h: *  include/asm-s390/string.h
asm-s390x/ioctls.h: *  include/asm-s390/ioctls.h
asm-s390x/ioctls.h: *  Derived from "include/asm-i386/ioctls.h"
asm-s390x/ioctls.h:#define TIOCGPTN	_IOR('T',0x30, unsigned int) /* Get Pty Number (of pty-mux device) */
asm-s390x/msgbuf.h: * - 2 miscellaneous 64-bit values
asm-s390x/socket.h: *  include/asm-s390/socket.h
asm-s390x/socket.h: *  Derived from "include/asm-i386/socket.h"
asm-s390x/socket.h:/* Security levels - as per NRL IPv6 - don't actually do anything */
asm-s390x/socket.h:/* Nast libc5 fixup - bletch */
asm-s390x/socket.h:#define SOCK_RDM	4		/* reliably-delivered message	*/
asm-sh/io.h: * If the platform has PC-like I/O, this function converts the offset into
asm-sh/io.h:/* SuperH on-chip I/O functions */
asm-sh/io.h:		length--;
asm-sh/io.h: * The caches on some architectures aren't dma-coherent and have need to
asm-sh/io.h: *  - dma_cache_wback_inv(start, size) makes caches and RAM coherent by
asm-sh/io.h: *  - dma_cache_inv(start, size) invalidates the affected parts of the
asm-sh/io.h: *  - dma_cache_wback(start, size) writes back any dirty lines but does
asm-sh/hd64465_gpio.h:#define HD64465_GPIO_PORTPIN(port,pin)	(((port)-'A')<<3|(pin))
asm-sh/hd64465_gpio.h:#define HD64465_GPIO_IN_PULLUP	2	/* input, pull-up MOS on */
asm-sh/atomic.h:#define atomic_read(v)		((v)->counter)
asm-sh/atomic.h:#define atomic_set(v,i)		((v)->counter = (i))
asm-sh/atomic.h:	*(long *)v -= i;
asm-sh/atomic.h:	temp -= i;
asm-sh/ipcbuf.h: * - 32-bit mode_t and seq
asm-sh/ipcbuf.h: * - 2 miscellaneous 32-bit values
asm-sh/ec3104.h: * Most of the register set is at 0xb0ec0000 - 0xb0ecffff.
asm-sh/ec3104.h: * 0xb0ec0000 - id string
asm-sh/ec3104.h: * 0xb0ec0XXX - power management
asm-sh/ec3104.h: * 0xb0ec1XXX - interrupt control
asm-sh/ec3104.h: * 0xb0ec3XXX - ps2 port (touch pad on aero 8000)
asm-sh/ec3104.h: * 0xb0ec6XXX - i2c
asm-sh/ec3104.h: * 0xb0ec7000 - first serial port (proprietary connector on aero 8000)
asm-sh/ec3104.h: * 0xb0ec8000 - second serial port
asm-sh/ec3104.h: * 0xb0ec9000 - third serial port
asm-sh/ec3104.h: * 0xb0eca000 - fourth serial port (keyboard controller on aero 8000)
asm-sh/ec3104.h: * 0xb0eccXXX - GPIO
asm-sh/ec3104.h: * 0xb0ecdXXX - GPIO
asm-sh/parport.h: * parport.h: SuperH-specific parport initialisation
asm-sh/io_7751se.h: * include/asm-sh/io_7751se.h
asm-sh/io_7751se.h: * Modified version of io_se.h for the 7751se-specific functions.
asm-sh/io_bigsur.h: * include/asm-sh/io_bigsur.h
asm-sh/io_bigsur.h:/* Provision for generic secondary demux step -- used by PCMCIA code */
asm-sh/shmbuf.h: * - 64-bit time_t to solve y2038 problem
asm-sh/shmbuf.h: * - 2 miscellaneous 32-bit values
asm-sh/bitops.h:	size -= result;
asm-sh/bitops.h:		tmp |= ~0UL >> (32-offset);
asm-sh/bitops.h:		size -= 32;
asm-sh/bitops.h:		size -= 32;
asm-sh/bitops.h: * of bits set) of a N-bit word
asm-sh/bitops.h:	size -= result;
asm-sh/bitops.h:		 * tmp |= ~0UL >> (32-offset);
asm-sh/bitops.h:		tmp |= __swab32(~0UL >> (32-offset));
asm-sh/bitops.h:		size -= 32;
asm-sh/bitops.h:		size -= 32;
asm-sh/div64.h:	__res = __n - __q * __base; \
asm-sh/resource.h:#define RLIMIT_MEMLOCK	8		/* max locked-in-memory address space */
asm-sh/ptrace.h: * -----------------------------
asm-sh/ptrace.h: *	 0 - 15 are integer registers
asm-sh/ptrace.h: *	17 - 22 are control/special registers
asm-sh/ptrace.h: *	24 - 39 fp registers
asm-sh/ptrace.h: *	40 - 47 xd registers
asm-sh/ptrace.h: *	48 -    fpscr register
asm-sh/ptrace.h: * -----------------------------
asm-sh/ptrace.h: *	16 --- program counter (PC)
asm-sh/ptrace.h: *	22 --- expevt # (Exception Event Number)
asm-sh/ptrace.h: *	23 --- floating point communication register
asm-sh/ptrace.h:#define user_mode(regs) (((regs)->sr & 0x40000000)==0)
asm-sh/ptrace.h:#define instruction_pointer(regs) ((regs)->pc)
asm-sh/pgalloc.h: * allocating and freeing a pmd is trivial: the 1-entry pmd is
asm-sh/pgalloc.h: *  - flush_tlb() flushes the current mm struct TLBs
asm-sh/pgalloc.h: *  - flush_tlb_all() flushes all processes TLBs
asm-sh/pgalloc.h: *  - flush_tlb_mm(mm) flushes the specified mm context TLB's
asm-sh/pgalloc.h: *  - flush_tlb_page(vma, vmaddr) flushes one page
asm-sh/pgalloc.h: *  - flush_tlb_range(mm, start, end) flushes a range of pages
asm-sh/pgalloc.h: *  - flush_tlb_pgtables(mm, start, end) flushes a range of page tables
asm-sh/pgalloc.h: * For SH-4, we have our own implementation for ptep_get_and_clear
asm-sh/pgalloc.h:		    (!page->mapping || !(page->mapping->i_mmap_shared)))
asm-sh/pgalloc.h:			__clear_bit(PG_mapped, &page->flags);
asm-sh/unistd.h:/* user-visible error numbers are in the range -1 - -125: see <asm-sh/errno.h> */
asm-sh/unistd.h:	if ((unsigned long)(res) >= (unsigned long)(-125)) { \
asm-sh/unistd.h:		int __err = -(res); \
asm-sh/unistd.h:		res = -1; \
asm-sh/unistd.h:/* XXX - _foo needs to be __foo, while __NR_bar could be _NR_bar. */
asm-sh/unistd.h: * we need this inline - forking from kernel space will result
asm-sh/unistd.h: * calls - which means inline code for fork too, as otherwise we
asm-sh/unistd.h:	return waitpid(-1,wait_stat,0);
asm-sh/elf.h:#define elf_check_arch(x) ( (x)->e_machine == EM_SH )
asm-sh/elf.h:  do { _r->regs[0]=0; _r->regs[1]=0; _r->regs[2]=0; _r->regs[3]=0; \
asm-sh/elf.h:       _r->regs[4]=0; _r->regs[5]=0; _r->regs[6]=0; _r->regs[7]=0; \
asm-sh/elf.h:       _r->regs[8]=0; _r->regs[9]=0; _r->regs[10]=0; _r->regs[11]=0; \
asm-sh/elf.h:       _r->regs[12]=0; _r->regs[13]=0; _r->regs[14]=0; \
asm-sh/elf.h:       _r->sr = SR_FD; } while (0)
asm-sh/ide.h: *  linux/include/asm-sh/ide.h
asm-sh/ide.h: *  Copyright (C) 1994-1996  Linus Torvalds & authors
asm-sh/ide.h:#include <asm-generic/ide_iops.h>
asm-sh/ide.h:/* Should never have fewer than 2, ide-pci.c(ide_match_hwif) requires it */
asm-sh/ide.h:		hw->io_ports[i] = reg;
asm-sh/ide.h:		hw->io_ports[IDE_CONTROL_OFFSET] = ctrl_port;
asm-sh/ide.h:		hw->io_ports[IDE_CONTROL_OFFSET] = hw->io_ports[IDE_DATA_OFFSET] + 0x206;
asm-sh/ide.h:	hw->io_ports[IDE_IRQ_OFFSET] = 0;
asm-sh/irq.h: * linux/include/asm-sh/irq.h
asm-sh/irq.h:#include <asm/irq-sh7300.h>
asm-sh/irq.h: *   1. ONCHIP_NR_IRQS - number of IRLS + on-chip peripherial modules
asm-sh/irq.h: *   2. PINT_NR_IRQS   - number of PINT interrupts
asm-sh/irq.h: *   3. OFFCHIP_NR_IRQS - numbe of IRQs from off-chip peripherial modules
asm-sh/pci.h:   already-configured bus numbers - to be used for buggy BIOSes
asm-sh/pci.h: * NULL for PCI-like buses (ISA, EISA).
asm-sh/pci.h: * Returns non-NULL cpu-view pointer to the buffer if successful and
asm-sh/pci.h: * The 32-bit bus address to use is returned.
asm-sh/pci.h:	((PTR)->ADDR_NAME)
asm-sh/pci.h:	(((PTR)->ADDR_NAME) = (VAL))
asm-sh/pci.h:	((PTR)->LEN_NAME)
asm-sh/pci.h:	(((PTR)->LEN_NAME) = (VAL))
asm-sh/pci.h: * mode for DMA.  This is the scather-gather version of the
asm-sh/pci.h: * The same as pci_dma_sync_single but for a scatter-gather list,
asm-sh/pci.h: * only drive the low 24-bits during PCI bus mastering, then
asm-sh/pci.h:/* Not supporting more than 32-bit PCI bus addresses now, but
asm-sh/pci.h:#define sg_dma_address(sg)	(virt_to_bus((sg)->address))
asm-sh/pci.h:#define sg_dma_len(sg)		((sg)->length)
asm-sh/rtc.h:#define RCR2_ADJ	0x04	/* ADJustment (30-second)  */
asm-sh/rtc.h:/* SH-3 RTC */
asm-sh/rtc.h:/* SH-4 RTC */
asm-sh/tlb.h:#include <asm-generic/tlb.h>
asm-sh/ubc.h:#define UBC_TYPE_SH7729	(cpu_data->type == CPU_SH7729)
asm-sh/xor.h:#include <asm-generic/xor.h>
asm-sh/io_generic.h: * include/asm-sh/io_generic.h
asm-sh/signal.h:#define SIGRTMAX	(_NSIG-1)
asm-sh/signal.h: * SA_INTERRUPT is a no-op, but left due to historical reasons. Use the
asm-sh/signal.h:#define SA_INTERRUPT	0x20000000 /* dummy -- ignored */
asm-sh/signal.h:#define SIG_ERR	((__sighandler_t)-1)	/* error return from signal */
asm-sh/signal.h:#define sigmask(sig)	(1UL << ((sig) - 1))
asm-sh/io_hd64461.h: * include/asm-sh/io_hd64461.h
asm-sh/io_hd64465.h: * include/asm-sh/io_hd64465.h
asm-sh/io_hd64465.h:/* Provision for generic secondary demux step -- used by PCMCIA code */
asm-sh/hardirq.h:#define irq_exit(cpu, irq)	(local_irq_count(cpu)--)
asm-sh/hardirq.h:#error Super-H SMP is not available
asm-sh/io_keywest.h: * include/asm-sh/io_keywest.h
asm-sh/io_keywest.h:/* Provision for generic secondary demux step -- used by PCMCIA code */
asm-sh/io_unknown.h: * include/asm-sh/io_unknown.h
asm-sh/shmparam.h: * SH-4 has D-cache alias issue
asm-sh/processor.h: * include/asm-sh/processor.h
asm-sh/processor.h: * Since SH7709 and SH7750 have "area 7", we can't use 0x7c000000--0x7fffffff
asm-sh/processor.h: * FD-bit:
asm-sh/processor.h: * IMASK-bit:
asm-sh/processor.h:	0, -1, 							\
asm-sh/processor.h:	regs->pr = 0;   		 	 \
asm-sh/processor.h:	regs->sr = 0;		/* User mode. */ \
asm-sh/processor.h:	regs->pc = new_pc;			 \
asm-sh/processor.h:	regs->regs[15] = new_sp
asm-sh/processor.h:	if ((tsk)->flags & PF_USEDFPU) {	\
asm-sh/processor.h:	if ((tsk)->flags & PF_USEDFPU) { 	\
asm-sh/processor.h:		(tsk)->flags &= ~PF_USEDFPU; 	\
asm-sh/processor.h:	return t->pc;
asm-sh/processor.h:#define KSTK_EIP(tsk)  ((tsk)->thread.pc)
asm-sh/processor.h:#define KSTK_ESP(tsk)  ((tsk)->thread.sp)
asm-sh/processor.h:#define get_task_struct(tsk)      atomic_inc(&virt_to_page(tsk)->count)
asm-sh/mmu_context.h:/* ASID is 8-bit value, so it can't be 0x100 */
asm-sh/mmu_context.h:	if (((mm->context ^ mc) & MMU_CONTEXT_VERSION_MASK) == 0)
asm-sh/mmu_context.h:	mm->context = mc;
asm-sh/mmu_context.h:	mm->context = NO_CONTEXT;
asm-sh/mmu_context.h: * After we have set current->mm to a new value, this activates
asm-sh/mmu_context.h:	set_asid(mm->context & MMU_CONTEXT_ASID_MASK);
asm-sh/mmu_context.h:		unsigned long __pgdir = (unsigned long)next->pgd;
asm-sh/semaphore.h: * SMP- and interrupt-safe semaphores.
asm-sh/semaphore.h:	atomic_set(&sem->count, val);
asm-sh/semaphore.h:	sem->sleepers = 0;
asm-sh/semaphore.h:	init_waitqueue_head(&sem->wait);
asm-sh/semaphore.h:	sem->__magic = (int)&sem->__magic;
asm-sh/semaphore.h:	CHECK_MAGIC(sem->__magic);
asm-sh/semaphore.h:	if (atomic_dec_return(&sem->count) < 0)
asm-sh/semaphore.h:	CHECK_MAGIC(sem->__magic);
asm-sh/semaphore.h:	if (atomic_dec_return(&sem->count) < 0)
asm-sh/semaphore.h:	CHECK_MAGIC(sem->__magic);
asm-sh/semaphore.h:	if (atomic_dec_return(&sem->count) < 0)
asm-sh/semaphore.h:	CHECK_MAGIC(sem->__magic);
asm-sh/semaphore.h:	if (atomic_inc_return(&sem->count) <= 0)
asm-sh/semaphore.h:	return atomic_read(&sem->count);
asm-sh/fcntl.h:/* open/fcntl - O_SYNC is only implemented on blocks devices and on files
asm-sh/fcntl.h:#define O_DIRECT	 040000	/* direct disk access hint - currently ignored */
asm-sh/fcntl.h:#define F_GETFL		3	/* get file->f_flags */
asm-sh/fcntl.h:#define F_SETFL		4	/* set file->f_flags */
asm-sh/mmzone.h: *  linux/include/asm-sh/mmzone.h
asm-sh/mmzone.h:#define PHYSADDR_TO_NID(phys)	((((phys) - __MEMORY_START) >= 0x01000000)?1:0)
asm-sh/mmzone.h:#define NODE_MEM_MAP(nid)	(NODE_DATA(nid)->node_mem_map)
asm-sh/mmzone.h:     + (((phys) - NODE_DATA(node)->node_start_paddr) >> PAGE_SHIFT); })
asm-sh/mmzone.h:		    page < NODE_MEM_MAP(i) + NODE_DATA(i)->node_size)
asm-sh/serial-bigsur.h: * include/asm-sh/serial-bigsur.h
asm-sh/errno.h:#define	EXDEV		18	/* Cross-device link */
asm-sh/errno.h:#define	EROFS		30	/* Read-only file system */
asm-sh/errno.h:#define	ENOTSOCK	88	/* Socket operation on non-socket */
asm-sh/irq_microdev.h: * linux/include/asm-sh/irq_microdev.h
asm-sh/irq_microdev.h: * IRQ functions for the SuperH SH4-202 MicroDev board.
asm-sh/irq_microdev.h:	 *	interrupt controller (INTC) on the CPU-board FPGA.
asm-sh/irq_microdev.h:	 *	and a seperate INTC on the SH4-202 core - these are
asm-sh/irq_microdev.h:	 *	to correctly route - unfortunately, they have the
asm-sh/irq_microdev.h:#define	MICRODEV_FPGA_INTC_BASE		0xa6110000ul				/* INTC base address on CPU-board FPGA */
asm-sh/irq_microdev.h:#define	MICRODEV_FPGA_INTENB_REG	(MICRODEV_FPGA_INTC_BASE+0ul)		/* Interrupt Enable Register on INTC on CPU-board FPGA */
asm-sh/irq_microdev.h:#define	MICRODEV_FPGA_INTDSB_REG	(MICRODEV_FPGA_INTC_BASE+8ul)		/* Interrupt Disable Register on INTC on CPU-board FPGA */
asm-sh/irq_microdev.h:#define	MICRODEV_FPGA_INTC_MASK(n)	(1ul<<(n))				/* Interupt mask to enable/disable INTC in CPU-board FPGA */
asm-sh/irq_microdev.h:#define	MICRODEV_FPGA_INTPRI_REG(n)	(MICRODEV_FPGA_INTC_BASE+0x10+((n)/8)*8)/* Interrupt Priority Register on INTC on CPU-board FPGA */
asm-sh/irq_microdev.h:#define	MICRODEV_FPGA_INTPRI_MASK(n)	(MICRODEV_FPGA_INTPRI_LEVEL((n),0xful))	/* Interrupt Priority Mask on INTC on CPU-board FPGA */
asm-sh/dc_sysasic.h:/* include/asm-sh/dc_sysasic.h
asm-sh/dc_sysasic.h:/* Hardware events -
asm-sh/dc_sysasic.h:#define HW_EVENT_GDROM_DMA (HW_EVENT_IRQ_BASE + 14) /* GD-ROM DMA complete */
asm-sh/dc_sysasic.h:#define HW_EVENT_GDROM_CMD (HW_EVENT_IRQ_BASE + 32) /* GD-ROM cmd. complete */
asm-sh/dc_sysasic.h:#define HW_EVENT_AICA_SYS  (HW_EVENT_IRQ_BASE + 33) /* AICA-related */
asm-sh/io_sh2000.h: * include/asm-sh/io_sh2000.h
asm-sh/smc37c93x.h: * linux/include/asm-sh/smc37c93x.h
asm-sh/irq-sh7300.h: * linux/include/asm-sh/irq-sh7300.h
asm-sh/irq-sh7300.h: * Copyright (C) 2003 Takashi Kusuda <kusuda-takashi@hitachi-ul.co.jp>
asm-sh/softirq.h:	local_bh_count(smp_processor_id())--;	\
asm-sh/softirq.h:	if (!--local_bh_count(smp_processor_id())	\
asm-sh/timex.h: * linux/include/asm-sh/timex.h
asm-sh/timex.h:#define FINETUNE ((((((long)LATCH * HZ - CLOCK_TICK_RATE) << SHIFT_HZ) * \
asm-sh/timex.h:		<< (SHIFT_SCALE-SHIFT_HZ)) / HZ)
asm-sh/bugs.h: * This is included by init/main.c to check for architecture-dependent bugs.
asm-sh/bugs.h: * I don't know of any Super-H bugs yet.
asm-sh/bugs.h:	cpu_data->loops_per_jiffy = loops_per_jiffy;
asm-sh/bugs.h:	switch (cpu_data->type) {
asm-sh/namei.h: * linux/include/asm-sh/namei.h
asm-sh/namei.h: * Look at asm-sparc/namei.h for details.
asm-sh/init.h:#error "<asm/init.h> should never be used - use <linux/init.h> instead"
asm-sh/uaccess.h:#define get_fs()        (current->addr_limit)
asm-sh/uaccess.h:#define set_fs(x)       (current->addr_limit=(x))
asm-sh/uaccess.h:#define __addr_ok(addr) ((unsigned long)(addr) < (current->addr_limit.seg))
asm-sh/uaccess.h: * Uhhuh, this needs 33-bit arithmetic. We have a carry..
asm-sh/uaccess.h: * sum := addr + size;  carry? --> flag = true;
asm-sh/uaccess.h:		:"1" (addr), "r" ((int)(size)), "r" (current->addr_limit.seg) \
asm-sh/uaccess.h:	return access_ok(type,addr,size) ? 0 : -EFAULT;
asm-sh/uaccess.h: * Uh, these should become the main single-value transfer routines ...
asm-sh/uaccess.h: * (a) re-use the arguments for side effects (sizeof is ok)
asm-sh/uaccess.h:long __gu_err = -EFAULT; \
asm-sh/uaccess.h:	:"m" (__m(__gu_addr)), "i" (-EFAULT)); })
asm-sh/uaccess.h:long __pu_err = -EFAULT; \
asm-sh/uaccess.h:	:"r" (__pu_val), "m" (__m(__pu_addr)), "i" (-EFAULT) \
asm-sh/uaccess.h:	: "r" (val), "m" (__m(addr)), "i" (-EFAULT) \
asm-sh/uaccess.h:	: "r" (val), "m" (__m(addr)), "i" (-EFAULT) \
asm-sh/uaccess.h:		  "i" (-EFAULT)
asm-sh/uaccess.h:long __sfu_res = -EFAULT; \
asm-sh/uaccess.h:		: "0" (0), "r" (__s), "r" (__n), "i" (-EFAULT)
asm-sh/kgdb.h: * Super-H port based on sh-stub.c (Ben Lee and Steve Chamberlain) by
asm-sh/kgdb.h: * Header file for low-level support for remote debug using GDB. 
asm-sh/kgdb.h:	__flush_purge_region((void*)(start), (int)(end) - (int)(start));       \
asm-sh/kgdb.h:#define KA_VALID_PTR_ERR(ptr) KA_VALID_ERRNO(-PTR_ERR(ptr))
asm-sh/kgdb.h:               (void *)(ptr) < ERR_PTR(-EMEDIUMTYPE)))
asm-sh/kgdb.h:#define KA_HELD_GKL()  (current->lock_depth >= 0)
asm-sh/hitachi_se.h: * linux/include/asm-sh/hitachi_se.h
asm-sh/hitachi_se.h:#define PA_PCIC		0x18000000	/* MR-SHPC-01 PCMCIA */
asm-sh/hitachi_se.h:#define PA_MRSHPC	0xb83fffe0	/* MR-SHPC-01 PCMCIA controller */
asm-sh/hitachi_se.h:#define PA_MRSHPC_MW1	0xb8400000	/* MR-SHPC-01 memory window base */
asm-sh/hitachi_se.h:#define PA_MRSHPC_MW2	0xb8500000	/* MR-SHPC-01 attribute window base */
asm-sh/hitachi_se.h:#define PA_MRSHPC_IO	0xb8600000	/* MR-SHPC-01 I/O window base */
asm-sh/semaphore-helper.h: * SMP- and interrupt-safe semaphores helper functions.
asm-sh/semaphore-helper.h:	atomic_inc((atomic_t *)&sem->sleepers);
asm-sh/semaphore-helper.h:	if (sem->sleepers > 0) {
asm-sh/semaphore-helper.h:		sem->sleepers--;
asm-sh/semaphore-helper.h: *	-EINTR	interrupted
asm-sh/semaphore-helper.h: * We must undo the sem->count down_interruptible() increment while we are
asm-sh/semaphore-helper.h: * atomic_read() in wake_one_more(), otherwise we can race. -arca
asm-sh/semaphore-helper.h:	if (sem->sleepers > 0) {
asm-sh/semaphore-helper.h:		sem->sleepers--;
asm-sh/semaphore-helper.h:		atomic_inc(&sem->count);
asm-sh/semaphore-helper.h:		ret = -EINTR;
asm-sh/semaphore-helper.h: * We must undo the sem->count down_trylock() increment while we are
asm-sh/semaphore-helper.h: * atomic_read() in wake_one_more(), otherwise we can race. -arca
asm-sh/semaphore-helper.h:	if (sem->sleepers <= 0)
asm-sh/semaphore-helper.h:		atomic_inc(&sem->count);
asm-sh/semaphore-helper.h:		sem->sleepers--;
asm-sh/io_hs7729pci.h: * include/asm-sh/io_hs7729pci.h
asm-sh/mman.h:#define MAP_GROWSDOWN	0x0100		/* stack-like segment */
asm-sh/mman.h:#define MADV_NORMAL	0x0		/* default page-in behavior */
asm-sh/mman.h:#define MADV_RANDOM	0x1		/* page-in minimum required */
asm-sh/mman.h:#define MADV_SEQUENTIAL	0x2		/* read-ahead aggressively */
asm-sh/mman.h:#define MADV_WILLNEED	0x3		/* pre-fault pages */
asm-sh/posix_types.h: * This file is generally used by user-level software, so you need to
asm-sh/posix_types.h:	__fdsetp->fds_bits[__tmp] |= (1UL<<__rem);
asm-sh/posix_types.h:	__fdsetp->fds_bits[__tmp] &= ~(1UL<<__rem);
asm-sh/posix_types.h:	return (__p->fds_bits[__tmp] & (1UL<<__rem)) != 0;
asm-sh/posix_types.h: * for a 256-bit fd_set)
asm-sh/posix_types.h:	unsigned long *__tmp = __p->fds_bits;
asm-sh/posix_types.h:		__i--;
asm-sh/io_cat68701.h: * include/asm-sh/io_cat68701.h
asm-sh/io_cat68701.h: *           2001 Yutarou Ebihar (ebihara@si-linux.com)
asm-sh/io_cat68701.h: * IO functions for an AONE Corp. CAT-68701 SH7708 Borad
asm-sh/hd64465.h: * to an address in the range 0xb0000000-0xb3ffffff.  Note that
asm-sh/hd64465.h: * manual, and accessed using address 0xb0005000 - Greg.
asm-sh/hd64465.h:#define     HD64465_PCCISR_PMWP     	 0x40    /* mem card write-protected */
asm-sh/hd64465.h:#define     HD64465_PCCCSCIER_PIREQE_LEVEL  	0x20   /* IREQ level-triggered */
asm-sh/hd64465.h:#define     HD64465_PCCCSCIER_PIREQE_FALLING	0x40   /* IREQ falling-edge-trig */
asm-sh/hd64465.h:#define     HD64465_PCCCSCIER_PIREQE_RISING 	0x60   /* IREQ rising-edge-trig */
asm-sh/hd64465.h:/* PS/2 Keyboard and mouse controller -- *not* register compatible */
asm-sh/page.h:   [ P0/U0 (virtual) ]		0x00000000     <------ User space
asm-sh/page.h:   [ P1 (fixed)   cached ]	0x80000000     <------ Kernel space
asm-sh/page.h:   [ P2 (fixed)  non-cachable]	0xA0000000     <------ Physical access
asm-sh/page.h:   [ P3 (virtual) cached]	0xC0000000     <------ vmalloced area
asm-sh/page.h:#define PAGE_MASK	(~(PAGE_SIZE-1))
asm-sh/page.h: * These are used to make use of C type-checking..
asm-sh/page.h:#define PAGE_ALIGN(addr)	(((addr)+PAGE_SIZE-1)&PAGE_MASK)
asm-sh/page.h:#define __pa(x)			((unsigned long)(x)-PAGE_OFFSET)
asm-sh/page.h:#define phys_to_page(phys)	(mem_map + (((phys)-__MEMORY_START) >> PAGE_SHIFT))
asm-sh/page.h:#define VALID_PAGE(page)	((page - mem_map) < max_mapnr)
asm-sh/page.h:#define page_to_phys(page)	(((page - mem_map) << PAGE_SHIFT) + __MEMORY_START)
asm-sh/page.h:	size = (size-1) >> (PAGE_SHIFT-1);
asm-sh/page.h:	order = -1;
asm-sh/pgtable-2level.h: * traditional two-level paging structure:
asm-sh/pgtable-2level.h: * this is two-level, so we don't really have any
asm-sh/pgtable-2level.h: * The "pgd_xxx()" functions here are trivial for a folded two-level
asm-sh/hdreg.h: *  linux/include/asm-sh/hdreg.h
asm-sh/hdreg.h: *  Copyright (C) 1994-1996  Linus Torvalds & authors
asm-sh/poll.h:/* The rest seem to be more-or-less nonstandard. Check them! */
asm-sh/types.h:/* Dma addresses are 32-bits wide.  */
asm-sh/sembuf.h: * - 64-bit time_t to solve y2038 problem
asm-sh/sembuf.h: * - 2 miscellaneous 32-bit values
asm-sh/system.h: register unsigned long *__ts1 __asm__ ("r1") = &prev->thread.sp; \
asm-sh/system.h: register unsigned long *__ts2 __asm__ ("r2") = &prev->thread.pc; \
asm-sh/system.h: register unsigned long *__ts6 __asm__ ("r6") = &next->thread.sp; \
asm-sh/system.h: register unsigned long __ts7 __asm__ ("r7") = next->thread.pc; \
asm-sh/system.h:		       "stc.l	gbr, @-r15\n\t" \
asm-sh/system.h:		       "sts.l	pr, @-r15\n\t" \
asm-sh/system.h:		       "mov.l	r8, @-r15\n\t" \
asm-sh/system.h:		       "mov.l	r9, @-r15\n\t" \
asm-sh/system.h:		       "mov.l	r10, @-r15\n\t" \
asm-sh/system.h:		       "mov.l	r11, @-r15\n\t" \
asm-sh/system.h:		       "mov.l	r12, @-r15\n\t" \
asm-sh/system.h:		       "mov.l	r13, @-r15\n\t" \
asm-sh/system.h:		       "mov.l	r14, @-r15\n\t" \
asm-sh/system.h:		       "mov.l	%0, @-r15	! push R0 onto new stack\n\t" \
asm-sh/stat.h:	unsigned long	st_blocks;	/* Number 512-byte blocks allocated. */
asm-sh/stat.h:	unsigned long	st_blocks;	/* Number 512-byte blocks allocated. */
asm-sh/checksum.h: * and adds in "sum" (32-bit)
asm-sh/checksum.h: * returns a 32-bit number suitable for feeding into itself
asm-sh/checksum.h: * it's best to have buff aligned on a 32-bit boundary
asm-sh/checksum.h: * checksums, and handles user-space pointer exceptions correctly, when needed.
asm-sh/checksum.h: * here even more important to align src and dst on a 32-bit (or even
asm-sh/checksum.h: * better 64-bit) boundary
asm-sh/checksum.h:		"add	#-2, %2\n\t"
asm-sh/checksum.h:		"addc	%2, %0"	    /* Here %2 is 0, add carry-bit */
asm-sh/checksum.h: * computes the checksum of the TCP/UDP pseudo-header
asm-sh/checksum.h: * returns a 16-bit checksum, already complemented
asm-sh/checksum.h: * this routine is used for miscellaneous IP-like checksums, mainly
asm-sh/checksum.h:		*err_ptr = -EFAULT;
asm-sh/checksum.h:	return -1; /* invalid checksum */
asm-sh/pci-sh7751.h: *	Low-Level PCI Support for SH7751 targets
asm-sh/pci-sh7751.h:  #define SH7751_PCICONF2_SCC        0x00FF0000  /* Sub-Class Code */
asm-sh/pci-sh7751.h:/* PCICONF7 - PCICONF10 are undefined */
asm-sh/pci-sh7751.h:  #define SH7751_PCIINT_MTABT        0x00000008  /* Master-Tgt. Abort Error */
asm-sh/pci-sh7751.h:  #define SH7751_PCIINT_MMABT        0x00000004  /* Master-Master Abort Error */
asm-sh/pci-sh7751.h:  #define SH7751_PCIDMABT_RRBN       0x00000001  /* DMA Arbitor Round-Robin */
asm-sh/termios.h:#define N_IRDA		11	/* Linux IR - http://irda.sourceforge.net/ */
asm-sh/termios.h:#define N_SMSBLOCK	12	/* SMS block mode - for talking to GSM data cards about SMS messages */
asm-sh/termios.h:	get_user(__tmp,&(termio)->x); \
asm-sh/termios.h:	*(unsigned short *) &(termios)->x = __tmp; \
asm-sh/termios.h:	copy_from_user((termios)->c_cc, (termio)->c_cc, NCC); \
asm-sh/termios.h:	put_user((termios)->c_iflag, &(termio)->c_iflag); \
asm-sh/termios.h:	put_user((termios)->c_oflag, &(termio)->c_oflag); \
asm-sh/termios.h:	put_user((termios)->c_cflag, &(termio)->c_cflag); \
asm-sh/termios.h:	put_user((termios)->c_lflag, &(termio)->c_lflag); \
asm-sh/termios.h:	put_user((termios)->c_line,  &(termio)->c_line); \
asm-sh/termios.h:	copy_to_user((termio)->c_cc, (termios)->c_cc, NCC); \
asm-sh/user.h: * linux we use the `trad-core' bfd).  The file contents are as follows:
asm-sh/user.h: *  data: The data segment follows next.  We use current->end_text to
asm-sh/user.h: *	current->brk to pick up all of the user variables, plus any memory
asm-sh/user.h: *	page is demand-zero or if a page is totally unused, we just cover
asm-sh/user.h: *	current->start_stack, so we round each of these in order to be able
asm-sh/user.h:	struct user_fpu_struct fpu;	/* Math Co-processor registers  */
asm-sh/user.h:	int u_fpvalid;		/* True if math co-processor being used */
asm-sh/user.h:	struct user_fpu_struct* u_fpstate;	/* Math Co-processor pointer */
asm-sh/serial.h: * include/asm-sh/serial.h
asm-sh/serial.h:#include <asm/serial-ec3104.h>
asm-sh/serial.h:#include <asm/serial-bigsur.h>
asm-sh/pgtable.h:#include <asm/pgtable-2level.h>
asm-sh/pgtable.h: *  - flush_cache_all() flushes entire cache
asm-sh/pgtable.h: *  - flush_cache_mm(mm) flushes the specified mm context's cache lines
asm-sh/pgtable.h: *  - flush_cache_page(mm, vmaddr) flushes a single page
asm-sh/pgtable.h: *  - flush_cache_range(mm, start, end) flushes a range of pages
asm-sh/pgtable.h: *  - flush_dcache_page(pg) flushes(wback&invalidates) a page for dcache
asm-sh/pgtable.h: *  - flush_page_to_ram(page) write back kernel page to ram
asm-sh/pgtable.h: *  - flush_icache_range(start, end) flushes(invalidates) a range for icache
asm-sh/pgtable.h: *  - flush_icache_page(vma, pg) flushes(invalidates) a page for icache
asm-sh/pgtable.h: *  Caches are indexed (effectively) by physical address on SH-3, so
asm-sh/pgtable.h: *  Caches are broken on SH-4, so we need them.
asm-sh/pgtable.h:/* Flush (write-back only) a region (smaller than a page) */
asm-sh/pgtable.h:/* Flush (write-back & invalidate) a region (smaller than a page) */
asm-sh/pgtable.h: * Basically we have the same two-level (which is the logical three level
asm-sh/pgtable.h: * for zero-mapped memory areas etc..
asm-sh/pgtable.h:#define PMD_MASK	(~(PMD_SIZE-1))
asm-sh/pgtable.h:#define PGDIR_MASK	(~(PGDIR_SIZE-1))
asm-sh/pgtable.h: * Currently only 4-enty (16kB) is used (see arch/sh/mm/cache.c)
asm-sh/pgtable.h:/*			0x001     WT-bit on SH-4, 0 on SH-3 */
asm-sh/pgtable.h:#define _PAGE_HW_SHARED	0x002  /* SH-bit  : page is shared among processes */
asm-sh/pgtable.h:#define _PAGE_DIRTY	0x004  /* D-bit   : page changed */
asm-sh/pgtable.h:#define _PAGE_CACHABLE	0x008  /* C-bit   : cachable */
asm-sh/pgtable.h:/*			0x010     SZ0-bit : Size of page */
asm-sh/pgtable.h:#define _PAGE_RW	0x020  /* PR0-bit : write access allowed */
asm-sh/pgtable.h:#define _PAGE_USER	0x040  /* PR1-bit : user space access allowed */
asm-sh/pgtable.h:/*			0x080     SZ1-bit : Size of page (on SH-4) */
asm-sh/pgtable.h:#define _PAGE_PRESENT	0x100  /* V-bit   : page is valid */
asm-sh/pgtable.h: * MMU on SH-3 has bug on SH-bit: We can't use it if MMUCR.IX=1.
asm-sh/pgtable.h: * Work around: Just drop SH-bit.
asm-sh/pgtable.h:/* Hardware flags: SZ=1 (4k-byte) */
asm-sh/pgtable.h:#define pages_to_mb(x)	((x) >> (20-PAGE_SHIFT))
asm-sh/pgtable.h:/* to find an entry in a page-table-directory. */
asm-sh/pgtable.h:#define pgd_index(address) (((address) >> PGDIR_SHIFT) & (PTRS_PER_PGD-1))
asm-sh/pgtable.h:#define pgd_offset(mm, address) ((mm)->pgd+pgd_index(address))
asm-sh/pgtable.h:/* to find an entry in a kernel page-table-directory */
asm-sh/pgtable.h:/* Find an entry in the third-level page table.. */
asm-sh/pgtable.h:		((address >> PAGE_SHIFT) & (PTRS_PER_PTE - 1))
asm-sh/pgtable.h:/* Encode and de-code a swap entry */
asm-sh/pgtable.h: * Set pg flags to non-cached
asm-sh/io_snapgear.h: * include/asm-sh/io_snapgear.h
asm-sh/io_snapgear.h: * Modified version of io_se.h for the snapgear-specific functions.
asm-sh/io_snapgear.h: * The external interrupt lines, these take up ints 0 - 15 inclusive
asm-sh/io_snapgear.h: * is the interrupt :-)
asm-sh/io_snapgear.h: * written :-|
asm-sh/io_snapgear.h: * -----------------------------------------------
asm-sh/io_snapgear.h: * D3         -                      WAN
asm-sh/io_snapgear.h: * D5         -                      ONLINE
asm-sh/io_snapgear.h: * D6         -                      VPN
asm-sh/io_snapgear.h: * D7         -                      DTR on ttySC1
asm-sh/io_snapgear.h: * D8         -                      ttySC0 RTS (7100)
asm-sh/io_snapgear.h: * D9         -                      ttySC0 DTR (7100)
asm-sh/io_snapgear.h: * D10        -                      RTC SCLK
asm-sh/io_snapgear.h: * D12        -                      RTS RESET
asm-sh/io_shmse.h: * include/asm-sh/io_shmse.h
asm-sh/io_shmse.h: * Copyright (C) 2003 Takashi Kusuda <kusuda-takashi@hitachi-ul.co.jp>
asm-sh/io_shmse.h: * IO functions for SH-Mobile(SH7300) SolutionEngine
asm-sh/param.h:#define NOGROUP		(-1)
asm-sh/hitachi_hs7729pci.h: * linux/include/asm-sh/hitachi_hs7729pci.h
asm-sh/hitachi_hs7729pci.h:#define PA_MRSHPC	0xb83fffe0	/* MR-SHPC-01 PCMCIA controler */
asm-sh/hitachi_hs7729pci.h:#define PA_MRSHPC_MW1	0xb8400000	/* MR-SHPC-01 memory window base */
asm-sh/hitachi_hs7729pci.h:#define PA_MRSHPC_MW2	0xb8500000	/* MR-SHPC-01 attribute window base */
asm-sh/hitachi_hs7729pci.h:#define PA_MRSHPC_IO	0xb8600000	/* MR-SHPC-01 I/O window base */
asm-sh/cache.h: * include/asm-sh/cache.h
asm-sh/io_adx.h: * include/asm-sh/io_adx.h
asm-sh/siginfo.h:#define SI_PAD_SIZE	((SI_MAX_SIZE/sizeof(int)) - 3)
asm-sh/siginfo.h: * Digital reserves positive values for kernel-generated signals.
asm-sh/siginfo.h:#define SI_QUEUE	-1		/* sent by sigqueue */
asm-sh/siginfo.h:#define SI_TIMER __SI_CODE(__SI_TIMER,-2) /* sent by timer expiration */
asm-sh/siginfo.h:#define SI_MESGQ	-3		/* sent by real time mesq state change */
asm-sh/siginfo.h:#define SI_ASYNCIO	-4		/* sent by AIO completion */
asm-sh/siginfo.h:#define SI_SIGIO	-5		/* sent by queued SIGIO */
asm-sh/siginfo.h:#define SI_TKILL	-6		/* sent by tkill system call */
asm-sh/siginfo.h:#define SI_FROMUSER(siptr)	((siptr)->si_code <= 0)
asm-sh/siginfo.h:#define SI_FROMKERNEL(siptr)	((siptr)->si_code > 0)
asm-sh/siginfo.h:#define BUS_ADRERR	(__SI_FAULT|2)	/* non-existant physical address */
asm-sh/siginfo.h:#define SIGEV_PAD_SIZE	((SIGEV_MAX_SIZE/sizeof(int)) - 3)
asm-sh/siginfo.h:	if (from->si_code < 0)
asm-sh/siginfo.h:		memcpy(to, from, 3*sizeof(int) + sizeof(from->_sifields._sigchld));
asm-sh/sockios.h:/* Socket-level I/O control calls. */
asm-sh/sockios.h:#define SIOCGSTAMP	_IOR('s', 100, struct timeval) /* Get stamp - linux-specific */
asm-sh/machvec_init.h: * include/asm-sh/machvec_init.h
asm-sh/machvec_init.h: * all but one of which we want to go away.  In a non-GENERIC kernel,
asm-sh/machvec_init.h: * Accomplish this in a non-GENERIC kernel by ifdef'ing out all but
asm-sh/machvec_init.h: * Upshot: set __initdata to nothing for non-GENERIC kernels.
asm-sh/keyboard.h:#include <asm/keyboard-ec3104.h>
asm-sh/keyboard.h:#include <asm/keyboard-hs7729pci.h>
asm-sh/keyboard.h:    return -EOPNOTSUPP;
asm-sh/keyboard.h:    return scancode > 127 ? -EINVAL : scancode;
asm-sh/io_se.h: * include/asm-sh/io_se.h
asm-sh/ioctl.h: * NOTE: This limits the max parameter size to 16kB -1 !
asm-sh/ioctl.h:#define _IOC_NRMASK	((1 << _IOC_NRBITS)-1)
asm-sh/ioctl.h:#define _IOC_TYPEMASK	((1 << _IOC_TYPEBITS)-1)
asm-sh/ioctl.h:#define _IOC_SIZEMASK	((1 << _IOC_SIZEBITS)-1)
asm-sh/ioctl.h:#define _IOC_DIRMASK	((1 << _IOC_DIRBITS)-1)
asm-sh/io_microdev.h: * linux/include/asm-sh/io_microdev.h
asm-sh/io_microdev.h: * IO functions for the SuperH SH4-202 MicroDev board.
asm-sh/hitachi_shmse.h: * linux/include/asm-sh/hitachi_shmse.h
asm-sh/hitachi_shmse.h: * Copyright (C) 2003 Takashi Kusuda <kusuda-takashi@hitachi-ul.co.jp>
asm-sh/hitachi_shmse.h: * Hitachi SH-Mobile SolutionEngine support
asm-sh/hitachi_shmse.h:#define PA_PCIC		0x10000000	/* MR-SHPC-01 PCMCIA */
asm-sh/hitachi_shmse.h:#define PA_MRSHPC       0xb03fffe0      /* MR-SHPC-01 PCMCIA controller */
asm-sh/hitachi_shmse.h:#define PA_MRSHPC_MW1   0xb0400000      /* MR-SHPC-01 memory window base */
asm-sh/hitachi_shmse.h:#define PA_MRSHPC_MW2   0xb0500000      /* MR-SHPC-01 attribute window base */
asm-sh/hitachi_shmse.h:#define PA_MRSHPC_IO    0xb0600000      /* MR-SHPC-01 I/O window base */
asm-sh/string.h:		"add	#-2, %1\n\t"
asm-sh/string.h:		"add	#-2, %1\n\t"
asm-sh/ioctls.h:#define TIOCGPTN	_IOR('T',0x30, unsigned int) /* Get Pty Number (of pty-mux device) */
asm-sh/bigsur.h:/* PCI interrupt base number (A_INTA-A_INTD) */
asm-sh/hitachi_7751se.h: * linux/include/asm-sh/hitachi_7751se.h
asm-sh/hitachi_7751se.h:#define PA_PCIC		0x18000000	/* MR-SHPC-01 PCMCIA */
asm-sh/hitachi_7751se.h:#define PA_MRSHPC	0xb83fffe0	/* MR-SHPC-01 PCMCIA controler */
asm-sh/hitachi_7751se.h:#define PA_MRSHPC_MW1	0xb8400000	/* MR-SHPC-01 memory window base */
asm-sh/hitachi_7751se.h:#define PA_MRSHPC_MW2	0xb8500000	/* MR-SHPC-01 attribute window base */
asm-sh/hitachi_7751se.h:#define PA_MRSHPC_IO	0xb8600000	/* MR-SHPC-01 I/O window base */
asm-sh/msgbuf.h: * - 64-bit time_t to solve y2038 problem
asm-sh/msgbuf.h: * - 2 miscellaneous 32-bit values
asm-sh/keyboard-hs7729pci.h: *  linux/include/asm-sh/keyboard.h
asm-sh/machvec.h: * include/asm-sh/machvec.h
asm-sh/socket.h:/* Security levels - as per NRL IPv6 - don't actually do anything */
asm-sh/socket.h:/* Nast libc5 fixup - bletch */
asm-sh/socket.h:#define SOCK_RDM	4		/* reliably-delivered message	*/
asm-sh64/io.h: * include/asm-sh64/io.h
asm-sh64/io.h: * mess is wrapped to this, as are the SH-specific ctrl_in/out routines.
asm-sh64/io.h:		length--;
asm-sh64/io.h: * The caches on some architectures aren't dma-coherent and have need to
asm-sh64/io.h: *  - dma_cache_wback_inv(start, size) makes caches and RAM coherent by
asm-sh64/io.h: *  - dma_cache_inv(start, size) invalidates the affected parts of the
asm-sh64/io.h: *  - dma_cache_wback(start, size) writes back any dirty lines but does
asm-sh64/atomic.h:#define atomic_read(v)		((v)->counter)
asm-sh64/atomic.h:#define atomic_set(v,i)		((v)->counter = (i))
asm-sh64/atomic.h:	*(long *)v -= i;
asm-sh64/atomic.h:	temp -= i;
asm-sh64/mc146818rtc.h: * linux/include/asm-sh64/mc146818rtc.h
asm-sh64/mc146818rtc.h:/* For now, an empty place-holder to get IDE to compile. */
asm-sh64/ipcbuf.h: * include/asm-sh64/ipcbuf.h
asm-sh64/ipcbuf.h: * - 32-bit mode_t and seq
asm-sh64/ipcbuf.h: * - 2 miscellaneous 32-bit values
asm-sh64/ucontext.h: * include/asm-sh64/ucontext.h
asm-sh64/hardware.h: * include/asm-sh64/hardware.h
asm-sh64/hardware.h:	u8	perr_flags;	/* P-port Error flags */
asm-sh64/shmbuf.h: * include/asm-sh64/shmbuf.h
asm-sh64/shmbuf.h: * - 64-bit time_t to solve y2038 problem
asm-sh64/shmbuf.h: * - 2 miscellaneous 32-bit values
asm-sh64/bitops.h:	size -= result;
asm-sh64/bitops.h:		tmp |= ~0UL >> (32-offset);
asm-sh64/bitops.h:		size -= 32;
asm-sh64/bitops.h:		size -= 32;
asm-sh64/bitops.h: * of bits set) of a N-bit word
asm-sh64/bitops.h:	size -= result;
asm-sh64/bitops.h:		 * tmp |= ~0UL >> (32-offset);
asm-sh64/bitops.h:		tmp |= __swab32(~0UL >> (32-offset));
asm-sh64/bitops.h:		size -= 32;
asm-sh64/bitops.h:		size -= 32;
asm-sh64/div64.h: * include/asm-sh64/div64.h
asm-sh64/resource.h:#define RLIMIT_MEMLOCK	8		/* max locked-in-memory address space */
asm-sh64/ptrace.h: * include/asm-sh64/ptrace.h
asm-sh64/ptrace.h:#define user_mode(regs) (((regs)->sr & 0x40000000)==0)
asm-sh64/ptrace.h:#define instruction_pointer(regs) ((regs)->pc)
asm-sh64/pgalloc.h: *  - flush_tlb() flushes the current mm struct TLBs
asm-sh64/pgalloc.h: *  - flush_tlb_all() flushes all processes TLBs
asm-sh64/pgalloc.h: *  - flush_tlb_mm(mm) flushes the specified mm context TLB's
asm-sh64/pgalloc.h: *  - flush_tlb_page(vma, vmaddr) flushes one page
asm-sh64/pgalloc.h: *  - flush_tlb_range(mm, start, end) flushes a range of pages
asm-sh64/pgalloc.h: *  - flush_tlb_pgtables(mm, start, end) flushes a range of page tables
asm-sh64/unistd.h: * include/asm-sh64/unistd.h
asm-sh64/unistd.h:/* user-visible error numbers are in the range -1 - -125: see <asm-sh64/errno.h> */
asm-sh64/unistd.h:	if ((unsigned long)(res) >= (unsigned long)(-125)) { \
asm-sh64/unistd.h:		errno = -(res);						    \
asm-sh64/unistd.h:		__sr2 = -1; 						    \
asm-sh64/unistd.h:/* XXX - _foo needs to be __foo, while __NR_bar could be _NR_bar. */
asm-sh64/unistd.h: * we need this inline - forking from kernel space will result
asm-sh64/unistd.h: * calls - which means inline code for fork too, as otherwise we
asm-sh64/unistd.h:	return waitpid(-1,wait_stat,0);
asm-sh64/dma.h: * include/asm-sh64/dma.h
asm-sh64/dma.h: * the highest DMA-able address based on the actual
asm-sh64/elf.h: * include/asm-sh64/elf.h
asm-sh64/elf.h:#define elf_check_arch(x) ( (x)->e_machine == EM_SH )
asm-sh64/elf.h:  do { _r->regs[0]=0; _r->regs[1]=0; _r->regs[2]=0; _r->regs[3]=0; \
asm-sh64/elf.h:       _r->regs[4]=0; _r->regs[5]=0; _r->regs[6]=0; _r->regs[7]=0; \
asm-sh64/elf.h:       _r->regs[8]=0; _r->regs[9]=0; _r->regs[10]=0; _r->regs[11]=0; \
asm-sh64/elf.h:       _r->regs[12]=0; _r->regs[13]=0; _r->regs[14]=0; _r->regs[15]=0; \
asm-sh64/elf.h:       _r->regs[16]=0; _r->regs[17]=0; _r->regs[18]=0; _r->regs[19]=0; \
asm-sh64/elf.h:       _r->regs[20]=0; _r->regs[21]=0; _r->regs[22]=0; _r->regs[23]=0; \
asm-sh64/elf.h:       _r->regs[24]=0; _r->regs[25]=0; _r->regs[26]=0; _r->regs[27]=0; \
asm-sh64/elf.h:       _r->regs[28]=0; _r->regs[29]=0; _r->regs[30]=0; _r->regs[31]=0; \
asm-sh64/elf.h:       _r->regs[32]=0; _r->regs[33]=0; _r->regs[34]=0; _r->regs[35]=0; \
asm-sh64/elf.h:       _r->regs[36]=0; _r->regs[37]=0; _r->regs[38]=0; _r->regs[39]=0; \
asm-sh64/elf.h:       _r->regs[40]=0; _r->regs[41]=0; _r->regs[42]=0; _r->regs[43]=0; \
asm-sh64/elf.h:       _r->regs[44]=0; _r->regs[45]=0; _r->regs[46]=0; _r->regs[47]=0; \
asm-sh64/elf.h:       _r->regs[48]=0; _r->regs[49]=0; _r->regs[50]=0; _r->regs[51]=0; \
asm-sh64/elf.h:       _r->regs[52]=0; _r->regs[53]=0; _r->regs[54]=0; _r->regs[55]=0; \
asm-sh64/elf.h:       _r->regs[56]=0; _r->regs[57]=0; _r->regs[58]=0; _r->regs[59]=0; \
asm-sh64/elf.h:       _r->regs[60]=0; _r->regs[61]=0; _r->regs[62]=0; \
asm-sh64/elf.h:       _r->tregs[0]=0; _r->tregs[1]=0; _r->tregs[2]=0; _r->tregs[3]=0; \
asm-sh64/elf.h:       _r->tregs[4]=0; _r->tregs[5]=0; _r->tregs[6]=0; _r->tregs[7]=0; \
asm-sh64/elf.h:       _r->sr = SR_FD | SR_MMU; } while (0)
asm-sh64/ide.h: *  linux/include/asm-sh64/ide.h
asm-sh64/ide.h: *  Copyright (C) 1994-1996  Linus Torvalds & authors
asm-sh64/ide.h:		hw->io_ports[i] = reg;
asm-sh64/ide.h:		hw->io_ports[IDE_CONTROL_OFFSET] = ctrl_port;
asm-sh64/ide.h:		hw->io_ports[IDE_CONTROL_OFFSET] = hw->io_ports[IDE_DATA_OFFSET] + 0x206;
asm-sh64/ide.h:	hw->io_ports[IDE_IRQ_OFFSET] = 0;
asm-sh64/ide.h:#include <asm-generic/ide_iops.h>
asm-sh64/ipc.h: * include/asm-sh64/ipc.h
asm-sh64/irq.h: * include/asm-sh64/irq.h
asm-sh64/irq.h: * Main reason is that there's no per-encoded-interrupt
asm-sh64/irq.h: * Priorities are set at Platform level, when IRQ_IRL0-3
asm-sh64/irq.h: * SH-5 supports Priority based interrupts only.
asm-sh64/pci.h:**                      P C I  -  C O M M O N  Internal Interface
asm-sh64/pci.h:** File:      include/asm-sh64/pci.h
asm-sh64/pci.h:** already-configured bus numbers - to be used for buggy BIOSes
asm-sh64/pci.h:** NULL for PCI-like buses (ISA, EISA).
asm-sh64/pci.h:** Returns non-NULL cpu-view pointer to the buffer if successful and
asm-sh64/pci.h:** The 32-bit bus address to use is returned.
asm-sh64/pci.h:	return ((dma_addr_t)(page - mem_map) *
asm-sh64/pci.h:** mode for DMA.  This is the scather-gather version of the
asm-sh64/pci.h:** The same as pci_dma_sync_single but for a scatter-gather list,
asm-sh64/pci.h:** only drive the low 24-bits during PCI bus mastering, then
asm-sh64/pci.h:/* Not supporting more than 32-bit PCI bus addresses now, but
asm-sh64/pci.h:#define sg_dma_address(sg)      ((sg)->dma_address)
asm-sh64/pci.h:#define sg_dma_len(sg)          ((sg)->length)
asm-sh64/smp.h: * include/asm-sh64/smp.h
asm-sh64/tlb.h: * include/asm-sh64/tlb.h
asm-sh64/tlb.h:#include <asm-generic/tlb.h>
asm-sh64/tlb.h: * Defined for both I and D tlb, per-processor.
asm-sh64/tlb.h: * Iterate over free (non-wired) DTLB entries
asm-sh64/tlb.h:	for (tlb  = cpu_data->dtlb.first;	\
asm-sh64/tlb.h:	     tlb <= cpu_data->dtlb.last;	\
asm-sh64/tlb.h:	     tlb += cpu_data->dtlb.step)
asm-sh64/tlb.h: * Iterate over free (non-wired) ITLB entries
asm-sh64/tlb.h:	for (tlb  = cpu_data->itlb.first;	\
asm-sh64/tlb.h:	     tlb <= cpu_data->itlb.last;	\
asm-sh64/tlb.h:	     tlb += cpu_data->itlb.step)
asm-sh64/signal.h: * include/asm-sh64/signal.h
asm-sh64/signal.h:#define SIGRTMAX	(_NSIG-1)
asm-sh64/signal.h: * SA_INTERRUPT is a no-op, but left due to historical reasons. Use the
asm-sh64/signal.h:#define SA_INTERRUPT	0x20000000 /* dummy -- ignored */
asm-sh64/signal.h:#define SIG_ERR	((__sighandler_t)-1)	/* error return from signal */
asm-sh64/signal.h:#define sigmask(sig)	(1UL << ((sig) - 1))
asm-sh64/hardirq.h:#define irq_exit(cpu, irq)	(local_irq_count(cpu)--)
asm-sh64/hardirq.h:#error Super-H SMP is not available
asm-sh64/shmparam.h: * include/asm-sh64/shmparam.h
asm-sh64/shmparam.h:#define	SHMLBA	(cpu_data->dcache.sets * L1_CACHE_BYTES)
asm-sh64/sigcontext.h: * include/asm-sh64/sigcontext.h
asm-sh64/platform.h: * include/asm-sh64/platform.h
asm-sh64/platform.h:#define code_resource (platform_parms.kram_res_p[STANDARD_KRAM_RESOURCES - 2])
asm-sh64/platform.h:#define data_resource (platform_parms.kram_res_p[STANDARD_KRAM_RESOURCES - 1])
asm-sh64/platform.h:/* Be prepared to 64-bit sign extensions */
asm-sh64/platform.h:#define PFN_UP(x)       ((((x) + PAGE_SIZE-1) >> PAGE_SHIFT) & 0x000fffff)
asm-sh64/processor.h: * include/asm-sh64/processor.h
asm-sh64/processor.h: * User space process size: 2GB - 4k.
asm-sh64/processor.h: * FD-bit:
asm-sh64/processor.h: * IMASK-bit:
asm-sh64/processor.h: * STEP-bit:
asm-sh64/processor.h: * FPU structure and data : require 8-byte alignment as we need to access it
asm-sh64/processor.h:	regs->sr = SR_USER;	/* User mode. */ 		\
asm-sh64/processor.h:	regs->pc = new_pc - 4;	/* Compensate syscall exit */	\
asm-sh64/processor.h:	regs->pc |= 1;		/* Set SHmedia ! */		\
asm-sh64/processor.h:	regs->regs[18] = 0;   		 	 		\
asm-sh64/processor.h:	regs->regs[15] = new_sp
asm-sh64/processor.h:   zero-divide, invalid.  Configure option for whether to flush denorms to
asm-sh64/processor.h:	return t->pc;
asm-sh64/processor.h:#define KSTK_EIP(tsk)  ((tsk)->thread.pc)
asm-sh64/processor.h:#define KSTK_ESP(tsk)  ((tsk)->thread.sp)
asm-sh64/linux_logo.h: * include/asm-shmedia/linux_logo.h
asm-sh64/mmu_context.h: * include/asm-sh64/mmu_context.h
asm-sh64/mmu_context.h:/* ASID is 8-bit value, so it can't be 0x100 */
asm-sh64/mmu_context.h:	mm->context = mc;
asm-sh64/mmu_context.h:		if ((mm->context ^ mc) & MMU_CONTEXT_VERSION_MASK)
asm-sh64/mmu_context.h:	mm->context = NO_CONTEXT;
asm-sh64/mmu_context.h: * After we have set current->mm to a new value, this activates
asm-sh64/mmu_context.h:	set_asid(mm->context & MMU_CONTEXT_ASID_MASK);
asm-sh64/mmu_context.h:	set_bit(cpu, &next->cpu_vm_mask);
asm-sh64/mmu_context.h:		mmu_pdtp_cache = next->pgd;
asm-sh64/mmu_context.h:		clear_bit(cpu, &prev->cpu_vm_mask);
asm-sh64/semaphore.h: * SMP- and interrupt-safe semaphores.
asm-sh64/semaphore.h:	atomic_set(&sem->count, val);
asm-sh64/semaphore.h:	sem->sleepers = 0;
asm-sh64/semaphore.h:	init_waitqueue_head(&sem->wait);
asm-sh64/semaphore.h:	sem->__magic = (int)&sem->__magic;
asm-sh64/semaphore.h:	CHECK_MAGIC(sem->__magic);
asm-sh64/semaphore.h:	if (atomic_dec_return(&sem->count) < 0)
asm-sh64/semaphore.h:	CHECK_MAGIC(sem->__magic);
asm-sh64/semaphore.h:	if (atomic_dec_return(&sem->count) < 0)
asm-sh64/semaphore.h:	CHECK_MAGIC(sem->__magic);
asm-sh64/semaphore.h:	if (atomic_dec_return(&sem->count) < 0)
asm-sh64/semaphore.h:	CHECK_MAGIC(sem->__magic);
asm-sh64/semaphore.h:	if (atomic_inc_return(&sem->count) <= 0)
asm-sh64/fcntl.h:/* open/fcntl - O_SYNC is only implemented on blocks devices and on files
asm-sh64/fcntl.h:#define O_DIRECT	 040000	/* direct disk access hint - currently ignored */
asm-sh64/fcntl.h:#define F_GETFL		3	/* get file->f_flags */
asm-sh64/fcntl.h:#define F_SETFL		4	/* set file->f_flags */
asm-sh64/spinlock.h: * include/asm-sh64/spinlock.h
asm-sh64/errno.h: * include/asm-sh64/errno.h
asm-sh64/errno.h:#define	EXDEV		18	/* Cross-device link */
asm-sh64/errno.h:#define	EROFS		30	/* Read-only file system */
asm-sh64/errno.h:#define	ENOTSOCK	88	/* Socket operation on non-socket */
asm-sh64/byteorder.h: * include/asm-sh64/byteorder.h
asm-sh64/softirq.h:	local_bh_count(smp_processor_id())--;	\
asm-sh64/softirq.h:	if (!--local_bh_count(smp_processor_id())	\
asm-sh64/hw_irq.h: * include/asm-sh64/hw_irq.h
asm-sh64/timex.h: * include/asm-sh64/timex.h
asm-sh64/timex.h: * sh-5 architecture timex specifications
asm-sh64/timex.h:#define FINETUNE ((((((long)LATCH * HZ - CLOCK_TICK_RATE) << SHIFT_HZ) * \
asm-sh64/timex.h:		<< (SHIFT_SCALE-SHIFT_HZ)) / HZ)
asm-sh64/bugs.h: * include/asm-sh64/bugs.h
asm-sh64/bugs.h: * This is included by init/main.c to check for architecture-dependent bugs.
asm-sh64/bugs.h: * I don't know of any Super-H bugs yet.
asm-sh64/bugs.h:	cpu_data->loops_per_jiffy = loops_per_jiffy;
asm-sh64/namei.h: * include/asm-sh64/namei.h
asm-sh64/namei.h: * Look at asm-sparc/namei.h for details.
asm-sh64/termbits.h: * include/asm-sh64/termbits.h
asm-sh64/registers.h: * include/asm-sh64/registers.h
asm-sh64/registers.h:** Section 1: acts on assembly sources pre-processed by GPP ( <source.S>).
asm-sh64/registers.h:			/* cr14-cr15 UNDEFINED */
asm-sh64/registers.h:			/* cr19-cr31 UNDEFINED */
asm-sh64/registers.h:			/* cr32-cr61 RESERVED */
asm-sh64/init.h: * include/asm-sh64/init.h
asm-sh64/init.h:#error "<asm/init.h> should never be used - use <linux/init.h> instead"
asm-sh64/uaccess.h: * include/asm-sh64/uaccess.h
asm-sh64/uaccess.h:#define get_fs()        (current->addr_limit)
asm-sh64/uaccess.h:#define set_fs(x)       (current->addr_limit=(x))
asm-sh64/uaccess.h:#define __addr_ok(addr) ((unsigned long)(addr) < (current->addr_limit.seg))
asm-sh64/uaccess.h: * Uhhuh, this needs 33-bit arithmetic. We have a carry..
asm-sh64/uaccess.h: * sum := addr + size;  carry? --> flag = true;
asm-sh64/uaccess.h:#define __range_ok(addr,size) (((unsigned long) (addr) + (size) < (current->addr_limit.seg)) ? 0 : 1)
asm-sh64/uaccess.h:	return access_ok(type,addr,size) ? 0 : -EFAULT;
asm-sh64/uaccess.h: * Uh, these should become the main single-value transfer routines ...
asm-sh64/uaccess.h: * (a) re-use the arguments for side effects (sizeof is ok)
asm-sh64/uaccess.h:long __sfu_res = -EFAULT; \
asm-sh64/semaphore-helper.h: * include/asm-sh64/semaphore-helper.h
asm-sh64/semaphore-helper.h: * SMP- and interrupt-safe semaphores helper functions.
asm-sh64/semaphore-helper.h:	atomic_inc((atomic_t *)&sem->sleepers);
asm-sh64/semaphore-helper.h:	if (sem->sleepers > 0) {
asm-sh64/semaphore-helper.h:		sem->sleepers--;
asm-sh64/semaphore-helper.h: *	-EINTR	interrupted
asm-sh64/semaphore-helper.h: * We must undo the sem->count down_interruptible() increment while we are
asm-sh64/semaphore-helper.h: * atomic_read() in wake_one_more(), otherwise we can race. -arca
asm-sh64/semaphore-helper.h:	if (sem->sleepers > 0) {
asm-sh64/semaphore-helper.h:		sem->sleepers--;
asm-sh64/semaphore-helper.h:		atomic_inc(&sem->count);
asm-sh64/semaphore-helper.h:		ret = -EINTR;
asm-sh64/semaphore-helper.h: * We must undo the sem->count down_trylock() increment while we are
asm-sh64/semaphore-helper.h: * atomic_read() in wake_one_more(), otherwise we can race. -arca
asm-sh64/semaphore-helper.h:	if (sem->sleepers <= 0)
asm-sh64/semaphore-helper.h:		atomic_inc(&sem->count);
asm-sh64/semaphore-helper.h:		sem->sleepers--;
asm-sh64/mman.h: * include/asm-sh64/mman.h
asm-sh64/mman.h:#define MAP_GROWSDOWN	0x0100		/* stack-like segment */
asm-sh64/mman.h:#define MADV_NORMAL	0x0		/* default page-in behavior */
asm-sh64/mman.h:#define MADV_RANDOM	0x1		/* page-in minimum required */
asm-sh64/mman.h:#define MADV_SEQUENTIAL	0x2		/* read-ahead aggressively */
asm-sh64/mman.h:#define MADV_WILLNEED	0x3		/* pre-fault pages */
asm-sh64/posix_types.h: * include/asm-sh64/posix_types.h
asm-sh64/posix_types.h: * This file is generally used by user-level software, so you need to
asm-sh64/posix_types.h:	__fdsetp->fds_bits[__tmp] |= (1UL<<__rem);
asm-sh64/posix_types.h:	__fdsetp->fds_bits[__tmp] &= ~(1UL<<__rem);
asm-sh64/posix_types.h:	return (__p->fds_bits[__tmp] & (1UL<<__rem)) != 0;
asm-sh64/posix_types.h: * for a 256-bit fd_set)
asm-sh64/posix_types.h:	unsigned long *__tmp = __p->fds_bits;
asm-sh64/posix_types.h:		__i--;
asm-sh64/scatterlist.h:**                      P C I  -  C O M M O N  Internal Interface
asm-sh64/scatterlist.h:** File:      include/asm-sh64/scatterlist.h
asm-sh64/smplock.h: * include/asm-sh64/smplock.h
asm-sh64/smplock.h:	if (!++current->lock_depth)
asm-sh64/smplock.h:	if (--current->lock_depth < 0)
asm-sh64/smplock.h:	if (task->lock_depth >= 0) \
asm-sh64/smplock.h: * Re-acquire the kernel lock
asm-sh64/smplock.h:	if (task->lock_depth >= 0) \
asm-sh64/page.h: * include/asm-sh64/page.h
asm-sh64/page.h: * Modified to take account of enabling for D-CACHE support.
asm-sh64/page.h:#define PAGE_MASK	(~(PAGE_SIZE-1))
asm-sh64/page.h: * These are used to make use of C type-checking..
asm-sh64/page.h:#define PAGE_ALIGN(addr)	(((addr)+PAGE_SIZE-1)&PAGE_MASK)
asm-sh64/page.h:#define __pa(x)			((unsigned long)(x)-PAGE_OFFSET)
asm-sh64/page.h:#define MAP_NR(addr)		((__pa(addr)-__MEMORY_START) >> PAGE_SHIFT)
asm-sh64/page.h:#define VALID_PAGE(page)	((page - mem_map) < max_mapnr)
asm-sh64/page.h:#define phys_to_page(phys)	(mem_map + (((phys)-__MEMORY_START) >> PAGE_SHIFT))
asm-sh64/page.h:#define page_to_phys(page)	(((page - mem_map) << PAGE_SHIFT) + __MEMORY_START)
asm-sh64/page.h:	size = (size-1) >> (PAGE_SHIFT-1);
asm-sh64/page.h:	order = -1;
asm-sh64/hdreg.h: *  linux/include/asm-sh64/hdreg.h
asm-sh64/hdreg.h: *  Copyright (C) 1994-1996  Linus Torvalds & authors
asm-sh64/poll.h: * include/asm-sh64/poll.h
asm-sh64/poll.h:/* The rest seem to be more-or-less nonstandard. Check them! */
asm-sh64/current.h: * include/asm-sh64/current.h
asm-sh64/types.h: * include/asm-sh64/types.h
asm-sh64/types.h:/* DMA addresses come in generic and 64-bit flavours.  */
asm-sh64/sembuf.h: * include/asm-sh64/sembuf.h
asm-sh64/sembuf.h: * - 64-bit time_t to solve y2038 problem
asm-sh64/sembuf.h: * - 2 miscellaneous 32-bit values
asm-sh64/system.h: * include/asm-sh64/system.h
asm-sh64/system.h: __asm__ __volatile__("addi.l	r15, -256, r15\n\t"		\
asm-sh64/system.h:  regs = next->thread.kregs;                                    \
asm-sh64/system.h:  regs->sr |= SR_FD;						\
asm-sh64/system.h: r36 = &prev->thread.sp;					\
asm-sh64/system.h: r37 = &prev->thread.pc;					\
asm-sh64/system.h: r38 = next->thread.sp | NEFF_MASK;				\
asm-sh64/system.h: r39 = next->thread.pc | NEFF_MASK;				\
asm-sh64/system.h: __asm__ __volatile__("addi.l	r15, -304, r15\n\t"		\
asm-sh64/system.h:		__sti();			/* yes...re-enable */	\
asm-sh64/stat.h: * include/asm-sh64/stat.h
asm-sh64/stat.h:	unsigned long	st_blocks;	/* Number 512-byte blocks allocated. */
asm-sh64/checksum.h: * include/asm-sh64/checksum.h
asm-sh64/checksum.h: * and adds in "sum" (32-bit)
asm-sh64/checksum.h: * returns a 32-bit number suitable for feeding into itself
asm-sh64/checksum.h: * it's best to have buff aligned on a 32-bit boundary
asm-sh64/checksum.h: * checksums, and handles user-space pointer exceptions correctly, when needed.
asm-sh64/checksum.h: * here even more important to align src and dst on a 32-bit (or even
asm-sh64/checksum.h: * better 64-bit) boundary
asm-sh64/checksum.h:		"shlli	%2, 1, %2\n\t"		/* Longs -> Shorts */
asm-sh64/checksum.h:		"addi	%2, -2, %2\n\t"		/* Last Short to start from */
asm-sh64/checksum.h:		"addi	%2, -2, %2\n\t"		/* Do it reverse */
asm-sh64/checksum.h:		"addi	%2, -2, %2\n\t"		/* Do it reverse */
asm-sh64/checksum.h:		"bnei	%2, -2, " __t0 "\n\t"
asm-sh64/checksum.h: * computes the checksum of the TCP/UDP pseudo-header
asm-sh64/checksum.h: * returns a 16-bit checksum, already complemented
asm-sh64/checksum.h: * this routine is used for miscellaneous IP-like checksums, mainly
asm-sh64/checksum.h:		*err_ptr = -EFAULT;
asm-sh64/checksum.h:	return -1; /* invalid checksum */
asm-sh64/termios.h: * include/asm-sh64/termios.h
asm-sh64/termios.h:#define N_IRDA		11	/* Linux IR - http://www.cs.uit.no/~dagb/irda/irda.html */
asm-sh64/termios.h:#define N_SMSBLOCK	12	/* SMS block mode - for talking to GSM data cards about SMS messages */
asm-sh64/termios.h:	get_user(__tmp,&(termio)->x); \
asm-sh64/termios.h:	*(unsigned short *) &(termios)->x = __tmp; \
asm-sh64/termios.h:	copy_from_user((termios)->c_cc, (termio)->c_cc, NCC); \
asm-sh64/termios.h:	put_user((termios)->c_iflag, &(termio)->c_iflag); \
asm-sh64/termios.h:	put_user((termios)->c_oflag, &(termio)->c_oflag); \
asm-sh64/termios.h:	put_user((termios)->c_cflag, &(termio)->c_cflag); \
asm-sh64/termios.h:	put_user((termios)->c_lflag, &(termio)->c_lflag); \
asm-sh64/termios.h:	put_user((termios)->c_line,  &(termio)->c_line); \
asm-sh64/termios.h:	copy_to_user((termio)->c_cc, (termios)->c_cc, NCC); \
asm-sh64/user.h: * include/asm-sh64/user.h
asm-sh64/user.h: * linux we use the `trad-core' bfd).  The file contents are as follows:
asm-sh64/user.h: *  data: The data segment follows next.  We use current->end_text to
asm-sh64/user.h: *	current->brk to pick up all of the user variables, plus any memory
asm-sh64/user.h: *	page is demand-zero or if a page is totally unused, we just cover
asm-sh64/user.h: *	current->start_stack, so we round each of these in order to be able
asm-sh64/user.h:	struct user_fpu_struct fpu;	/* Math Co-processor registers  */
asm-sh64/user.h:	int u_fpvalid;		/* True if math co-processor being used */
asm-sh64/user.h:	struct user_fpu_struct* u_fpstate;	/* Math Co-processor pointer */
asm-sh64/statfs.h: * include/asm-sh64/statfs.h
asm-sh64/serial.h: * include/asm-sh/serial.h
asm-sh64/pgtable.h: * include/asm-sh64/pgtable.h
asm-sh64/pgtable.h: * Basically we have the same two-level (which is the logical three level
asm-sh64/pgtable.h: * for zero-mapped memory areas etc..
asm-sh64/pgtable.h: * FIXME : These need to be model-dependent.  For now this is OK, SH5-101 and SH5-103
asm-sh64/pgtable.h:#define	NEFF_SIGN	(1LL << (NEFF - 1))
asm-sh64/pgtable.h:#define	NEFF_MASK	(-1LL << NEFF)
asm-sh64/pgtable.h:#define	NPHYS_SIGN	(1LL << (NPHYS - 1))
asm-sh64/pgtable.h:#define	NPHYS_MASK	(-1LL << NPHYS)
asm-sh64/pgtable.h:/* Typically 2-level is sufficient up to 32 bits of virtual address space, beyond
asm-sh64/pgtable.h:   that 3-level would be appropriate. */
asm-sh64/pgtable.h:#define PTE_BITS	(PAGE_SHIFT - PTE_MAGNITUDE)
asm-sh64/pgtable.h:#define PGD_BITS	(NEFF - PGDIR_SHIFT)
asm-sh64/pgtable.h:/* middle level: PMD. This doesn't do anything for the 2-level case. */
asm-sh64/pgtable.h:#define PGDIR_MASK	(~(PGDIR_SIZE-1))
asm-sh64/pgtable.h: * three-level asymmetric paging structure: PGD is top level.
asm-sh64/pgtable.h: * The asymmetry comes from 32-bit pointers and 64-bit PTEs.
asm-sh64/pgtable.h:#define PTE_BITS	(PAGE_SHIFT - PTE_MAGNITUDE)
asm-sh64/pgtable.h:#define PMD_BITS	(PAGE_SHIFT - PMD_MAGNITUDE)
asm-sh64/pgtable.h:#define PGD_BITS	(NEFF - PGDIR_SHIFT)
asm-sh64/pgtable.h:#define PMD_MASK	(~(PMD_SIZE-1))
asm-sh64/pgtable.h:#define PGDIR_MASK	(~(PGDIR_SIZE-1))
asm-sh64/pgtable.h:	 * Sign-extend based on NPHYS.
asm-sh64/pgtable.h:#define pgd_index(address) (((address) >> PGDIR_SHIFT) & (PTRS_PER_PGD-1))
asm-sh64/pgtable.h:#define pgd_offset(mm, address) ((mm)->pgd+pgd_index(address))
asm-sh64/pgtable.h:		(((address) >> PMD_SHIFT) & (PTRS_PER_PMD-1))
asm-sh64/pgtable.h:		((address >> PAGE_SHIFT) & (PTRS_PER_PTE - 1))
asm-sh64/pgtable.h:#define USER_PTRS_PER_PGD	((TASK_SIZE+PGDIR_SIZE-1)/PGDIR_SIZE)
asm-sh64/pgtable.h:/* The bits that are required in the SH-5 TLB are placed in the h/w-defined
asm-sh64/pgtable.h:   scheme doesn't map to SH-5 because bit [0] controls cacheability.  So bit
asm-sh64/pgtable.h:#define _PAGE_WT	0x001  /* CB0: if cacheable, 1->write-thru, 0->write-back */
asm-sh64/pgtable.h:#define _PAGE_DEVICE	0x001  /* CB0: if uncacheable, 1->device (i.e. no write-combining or reordering at bus level) */
asm-sh64/pgtable.h:#define _PAGE_SIZE0	0x008  /* SZ0-bit : size of page */
asm-sh64/pgtable.h:#define _PAGE_SIZE1	0x010  /* SZ1-bit : size of page */
asm-sh64/pgtable.h:#define _PAGE_READ	0x040  /* PR0-bit : read access allowed */
asm-sh64/pgtable.h:#define _PAGE_EXECUTE	0x080  /* PR1-bit : execute access allowed */
asm-sh64/pgtable.h:#define _PAGE_WRITE	0x100  /* PR2-bit : write access allowed */
asm-sh64/pgtable.h:#define _PAGE_USER	0x200  /* PR3-bit : user space access allowed */
asm-sh64/pgtable.h:   registers into user-space via /dev/map).  */
asm-sh64/pgtable.h:#define pte_pagenr(x)		(((unsigned long) (pte_val(x)) - \
asm-sh64/pgtable.h:#define pages_to_mb(x) ((x) >> (20-PAGE_SHIFT))
asm-sh64/pgtable.h:	set_pte(&__pte, __pte((((page)-mem_map) << PAGE_SHIFT) | 		\
asm-sh64/pgtable.h:/* Swap-related things */
asm-sh64/pgtable.h:/* Encode and de-code a swap entry */
asm-sh64/unaligned.h: * include/asm-sh64/unaligned.h
asm-sh64/param.h: * include/asm-sh64/param.h
asm-sh64/param.h:#  define HZ		1000		/* Needed for high-res WOVF */
asm-sh64/param.h:#define NOGROUP		(-1)
asm-sh64/cache.h: * include/asm-sh64/cache.h
asm-sh64/cache.h:#define L1_CACHE_ALIGN_MASK	(~(L1_CACHE_BYTES - 1))
asm-sh64/cache.h:#define L1_CACHE_ALIGN(x)	(((x)+(L1_CACHE_BYTES - 1)) & L1_CACHE_ALIGN_MASK)
asm-sh64/cache.h: * SH-5
asm-sh64/cache.h: *                               |<--- tag  (19 bits) --->|
asm-sh64/cache.h: * +-----------------------------+-----------------+------+----------+------+
asm-sh64/cache.h: * +-----------------------------+-----------------+------+----------+------+
asm-sh64/cache.h: *                                +- Bit 31
asm-sh64/cache.h: * Defined for both I and D cache, per-processor.
asm-sh64/cache.h:   case of SH5-101 & SH5-103, only bit 12 is affected for 4k pages. */
asm-sh64/cache.h:#define CACHE_OC_SYN_MASK   (((1UL<<CACHE_OC_N_SYNBITS)-1)<<CACHE_OC_SYN_SHIFT)
asm-sh64/siginfo.h:#define SI_PAD_SIZE	((SI_MAX_SIZE/sizeof(int)) - 3)
asm-sh64/siginfo.h: * Digital reserves positive values for kernel-generated signals.
asm-sh64/siginfo.h:#define SI_QUEUE	-1		/* sent by sigqueue */
asm-sh64/siginfo.h:#define SI_TIMER __SI_CODE(__SI_TIMER,-2) /* sent by timer expiration */
asm-sh64/siginfo.h:#define SI_MESGQ	-3		/* sent by real time mesq state change */
asm-sh64/siginfo.h:#define SI_ASYNCIO	-4		/* sent by AIO completion */
asm-sh64/siginfo.h:#define SI_SIGIO	-5		/* sent by queued SIGIO */
asm-sh64/siginfo.h:#define SI_TKILL	-6		/* sent by tkill system call */
asm-sh64/siginfo.h:#define SI_FROMUSER(siptr)	((siptr)->si_code <= 0)
asm-sh64/siginfo.h:#define SI_FROMKERNEL(siptr)	((siptr)->si_code > 0)
asm-sh64/siginfo.h:#define BUS_ADRERR	(__SI_FAULT|2)	/* non-existant physical address */
asm-sh64/siginfo.h:#define SIGEV_PAD_SIZE	((SIGEV_MAX_SIZE/sizeof(int)) - 3)
asm-sh64/siginfo.h:	if (from->si_code < 0)
asm-sh64/siginfo.h:		memcpy(to, from, 3*sizeof(int) + sizeof(from->_sifields._sigchld));
asm-sh64/sockios.h: * include/asm-sh64/sockios.h
asm-sh64/sockios.h:/* Socket-level I/O control calls. */
asm-sh64/sockios.h:#define SIOCGSTAMP	_IOR('s', 100, struct timeval) /* Get stamp - linux-specific */
asm-sh64/keyboard.h: *  linux/include/asm-shmedia/keyboard.h
asm-sh64/a.out.h: * include/asm-sh64/a.out.h
asm-sh64/ioctl.h: * include/asm-sh64/ioctl.h
asm-sh64/ioctl.h: * NOTE: This limits the max parameter size to 16kB -1 !
asm-sh64/ioctl.h:#define _IOC_NRMASK	((1 << _IOC_NRBITS)-1)
asm-sh64/ioctl.h:#define _IOC_TYPEMASK	((1 << _IOC_TYPEBITS)-1)
asm-sh64/ioctl.h:#define _IOC_SIZEMASK	((1 << _IOC_SIZEBITS)-1)
asm-sh64/ioctl.h:#define _IOC_DIRMASK	((1 << _IOC_DIRBITS)-1)
asm-sh64/string.h: * include/asm-sh64/string.h
asm-sh64/ioctls.h: * include/asm-sh64/ioctls.h
asm-sh64/ioctls.h:#define TIOCGPTN	_IOR('T',0x30, unsigned int) /* Get Pty Number (of pty-mux device) */
asm-sh64/msgbuf.h: * include/asm-sh64/msgbuf.h
asm-sh64/msgbuf.h: * - 64-bit time_t to solve y2038 problem
asm-sh64/msgbuf.h: * - 2 miscellaneous 32-bit values
asm-sh64/socket.h:/* Security levels - as per NRL IPv6 - don't actually do anything */
asm-sh64/socket.h:/* Nast libc5 fixup - bletch */
asm-sh64/socket.h:#define SOCK_RDM	4		/* reliably-delivered message	*/
asm-sparc/sunbpp.h: * include/asm-sparc/sunbpp.h
asm-sparc/sunbpp.h:#define P_OCR_EN_VER    0x0001      /* Enable Versatec (0 - enable). Zebra only. */
asm-sparc/viking.h: * -----------------------------------------------------------
asm-sparc/viking.h: * |impl-vers| RSV |TC|AC|SP|BM|PC|MBM|SB|IC|DC|PSO|RSV|NF|ME|
asm-sparc/viking.h: * -----------------------------------------------------------
asm-sparc/viking.h: *  31     24 23-17 16 15 14 13 12 11  10  9  8  7  6-2  1  0
asm-sparc/viking.h: * TC: Tablewalk Cacheable -- 0 = Twalks are not cacheable in E-cache
asm-sparc/viking.h: *                            1 = Twalks are cacheable in E-cache
asm-sparc/viking.h: * GNU/Viking will only cache tablewalks in the E-cache (mxcc) if present
asm-sparc/viking.h: * for machines lacking an E-cache (ie. in MBUS mode) this bit must
asm-sparc/viking.h: * AC: Alternate Cacheable -- 0 = Passthru physical accesses not cacheable
asm-sparc/viking.h: * is present in the pte when the processor is in boot-mode or the
asm-sparc/viking.h: * access does not need pte's for translation (ie. pass-thru ASI's).
asm-sparc/viking.h: * "Cachable" is only referring to E-cache (if present) and not the
asm-sparc/viking.h: * SP: SnooP Enable -- 0 = bus snooping off, 1 = bus snooping on
asm-sparc/viking.h: * to work at all.  On non-mxcc GNU/Viking modules the split I/D
asm-sparc/viking.h: * not affect GNU/Viking store-buffer snoops, those happen if the
asm-sparc/viking.h: * store-buffer is enabled no matter what.
asm-sparc/viking.h: * BM: Boot Mode -- 0 = not in boot mode, 1 = in boot mode
asm-sparc/viking.h: * This indicates whether the GNU/Viking is in boot-mode or not,
asm-sparc/viking.h: * GNU/Viking boot-mode does not affect data accesses.  Also,
asm-sparc/viking.h: * MBM: MBus Mode -- 0 = not in MBus mode, 1 = in MBus mode
asm-sparc/viking.h: * MBUS mode, the GNU/Viking lacks a GNU/MXCC E-cache.  If it is
asm-sparc/viking.h: * to either an GNU/MBUS (sun4m) or the packet-switched GNU/XBus (sun4d).
asm-sparc/viking.h: * SB: StoreBuffer enable -- 0 = store buffer off, 1 = store buffer on
asm-sparc/viking.h: * IC: Instruction Cache -- 0 = off, 1 = on
asm-sparc/viking.h: * DC: Data Cache -- 0 = off, 1 = 0n
asm-sparc/viking.h: * These bits enable the on-cpu GNU/Viking split I/D caches.  Note,
asm-sparc/viking.h: * NF: No Fault -- 0 = faults generate traps, 1 = faults don't trap
asm-sparc/viking.h: * ME: MMU enable -- 0 = mmu not translating, 1 = mmu translating
asm-sparc/viking.h:#define VIKING_TCENABLE     0x00010000   /* Enable table-walks to be cached */
asm-sparc/io.h:#define page_to_phys(page)     ((((page) - mem_map) << PAGE_SHIFT)+phys_base)
asm-sparc/io.h:	while(n--) {
asm-sparc/io.h:/* P3: talk davem into dropping "name" argument in favor of res->name */
asm-sparc/io.h: * Bus number may be in res->flags... somewhere.
asm-sparc/turbosparc.h: * -------------------------------------------------------------------
asm-sparc/turbosparc.h: * |impl-vers| RSV| PMC |PE|PC| RSV |BM| RFR |IC|DC|PSO|RSV|ICS|NF|ME|
asm-sparc/turbosparc.h: * -------------------------------------------------------------------
asm-sparc/turbosparc.h: *  31    24 23-21 20-19 18 17 16-15 14 13-10  9  8  7  6-3   2  1  0
asm-sparc/turbosparc.h: * BM: Boot Mode -- 0 = not in boot mode, 1 = in boot mode
asm-sparc/turbosparc.h: * This indicates whether the TurboSparc is in boot-mode or not.
asm-sparc/turbosparc.h: * IC: Instruction Cache -- 0 = off, 1 = on
asm-sparc/turbosparc.h: * DC: Data Cache -- 0 = off, 1 = 0n
asm-sparc/turbosparc.h: * These bits enable the on-cpu TurboSparc split I/D caches.
asm-sparc/turbosparc.h: * ICS: ICache Snooping -- 0 = disable, 1 = enable snooping of icache
asm-sparc/turbosparc.h: * NF: No Fault -- 0 = faults generate traps, 1 = faults don't trap
asm-sparc/turbosparc.h: * ME: MMU enable -- 0 = mmu not translating, 1 = mmu translating
asm-sparc/turbosparc.h: * -------------------------------------------------------
asm-sparc/turbosparc.h: * -------------------------------------------------------
asm-sparc/turbosparc.h: *    31   30 29-28 27-26 25-23   22-8  7-6  5  4   3 2-0
asm-sparc/atomic.h:/* atomic.h: These still suck, but the I-cache hit rate is higher.
asm-sparc/atomic.h:#define atomic_read(v)          ((v)->counter)
asm-sparc/atomic.h:#define atomic_set(v, i)        (((v)->counter) = i)
asm-sparc/atomic.h: *	----------------------------------------
asm-sparc/atomic.h: *	| signed 24-bit counter value |  lock  |  atomic_t
asm-sparc/atomic.h: *	----------------------------------------
asm-sparc/atomic.h:	int ret = v->counter;
asm-sparc/atomic.h:		ret = v->counter;
asm-sparc/atomic.h:#define atomic_set(v, i)	(((v)->counter) = ((i) << 8))
asm-sparc/atomic.h:	ptr = &v->counter;
asm-sparc/atomic.h:	ptr = &v->counter;
asm-sparc/ipcbuf.h: * - 32-bit mode
asm-sparc/ipcbuf.h: * - 32-bit seq
asm-sparc/ipcbuf.h: * - 2 miscellaneous 64-bit values (so that this structure matches
asm-sparc/shmbuf.h: * - 64-bit time_t to solve y2038 problem
asm-sparc/shmbuf.h: * - 2 miscellaneous 32-bit values
asm-sparc/sfp-machine.h:/* Machine-dependent software floating-point definitions.
asm-sparc/sfp-machine.h:   59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
asm-sparc/sfp-machine.h:#define _FP_NANFRAC_S		((_FP_QNANBIT_S << 1) - 1)
asm-sparc/sfp-machine.h:#define _FP_NANFRAC_D		((_FP_QNANBIT_D << 1) - 1), -1
asm-sparc/sfp-machine.h:#define _FP_NANFRAC_Q		((_FP_QNANBIT_Q << 1) - 1), -1, -1, -1
asm-sparc/sfp-machine.h:#define FP_ROUNDMODE	((current->thread.fsr >> 30) & 0x3)
asm-sparc/sfp-machine.h:#define FP_ROUNDMODE	((last_task_used_math->thread.fsr >> 30) & 0x3)
asm-sparc/sfp-machine.h:#define FP_INHIBIT_RESULTS ((current->thread.fsr >> 23) & _fex)
asm-sparc/sfp-machine.h:#define FP_INHIBIT_RESULTS ((last_task_used_math->thread.fsr >> 23) & _fex)
asm-sparc/bitops.h: * Set bit 'nr' in 32-bit quantity at address 'addr' where bit '0'
asm-sparc/bitops.h: * within the first byte. Sparc is BIG-Endian. Unless noted otherwise
asm-sparc/bitops.h: * all bit-ops return 0 if bit was previously clear and != 0 otherwise.
asm-sparc/bitops.h: * non-atomic versions
asm-sparc/bitops.h: * of bits set) of a N-bit word
asm-sparc/bitops.h:	size -= result;
asm-sparc/bitops.h:		tmp |= ~0UL >> (32-offset);
asm-sparc/bitops.h:		size -= 32;
asm-sparc/bitops.h:		size -= 32;
asm-sparc/bitops.h: * non-atomic versions
asm-sparc/bitops.h:	size -= result;
asm-sparc/bitops.h:		tmp |= __swab32(~0UL >> (32-offset));
asm-sparc/bitops.h:		size -= 32;
asm-sparc/bitops.h:		size -= 32;
asm-sparc/div64.h:/* We're not 64-bit, but... */
asm-sparc/resource.h:#define RLIMIT_MEMLOCK  8               /* max locked-in-memory address space */
asm-sparc/ptrace.h:#define user_mode(regs) (!((regs)->psr & PSR_PS))
asm-sparc/ptrace.h:#define instruction_pointer(regs) ((regs)->pc)
asm-sparc/ptrace.h:#define PTRACE_GETUCODE           29  /* stupid bsd-ism */
asm-sparc/unistd.h:#define __NR_pause               29 /* Is sigblock(0)->sigpause() in SunOS         */
asm-sparc/unistd.h:/* #define __NR_iopl            209    Linux Specific - i386 specific, unused      */
asm-sparc/unistd.h:/* #define __NR_idle            210    Linux Specific - was sys_idle, now unused   */
asm-sparc/unistd.h:/* #define __NR_vm86            211    Linux Specific - i386 specific, unused      */
asm-sparc/unistd.h:/* #define __NR_modify_ldt      218    Linux Specific - i386 specific, unused      */
asm-sparc/unistd.h:if (__res < -255 || __res >= 0) \
asm-sparc/unistd.h:errno = -__res; \
asm-sparc/unistd.h:return -1; \
asm-sparc/unistd.h:if (__res < -255 || __res >= 0) \
asm-sparc/unistd.h:errno = -__res; \
asm-sparc/unistd.h:return -1; \
asm-sparc/unistd.h:if (__res < -255 || __res >= 0) \
asm-sparc/unistd.h:errno = -__res; \
asm-sparc/unistd.h:return -1; \
asm-sparc/unistd.h:if (__res < -255 || __res>=0) \
asm-sparc/unistd.h:errno = -__res; \
asm-sparc/unistd.h:return -1; \
asm-sparc/unistd.h:if (__res < -255 || __res>=0) \
asm-sparc/unistd.h:errno = -__res; \
asm-sparc/unistd.h:return -1; \
asm-sparc/unistd.h:if (__res < -255 || __res>=0) \
asm-sparc/unistd.h:errno = -__res; \
asm-sparc/unistd.h:return -1; \
asm-sparc/unistd.h: * we need this inline - forking from kernel space will result
asm-sparc/unistd.h: * calls - which means inline code for fork too, as otherwise we
asm-sparc/unistd.h:	return waitpid(-1,wait_stat,0);
asm-sparc/apc.h:/* apc - Driver definitions for power management functions
asm-sparc/apc.h: * of Aurora Personality Chip (APC) on SPARCstation-4/5 and 
asm-sparc/apc.h: * IDLE - CPU standby values (set to initiate standby)
asm-sparc/apc.h: * FANCTL - Fan speed control state values
asm-sparc/apc.h: * CPWR - Convenience power outlet state values 
asm-sparc/apc.h: * BPA/BPB - Read-Write "Bit Ports" state values (reset to 0 at power-on)
asm-sparc/apc.h: * WARNING: Internal usage of bit ports is platform dependent--
asm-sparc/apc.h: * On SS5 BPA seems to toggle onboard ethernet loopback... -E
asm-sparc/asi.h:/* SPARCstation-5: only 6 bits are decoded. */
asm-sparc/asi.h:/* Block-copy operations are available only on certain V8 cpus. */
asm-sparc/asi.h:/* Block-fill operations are available on certain V8 cpus */
asm-sparc/asi.h: * the available ASI's for physical ram pass-through, but I don't have
asm-sparc/asi.h:#define ASI_M_VMEUS        0x2A   /* VME user 16-bit access */
asm-sparc/asi.h:#define ASI_M_VMEPS        0x2B   /* VME priv 16-bit access */
asm-sparc/asi.h:#define ASI_M_VMEUT        0x2C   /* VME user 32-bit access */
asm-sparc/asi.h:#define ASI_M_VMEPT        0x2D   /* VME priv 32-bit access */
asm-sparc/bpp.h: * This is a driver that supports IEEE Std 1284-1994 communications
asm-sparc/bpp.h: * with bizzarro-mode of the ACME Special TurboThingy Plus.
asm-sparc/dma.h: * include/asm-sparc/dma.h
asm-sparc/dma.h:#include <asm/vac-ops.h>  /* for invalidate's, etc. */
asm-sparc/dma.h: * Or is rev0 present only on sun4 boxes? -jj */
asm-sparc/dma.h:#define DMA_ISBROKEN(dma)    ((dma)->revision == dvmarev0 || (dma)->revision == dvmarev1)
asm-sparc/dma.h:#define DMA_ISBROKEN(dma)    ((dma)->revision == dvmarev1)
asm-sparc/dma.h:#define DMA_ISESC1(dma)      ((dma)->revision == dvmaesc1)
asm-sparc/dma.h:#define DMA_SCSI_SBUS64  0x00008000        /* HME: Enable 64-bit SBUS mode. */
asm-sparc/dma.h:#define DMA_BRST0        0x00080000        /* SCSI: no bursts (non-HME gate arrays) */
asm-sparc/dma.h:#define DMA_EN_ENETAUI   DMA_3CLKS         /* Put lance into AUI-cable mode */
asm-sparc/dma.h:/* Values describing the burst-size property from the PROM */
asm-sparc/dma.h:#define DMA_MAXEND(addr) (0x01000000UL-(((unsigned long)(addr))&0x00ffffffUL))
asm-sparc/dma.h:#define DMA_ERROR_P(regs)  ((((regs)->cond_reg) & DMA_HNDL_ERROR))
asm-sparc/dma.h:#define DMA_IRQ_P(regs)    ((((regs)->cond_reg) & (DMA_HNDL_INTR | DMA_HNDL_ERROR)))
asm-sparc/dma.h:#define DMA_WRITE_P(regs)  ((((regs)->cond_reg) & DMA_ST_WRITE))
asm-sparc/dma.h:#define DMA_OFF(regs)      ((((regs)->cond_reg) &= (~DMA_ENABLE)))
asm-sparc/dma.h:#define DMA_INTSOFF(regs)  ((((regs)->cond_reg) &= (~DMA_INT_ENAB)))
asm-sparc/dma.h:#define DMA_INTSON(regs)   ((((regs)->cond_reg) |= (DMA_INT_ENAB)))
asm-sparc/dma.h:#define DMA_PUNTFIFO(regs) ((((regs)->cond_reg) |= DMA_FIFO_INV))
asm-sparc/dma.h:#define DMA_SETSTART(regs, addr)  ((((regs)->st_addr) = (char *) addr))
asm-sparc/dma.h:        ((((regs)->cond_reg |= (DMA_ST_WRITE|DMA_ENABLE|DMA_INT_ENAB))))
asm-sparc/dma.h:        ((((regs)->cond_reg |= ((DMA_ENABLE|DMA_INT_ENAB)&(~DMA_ST_WRITE)))))
asm-sparc/dma.h:	while((regs->cond_reg&bit) && (ctr>0)) {
asm-sparc/dma.h:		ctr--;
asm-sparc/dma.h:	struct sparc_dma_registers *regs = dma->regs;                      \
asm-sparc/dma.h:	regs->cond_reg |= (DMA_RST_SCSI);     /* assert */                 \
asm-sparc/dma.h:	regs->cond_reg &= ~(DMA_RST_SCSI);    /* de-assert */              \
asm-sparc/dma.h:	sparc_dma_enable_interrupts(regs);    /* Re-enable interrupts */   \
asm-sparc/dma.h:	if(dma->revision>dvmarev1) regs->cond_reg |= DMA_3CLKS;            \
asm-sparc/dma.h:	dma->running = 0;                                                  \
asm-sparc/dma.h:        for((dma) = dma_chain; (dma); (dma) = (dma)->next)
asm-sparc/ecc.h: * ----------------------------------------
asm-sparc/ecc.h: * ----------------------------------------
asm-sparc/ecc.h: * -----------------------------
asm-sparc/ecc.h: * -----------------------------
asm-sparc/ecc.h: * -----------------------------------------------------
asm-sparc/ecc.h: * -----------------------------------------------------
asm-sparc/ecc.h: *  31-28  27 26-22  21-14   13  12 11 10-8 7-4   3-0
asm-sparc/ecc.h: * VA: Bits 19-12 of the virtual faulting address, these are the
asm-sparc/ecc.h: * PADDR: Bits 35-32 of the physical address for the fault.
asm-sparc/ecc.h: * -------------------------------------
asm-sparc/ecc.h: * |          Physical Address 31-0    |
asm-sparc/ecc.h: * -------------------------------------
asm-sparc/ecc.h: * ----------------------------------------------
asm-sparc/ecc.h: * ----------------------------------------------
asm-sparc/ecc.h: *  31-18  17  16    15-8    7-4   3    2    1 0
asm-sparc/ecc.h: * MULT: Multiple errors occurred ;-O 0=no 1=prom_panic(yes)
asm-sparc/elf.h: * 	G0 --> G7
asm-sparc/elf.h: *	O0 --> O7
asm-sparc/elf.h: *	L0 --> L7
asm-sparc/elf.h: *	I0 --> I7
asm-sparc/elf.h:	memcpy(&dest[0], &src->u_regs[0],		\
asm-sparc/elf.h:	sp = (unsigned long *) src->u_regs[14];		\
asm-sparc/elf.h:	dest[32] = src->psr;				\
asm-sparc/elf.h:	dest[33] = src->pc;				\
asm-sparc/elf.h:	dest[34] = src->npc;				\
asm-sparc/elf.h:	dest[35] = src->y;				\
asm-sparc/elf.h:#define elf_check_arch(x) ((x)->e_machine == EM_SPARC)
asm-sparc/elf.h: * XXX This is gross, set some global variable at boot time. -DaveM
asm-sparc/ide.h:		hw->io_ports[i] = reg;
asm-sparc/ide.h:		hw->io_ports[IDE_CONTROL_OFFSET] = ctrl_port;
asm-sparc/ide.h:		hw->io_ports[IDE_CONTROL_OFFSET] = 0;
asm-sparc/ide.h:	hw->io_ports[IDE_IRQ_OFFSET] = 0;
asm-sparc/ide.h:		count--;
asm-sparc/ide.h:		count -= 2;
asm-sparc/ide.h:		count--;
asm-sparc/ide.h:		count -= 2;
asm-sparc/irq.h:/* On the sun4m, just like the timers, we have both per-cpu and master
asm-sparc/irq.h:	/* These next two registers are WRITE-ONLY and are only
asm-sparc/irq.h:	unsigned char space[PAGE_SIZE - 12];
asm-sparc/irq.h:	/* Again, like the above, two these registers are WRITE-ONLY. */
asm-sparc/msi.h: * msi.h:  Defines specific to the MBus - Sbus - Interface.
asm-sparc/pbm.h: *   pci_bus  - Linux PCI subsystem view of a PCI bus (including bridged buses)
asm-sparc/pbm.h: *   pbm      - Arch-specific view of a PCI bus (sparc or sparc64)
asm-sparc/pbm.h: *   pcic     - Chip-specific information for PCIC.
asm-sparc/pci.h: * already-configured bus numbers - to be used for buggy BIOSes
asm-sparc/pci.h: * The 32-bit bus address to use is returned.
asm-sparc/pci.h:	((PTR)->ADDR_NAME)
asm-sparc/pci.h:	(((PTR)->ADDR_NAME) = (VAL))
asm-sparc/pci.h:	((PTR)->LEN_NAME)
asm-sparc/pci.h:	(((PTR)->LEN_NAME) = (VAL))
asm-sparc/pci.h: * mode for DMA.  This is the scather-gather version of the
asm-sparc/pci.h: * The same as pci_dma_sync_single but for a scatter-gather list,
asm-sparc/pci.h: * only drive the low 24-bits during PCI bus mastering, then
asm-sparc/psr.h: *  ------------------------------------------------------------------------
asm-sparc/psr.h: *  | 31-28 | 27-24 | 23-20 | 19-14 | 13 | 12 | 11-8 | 7 | 6  | 5  |  4-0  |
asm-sparc/psr.h: *  ------------------------------------------------------------------------
asm-sparc/psr.h:#define PSR_EC      0x00002000         /* enable co-processor        */
asm-sparc/psr.h:#define PSR_LE      0x00008000         /* SuperSparcII little-endian */
asm-sparc/psr.h:#define PSR_VERS    0x0f000000         /* cpu-version field          */
asm-sparc/psr.h:#define PSR_IMPL    0xf0000000         /* cpu-implementation field   */
asm-sparc/reg.h: * linux/asm-sparc/reg.h
asm-sparc/reg.h: * -miguel
asm-sparc/sbi.h: *		   +-------+-------+-------+-------+-------+-------+-------+-------+
asm-sparc/sbi.h: *		   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ Reser |
asm-sparc/sbi.h: *                 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-------+
asm-sparc/rtc.h:	int	sec;	/* Seconds (0-59) */
asm-sparc/rtc.h:	int	min;	/* Minutes (0-59) */
asm-sparc/rtc.h:	int	hour;	/* Hour (0-23) */
asm-sparc/rtc.h:	int	dow;	/* Day of the week (1-7) */
asm-sparc/rtc.h:	int	dom;	/* Day of the month (1-31) */
asm-sparc/rtc.h:	int	month;	/* Month of year (1-12) */
asm-sparc/rtc.h:	int	year;	/* Year (0-99) */
asm-sparc/smp.h:/* PROM provided per-processor information we need
asm-sparc/smp.h:	/* Black box - sun4m
asm-sparc/smp.h:	             - sun4d
asm-sparc/smp.h:/* XXX We really need to implement this now.  -DaveM */
asm-sparc/smp.h:/* Empirical PROM processor mailbox constants.  If the per-cpu mailbox
asm-sparc/smp.h: * a watchdog reset or the user enters the monitor using L1-A keys.
asm-sparc/tlb.h:#include <asm-generic/tlb.h>
asm-sparc/xor.h: * include/asm-sparc/xor.h
asm-sparc/xor.h: * Optimized RAID-5 checksumming functions for 32-bit Sparc.
asm-sparc/xor.h:	} while (--lines > 0);
asm-sparc/xor.h:	} while (--lines > 0);
asm-sparc/xor.h:	} while (--lines > 0);
asm-sparc/xor.h:	} while (--lines > 0);
asm-sparc/xor.h:#include <asm-generic/xor.h>
asm-sparc/signal.h:/* On the Sparc the signal handlers get passed a 'sub-signal' code
asm-sparc/signal.h:#define SIGRTMAX	(__NEW_NSIG - 1)
asm-sparc/signal.h:#define SV_SSTACK    1     /* This signal handler should use sig-stack */
asm-sparc/signal.h: * SA_INTERRUPT is a no-op, but left due to historical reasons. Use the
asm-sparc/signal.h:#define SIG_ERR	((__sighandler_t)-1)	/* error return from signal */
asm-sparc/hardirq.h:/* hardirq.h: 32-bit Sparc hard IRQ support.
asm-sparc/hardirq.h: * Copyright (C) 1998-2000 Anton Blanchard (anton@samba.org)
asm-sparc/hardirq.h:#define irq_exit(cpu, irq)	((void)(irq), local_irq_count(cpu)--)
asm-sparc/solerrno.h:#define	SOL_ENOTBLK        15    /* blkdev op on non-block device    */
asm-sparc/solerrno.h:#define	SOL_ENOTDIR        20    /* Dir operation on non-directory   */
asm-sparc/solerrno.h:#define	SOL_ESPIPE         29    /* Seek attempted on non-seeking dev*/
asm-sparc/solerrno.h:#define	SOL_EROFS          30    /* Write attempted on read-only fs  */
asm-sparc/solerrno.h:#define	SOL_ENOSTR         60    /* Stream-op on non-stream dev      */
asm-sparc/solerrno.h:#define	SOL_ENOPKG         65    /* Non-installed package            */
asm-sparc/solerrno.h:#define	SOL_ENOTEMPTY      93    /* Rmdir of non-empty directory     */
asm-sparc/solerrno.h:#define	SOL_ENOTSOCK       95    /* Sock-op on non-sock              */
asm-sparc/solerrno.h:#define	SOL_EOPNOTSUPP     122   /* Unsupported sock-op              */
asm-sparc/solerrno.h:#define	SOL_ENETRESET      129   /* Buy less-buggy ethernet cards    */
asm-sparc/solerrno.h:#define	SOL_ENOTCONN       134   /* Comm on non-connected socket     */
asm-sparc/solerrno.h:#define	SOL_ESHUTDOWN      143   /* Op attempted after sock-shutdown */
asm-sparc/processor.h: * include/asm-sparc/processor.h
asm-sparc/processor.h:	return t->kpc;
asm-sparc/processor.h:	regs->psr = (regs->psr & (PSR_CWP)) | PSR_S;
asm-sparc/processor.h:	regs->pc = ((pc & (~3)) - 4);
asm-sparc/processor.h:	regs->npc = regs->pc + 4;
asm-sparc/processor.h:	regs->y = 0;
asm-sparc/processor.h:			       "r" (sp - sizeof(struct reg_window)),
asm-sparc/processor.h:			       "i" ((const unsigned long)(&((struct pt_regs *)0)->u_regs[0]))
asm-sparc/processor.h:            (__TSK)->state == TASK_RUNNING) \
asm-sparc/processor.h:	fp = (__TSK)->thread.ksp + bias; \
asm-sparc/processor.h:		pc = rw->ins[7]; \
asm-sparc/processor.h:		fp = rw->ins[6] + bias; \
asm-sparc/processor.h:#define KSTK_EIP(tsk)  ((tsk)->thread.kregs->pc)
asm-sparc/processor.h:#define KSTK_ESP(tsk)  ((tsk)->thread.kregs->u_regs[UREG_FP])
asm-sparc/linux_logo.h: * include/asm-sparc/linux_logo.h: This is a linux logo
asm-sparc/mmu_context.h:#define init_new_context(tsk, mm) (((mm)->context = NO_CONTEXT), 0)
asm-sparc/mmu_context.h: * any remaining processor-specific state.
asm-sparc/semaphore.h:	atomic_set(&sem->count, val);
asm-sparc/semaphore.h:	sem->sleepers = 0;
asm-sparc/semaphore.h:	init_waitqueue_head(&sem->wait);
asm-sparc/semaphore.h:	sem->__magic = (long)&sem->__magic;
asm-sparc/semaphore.h:	CHECK_MAGIC(sem->__magic);
asm-sparc/semaphore.h:	ptr = &(sem->count.counter);
asm-sparc/semaphore.h:	"save	%%sp, -64, %%sp\n\t"
asm-sparc/semaphore.h:	CHECK_MAGIC(sem->__magic);
asm-sparc/semaphore.h:	ptr = &(sem->count.counter);
asm-sparc/semaphore.h:	"save	%%sp, -64, %%sp\n\t"
asm-sparc/semaphore.h:	CHECK_MAGIC(sem->__magic);
asm-sparc/semaphore.h:	ptr = &(sem->count.counter);
asm-sparc/semaphore.h:	"save	%%sp, -64, %%sp\n\t"
asm-sparc/semaphore.h:	CHECK_MAGIC(sem->__magic);
asm-sparc/semaphore.h:	ptr = &(sem->count.counter);
asm-sparc/semaphore.h:	"save	%%sp, -64, %%sp\n\t"
asm-sparc/semaphore.h:	return atomic_read(&sem->count);
asm-sparc/perfctr.h:/*----------------------------------------
asm-sparc/perfctr.h:  ---------------------------------------*/
asm-sparc/perfctr.h: * Pointers which are passed by the user are pointers to 64-bit
asm-sparc/perfctr.h:	 * to 64-bit accumulator for D0 counter in PIC, ARG1 is pointer
asm-sparc/perfctr.h:	 * to 64-bit accumulator for D1 counter.  ARG2 is a pointer to
asm-sparc/perfctr.h: * stuff when this file is included.  --DaveM
asm-sparc/perfctr.h:/* Pic.S0 Selection Bit Field Encoding, Ultra-I/II  */
asm-sparc/perfctr.h:/* Pic.S0 Selection Bit Field Encoding, Ultra-III  */
asm-sparc/perfctr.h:/* Pic.S1 Selection Bit Field Encoding, Ultra-I/II  */
asm-sparc/perfctr.h:/* Pic.S1 Selection Bit Field Encoding, Ultra-III  */
asm-sparc/fcntl.h:/* open/fcntl - O_SYNC is only implemented on blocks devices and on files
asm-sparc/fcntl.h:#define F_GETFL		3	/* get file->f_flags */
asm-sparc/fcntl.h:#define F_SETFL		4	/* set file->f_flags */
asm-sparc/io-unit.h:/* io-unit.h: Definitions for the sun4d IO-UNIT.
asm-sparc/io-unit.h:/* The io-unit handles all virtual to physical address translations
asm-sparc/io-unit.h: * translated by the on chip SRMMU.  The io-unit and the srmmu do
asm-sparc/io-unit.h: * Basically the io-unit handles all dvma sbus activity.
asm-sparc/io-unit.h:#define IOUNIT_DMA_BASE	    0xfc000000 /* TOP - 64M */
asm-sparc/io-unit.h: * XXX some horrible hwbugs though, so be careful.  -DaveM
asm-sparc/io-unit.h:#define IOUPTE_INTRA	     0x00000008 /* SBUS direct slot->slot transfer	*/
asm-sparc/io-unit.h:#define IOUNIT_BMAPM_END	((IOUNIT_DMA_SIZE - IOUNIT_DVMA_SIZE) >> PAGE_SHIFT)
asm-sparc/audioio.h: * include/asm-sparc/audioio.h
asm-sparc/audioio.h:	unsigned int precision;	/* bit-width of each sample */
asm-sparc/audioio.h:	unsigned int gain;		/* gain level: 0 - 255 */
asm-sparc/audioio.h:	unsigned char	pause;		/* non-zero for pause, zero to resume */
asm-sparc/audioio.h:	unsigned char	error;		/* non-zero if overflow/underflow */
asm-sparc/audioio.h:	unsigned char	waiting;	/* non-zero if a process wants access */
asm-sparc/audioio.h:	 * The following values are read-only state flags
asm-sparc/audioio.h:	unsigned char open;		/* non-zero if open access permitted */
asm-sparc/audioio.h:	unsigned char active;		/* non-zero if I/O is active */
asm-sparc/audioio.h:	 * Per-stream information
asm-sparc/audioio.h:	 * Per-unit/channel information
asm-sparc/audioio.h:	unsigned int monitor_gain;	/* input to output mix: 0 - 255 */
asm-sparc/audioio.h:	unsigned char output_muted;	/* non-zero if output is muted */
asm-sparc/audioio.h:#define	AUDIO_ENCODING_ULAW	(1)	/* u-law encoding	  */
asm-sparc/audioio.h:#define	AUDIO_ENCODING_ALAW	(2)	/* A-law encoding	  */
asm-sparc/audioio.h:#define AUDIO_ENCODING_FLOAT    (4)     /* IEEE float (-1. <-> +1.) */
asm-sparc/audioio.h:#define	AUDIO_SPEAKER		0x01	/* output to built-in speaker */
asm-sparc/audioio.h:#define	AUDIO_CD		0x04	/* input from on-board CD inputs */
asm-sparc/audioio.h: * values are not set to the initialized value (-1) to the device state.
asm-sparc/audioio.h: * device-dependent -- see the device specific manual pages for details.
asm-sparc/audioio.h: * old SunOS-style AUDIO_GETDEV ioctl */
asm-sparc/audioio.h:        /* Get and set the output volume. (0-255) */
asm-sparc/audioio.h:        /* Get and set the input volume. (0-255) */
asm-sparc/audioio.h:        /* Get and set the monitor volume. (0-255) */
asm-sparc/audioio.h:        /* Get and set the output balance. (0-64) */
asm-sparc/audioio.h:        /* Get and set the input balance. (0-64) */
asm-sparc/audioio.h:        /* Get and set the output channels. (1-4) */
asm-sparc/audioio.h:        /* Get and set the input channels. (1-4) */
asm-sparc/audioio.h:        /* Get and set the output precision. (8-32) */
asm-sparc/audioio.h:        /* Get and set the input precision. (8-32) */
asm-sparc/audioio.h:    return ((OSS_TO_GAIN(value) - OSS_TO_LGAIN(value)) >> AUDIO_BALANCE_SHIFT)
asm-sparc/audioio.h:    return AUDIO_MID_BALANCE - ((OSS_TO_GAIN(value) - OSS_TO_LGAIN(value)) 
asm-sparc/audioio.h:    adj = ((AUDIO_MID_BALANCE - balance) << AUDIO_BALANCE_SHIFT);
asm-sparc/audioio.h:      r = (int)(value - adj)
asm-sparc/audioio.h:    adj = ((balance - AUDIO_MID_BALANCE) << AUDIO_BALANCE_SHIFT);
asm-sparc/audioio.h:      l = (int)(value - adj)
asm-sparc/audioio.h:  if (drv->ops->get_output_port) {
asm-sparc/audioio.h:    p = drv->ops->get_output_port(drv);
asm-sparc/audioio.h:  if (drv->ops->get_input_port) {
asm-sparc/audioio.h:    p = drv->ops->get_input_port(drv);
asm-sparc/audioio.h:    if (drv->ops->get_output_port && drv->ops->set_output_port) {
asm-sparc/audioio.h:      p = drv->ops->get_output_port(drv);
asm-sparc/audioio.h:	drv->ops->set_output_port(drv, p & ~(set));
asm-sparc/audioio.h:	drv->ops->set_output_port(drv, p | set);
asm-sparc/audioio.h:    if (drv->ops->get_input_port && drv->ops->set_input_port) {
asm-sparc/audioio.h:      p = drv->ops->get_input_port(drv);
asm-sparc/audioio.h:	drv->ops->set_input_port(drv, p & ~(set));
asm-sparc/audioio.h:	drv->ops->set_input_port(drv, p | set);
asm-sparc/spinlock.h:/* spinlock.h: 32-bit Sparc spinlock support.
asm-sparc/spinlock.h:#define spin_is_locked(lp)  (*((volatile unsigned char *)(&((lp)->lock))) != 0)
asm-sparc/spinlock.h:#define spin_unlock_wait(lp)	do { barrier(); } while(*(volatile unsigned char *)(&(lp)->lock))
asm-sparc/spinlock.h:/* Read-write spinlocks, allowing multiple readers
asm-sparc/spinlock.h: * can "mix" irq-safe locks - any writer needs to get a
asm-sparc/spinlock.h: * irq-safe write-lock, but readers can get non-irqsafe
asm-sparc/spinlock.h: * read-locks.
asm-sparc/spinlock.h: * XXX scheme, deadlocks etc. -DaveM
asm-sparc/spinlock.h: *	------------------------------------
asm-sparc/spinlock.h: *	| 24-bit counter           | wlock |  rwlock_t
asm-sparc/spinlock.h: *	------------------------------------
asm-sparc/spinlock.h: * but counter is non-zero, he has to release the lock and wait,
asm-sparc/spinlock.h:#define write_unlock(rw)	do { (rw)->lock = 0; } while(0)
asm-sparc/openpromio.h:#define OPROMSETCUR		0x20004FF0	/* int node - Sets current node */
asm-sparc/openpromio.h:#define OPROMPCI2NODE		0x20004FF1	/* int pci_bus, pci_devfn - Sets current node to PCI device's node */
asm-sparc/openpromio.h:#define OPROMPATH2NODE		0x20004FF2	/* char path[] - Set current node from fully qualified PROM path */
asm-sparc/openpromio.h:	int	op_nodeid;		/* PROM Node ID (value-result) */
asm-sparc/openpromio.h:	int	op_buflen;		/* Length of op_buf (value-result) */
asm-sparc/errno.h:#define	EXDEV		18	/* Cross-device link */
asm-sparc/errno.h:#define	EROFS		30	/* Read-only file system */
asm-sparc/errno.h:#define	ENOTSOCK	38	/* Socket operation on non-socket */
asm-sparc/vac-ops.h:/* $Id: ack,v 1.1.1.1 2006-10-13 02:42:37 steven Exp $ */
asm-sparc/vac-ops.h:/* vac-ops.h: Inline assembly routines to do operations on the Sparc
asm-sparc/vac-ops.h:/* The SUN4C models have a virtually addressed write-through
asm-sparc/vac-ops.h: * ------------------------------------------------------------
asm-sparc/vac-ops.h: * ------------------------------------------------------------
asm-sparc/vac-ops.h: * ----------------------------------------
asm-sparc/vac-ops.h: * |  RESV  | TagID | LINE | BYTE-in-LINE |
asm-sparc/vac-ops.h: * ----------------------------------------
asm-sparc/vac-ops.h: * TagID: Used to match the Tag-ID in that vac tags.
asm-sparc/vac-ops.h: * BYTE-in-LINE: Which byte within the cache line.
asm-sparc/softirq.h:/* softirq.h: 32-bit Sparc soft IRQ support.
asm-sparc/softirq.h: * Copyright (C) 1998-99 Anton Blanchard (anton@progsoc.uts.edu.au)
asm-sparc/softirq.h:#define __local_bh_enable()	(local_bh_count(smp_processor_id())--)
asm-sparc/softirq.h:do { if (!--local_bh_count(smp_processor_id()) && \
asm-sparc/timer.h: * L1-A to work.
asm-sparc/timer.h: * which are per-cpu and master.  Per-cpu timers only hit that cpu and are
asm-sparc/timer.h:   * on Uni-Processor sun4m machines.
asm-sparc/timer.h:  __volatile__ unsigned char space[PAGE_SIZE - 16];
asm-sparc/timer.h:	 * on uni-processor sun4m machines.
asm-sparc/timex.h: * linux/include/asm-sparc/timex.h
asm-sparc/timex.h:#define FINETUNE ((((((long)LATCH * HZ - CLOCK_TICK_RATE) << SHIFT_HZ) * \
asm-sparc/timex.h:		<< (SHIFT_SCALE-SHIFT_HZ)) / HZ)
asm-sparc/timex.h:/* XXX Maybe do something better at some point... -DaveM */
asm-sparc/bugs.h: *  include/asm-sparc/bugs.h:  Sparc probes for various bugs.
asm-sparc/namei.h: * linux/include/asm-sparc/namei.h
asm-sparc/namei.h:	switch (current->personality) {
asm-sparc/termbits.h:#define SIZEOF_USER_TERMIOS sizeof (struct termios) - (2*sizeof (cc_t))
asm-sparc/ebus.h:        for((bus) = ebus_chain; (bus); (bus) = (bus)->next)
asm-sparc/ebus.h:        for((dev) = (bus)->devices; (dev); (dev) = (dev)->next)
asm-sparc/ebus.h:        for((child) = (dev)->children; (child); (child) = (child)->next)
asm-sparc/fbio.h:#define FBTYPE_NOTYPE           -1
asm-sparc/fbio.h:        int     emu_type;	/* -1 if none */
asm-sparc/fbio.h:#define CG14_XLUT        0x3000  /* X Look Up Table -- ??? */
asm-sparc/cprefix.h: *             to know what the c-label prefixes are. The newer versions
asm-sparc/highmem.h: * Redesigned the x86 32-bit VM architecture to deal with 
asm-sparc/highmem.h:#define LAST_PKMAP_MASK		(LAST_PKMAP - 1)
asm-sparc/highmem.h:#define PKMAP_NR(virt)		((virt - pkmap_base) >> PAGE_SHIFT)
asm-sparc/idprom.h:/* MicroSPARC(-II) does not decode 31rd bit, but it works. */
asm-sparc/idprom.h:	unsigned char	id_cksum;	/* Checksum - xor of the data bytes */
asm-sparc/head.h: * the same generic system call low-level entry point.  The trap table
asm-sparc/head.h: * entry sequences are also HyperSparc pipeline friendly ;-)
asm-sparc/head.h:/* Software trap for Sparc-netbsd system calls. */
asm-sparc/head.h:/* This is for hard interrupts from level 1-14, 15 is non-maskable (nmi) and
asm-sparc/mostek.h: *   7ff  -     -     -     -    -     -     -     -       Year 00-99
asm-sparc/mostek.h: *   7fe  0     0     0     -    -     -     -     -      Month 01-12
asm-sparc/mostek.h: *   7fd  0     0     -     -    -     -     -     -       Date 01-31
asm-sparc/mostek.h: *   7fc  0     FT    0     0    0     -     -     -        Day 01-07
asm-sparc/mostek.h: *   7fb  KS    0     -     -    -     -     -     -      Hours 00-23
asm-sparc/mostek.h: *   7fa  0     -     -     -    -     -     -     -    Minutes 00-59
asm-sparc/mostek.h: *   7f9  ST    -     -     -    -     -     -     -    Seconds 00-59
asm-sparc/mostek.h: *   7f8  W     R     S     -    -     -     -     -    Control
asm-sparc/mostek.h:	volatile unsigned char sec;	/* Seconds (0-59) */
asm-sparc/mostek.h:	volatile unsigned char min;	/* Minutes (0-59) */
asm-sparc/mostek.h:	volatile unsigned char hour;	/* Hour (0-23) */
asm-sparc/mostek.h:	volatile unsigned char dow;	/* Day of the week (1-7) */
asm-sparc/mostek.h:	volatile unsigned char dom;	/* Day of the month (1-31) */
asm-sparc/mostek.h:	volatile unsigned char month;	/* Month of year (1-12) */
asm-sparc/mostek.h:	volatile unsigned char year;	/* Year (0-99) */
asm-sparc/mostek.h:#define MSTK_GET(regs,var,mask) (MSTK_REGVAL_TO_DECIMAL(((struct mostek48t02 *)regs)->var & MSTK_ ## mask ## _MASK))
asm-sparc/mostek.h:#define MSTK_SET(regs,var,value,mask) do { ((struct mostek48t02 *)regs)->var &= ~(MSTK_ ## mask ## _MASK); ((struct mostek48t02 *)regs)->var |= MSTK_DECIMAL_TO_REGVAL(value) & (MSTK_ ## mask ## _MASK); } while (0)
asm-sparc/mostek.h:#define	MSTK_REG_CREG(regs)	(((struct mostek48t02 *)regs)->creg)
asm-sparc/kdebug.h:/* Use this macro in C-code to enter the debugger. */
asm-sparc/kdebug.h:	     if((linux_dbvec!=0) && ((*(short *)linux_dbvec)!=-1)) \
asm-sparc/init.h:#error "<asm/init.h> should never be used - use <linux/init.h> instead"
asm-sparc/uaccess.h:#include <asm/vac-ops.h>
asm-sparc/uaccess.h: * "For historical reasons, these macros are grossly misnamed." -Linus
asm-sparc/uaccess.h:#define USER_DS     ((mm_segment_t) { -1 })
asm-sparc/uaccess.h:#define get_fs()	(current->thread.current_ds)
asm-sparc/uaccess.h:#define set_fs(val)	((current->thread.current_ds) = (val))
asm-sparc/uaccess.h:/* We have there a nice not-mapped page at PAGE_OFFSET - PAGE_SIZE, so that this test
asm-sparc/uaccess.h: * large size and address near to PAGE_OFFSET - a fault will break his intentions.
asm-sparc/uaccess.h:	return access_ok(type,addr,size)?0:-EFAULT;
asm-sparc/uaccess.h: * (faulting_insn_address - first_insn_in_the_range_address)/4
asm-sparc/uaccess.h:/* Uh, these should become the main single-value transfer routines..
asm-sparc/uaccess.h:} } else { __pu_ret = -EFAULT; } __pu_ret; })
asm-sparc/uaccess.h:	 "i" (-EFAULT))
asm-sparc/uaccess.h:if (__builtin_constant_p(ret) && ret == -EFAULT)			\
asm-sparc/uaccess.h:} } else { __gu_val = 0; __gu_ret = -EFAULT; } x = (type) __gu_val; __gu_ret; })
asm-sparc/uaccess.h:	 "i" (-EFAULT))
asm-sparc/uaccess.h:if (__builtin_constant_p(retval) && retval == -EFAULT)			\
asm-sparc/uaccess.h:long __sfu_res = -EFAULT; \
asm-sparc/traps.h:          (0x10800000 | (((dest_addr-inst_addr)>>2)&0x3fffff))
asm-sparc/traps.h:#define SP_TRAP_IRQ15   0x1f         /* IRQ level 15 Non-maskable */
asm-sparc/traps.h:#define SP_TRAP_CPDIS   0x24         /* Co-Processor Disabled */
asm-sparc/traps.h:#define SP_TRAP_CPEXP   0x28         /* Co-Processor Exception */
asm-sparc/traps.h:#define SP_TRAP_SDIVZ   0x82         /* Software Divide-by-Zero trap */
asm-sparc/bsderrno.h:#define BSD_EXDEV         18     /* Cross-device link */
asm-sparc/bsderrno.h:#define BSD_EROFS         30     /* Read-only file system */
asm-sparc/bsderrno.h:#define BSD_ENOTSOCK      38     /* Socket operation on non-socket */
asm-sparc/contregs.h:#define AC_CONTEXT    0x30000000    /* 34c current mmu-context               */
asm-sparc/contregs.h:#define AC_VME_VECTOR 0xE0000000    /* 4  For non-Autovector VME, byte       */
asm-sparc/mpmbox.h:/* Another CPU called romvec->pv_exit(), you should call
asm-sparc/mpmbox.h:/* Another CPU called romvec->pv_enter(), you should call
asm-sparc/mpmbox.h:/* Is the cpu actively running an application/kernel-code? */
asm-sparc/tsunami.h: * -----------------------------------------------------------------------
asm-sparc/tsunami.h: * -----------------------------------------------------------------------
asm-sparc/tsunami.h: *  31      24 23 22 21 20 19-18 17  16 14  13-12 11 10-9  8  7 6-2  1  0
asm-sparc/mman.h:#define MAP_GROWSDOWN	0x0200		/* stack-like segment */
asm-sparc/mman.h:#define MADV_NORMAL	0x0		/* default page-in behavior */
asm-sparc/mman.h:#define MADV_RANDOM	0x1		/* page-in minimum required */
asm-sparc/mman.h:#define MADV_SEQUENTIAL	0x2		/* read-ahead aggressively */
asm-sparc/mman.h:#define MADV_WILLNEED	0x3		/* pre-fault pages */
asm-sparc/posix_types.h: * This file is generally used by user-level software, so you need to
asm-sparc/posix_types.h:	fdsetp->fds_bits[_tmp] |= (1UL<<_rem);
asm-sparc/posix_types.h:	fdsetp->fds_bits[_tmp] &= ~(1UL<<_rem);
asm-sparc/posix_types.h:	return (p->fds_bits[_tmp] & (1UL<<_rem)) != 0;
asm-sparc/posix_types.h: * for 256 and 1024-bit fd_sets respectively)
asm-sparc/posix_types.h:	unsigned long *tmp = p->fds_bits;
asm-sparc/posix_types.h:		i--;
asm-sparc/scatterlist.h:	__u32 dvma_address; /* A place to hang host-specific addresses at. */
asm-sparc/scatterlist.h:#define sg_dma_address(sg) ((sg)->dvma_address)
asm-sparc/scatterlist.h:#define sg_dma_len(sg)     ((sg)->dvma_length)
asm-sparc/smplock.h:	if (task->lock_depth >= 0) \
asm-sparc/smplock.h: * Re-acquire the kernel lock
asm-sparc/smplock.h:	if (task->lock_depth >= 0) \
asm-sparc/smplock.h:	if (!++current->lock_depth)
asm-sparc/smplock.h:	if (--current->lock_depth < 0)
asm-sparc/mxcc.h:#define MXCC_STEST           0x1C00804  /* Internal self-test */
asm-sparc/mxcc.h: * ----------------------------------------------------------------------
asm-sparc/mxcc.h: * ----------------------------------------------------------------------
asm-sparc/mxcc.h: *  31                              10    9    8-6   5   4    3   2  1-0
asm-sparc/mxcc.h: * --------------------------------------------------------
asm-sparc/mxcc.h: * --------------------------------------------------------
asm-sparc/mxcc.h: *  31   30 29  28  27  26  25 24-15  14-7   6  5-3   2-0
asm-sparc/mxcc.h: * HPADDR: High PhysicalADDRess bits (35-32)
asm-sparc/mxcc.h: * -----------------------------------------------------
asm-sparc/mxcc.h: * -----------------------------------------------------
asm-sparc/mxcc.h: *  31            21 20-18 17                         0
asm-sparc/mxcc.h:	__asm__ __volatile__("set -1, %%g2\n\t"
asm-sparc/mxcc.h:			     "set -1, %%g3\n\t"
asm-sparc/obio.h: *  ------------------------------------------------------------------------
asm-sparc/obio.h: *  ------------------------------------------------------------------------
asm-sparc/obio.h:#define CSR_CPU_SHIFT		(32 - 4 - 5)
asm-sparc/obio.h: *  ------------------------------------------------------------------------
asm-sparc/obio.h: *  ------------------------------------------------------------------------
asm-sparc/obio.h:#define ECSR_CPU_SHIFT		(32 - 5)
asm-sparc/obio.h:#define ECSR_DEV_SHIFT		(32 - 8)
asm-sparc/obio.h:#define CC_STEST	0x1F00804  /* Internal self-test */
asm-sparc/obio.h:/* +-------+-------------+-----------+------------------------------------+
asm-sparc/obio.h: * +-------+-------------+-----------+------------------------------------+
asm-sparc/obio.h:	cc_set_igen(IGEN_MESSAGE(0, cpu << 3, 6 + ((level >> 1) & 7), 1 << (level - 1)));
asm-sparc/asmmacro.h: * c-code can be called.
asm-sparc/asmmacro.h:/* All traps low-level code here must end with this macro. */
asm-sparc/page.h:/* I have my suspicions... -DaveM */
asm-sparc/page.h:#define PAGE_MASK    (~(PAGE_SIZE-1))
asm-sparc/page.h: * this so lets disable it. - Anton
asm-sparc/page.h:/* We need the mb()'s so we don't trigger a compiler bug - Anton */
asm-sparc/page.h:/* Cache alias structure.  Entry is valid if context != -1. */
asm-sparc/page.h: * These are used to make use of C type-checking..
asm-sparc/page.h:	size = (size-1) >> (PAGE_SHIFT-1);
asm-sparc/page.h:	order = -1;
asm-sparc/page.h:#define PAGE_ALIGN(addr)  (((addr)+PAGE_SIZE-1)&PAGE_MASK)
asm-sparc/page.h:#define __pa(x)                 ((unsigned long)(x) - PAGE_OFFSET)
asm-sparc/page.h:#define VALID_PAGE(page)	((page - mem_map) < max_mapnr)
asm-sparc/btfixup.h: *  asm-sparc/btfixup.h:    Macros for boot time linking.
asm-sparc/types.h: * application is Linux specific so (user-) name space pollution is
asm-sparc/sbus.h:  return (int) (((dev_addr)-SUN_SBUS_BVADDR)>>25);
asm-sparc/sbus.h:        for((bus) = sbus_root; (bus); (bus)=(bus)->next)
asm-sparc/sbus.h:        for((device) = (bus)->devices; (device); (device)=(device)->next)
asm-sparc/sbus.h:	for ((bus) = sbus_root; (bus); (bus) = (bus)->next) \
asm-sparc/sbus.h:		for ((device) = (bus)->devices; (device); (device) = (device)->next)
asm-sparc/sbus.h: * Translate SBus interrupt levels to ino values--
asm-sparc/sbus.h: * "sbus-intr>cpu (sbint -- ino)" from kernel...
asm-sparc/smpprim.h:/* Initialize a spin-lock. */
asm-sparc/ross.h: * -----------------------------------------------------------------
asm-sparc/ross.h: * -----------------------------------------------------------------
asm-sparc/ross.h: *  31    24 23-22 21  20  19 18-15 14 13 12 11 10  9   8 7-2  1  0
asm-sparc/ross.h: * Phew, lots of fields there ;-)
asm-sparc/ross.h: * BM: Boot-Mode. One indicates the MMU is in boot mode.
asm-sparc/ross.h: * CS: Cache Size -- 0 = 128k, 1 = 256k
asm-sparc/ross.h: * CM: Cache Mode -- 0 = write-through, 1 = copy-back
asm-sparc/ross.h: * CE: Cache Enable -- 0 = no caching, 1 = cache is on
asm-sparc/ross.h: * NF: No Fault -- 0 = faults trap the CPU from supervisor mode
asm-sparc/ross.h: * ME: MMU Enable -- 0 = MMU is off, 1 = MMU is on
asm-sparc/ross.h: * -----------------------------------------------
asm-sparc/ross.h: * -----------------------------------------------
asm-sparc/ross.h: *       for said cache-hit is invalidated.  If FTD is zero,
asm-sparc/ross.h:/* This is for the on-chip instruction cache. */
asm-sparc/sembuf.h: * - 64-bit time_t to solve y2038 problem
asm-sparc/sembuf.h: * - 2 miscellaneous 32-bit values
asm-sparc/system.h:	if(prev->flags & PF_USEDFPU) { \
asm-sparc/system.h:		fpsave(&prev->thread.float_regs[0], &prev->thread.fsr, \
asm-sparc/system.h:		       &prev->thread.fpqueue[0], &prev->thread.fpqdepth); \
asm-sparc/system.h:		prev->flags &= ~PF_USEDFPU; \
asm-sparc/system.h:		prev->thread.kregs->psr &= ~PSR_EF; \
asm-sparc/system.h:#define SWITCH_DO_LAZY_FPU if(last_task_used_math != next) next->thread.kregs->psr&=~PSR_EF;
asm-sparc/system.h:	"save %sp, -0x40, %sp; save %sp, -0x40, %sp; save %sp, -0x40, %sp\n\t" \
asm-sparc/system.h:	"save %sp, -0x40, %sp; save %sp, -0x40, %sp; save %sp, -0x40, %sp\n\t" \
asm-sparc/system.h:	"save %sp, -0x40, %sp\n\t" \
asm-sparc/system.h:	 * clobber every non-fixed-usage register besides l2/l3/o4/o5.  -DaveM
asm-sparc/system.h:	 * - Anton
asm-sparc/system.h:	next->active_mm->cpu_vm_mask |= (1 << smp_processor_id());			\
asm-sparc/system.h:	"sethi	%%hi(here - 0x8), %%o7\n\t"						\
asm-sparc/system.h:	"or	%%o7, %%lo(here - 0x8), %%o7\n\t"					\
asm-sparc/system.h:	  "i" ((const unsigned long)(&((struct task_struct *)0)->thread.kpsr)),		\
asm-sparc/system.h:	  "i" ((const unsigned long)(&((struct task_struct *)0)->thread.ksp))		\
asm-sparc/svr4.h:/* Solaris/SPARC constants and definitions -- 
asm-sparc/svr4.h: * ucontext->mcontext holds a pointer to them.
asm-sparc/checksum.h: *	Alpha checksum c-code
asm-sparc/checksum.h: * and adds in "sum" (32-bit)
asm-sparc/checksum.h: * returns a 32-bit number suitable for feeding into itself
asm-sparc/checksum.h: * it's best to have buff aligned on a 32-bit boundary
asm-sparc/checksum.h: * here even more important to align src and dst on a 32-bit (or even
asm-sparc/checksum.h: * better 64-bit) boundary
asm-sparc/checksum.h:		*err = -EFAULT;
asm-sparc/checksum.h:		*err = -EFAULT;
asm-sparc/checksum.h: * computes the checksum of the TCP/UDP pseudo-header
asm-sparc/checksum.h: * returns a 16-bit checksum, already complemented
asm-sparc/checksum.h:/* this routine is used for miscellaneous IP-like checksums, mainly in icmp.c */
asm-sparc/termios.h:#define N_IRDA		11	/* Linux IrDa - http://irda.sourceforge.net/ */
asm-sparc/termios.h:#define N_SMSBLOCK	12	/* SMS block mode - for talking to GSM data cards about SMS messages */
asm-sparc/termios.h:	get_user(tmp, &(termio)->c_iflag); \
asm-sparc/termios.h:	(termios)->c_iflag = (0xffff0000 & ((termios)->c_iflag)) | tmp; \
asm-sparc/termios.h:	get_user(tmp, &(termio)->c_oflag); \
asm-sparc/termios.h:	(termios)->c_oflag = (0xffff0000 & ((termios)->c_oflag)) | tmp; \
asm-sparc/termios.h:	get_user(tmp, &(termio)->c_cflag); \
asm-sparc/termios.h:	(termios)->c_cflag = (0xffff0000 & ((termios)->c_cflag)) | tmp; \
asm-sparc/termios.h:	get_user(tmp, &(termio)->c_lflag); \
asm-sparc/termios.h:	(termios)->c_lflag = (0xffff0000 & ((termios)->c_lflag)) | tmp; \
asm-sparc/termios.h:	copy_from_user((termios)->c_cc, (termio)->c_cc, NCC); \
asm-sparc/termios.h:	put_user((termios)->c_iflag, &(termio)->c_iflag); \
asm-sparc/termios.h:	put_user((termios)->c_oflag, &(termio)->c_oflag); \
asm-sparc/termios.h:	put_user((termios)->c_cflag, &(termio)->c_cflag); \
asm-sparc/termios.h:	put_user((termios)->c_lflag, &(termio)->c_lflag); \
asm-sparc/termios.h:	put_user((termios)->c_line,  &(termio)->c_line); \
asm-sparc/termios.h:	copy_to_user((termio)->c_cc, (termios)->c_cc, NCC); \
asm-sparc/termios.h:	if (!((termios)->c_lflag & ICANON)) { \
asm-sparc/termios.h:		put_user((termios)->c_cc[VMIN], &(termio)->c_cc[_VMIN]); \
asm-sparc/termios.h:		put_user((termios)->c_cc[VTIME], &(termio)->c_cc[_VTIME]); \
asm-sparc/termios.h:	get_user((k)->c_iflag, &(u)->c_iflag); \
asm-sparc/termios.h:	get_user((k)->c_oflag, &(u)->c_oflag); \
asm-sparc/termios.h:	get_user((k)->c_cflag, &(u)->c_cflag); \
asm-sparc/termios.h:	get_user((k)->c_lflag, &(u)->c_lflag); \
asm-sparc/termios.h:	get_user((k)->c_line,  &(u)->c_line); \
asm-sparc/termios.h:	copy_from_user((k)->c_cc, (u)->c_cc, NCCS); \
asm-sparc/termios.h:	if((k)->c_lflag & ICANON) { \
asm-sparc/termios.h:		get_user((k)->c_cc[VEOF], &(u)->c_cc[VEOF]); \
asm-sparc/termios.h:		get_user((k)->c_cc[VEOL], &(u)->c_cc[VEOL]); \
asm-sparc/termios.h:		get_user((k)->c_cc[VMIN],  &(u)->c_cc[_VMIN]); \
asm-sparc/termios.h:		get_user((k)->c_cc[VTIME], &(u)->c_cc[_VTIME]); \
asm-sparc/termios.h:	put_user((k)->c_iflag, &(u)->c_iflag); \
asm-sparc/termios.h:	put_user((k)->c_oflag, &(u)->c_oflag); \
asm-sparc/termios.h:	put_user((k)->c_cflag, &(u)->c_cflag); \
asm-sparc/termios.h:	put_user((k)->c_lflag, &(u)->c_lflag); \
asm-sparc/termios.h:	put_user((k)->c_line, &(u)->c_line); \
asm-sparc/termios.h:	copy_to_user((u)->c_cc, (k)->c_cc, NCCS); \
asm-sparc/termios.h:	if(!((k)->c_lflag & ICANON)) { \
asm-sparc/termios.h:		put_user((k)->c_cc[VMIN],  &(u)->c_cc[_VMIN]); \
asm-sparc/termios.h:		put_user((k)->c_cc[VTIME], &(u)->c_cc[_VTIME]); \
asm-sparc/termios.h:		put_user((k)->c_cc[VEOF], &(u)->c_cc[VEOF]); \
asm-sparc/termios.h:		put_user((k)->c_cc[VEOL], &(u)->c_cc[VEOL]); \
asm-sparc/machines.h: * ---------------
asm-sparc/machines.h: * ---------------
asm-sparc/machines.h:/* Sun4c machines                Full Name              - PROM NAME */
asm-sparc/machines.h:#define SM_4C_SS1     0x01    /* Sun4c SparcStation 1   - Sun 4/60  */
asm-sparc/machines.h:#define SM_4C_IPC     0x02    /* Sun4c SparcStation IPC - Sun 4/40  */
asm-sparc/machines.h:#define SM_4C_SS1PLUS 0x03    /* Sun4c SparcStation 1+  - Sun 4/65  */
asm-sparc/machines.h:#define SM_4C_SLC     0x04    /* Sun4c SparcStation SLC - Sun 4/20  */
asm-sparc/machines.h:#define SM_4C_SS2     0x05    /* Sun4c SparcStation 2   - Sun 4/75  */
asm-sparc/machines.h:#define SM_4C_ELC     0x06    /* Sun4c SparcStation ELC - Sun 4/25  */
asm-sparc/machines.h:#define SM_4C_IPX     0x07    /* Sun4c SparcStation IPX - Sun 4/50  */
asm-sparc/machines.h:/* Sun4d machines -- N/A */
asm-sparc/machines.h:/* Sun4e machines -- N/A */
asm-sparc/machines.h:/* Sun4u machines -- N/A */
asm-sparc/user.h: * asm-sparc/user.h: Core file definitions for the Sparc.
asm-sparc/user.h: * one, since we won't a.out core dump that much anyways - miguel.
asm-sparc/user.h:#define HOST_STACK_END_ADDR    (- u.u_ssize * NBPG)
asm-sparc/pgtable.h:/*  asm-sparc/pgtable.h:  Defines and functions used to work
asm-sparc/pgtable.h:#include <asm/vac-ops.h>
asm-sparc/pgtable.h:/* Top-level page directory */
asm-sparc/pgtable.h:/* Page table for 0-4MB for everybody, on the Sparc this
asm-sparc/pgtable.h: * va-->pa and vice versa conversions work properly without performance
asm-sparc/pgtable.h: * BAD_PAGETABLE is used when we need a bogus page-table, while
asm-sparc/pgtable.h: * for zero-mapped memory areas etc..
asm-sparc/pgtable.h:#define ZERO_PAGE(vaddr) (mem_map + (((unsigned long)&empty_zero_page - PAGE_OFFSET + phys_base) >> PAGE_SHIFT))
asm-sparc/pgtable.h:#define PTR_MASK          (~(sizeof(void*)-1))
asm-sparc/pgtable.h:/* to find an entry in a page-table-directory */
asm-sparc/pgtable.h:#define pgd_offset(mm, address) ((mm)->pgd + pgd_index(address))
asm-sparc/pgtable.h:/* to find an entry in a kernel page-table-directory */
asm-sparc/pgtable.h:/* Find an entry in the second-level page table.. */
asm-sparc/pgtable.h:/* Find an entry in the third-level page table.. */ 
asm-sparc/pgtable.h:/* Encode and de-code a swap entry */
asm-sparc/pgtable.h:#define NO_CONTEXT     -1
asm-sparc/pgtable.h:	entry->next->prev = entry->prev;
asm-sparc/pgtable.h:	entry->prev->next = entry->next;
asm-sparc/pgtable.h:	entry->next = head;
asm-sparc/pgtable.h:	(entry->prev = head->prev)->next = entry;
asm-sparc/pgtable.h:	head->prev = entry;
asm-sparc/pgtable.h:		return -1; /* Don't check iospace on sun4c */
asm-sparc/pgtable.h:		return -1;
asm-sparc/pgtable.h:#include <asm-generic/pgtable.h>
asm-sparc/cypress.h: * ---------------------------------------------------------------
asm-sparc/cypress.h: * ---------------------------------------------------------------
asm-sparc/cypress.h: *  31    24 23-22 21-20 19 18-15 14 13  12 11 10  9  8 7-2  1  0
asm-sparc/cypress.h: * MCA: MultiChip Access -- Used for configuration of multiple
asm-sparc/cypress.h: * MCM: MultiChip Mask -- Again, for multiple cache unit config.
asm-sparc/cypress.h: * MV: MultiChip Valid -- Indicates MCM and MCA have valid settings.
asm-sparc/cypress.h: * MID: ModuleID -- Unique processor ID for MBus transactions. (605 only)
asm-sparc/cypress.h: * BM: Boot Mode -- 0 = not in boot mode, 1 = in boot mode
asm-sparc/cypress.h: * C: Cacheable -- Indicates whether accesses are cacheable while
asm-sparc/cypress.h: * MR: MemoryReflection -- Indicates whether the bus attached to the
asm-sparc/cypress.h: * CM: CacheMode -- Indicates whether the cache is operating in write
asm-sparc/cypress.h: *     through or copy-back mode. 0=write-through 1=copy-back
asm-sparc/cypress.h: * CL: CacheLock -- Indicates if the entire cache is locked or not.
asm-sparc/cypress.h: *     0=not-locked 1=locked  (604 only)
asm-sparc/cypress.h: * CE: CacheEnable -- Is the virtual cache on? 0=no 1=yes
asm-sparc/cypress.h: * NF: NoFault -- Do faults generate traps? 0=yes 1=no
asm-sparc/cypress.h: * ME: MmuEnable -- Is the MMU doing translations? 0=no 1=yes
asm-sparc/vaddrs.h: * asm-sparc/vaddrs.h:  Here we define the virtual addresses at
asm-sparc/vaddrs.h:/* XXX Alter this when I get around to fixing sun4c - Anton */
asm-sparc/vaddrs.h: * over to map SCSI dvma + floppy pseudo-dma buffers.  So be
asm-sparc/vaddrs.h:#define KADB_DEBUGGER_BEGVM	0xffc00000 /* Where kern debugger is in virt-mem */
asm-sparc/param.h:#define NOGROUP		(-1)
asm-sparc/oplib.h: * and usage utility functions.  Only prom-lib should use these,
asm-sparc/oplib.h: * of the string is different on V0 vs. V2->higher proms.  The caller must
asm-sparc/oplib.h: * These lists are returned pre-sorted, this should make your life easier
asm-sparc/oplib.h:/* Enter the prom, with no chance of continuation for the stand-alone
asm-sparc/oplib.h: * XXX The arguments are different on V0 vs. V2->higher proms, grrr! XXX
asm-sparc/oplib.h:/* Non-blocking get character from console. */
asm-sparc/oplib.h:/* Non-blocking put character to console. */
asm-sparc/oplib.h:/* Re-Start the CPU with the passed device tree node. */
asm-sparc/oplib.h:/* Sun4/sun4c specific memory-management startup hook. */
asm-sparc/oplib.h: * Returns -1 on error (ie. no such property at this node).
asm-sparc/oplib.h: * the number of bytes the prom put into your buffer or -1 on error.
asm-sparc/sun4prom.h: * sun4prom.h -- interface to sun4 PROM monitor.  We don't use most of this,
asm-sparc/sun4prom.h:	int		(*mayget)(void);	/* Maybe get char, or -1 */
asm-sparc/sun4prom.h:	int		(*mayput)(void);	/* Maybe put char, or -1 */
asm-sparc/auxio.h:#define AUXIO_ORMEIN4M    0xc0    /* sun4m - All writes must set these bits. */
asm-sparc/auxio.h:#define AUXIO_EDGE_ON     0x10    /* sun4m - On means Jumper block is in. */
asm-sparc/auxio.h:#define AUXIO_FLPY_DSEL   0x08    /* Drive select/start-motor. Write only. */
asm-sparc/auxio.h:#define AUXIO_LINK_TEST   0x08    /* sun4m - On means TPE Carrier detect. */
asm-sparc/auxio.h: * NOTE: these routines are implementation dependent-- 
asm-sparc/auxio.h:extern unsigned char get_auxio(void); /* .../asm-sparc/floppy.h */
asm-sparc/auxio.h: * The following routines are provided for driver-compatibility
asm-sparc/auxio.h:/* auxio_set_lte - Set Link Test Enable (TPE Link Detect)
asm-sparc/auxio.h: * on - AUXIO_LTE_ON or AUXIO_LTE_OFF
asm-sparc/auxio.h:/* auxio_set_led - Set system front panel LED
asm-sparc/auxio.h: * on - AUXIO_LED_ON or AUXIO_LED_OFF
asm-sparc/cache.h:#define L1_CACHE_ALIGN(x) ((((x)+(L1_CACHE_BYTES-1))&~(L1_CACHE_BYTES-1)))
asm-sparc/cache.h:/* First, cache-tag access. */
asm-sparc/cache.h:/* Second cache-data access.  The data is returned two-32bit quantities
asm-sparc/cache.h:/* Flushes which clear out both the on-chip and external caches */
asm-sparc/siginfo.h:#define SI_PAD_SIZE	((SI_MAX_SIZE/sizeof(int)) - 3)
asm-sparc/siginfo.h: * Digital reserves positive values for kernel-generated signals.
asm-sparc/siginfo.h:#define SI_QUEUE	-1		/* sent by sigqueue */
asm-sparc/siginfo.h:#define SI_TIMER __SI_CODE(__SI_TIMER,-2) /* sent by timer expiration */
asm-sparc/siginfo.h:#define SI_MESGQ	-3		/* sent by real time mesq state change */
asm-sparc/siginfo.h:#define SI_ASYNCIO	-4		/* sent by AIO completion */
asm-sparc/siginfo.h:#define SI_SIGIO	-5		/* sent by queued SIGIO */
asm-sparc/siginfo.h:#define SI_TKILL	-6		/* sent by tkill system call */
asm-sparc/siginfo.h:#define SI_FROMUSER(siptr)	((siptr)->si_code <= 0)
asm-sparc/siginfo.h:#define SI_FROMKERNEL(siptr)	((siptr)->si_code > 0)
asm-sparc/siginfo.h:#define BUS_ADRERR	(__SI_FAULT|2)	/* non-existant physical address */
asm-sparc/siginfo.h:#define SIGEV_PAD_SIZE	((SIGEV_MAX_SIZE/sizeof(int)) - 3)
asm-sparc/siginfo.h:	if (from->si_code < 0)
asm-sparc/siginfo.h:		memcpy(to, from, 3*sizeof(int) + sizeof(from->_sifields._sigchld));
asm-sparc/floppy.h:/* asm-sparc/floppy.h: Sparc specific parts of the Floppy driver.
asm-sparc/floppy.h:		return sun_fdc->status_82072 & ~STATUS_DMA;
asm-sparc/floppy.h:		return sun_fdc->data_82072;
asm-sparc/floppy.h:		sun_fdc->data_82072 = value;
asm-sparc/floppy.h:		sun_fdc->dcr_82072 = value;
asm-sparc/floppy.h:		sun_fdc->status_82072 = value;
asm-sparc/floppy.h:		return sun_fdc->status_82077 & ~STATUS_DMA;
asm-sparc/floppy.h:		return sun_fdc->data_82077;
asm-sparc/floppy.h:		return sun_fdc->dir_82077;
asm-sparc/floppy.h:		sun_fdc->dor_82077 = value;
asm-sparc/floppy.h:		sun_fdc->data_82077 = value;
asm-sparc/floppy.h:		sun_fdc->dcr_82077 = value;
asm-sparc/floppy.h:		sun_fdc->status_82077 = value;
asm-sparc/floppy.h:/* For pseudo-dma (Sun floppy drives have no real DMA available to
asm-sparc/floppy.h: * three state variables.  doing_pdma tells our inline low-level
asm-sparc/floppy.h: * floppy interrupt c-code.  I tried very hard but I could not get the
asm-sparc/floppy.h: * pseudo-dma to work in c-code without getting many overruns and
asm-sparc/floppy.h: * underruns.  If non-zero, doing_pdma encodes the direction of
asm-sparc/floppy.h:/* Our low-level entry point in arch/sparc/kernel/entry.S */
asm-sparc/floppy.h:		return ((error == 0) ? 0 : -1);
asm-sparc/floppy.h:	   ((idprom->id_machtype == (SM_SUN4C | SM_4C_SLC)) ||
asm-sparc/floppy.h:	    (idprom->id_machtype == (SM_SUN4C | SM_4C_ELC)))) {
asm-sparc/floppy.h:	if(sun_fdc->status_82072 == 0xff) {
asm-sparc/floppy.h:                fdc_status = &sun_fdc->status_82072;
asm-sparc/floppy.h:                fdc_status = &sun_fdc->status_82077;
asm-sparc/floppy.h:                /* printk("DOR @0x%p\n", &sun_fdc->dor_82077); */ /* P3 */
asm-sparc/floppy.h:	return -1;
asm-sparc/sockios.h:/* Socket-level I/O control calls. */
asm-sparc/keyboard.h: * linux/include/asm-sparc/keyboard.h
asm-sparc/a.out.h:	RELOC_DISP32,	/* Disp's (pc-rel) */
asm-sparc/a.out.h:	RELOC_22,	/* SR 22-bit relocs */
asm-sparc/a.out.h:	RELOC_LO10,	/* SR 13&10-bit relocs */
asm-sparc/a.out.h:	RELOC_PC22,	/* special pc-rel pic */
asm-sparc/a.out.h:	RELOC_SEGOFF16,	/* ShLib offset-in-seg */
asm-sparc/a.out.h:#define STACK_TOP	(PAGE_OFFSET - PAGE_SIZE)
asm-sparc/pgtsrmmu.h:/* Number of contexts is implementation-dependent; 64k is the most we support */
asm-sparc/pgtsrmmu.h:/* PMD_SHIFT determines the size of the area a second-level page table can map */
asm-sparc/pgtsrmmu.h:#define SRMMU_PMD_MASK          (~(SRMMU_PMD_SIZE-1))
asm-sparc/pgtsrmmu.h:#define SRMMU_PMD_ALIGN(addr)   (((addr)+SRMMU_PMD_SIZE-1)&SRMMU_PMD_MASK)
asm-sparc/pgtsrmmu.h:/* PGDIR_SHIFT determines what a third-level page table entry can map */
asm-sparc/pgtsrmmu.h:#define SRMMU_PGDIR_MASK        (~(SRMMU_PGDIR_SIZE-1))
asm-sparc/pgtsrmmu.h:#define SRMMU_PGDIR_ALIGN(addr) (((addr)+SRMMU_PGDIR_SIZE-1)&SRMMU_PGDIR_MASK)
asm-sparc/pgtsrmmu.h:/* The pte non-page bits.  Some notes:
asm-sparc/pgtsrmmu.h:	 save	%sp, -64, %sp;						\
asm-sparc/ioctl.h: * a non-zero _IOC_NONE (for binary compatibility) and
asm-sparc/ioctl.h:#define _IOC_NRMASK      ((1 << _IOC_NRBITS)-1)
asm-sparc/ioctl.h:#define _IOC_TYPEMASK    ((1 << _IOC_TYPEBITS)-1)
asm-sparc/ioctl.h:#define _IOC_SIZEMASK    ((1 << _IOC_SIZEBITS)-1)
asm-sparc/ioctl.h:#define _IOC_XSIZEMASK   ((1 << (_IOC_SIZEBITS+1))-1)
asm-sparc/ioctl.h:#define _IOC_DIRMASK     ((1 << _IOC_DIRBITS)-1)
asm-sparc/iommu.h:	volatile unsigned long afsr;       /* Async-fault status register */
asm-sparc/iommu.h:	volatile unsigned long afar;       /* Async-fault physical address */
asm-sparc/iommu.h:	volatile unsigned long sbuscfg0;   /* SBUS configuration registers, per-slot */
asm-sparc/iommu.h:	volatile unsigned long mfsr;       /* Memory-fault status register */
asm-sparc/iommu.h:	volatile unsigned long mfar;       /* Memory-fault physical address */
asm-sparc/iommu.h:	volatile unsigned long mid;        /* IOMMU module-id */
asm-sparc/iommu.h:#define IOMMU_RNGE_16MB     0x00000000 /* 0xff000000 -> 0xffffffff */
asm-sparc/iommu.h:#define IOMMU_RNGE_32MB     0x00000004 /* 0xfe000000 -> 0xffffffff */
asm-sparc/iommu.h:#define IOMMU_RNGE_64MB     0x00000008 /* 0xfc000000 -> 0xffffffff */
asm-sparc/iommu.h:#define IOMMU_RNGE_128MB    0x0000000c /* 0xf8000000 -> 0xffffffff */
asm-sparc/iommu.h:#define IOMMU_RNGE_256MB    0x00000010 /* 0xf0000000 -> 0xffffffff */
asm-sparc/iommu.h:#define IOMMU_RNGE_512MB    0x00000014 /* 0xe0000000 -> 0xffffffff */
asm-sparc/iommu.h:#define IOMMU_RNGE_1GB      0x00000018 /* 0xc0000000 -> 0xffffffff */
asm-sparc/iommu.h:#define IOMMU_RNGE_2GB      0x0000001c /* 0x80000000 -> 0xffffffff */
asm-sparc/iommu.h:#define IOMMU_SBCFG_SAB30   0x00010000 /* Phys-address bit 30 when bypass enabled */
asm-sparc/iommu.h:#define IOMMU_MID_MID       0x0000000f /* Module-id, hardcoded to 0x8 */
asm-sparc/iommu.h:	regs->tlbflush = 0;
asm-sparc/iommu.h:	regs->pageflush = (page & PAGE_MASK);
asm-sparc/string.h:	case 1: return (src[0] - dest[0]);
asm-sparc/string.h:	case 2: retval = (src[0] - dest[0]);
asm-sparc/string.h:		  retval = (src[1] - dest[1]);
asm-sparc/string.h:	case 3: retval = (src[0] - dest[0]);
asm-sparc/string.h:		  retval = (src[1] - dest[1]);
asm-sparc/string.h:		    retval = (src[2] - dest[2]);
asm-sparc/string.h:	case 4: retval = (src[0] - dest[0]);
asm-sparc/string.h:		  retval = (src[1] - dest[1]);
asm-sparc/string.h:		    retval = (src[2] - dest[2]);
asm-sparc/string.h:		      retval = (src[3] - dest[3]);
asm-sparc/string.h:	case 5: retval = (src[0] - dest[0]);
asm-sparc/string.h:		  retval = (src[1] - dest[1]);
asm-sparc/string.h:		    retval = (src[2] - dest[2]);
asm-sparc/string.h:		      retval = (src[3] - dest[3]);
asm-sparc/string.h:		        retval = (src[4] - dest[4]);
asm-sparc/string.h:		retval = (src[0] - dest[0]);
asm-sparc/string.h:		  retval = (src[1] - dest[1]);
asm-sparc/string.h:		    retval = (src[2] - dest[2]);
asm-sparc/string.h:		      retval = __strncmp(src+3,dest+3,count-3);
asm-sparc/ioctls.h:/* 118 is the non-posix setpgrp tty ioctl */
asm-sparc/ioctls.h:/* 119 is the non-posix getpgrp tty ioctl */
asm-sparc/ioctls.h:/* Get minor device of a pty master's FD -- Solaris equiv is ISPTM */
asm-sparc/pgtsun4c.h:/* PMD_SHIFT determines the size of the area a second-level page table can map */
asm-sparc/pgtsun4c.h:#define SUN4C_PMD_MASK        (~(SUN4C_PMD_SIZE-1))
asm-sparc/pgtsun4c.h:#define SUN4C_PMD_ALIGN(addr) (((addr)+SUN4C_PMD_SIZE-1)&SUN4C_PMD_MASK)
asm-sparc/pgtsun4c.h:/* PGDIR_SHIFT determines what a third-level page table entry can map */
asm-sparc/pgtsun4c.h:#define SUN4C_PGDIR_MASK        (~(SUN4C_PGDIR_SIZE-1))
asm-sparc/pgtsun4c.h:#define SUN4C_PGDIR_ALIGN(addr) (((addr)+SUN4C_PGDIR_SIZE-1)&SUN4C_PGDIR_MASK)
asm-sparc/pgtsun4c.h:#define SUN4C_REAL_PGDIR_MASK        (~(SUN4C_REAL_PGDIR_SIZE-1))
asm-sparc/pgtsun4c.h:#define SUN4C_REAL_PGDIR_ALIGN(addr) (((addr)+SUN4C_REAL_PGDIR_SIZE-1)&SUN4C_REAL_PGDIR_MASK)
asm-sparc/pgtsun4c.h:#define _SUN4C_PAGE_NOCACHE      0x10000000   /* non-cacheable page */
asm-sparc/msgbuf.h: * - 64-bit time_t to solve y2038 problem
asm-sparc/msgbuf.h: * - 2 miscellaneous 32-bit values
asm-sparc/openprom.h:	/* Non-blocking variants. */
asm-sparc/openprom.h:	/* Evaluate a forth string, not different proto for V0 and V2->up. */
asm-sparc/openprom.h:	 * crashes the machine, have to test this. :-)
asm-sparc/openprom.h:	/* v3_cpustart() will start the cpu 'whichcpu' in mmu-context
asm-sparc/winmacro.h: * winmacro.h: Window loading-unloading macros.
asm-sparc/winmacro.h:/* Store the register window onto the 8-byte aligned area starting
asm-sparc/winmacro.h:/* Blackbox - take care with this... - check smp4m and smp4d before changing this. */
asm-sparc/socket.h:/* Security levels - as per NRL IPv6 - don't actually do anything */
asm-sparc/socket.h:/* Nast libc5 fixup - bletch */
asm-sparc/socket.h:#define SOCK_RDM	4		/* reliably-delivered message	*/
asm-sparc/pgtsun4.h:/* PMD_SHIFT determines the size of the area a second-level page table can map */
asm-sparc/pgtsun4.h:#define SUN4C_PMD_MASK        (~(SUN4C_PMD_SIZE-1))
asm-sparc/pgtsun4.h:#define SUN4C_PMD_ALIGN(addr) (((addr)+SUN4C_PMD_SIZE-1)&SUN4C_PMD_MASK)
asm-sparc/pgtsun4.h:/* PGDIR_SHIFT determines what a third-level page table entry can map */
asm-sparc/pgtsun4.h:#define SUN4C_PGDIR_MASK        (~(SUN4C_PGDIR_SIZE-1))
asm-sparc/pgtsun4.h:#define SUN4C_PGDIR_ALIGN(addr) (((addr)+SUN4C_PGDIR_SIZE-1)&SUN4C_PGDIR_MASK)
asm-sparc/pgtsun4.h:#define SUN4C_REAL_PGDIR_MASK        (~(SUN4C_REAL_PGDIR_SIZE-1))
asm-sparc/pgtsun4.h:#define SUN4C_REAL_PGDIR_ALIGN(addr) (((addr)+SUN4C_REAL_PGDIR_SIZE-1)&SUN4C_REAL_PGDIR_MASK)
asm-sparc/pgtsun4.h:#define _SUN4C_PAGE_NOCACHE      0x10000000   /* non-cacheable page */
asm-sparc/memreg.h:#define SUN4C_SYNC_NOMEM     0x0020  /* translation to non-existent ram */
asm-sparc/memreg.h:#define SUN4C_ASYNC_BADWB   0x0080  /* write back points to non-present page */
asm-sparc/memreg.h:#define	SUN4C_MPE_ERR00	0x08	/* Parity error in bits 0-7. (ro) */
asm-sparc/memreg.h:#define	SUN4C_MPE_ERR08	0x04	/* Parity error in bits 8-15. (ro) */
asm-sparc/memreg.h:#define	SUN4C_MPE_ERR16	0x02	/* Parity error in bits 16-23. (ro) */
asm-sparc/memreg.h:#define	SUN4C_MPE_ERR24	0x01	/* Parity error in bits 24-31. (ro) */
asm-sparc64/pstate.h: * -----------------------------------------------------------------------
asm-sparc64/pstate.h: * -----------------------------------------------------------------------
asm-sparc64/pstate.h: * ---------------------------------------------------------------
asm-sparc64/pstate.h: * ---------------------------------------------------------------
asm-sparc64/pstate.h:/* Floating-Point Registers State Register.
asm-sparc64/pstate.h: * --------------------------------
asm-sparc64/pstate.h: * --------------------------------
asm-sparc64/pstate.h: * ------------------------------------------------------
asm-sparc64/pstate.h: * ------------------------------------------------------
asm-sparc64/sunbpp.h: * include/asm-sparc64/sunbpp.h
asm-sparc64/sunbpp.h:#define P_OCR_EN_VER    0x0001      /* Enable Versatec (0 - enable). Zebra only. */
asm-sparc64/io.h:#define page_to_phys(page)	((((page) - mem_map) << PAGE_SHIFT)+phys_base)
asm-sparc64/io.h:/* Now versions without byte-swapping. */
asm-sparc64/io.h: * not use little-endian ASIs.
asm-sparc64/io.h:	while(n--) {
asm-sparc64/io.h:	while (n--) {
asm-sparc64/io.h:	while (n--) {
asm-sparc64/io.h:	while (n--) {
asm-sparc64/io.h:	} while (--length);
asm-sparc64/io.h:	__ret  = (__res)->start + (((__res)->flags & 0x1ffUL) << 32UL); \
asm-sparc64/atomic.h:#define atomic_read(v)		((v)->counter)
asm-sparc64/atomic.h:#define atomic_set(v, i)	(((v)->counter) = i)
asm-sparc64/atomic.h: * atomic_inc_and_test - increment and test
asm-sparc64/ipcbuf.h: * - 32-bit seq
asm-sparc64/ipcbuf.h: * - 2 miscellaneous 64-bit values
asm-sparc64/parport.h:	writel(EBUS_DCSR_RESET, &sparc_ebus_dmas[dmanr]->dcsr);
asm-sparc64/parport.h:	writel(dcsr, &sparc_ebus_dmas[dmanr]->dcsr);
asm-sparc64/parport.h:	dcsr = readl(&sparc_ebus_dmas[dmanr]->dcsr);
asm-sparc64/parport.h:	writel(dcsr, &sparc_ebus_dmas[dmanr]->dcsr);
asm-sparc64/parport.h:	dcsr = readl(&sparc_ebus_dmas[dmanr]->dcsr);
asm-sparc64/parport.h:			dcsr = readl(&sparc_ebus_dmas[dmanr]->dcsr);
asm-sparc64/parport.h:		writel(dcsr, &sparc_ebus_dmas[dmanr]->dcsr);
asm-sparc64/parport.h:		dcsr = readl(&sparc_ebus_dmas[dmanr]->dcsr);
asm-sparc64/parport.h:	dcsr = readl(&sparc_ebus_dmas[dmanr]->dcsr);
asm-sparc64/parport.h:	writel(dcsr, &sparc_ebus_dmas[dmanr]->dcsr);
asm-sparc64/parport.h:	writel(addr, &sparc_ebus_dmas[dmanr]->dacr);
asm-sparc64/parport.h:	writel(count, &sparc_ebus_dmas[dmanr]->dbcr);
asm-sparc64/parport.h:	res = readl(&sparc_ebus_dmas[dmanr]->dbcr);
asm-sparc64/parport.h:	if (!strcmp(edev->prom_name, "ecpp"))
asm-sparc64/parport.h:	if (!strcmp(edev->prom_name, "parallel")) {
asm-sparc64/parport.h:		prom_getstring(edev->prom_node,
asm-sparc64/parport.h:		if (!strcmp(compat, "ns87317-ecpp") &&
asm-sparc64/parport.h:			if (strcmp(isa_dev->prom_name, "dma"))
asm-sparc64/parport.h:			child = isa_dev->child;
asm-sparc64/parport.h:				if (!strcmp(child->prom_name, "parallel"))
asm-sparc64/parport.h:				child = child->next;
asm-sparc64/parport.h:			base = child->resource.start;
asm-sparc64/parport.h:			 * asm-sparc64/floppy.h:isa_floppy_init()
asm-sparc64/parport.h:						  child->irq, PARPORT_DMA_NOFIFO,
asm-sparc64/parport.h:						  child->bus->self))
asm-sparc64/parport.h:				unsigned long base = edev->resource[0].start;
asm-sparc64/parport.h:				unsigned long config = edev->resource[1].start;
asm-sparc64/parport.h:							edev->resource[2].start;
asm-sparc64/parport.h:							  edev->irqs[0],
asm-sparc64/parport.h:							  count, ebus->self))
asm-sparc64/display7seg.h: * display7seg - Driver interface for the 7-segment display
asm-sparc64/display7seg.h: * POINT	- Toggle decimal point	(0=absent 1=present)
asm-sparc64/display7seg.h: * ALARM	- Toggle alarm LED 		(0=green  1=red)
asm-sparc64/display7seg.h: * FLIP		- Toggle inverted mode 	(0=normal 1=flipped) 
asm-sparc64/display7seg.h: * bits 0-4	- Character displayed	(see definitions below)
asm-sparc64/display7seg.h: *   ---
asm-sparc64/display7seg.h: *   -g-
asm-sparc64/display7seg.h: *   ---
asm-sparc64/display7seg.h:#define D7S_0		0x00		/* Numerals 0-9 */
asm-sparc64/display7seg.h:#define D7S_A		0x0A		/* Letters A-F, H, L, P */
asm-sparc64/shmbuf.h: * - 2 miscellaneous 64-bit values
asm-sparc64/sfp-machine.h:/* Machine-dependent software floating-point definitions.
asm-sparc64/sfp-machine.h:   59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
asm-sparc64/sfp-machine.h:#define _FP_NANFRAC_S		((_FP_QNANBIT_S << 1) - 1)
asm-sparc64/sfp-machine.h:#define _FP_NANFRAC_D		((_FP_QNANBIT_D << 1) - 1)
asm-sparc64/sfp-machine.h:#define _FP_NANFRAC_Q		((_FP_QNANBIT_Q << 1) - 1), -1
asm-sparc64/sfp-machine.h:#define FP_ROUNDMODE	((current->thread.xfsr[0] >> 30) & 0x3)
asm-sparc64/sfp-machine.h:#define FP_INHIBIT_RESULTS ((current->thread.xfsr[0] >> 23) & _fex)
asm-sparc64/bitops.h:/* "non-atomic" versions... */
asm-sparc64/bitops.h: * __ffs - find first bit in word.
asm-sparc64/bitops.h: * of bits set) of a N-bit word
asm-sparc64/bitops.h:	size -= result;
asm-sparc64/bitops.h:		tmp |= ~0UL >> (64-offset);
asm-sparc64/bitops.h:		size -= 64;
asm-sparc64/bitops.h:		size -= 64;
asm-sparc64/bitops.h:	size -= result;
asm-sparc64/bitops.h:		tmp |= (~0UL >> (64-offset));
asm-sparc64/bitops.h:		size -= 64;
asm-sparc64/bitops.h:		size -= 64;
asm-sparc64/visasm.h:#define AOFF_task_fpregs	(((ASIZ_task) + (64 - 1)) & ~(64 - 1))
asm-sparc64/div64.h: * Hey, we're already 64-bit, no
asm-sparc64/resource.h:#define RLIMIT_MEMLOCK  8               /* max locked-in-memory address space */
asm-sparc64/ptrace.h:/* A 32-bit register window. */
asm-sparc64/ptrace.h:/* A 32-bit Sparc stack frame */
asm-sparc64/ptrace.h:#define user_mode(regs) (!((regs)->tstate & TSTATE_PRIV))
asm-sparc64/ptrace.h:#define instruction_pointer(regs) ((regs)->tpc)
asm-sparc64/ptrace.h:	current->thread.flags |= SPARC_FLAG_SYS_SUCCESS; \
asm-sparc64/ptrace.h:/* There are for debugging 64-bit processes, either from a 32 or 64 bit
asm-sparc64/ptrace.h: * parent.  Thus their compliments are for debugging 32-bit processes only.
asm-sparc64/ptrace.h:#define PTRACE_GETUCODE           29  /* stupid bsd-ism */
asm-sparc64/ptrace.h:/* These are for 32-bit processes debugging 64-bit ones.
asm-sparc64/pgalloc.h:	do { if ((__mm) == current->mm) flushw_user(); } while(0)
asm-sparc64/pgalloc.h:	flush_cache_mm((vma)->vm_mm)
asm-sparc64/pgalloc.h:/* This is unnecessary on the SpitFire since D-CACHE is write-through. */
asm-sparc64/pgalloc.h:do { if(CTX_VALID((__mm)->context)) \
asm-sparc64/pgalloc.h:	__flush_tlb_mm(CTX_HWBITS((__mm)->context), SECONDARY_CONTEXT); \
asm-sparc64/pgalloc.h:do { if(CTX_VALID((__mm)->context)) { \
asm-sparc64/pgalloc.h:	__flush_tlb_range(CTX_HWBITS((__mm)->context), __start, \
asm-sparc64/pgalloc.h:			  (__end - __start)); \
asm-sparc64/pgalloc.h:do { struct mm_struct *__mm = (vma)->vm_mm; \
asm-sparc64/pgalloc.h:     if(CTX_VALID(__mm->context)) \
asm-sparc64/pgalloc.h:	__flush_tlb_page(CTX_HWBITS(__mm->context), (page)&PAGE_MASK, \
asm-sparc64/pgalloc.h:	smp_flush_tlb_page((vma)->vm_mm, page)
asm-sparc64/pgalloc.h:	e = (e + PMD_SIZE - 1) & PMD_MASK;
asm-sparc64/pgalloc.h:			vpte_base + (s >> (PAGE_SHIFT - 3)),
asm-sparc64/pgalloc.h:			vpte_base + (e >> (PAGE_SHIFT - 3)));
asm-sparc64/pgalloc.h:	if (!page->pprev_hash) {
asm-sparc64/pgalloc.h:		page->next_hash = (struct page *)pgd_quicklist;
asm-sparc64/pgalloc.h:	page->pprev_hash = (struct page **)(((unsigned long)page->pprev_hash) |
asm-sparc64/pgalloc.h:                unsigned long mask = (unsigned long)ret->pprev_hash;
asm-sparc64/pgalloc.h:		ret->pprev_hash = (struct page **)mask;
asm-sparc64/pgalloc.h:			pgd_quicklist = (unsigned long *)ret->next_hash;
asm-sparc64/pgalloc.h:                pgd_cache_size--;
asm-sparc64/pgalloc.h:			page->pprev_hash = (struct page **) 2UL;
asm-sparc64/pgalloc.h:			page->next_hash = (struct page *) pgd_quicklist;
asm-sparc64/pgalloc.h:		pgtable_cache_size--;
asm-sparc64/pgalloc.h:		pgtable_cache_size--;
asm-sparc64/pgalloc.h:		pgtable_cache_size--;
asm-sparc64/unistd.h:#define __NR_pause               29 /* Is sigblock(0)->sigpause() in SunOS         */
asm-sparc64/unistd.h:/* #define __NR_iopl            209    Linux Specific - i386 specific, unused      */
asm-sparc64/unistd.h:/* #define __NR_idle            210    Linux Specific - was sys_idle, now unused   */
asm-sparc64/unistd.h:/* #define __NR_vm86            211    Linux Specific - i386 specific, unused      */
asm-sparc64/unistd.h:/* #define __NR_modify_ldt      218    Linux Specific - i386 specific, unused      */
asm-sparc64/unistd.h:errno = -__res; \
asm-sparc64/unistd.h:return -1; \
asm-sparc64/unistd.h:errno = -__res; \
asm-sparc64/unistd.h:return -1; \
asm-sparc64/unistd.h:errno = -__res; \
asm-sparc64/unistd.h:return -1; \
asm-sparc64/unistd.h:errno = -__res; \
asm-sparc64/unistd.h:return -1; \
asm-sparc64/unistd.h:errno = -__res; \
asm-sparc64/unistd.h:return -1; \
asm-sparc64/unistd.h:errno = -__res; \
asm-sparc64/unistd.h:return -1; \
asm-sparc64/unistd.h: * we need this inline - forking from kernel space will result
asm-sparc64/unistd.h: * calls - which means inline code for fork too, as otherwise we
asm-sparc64/unistd.h:	return waitpid(-1,wait_stat,0);
asm-sparc64/bbc.h: * bbc.h: Defines for BootBus Controller found on UltraSPARC-III
asm-sparc64/bbc.h:/* Register sizes are indicated by "B" (Byte, 1-byte),
asm-sparc64/bbc.h: * "H" (Half-word, 2 bytes), "W" (Word, 4 bytes) or
asm-sparc64/bbc.h:#define BBC_ES_DACT	0x14	/* [B] E* De-Assert Change Time	*/
asm-sparc64/bbc.h:#define BBC_ES_DABT	0x15	/* [B] E* De-Assert Bypass Time	*/
asm-sparc64/bbc.h:#define BBC_I2C_0_S1	0x2e	/* [B] I2C ctrlr-0 reg S1	*/
asm-sparc64/bbc.h:#define BBC_I2C_0_S0	0x2f	/* [B] I2C ctrlr-0 regs S0,S0',S2,S3*/
asm-sparc64/bbc.h:#define BBC_I2C_1_S1	0x30	/* [B] I2C ctrlr-1 reg S1	*/
asm-sparc64/bbc.h:#define BBC_I2C_1_S0	0x31	/* [B] I2C ctrlr-1 regs S0,S0',S2,S3*/
asm-sparc64/bbc.h:#define BBC_PSRC_BUTTON	0x0040 /* System reset via push-button dongle	*/
asm-sparc64/bbc.h:#define BBC_PSRC_PWRUP	0x0080 /* System reset via power-up		*/
asm-sparc64/bbc.h:#define BBC_PSRC_SYNTH	0x8000 /* System reset when on-board clock synthesizers
asm-sparc64/bbc.h:/* Clock Synthesizers Control register.  This register provides the big-bang
asm-sparc64/bbc.h: * de-assertion of CLK_CHANGE_L[2:0] and the de-assertion of the FREEZE_L
asm-sparc64/bbc.h: * BBC clocks between the de-assertion of CLK_CHANGE_L[2:0] and the first
asm-sparc64/bbc.h:/* Keyboard Beep Counter register.  There is a free-running counter inside
asm-sparc64/asi.h:#define ASI_PL			0x88 /* Primary, implicit, l-endian	*/
asm-sparc64/asi.h:#define ASI_SL			0x89 /* Secondary, implicit, l-endian	*/
asm-sparc64/asi.h:#define ASI_PNFL		0x8a /* Primary, no fault, l-endian	*/
asm-sparc64/asi.h:#define ASI_SNFL		0x8b /* Secondary, no fault, l-endian	*/
asm-sparc64/asi.h: * UltraSparc-III and later specific ASIs.  The "(CMT)" marker designates
asm-sparc64/asi.h:#define ASI_PHYS_USE_EC		0x14 /* PADDR, E-cachable		*/
asm-sparc64/asi.h:#define ASI_PHYS_BYPASS_EC_E	0x15 /* PADDR, E-bit			*/
asm-sparc64/asi.h:#define ASI_PHYS_USE_EC_L	0x1c /* PADDR, E-cachable, little endian*/
asm-sparc64/asi.h:#define ASI_PHYS_BYPASS_EC_E_L	0x1d /* PADDR, E-bit, little endian	*/
asm-sparc64/asi.h:#define ASI_NUCLEUS_QUAD_LDD_L	0x2c /* Cachable, qword load, l-endian 	*/
asm-sparc64/asi.h:#define ASI_QUAD_LDD_PHYS_L	0x3c /* (III+) PADDR, qw-load, l-endian	*/
asm-sparc64/asi.h:#define ASI_CORE_RUNNING_W1S	0x41 /* (CMT) LP Running Write-One Set	*/
asm-sparc64/asi.h:#define ASI_CORE_RUNNING_W1C	0x41 /* (CMT) LP Running Write-One Clr	*/
asm-sparc64/asi.h:#define ASI_LSU_CONTROL		0x45 /* Load-store control unit		*/
asm-sparc64/asi.h:#define ASI_DCACHE_DATA		0x46 /* DCache data-ram diag access	*/
asm-sparc64/asi.h:#define ASI_ESTATE_ERROR_EN	0x4b /* E-cache error enable space	*/
asm-sparc64/asi.h:#define ASI_EC_TAG_DATA		0x4e /* E-cache tag/valid ram diag acc	*/
asm-sparc64/asi.h:#define ASI_IMMU		0x50 /* Insn-MMU main register space	*/
asm-sparc64/asi.h:#define ASI_IMMU_TSB_8KB_PTR	0x51 /* Insn-MMU 8KB TSB pointer reg	*/
asm-sparc64/asi.h:#define ASI_IMMU_TSB_64KB_PTR	0x52 /* Insn-MMU 64KB TSB pointer reg	*/
asm-sparc64/asi.h:#define ASI_ITLB_DATA_IN	0x54 /* Insn-MMU TLB data in reg	*/
asm-sparc64/asi.h:#define ASI_ITLB_DATA_ACCESS	0x55 /* Insn-MMU TLB data access reg	*/
asm-sparc64/asi.h:#define ASI_ITLB_TAG_READ	0x56 /* Insn-MMU TLB tag read reg	*/
asm-sparc64/asi.h:#define ASI_IMMU_DEMAP		0x57 /* Insn-MMU TLB demap		*/
asm-sparc64/asi.h:#define ASI_DMMU		0x58 /* Data-MMU main register space	*/
asm-sparc64/asi.h:#define ASI_DMMU_TSB_8KB_PTR	0x59 /* Data-MMU 8KB TSB pointer reg	*/
asm-sparc64/asi.h:#define ASI_DMMU_TSB_64KB_PTR	0x5a /* Data-MMU 16KB TSB pointer reg	*/
asm-sparc64/asi.h:#define ASI_DMMU_TSB_DIRECT_PTR	0x5b /* Data-MMU TSB direct pointer reg	*/
asm-sparc64/asi.h:#define ASI_DTLB_DATA_IN	0x5c /* Data-MMU TLB data in reg	*/
asm-sparc64/asi.h:#define ASI_DTLB_DATA_ACCESS	0x5d /* Data-MMU TLB data access reg	*/
asm-sparc64/asi.h:#define ASI_DTLB_TAG_READ	0x5e /* Data-MMU TLB tag read reg	*/
asm-sparc64/asi.h:#define ASI_DMMU_DEMAP		0x5f /* Data-MMU TLB demap		*/
asm-sparc64/asi.h:#define ASI_IC_PRE_DECODE	0x6e /* Insn cache pre-decode ram diag	*/
asm-sparc64/asi.h:#define ASI_IC_NEXT_FIELD	0x6f /* Insn cache next-field ram diag	*/
asm-sparc64/asi.h:#define ASI_EC_DATA		0x74 /* (III) E-cache data staging reg	*/
asm-sparc64/asi.h:#define ASI_EC_CTRL		0x75 /* (III) E-cache control reg	*/
asm-sparc64/asi.h:#define ASI_EC_W		0x76 /* E-cache diag write access	*/
asm-sparc64/asi.h:#define ASI_EC_R		0x7e /* E-cache diag read access	*/
asm-sparc64/asi.h:#define ASI_PST8_P		0xc0 /* Primary, 8 8-bit, partial	*/
asm-sparc64/asi.h:#define ASI_PST8_S		0xc1 /* Secondary, 8 8-bit, partial	*/
asm-sparc64/asi.h:#define ASI_PST16_P		0xc2 /* Primary, 4 16-bit, partial	*/
asm-sparc64/asi.h:#define ASI_PST16_S		0xc3 /* Secondary, 4 16-bit, partial	*/
asm-sparc64/asi.h:#define ASI_PST32_P		0xc4 /* Primary, 2 32-bit, partial	*/
asm-sparc64/asi.h:#define ASI_PST32_S		0xc5 /* Secondary, 2 32-bit, partial	*/
asm-sparc64/asi.h:#define ASI_PST8_PL		0xc8 /* Primary, 8 8-bit, partial, L	*/
asm-sparc64/asi.h:#define ASI_PST8_SL		0xc9 /* Secondary, 8 8-bit, partial, L	*/
asm-sparc64/asi.h:#define ASI_PST16_PL		0xca /* Primary, 4 16-bit, partial, L	*/
asm-sparc64/asi.h:#define ASI_PST16_SL		0xcb /* Secondary, 4 16-bit, partial, L	*/
asm-sparc64/asi.h:#define ASI_PST32_PL		0xcc /* Primary, 2 32-bit, partial, L	*/
asm-sparc64/asi.h:#define ASI_PST32_SL		0xcd /* Secondary, 2 32-bit, partial, L	*/
asm-sparc64/asi.h:#define ASI_FL8_P		0xd0 /* Primary, 1 8-bit, fpu ld/st	*/
asm-sparc64/asi.h:#define ASI_FL8_S		0xd1 /* Secondary, 1 8-bit, fpu ld/st	*/
asm-sparc64/asi.h:#define ASI_FL16_P		0xd2 /* Primary, 1 16-bit, fpu ld/st	*/
asm-sparc64/asi.h:#define ASI_FL16_S		0xd3 /* Secondary, 1 16-bit, fpu ld/st	*/
asm-sparc64/asi.h:#define ASI_FL8_PL		0xd8 /* Primary, 1 8-bit, fpu ld/st, L	*/
asm-sparc64/asi.h:#define ASI_FL8_SL		0xd9 /* Secondary, 1 8-bit, fpu ld/st, L*/
asm-sparc64/asi.h:#define ASI_FL16_PL		0xda /* Primary, 1 16-bit, fpu ld/st, L	*/
asm-sparc64/asi.h:#define ASI_FL16_SL		0xdb /* Secondary, 1 16-bit, fpu ld/st,L*/
asm-sparc64/bpp.h: * This is a driver that supports IEEE Std 1284-1994 communications
asm-sparc64/bpp.h: * with bizzarro-mode of the ACME Special TurboThingy Plus.
asm-sparc64/cmt.h:/* cmt.h: Chip Multi-Threading register definitions
asm-sparc64/cmt.h:/* ASI_CORE_ID - private */
asm-sparc64/cmt.h:/* ASI_INTR_ID - private */
asm-sparc64/cmt.h:/* ASI_CESR_ID - private */
asm-sparc64/cmt.h:/* ASI_CORE_AVAILABLE - shared */
asm-sparc64/cmt.h:/* ASI_CORE_ENABLE_STATUS - shared */
asm-sparc64/cmt.h:/* ASI_CORE_ENABLE - shared */
asm-sparc64/cmt.h:/* ASI_CORE_RUNNING - shared */
asm-sparc64/cmt.h:/* ASI_CORE_RUNNING_STAT - shared */
asm-sparc64/cmt.h:/* ASI_XIR_STEERING - shared */
asm-sparc64/cmt.h:/* ASI_CMT_ERROR_STEERING - shared */
asm-sparc64/dcr.h:/* UltraSparc-III/III+ Dispatch Control Register, ASR 0x12 */
asm-sparc64/dcr.h:#define DCR_MS		0x0000000000000001 /* Multi-Scalar dispatch		*/
asm-sparc64/dcu.h:/* UltraSparc-III Data Cache Unit Control Register */
asm-sparc64/dcu.h:#define DCU_ME		0x0000800000000000 /* NC-store Merging Enable	*/
asm-sparc64/dma.h: * include/asm-sparc64/dma.h
asm-sparc64/dma.h:#define DMA_ISBROKEN(dma)    ((dma)->revision == dvmarev1)
asm-sparc64/dma.h:#define DMA_ISESC1(dma)      ((dma)->revision == dvmaesc1)
asm-sparc64/dma.h:#define DMA_SCSI_SBUS64  0x00008000        /* HME: Enable 64-bit SBUS mode. */
asm-sparc64/dma.h:#define DMA_BRST0        0x00080000        /* SCSI: no bursts (non-HME gate arrays) */
asm-sparc64/dma.h:#define DMA_EN_ENETAUI   DMA_3CLKS         /* Put lance into AUI-cable mode */
asm-sparc64/dma.h:/* Values describing the burst-size property from the PROM */
asm-sparc64/dma.h:#define DMA_MAXEND(addr) (0x01000000UL-(((unsigned long)(addr))&0x00ffffffUL))
asm-sparc64/dma.h:        for((dma) = dma_chain; (dma); (dma) = (dma)->next)
asm-sparc64/elf.h:/* Format of 64-bit elf_gregset_t is:
asm-sparc64/elf.h: * 	G0 --> G7
asm-sparc64/elf.h: * 	O0 --> O7
asm-sparc64/elf.h: * 	L0 --> L7
asm-sparc64/elf.h: * 	I0 --> I7
asm-sparc64/elf.h:		dest[i] = src->u_regs[i];		\
asm-sparc64/elf.h:	 ((src->u_regs[14] + STACK_BIAS)		\
asm-sparc64/elf.h:	dest[32] = src->tstate;				\
asm-sparc64/elf.h:	dest[33] = src->tpc;				\
asm-sparc64/elf.h:	dest[34] = src->tnpc;				\
asm-sparc64/elf.h:	dest[35] = src->y;				\
asm-sparc64/elf.h:#define elf_check_arch(x) ((x)->e_machine == ELF_ARCH)	/* Might be EM_SPARCV9 or EM_SPARC */
asm-sparc64/elf.h:do {	unsigned char flags = current->thread.flags;	\
asm-sparc64/elf.h:	if (flags != current->thread.flags) {		\
asm-sparc64/elf.h:		current->thread.flags |= SPARC_FLAG_ABI_PENDING; \
asm-sparc64/elf.h:		current->thread.flags &= ~SPARC_FLAG_ABI_PENDING; \
asm-sparc64/elf.h:	else if (current->personality != PER_LINUX32)	\
asm-sparc64/fhc.h:#define  FHC_CONTROL_DCD	0x00008000 /* DC-->DC Converter Disable		*/
asm-sparc64/ide.h:		hw->io_ports[i] = reg;
asm-sparc64/ide.h:		hw->io_ports[IDE_CONTROL_OFFSET] = ctrl_port;
asm-sparc64/ide.h:		hw->io_ports[IDE_CONTROL_OFFSET] = 0;
asm-sparc64/ide.h:	hw->io_ports[IDE_IRQ_OFFSET] = 0;
asm-sparc64/ide.h:		count--;
asm-sparc64/ide.h:		count -= 2;
asm-sparc64/ide.h:		count--;
asm-sparc64/ide.h:		count -= 2;
asm-sparc64/isa.h:        for((bus) = isa_chain; (bus); (bus) = (bus)->next)
asm-sparc64/isa.h:        for((dev) = (bus)->devices; (dev); (dev) = (dev)->next)
asm-sparc64/irq.h: * irq.h: IRQ registers on the 64-bit Sparc.
asm-sparc64/irq.h: * SBUS/floppy interrupt handler in entry.S -DaveM
asm-sparc64/irq.h:	/* Next handler in per-CPU PIL worklist.  We know that
asm-sparc64/irq.h:	 * bucket pointers have the high 32-bits clear, so to
asm-sparc64/irq.h:	 * non-NULL this means it is active and should be
asm-sparc64/irq.h:/* Only 8-bits are available, be careful.  -DaveM */
asm-sparc64/irq.h:        (((struct ino_bucket *)(unsigned long)(irq)) - &ivector_table[0])
asm-sparc64/irq.h:#define __irq_pil(irq) ((struct ino_bucket *)(unsigned long)(irq))->pil
asm-sparc64/lsu.h:#define LSU_CONTROL_PM		0x000001fe00000000 /* Phys-watchpoint byte mask     */
asm-sparc64/lsu.h:#define LSU_CONTROL_VM		0x00000001fe000000 /* Virt-watchpoint byte mask     */
asm-sparc64/lsu.h:#define LSU_CONTROL_PR		0x0000000001000000 /* Phys-read watchpoint enable   */
asm-sparc64/lsu.h:#define LSU_CONTROL_PW		0x0000000000800000 /* Phys-write watchpoint enable  */
asm-sparc64/lsu.h:#define LSU_CONTROL_VR		0x0000000000400000 /* Virt-read watchpoint enable   */
asm-sparc64/lsu.h:#define LSU_CONTROL_VW		0x0000000000200000 /* Virt-write watchpoint enable  */
asm-sparc64/pbm.h: * PBMs of a controller, or per-PBM), and if a streaming buffer
asm-sparc64/pbm.h:	 * read will have no side-effects but will guarentee
asm-sparc64/pbm.h:	/* In order to deal with some buggy third-party PCI bridges that
asm-sparc64/pbm.h:	 * these counters.  You have been duly warned. -DaveM
asm-sparc64/pbm.h:	 * a 64-byte aligned area.
asm-sparc64/pbm.h:	volatile unsigned long	__flushflag_buf[(64 + (64 - 1)) / sizeof(long)];
asm-sparc64/pbm.h:	(*((STC)->strbuf_flushflag) = 0UL)
asm-sparc64/pbm.h:	(*((STC)->strbuf_flushflag) != 0UL)
asm-sparc64/pbm.h:	/* Opaque 32-bit system bus Port ID. */
asm-sparc64/pbm.h:	/* Name used for top-level resources. */
asm-sparc64/pbm.h:	/* Base of PCI Config space, can be per-PBM or shared. */
asm-sparc64/pci.h: * already-configured bus numbers - to be used for buggy BIOSes
asm-sparc64/pci.h: * The 32-bit bus address to use is returned.
asm-sparc64/pci.h:	((PTR)->ADDR_NAME)
asm-sparc64/pci.h:	(((PTR)->ADDR_NAME) = (VAL))
asm-sparc64/pci.h:	((PTR)->LEN_NAME)
asm-sparc64/pci.h:	(((PTR)->LEN_NAME) = (VAL))
asm-sparc64/pci.h: * mode for DMA.  This is the scather-gather version of the
asm-sparc64/pci.h: * The same as pci_dma_sync_single but for a scatter-gather list,
asm-sparc64/pci.h: * only drive the low 24-bits during PCI bus mastering, then
asm-sparc64/pci.h:/* PCI 64-bit addressing works for all slots on all controller
asm-sparc64/pci.h:	unsigned long paddr = (dma_addr & PAGE_MASK) - PCI64_ADDR_BASE;
asm-sparc64/reg.h: * linux/asm-sparc64/reg.h
asm-sparc64/reg.h: * -miguel
asm-sparc64/rtc.h:	int	sec;	/* Seconds (0-59) */
asm-sparc64/rtc.h:	int	min;	/* Minutes (0-59) */
asm-sparc64/rtc.h:	int	hour;	/* Hour (0-23) */
asm-sparc64/rtc.h:	int	dow;	/* Day of the week (1-7) */
asm-sparc64/rtc.h:	int	dom;	/* Day of the month (1-31) */
asm-sparc64/rtc.h:	int	month;	/* Month of year (1-12) */
asm-sparc64/rtc.h:	int	year;	/* Year (0-99) */
asm-sparc64/smp.h:/* PROM provided per-processor information we need
asm-sparc64/smp.h:/* Keep this a multiple of 64-bytes for cache reasons. */
asm-sparc64/smp.h:#define smp_processor_id() (current->processor)
asm-sparc64/tlb.h:#include <asm-generic/tlb.h>
asm-sparc64/upa.h:#define UPA_PORTID_PREQDQ       0x000000007e000000 /* slave-wr's to mod supported  */
asm-sparc64/xor.h: * include/asm-sparc64/xor.h
asm-sparc64/xor.h: *	!(((long)dest | (long)sourceN) & (64 - 1)) &&
asm-sparc64/xor.h: * It is done in pure assembly, as otherwise gcc makes it a non-leaf
asm-sparc64/xor.h:	stda	%f48, [%o1 - 64] %asi\n\
asm-sparc64/xor.h:	.size xor_vis_2, .-xor_vis_2\n\
asm-sparc64/xor.h:	stda	%f48, [%o1 - 64] %asi\n\
asm-sparc64/xor.h:	.size xor_vis_3, .-xor_vis_3\n\
asm-sparc64/xor.h:	stda	%f48, [%o1 - 64] %asi\n\
asm-sparc64/xor.h:	.size xor_vis_4, .-xor_vis_4\n\
asm-sparc64/xor.h:	stda	%f48, [%o1 - 64] %asi\n\
asm-sparc64/xor.h:	.size xor_vis_5, .-xor_vis_5\n\
asm-sparc64/kmap_types.h: * is actually used on sparc64.  -DaveM
asm-sparc64/spitfire.h:#define TSB_EXTENSION_P		0x0000000000000048 /* Ultra-III and later		*/
asm-sparc64/spitfire.h:#define TSB_EXTENSION_S		0x0000000000000050 /* Ultra-III and later, D-TLB only	*/
asm-sparc64/spitfire.h:#define TSB_EXTENSION_N		0x0000000000000058 /* Ultra-III and later		*/
asm-sparc64/spitfire.h:#define TLB_TAG_ACCESS_EXT	0x0000000000000060 /* Ultra-III+ and later		*/
asm-sparc64/spitfire.h:#define SPITFIRE_HIGHEST_LOCKED_TLBENT	(64 - 1)
asm-sparc64/spitfire.h:#define CHEETAH_HIGHEST_LOCKED_TLBENT	(16 - 1)
asm-sparc64/spitfire.h:/* Cheetah has "all non-locked" tlb flushes. */
asm-sparc64/spitfire.h:/* Cheetah has a 4-tlb layout so direct access is a bit different.
asm-sparc64/spitfire.h: * The third TLB is for data accesses to 8K non-locked translations, is
asm-sparc64/spitfire.h: * instruction accesses to 8K non-locked translations, is 2 way
asm-sparc64/spitfire.h: * the problem for me. -DaveM
asm-sparc64/signal.h:/* On the Sparc the signal handlers get passed a 'sub-signal' code
asm-sparc64/signal.h:#define SIGRTMAX       (__NEW_NSIG - 1)
asm-sparc64/signal.h:	/* XXX 32-bit pointers pinhead XXX */
asm-sparc64/signal.h:#define SV_SSTACK    1     /* This signal handler should use sig-stack */
asm-sparc64/signal.h: * SA_INTERRUPT is a no-op, but left due to historical reasons. Use the
asm-sparc64/signal.h:#define SIG_ERR	((__sighandler_t)-1)	/* error return from signal */
asm-sparc64/hardirq.h:/* hardirq.h: 64-bit Sparc hard IRQ support.
asm-sparc64/hardirq.h:#define irq_exit(cpu, irq)	((void)(irq), local_irq_count(cpu)--)
asm-sparc64/solerrno.h:#define	SOL_ENOTBLK        15    /* blkdev op on non-block device    */
asm-sparc64/solerrno.h:#define	SOL_ENOTDIR        20    /* Dir operation on non-directory   */
asm-sparc64/solerrno.h:#define	SOL_ESPIPE         29    /* Seek attempted on non-seeking dev*/
asm-sparc64/solerrno.h:#define	SOL_EROFS          30    /* Write attempted on read-only fs  */
asm-sparc64/solerrno.h:#define	SOL_ENOSTR         60    /* Stream-op on non-stream dev      */
asm-sparc64/solerrno.h:#define	SOL_ENOPKG         65    /* Non-installed package            */
asm-sparc64/solerrno.h:#define	SOL_ENOTEMPTY      93    /* Rmdir of non-empty directory     */
asm-sparc64/solerrno.h:#define	SOL_ENOTSOCK       95    /* Sock-op on non-sock              */
asm-sparc64/solerrno.h:#define	SOL_EOPNOTSUPP     122   /* Unsupported sock-op              */
asm-sparc64/solerrno.h:#define	SOL_ENETRESET      129   /* Buy less-buggy ethernet cards    */
asm-sparc64/solerrno.h:#define	SOL_ENOTCONN       134   /* Comm on non-connected socket     */
asm-sparc64/solerrno.h:#define	SOL_ESHUTDOWN      143   /* Op attempted after sock-shutdown */
asm-sparc64/sigcontext.h:/* This is what we use for 32bit new non-rt signals. */
asm-sparc64/ttable.h: * see how arch/sparc64/kernel/winfixup.S works... -DaveM
asm-sparc64/chafsr.h: * ch	-->	cheetah
asm-sparc64/chafsr.h: * ch+	-->	cheetah plus
asm-sparc64/chafsr.h: * jp	-->	jalapeno
asm-sparc64/chafsr.h: * read, write 1 to clear.  M_SYNDROME and E_SYNDROME are read-only.
asm-sparc64/chafsr.h:/* Hardware corrected E-cache Tag ECC error */
asm-sparc64/chafsr.h:/* SW handled correctable E-cache Tag ECC error */
asm-sparc64/chafsr.h:/* Uncorrectable E-cache Tag ECC error */
asm-sparc64/chafsr.h: * 64-byte system bus transaction.  Only the first ECC error in a 16-byte
asm-sparc64/chafsr.h: * subunit will be logged.  All errors in subsequent 16-byte subunits
asm-sparc64/chafsr.h: * from the same 64-byte transaction are ignored.
asm-sparc64/chafsr.h:/* SW Correctable E-cache ECC error for instruction fetch or data access
asm-sparc64/chafsr.h:/* Uncorrectable E-cache ECC error for instruction fetch or data access
asm-sparc64/chafsr.h:/* HW Corrected ECC error from E-cache for writeback */
asm-sparc64/chafsr.h:/* Uncorrectable ECC error from E-cache for writeback */
asm-sparc64/chafsr.h:/* HW Corrected ECC error from E-cache for store merge or block load */
asm-sparc64/chafsr.h:/* Uncorrectable ECC error from E-cache for store merge or block load */
asm-sparc64/chafsr.h: * first occurrence of the highest-priority error according to the M_SYND
asm-sparc64/chafsr.h:/* System bus or E-cache data ECC syndrome.  This field captures the status
asm-sparc64/chafsr.h: * of the first occurrence of the highest-priority error according to the
asm-sparc64/chafsr.h: * interrupts are re-enabled to prevent multiple traps for the same error.  I.e.
asm-sparc64/processor.h: * include/asm-sparc64/processor.h
asm-sparc64/processor.h:#define VPTE_SIZE	(1UL << (VA_BITS - PAGE_SHIFT + 3))
asm-sparc64/processor.h:#define VPTE_SIZE	(1 << (VA_BITS - PAGE_SHIFT + 3))
asm-sparc64/processor.h:#define TASK_SIZE	((unsigned long)-VPTE_SIZE)
asm-sparc64/processor.h:#define VPTE_BASE_SPITFIRE	(-(VPTE_SIZE/2))
asm-sparc64/processor.h:#define SPARC_FLAG_NEWSIGNALS   0x02    /* task wants new-style signals		*/
asm-sparc64/processor.h:#define SPARC_FLAG_32BIT        0x04    /* task is older 32-bit binary		*/
asm-sparc64/processor.h:#define SPARC_FLAG_NEWCHILD     0x08    /* task is just-spawned child process	*/
asm-sparc64/processor.h:#define FAULT_CODE_WRITE	0x01	/* Write access, implies D-TLB		*/
asm-sparc64/processor.h:#define FAULT_CODE_DTLB		0x02	/* Miss happened in D-TLB		*/
asm-sparc64/processor.h:#define FAULT_CODE_ITLB		0x04	/* Miss happened in I-TLB		*/
asm-sparc64/processor.h:	if (t->ksp) {
asm-sparc64/processor.h:		sp = (unsigned long *)(t->ksp + STACK_BIAS);
asm-sparc64/processor.h:		if (((unsigned long)sp & (sizeof(long) - 1)) == 0UL &&
asm-sparc64/processor.h:			if (((unsigned long)fp & (sizeof(long) - 1)) == 0UL)
asm-sparc64/processor.h:	regs->tstate = (regs->tstate & (TSTATE_CWP)) | (TSTATE_INITIAL_MM|TSTATE_IE) | (ASI_PNF << 24); \
asm-sparc64/processor.h:	regs->tpc = ((pc & (~3)) - 4); \
asm-sparc64/processor.h:	regs->tnpc = regs->tpc + 4; \
asm-sparc64/processor.h:	regs->y = 0; \
asm-sparc64/processor.h:	current->thread.wstate = (1 << 3); \
asm-sparc64/processor.h:	if (current->thread.utraps) { \
asm-sparc64/processor.h:		if (*(current->thread.utraps) < 2) \
asm-sparc64/processor.h:			kfree (current->thread.utraps); \
asm-sparc64/processor.h:			(*(current->thread.utraps))--; \
asm-sparc64/processor.h:		current->thread.utraps = NULL; \
asm-sparc64/processor.h:	: "r" (regs), "r" (sp - sizeof(struct reg_window) - STACK_BIAS), \
asm-sparc64/processor.h:	  "i" ((const unsigned long)(&((struct pt_regs *)0)->u_regs[0]))); \
asm-sparc64/processor.h:	regs->tstate = (regs->tstate & (TSTATE_CWP))|(TSTATE_INITIAL_MM|TSTATE_IE|TSTATE_AM); \
asm-sparc64/processor.h:	regs->tpc = ((pc & (~3)) - 4); \
asm-sparc64/processor.h:	regs->tnpc = regs->tpc + 4; \
asm-sparc64/processor.h:	regs->y = 0; \
asm-sparc64/processor.h:	current->thread.wstate = (2 << 3); \
asm-sparc64/processor.h:	if (current->thread.utraps) { \
asm-sparc64/processor.h:		if (*(current->thread.utraps) < 2) \
asm-sparc64/processor.h:			kfree (current->thread.utraps); \
asm-sparc64/processor.h:			(*(current->thread.utraps))--; \
asm-sparc64/processor.h:		current->thread.utraps = NULL; \
asm-sparc64/processor.h:	: "r" (regs), "r" (sp - sizeof(struct reg_window32)), \
asm-sparc64/processor.h:	  "i" ((const unsigned long)(&((struct pt_regs *)0)->u_regs[0]))); \
asm-sparc64/processor.h:            (__TSK)->state == TASK_RUNNING) \
asm-sparc64/processor.h:	fp = (__TSK)->thread.ksp + bias; \
asm-sparc64/processor.h:		pc = rw->ins[7]; \
asm-sparc64/processor.h:		fp = rw->ins[6] + bias; \
asm-sparc64/processor.h:#define KSTK_EIP(tsk)  ((tsk)->thread.kregs->tpc)
asm-sparc64/processor.h:#define KSTK_ESP(tsk)  ((tsk)->thread.kregs->u_regs[UREG_FP])
asm-sparc64/processor.h:#define get_task_struct(tsk)      atomic_inc(&virt_to_page(tsk)->count)
asm-sparc64/linux_logo.h: * include/asm-sparc64/linux_logo.h: This is a linux logo
asm-sparc64/mmu_context.h: * This just needs to set mm->context to an invalid context.
asm-sparc64/mmu_context.h:#define init_new_context(__tsk, __mm)	(((__mm)->context = 0UL), 0)
asm-sparc64/mmu_context.h: * any remaining processor-specific state, and in the sparc64
asm-sparc64/mmu_context.h:	if (CTX_VALID((__mm)->context)) {			\
asm-sparc64/mmu_context.h:		unsigned long nr = CTX_HWBITS((__mm)->context);	\
asm-sparc64/mmu_context.h: * 1) The physical address of mm->pgd, when full page
asm-sparc64/mmu_context.h: * 2) A "PGD cache".  For 32-bit tasks only pgd[0] is
asm-sparc64/mmu_context.h:	paddr = __pa((__mm)->pgd); \
asm-sparc64/mmu_context.h:	if ((__tsk)->thread.flags & SPARC_FLAG_32BIT) \
asm-sparc64/mmu_context.h:		   ((unsigned long)pgd_val((__mm)->pgd[0])) << 11UL; \
asm-sparc64/mmu_context.h:			     : "r" (CTX_HWBITS((__mm)->context)), \
asm-sparc64/mmu_context.h:	spin_lock(&mm->page_table_lock);
asm-sparc64/mmu_context.h:	if (CTX_VALID(mm->context))
asm-sparc64/mmu_context.h:		 * and lazy tlb switches work. -DaveM
asm-sparc64/mmu_context.h:		if (!ctx_valid || !(mm->cpu_vm_mask & vm_mask)) {
asm-sparc64/mmu_context.h:			mm->cpu_vm_mask |= vm_mask;
asm-sparc64/mmu_context.h:			__flush_tlb_mm(CTX_HWBITS(mm->context), SECONDARY_CONTEXT);
asm-sparc64/mmu_context.h:	spin_unlock(&mm->page_table_lock);
asm-sparc64/mmu_context.h:	spin_lock(&mm->page_table_lock);
asm-sparc64/mmu_context.h:	if (!CTX_VALID(mm->context))
asm-sparc64/mmu_context.h:	if (!(mm->cpu_vm_mask & vm_mask))
asm-sparc64/mmu_context.h:		mm->cpu_vm_mask |= vm_mask;
asm-sparc64/mmu_context.h:	spin_unlock(&mm->page_table_lock);
asm-sparc64/mmu_context.h:	__flush_tlb_mm(CTX_HWBITS(mm->context), SECONDARY_CONTEXT);
asm-sparc64/semaphore.h: * See asm-ppc/semaphore.h for implementation commentary,
asm-sparc64/semaphore.h:	atomic_set(&sem->count, val);
asm-sparc64/semaphore.h:	init_waitqueue_head(&sem->wait);
asm-sparc64/semaphore.h:	 * 	old_val = sem->count;
asm-sparc64/semaphore.h:	 *	new_val = sem->count - 1;
asm-sparc64/semaphore.h:	 *	sem->count = new_val;
asm-sparc64/semaphore.h:"	save	%%sp, -160, %%sp\n"
asm-sparc64/semaphore.h:	 * 	old_val = sem->count;
asm-sparc64/semaphore.h:	 *	new_val = sem->count - 1;
asm-sparc64/semaphore.h:	 *	sem->count = new_val;
asm-sparc64/semaphore.h:"	save	%%sp, -160, %%sp\n"
asm-sparc64/semaphore.h:	 * 	old_val = sem->count;
asm-sparc64/semaphore.h:	 *	new_val = sem->count - 1;
asm-sparc64/semaphore.h:	 *		sem->count = new_val;
asm-sparc64/semaphore.h:	 * 	old_val = sem->count;
asm-sparc64/semaphore.h:	 *	new_val = sem->count + 1;
asm-sparc64/semaphore.h:	 *	sem->count = new_val;
asm-sparc64/semaphore.h:"	save	%%sp, -160, %%sp\n"
asm-sparc64/semaphore.h:	return atomic_read(&sem->count);
asm-sparc64/perfctr.h:/*----------------------------------------
asm-sparc64/perfctr.h:  ---------------------------------------*/
asm-sparc64/perfctr.h: * Pointers which are passed by the user are pointers to 64-bit
asm-sparc64/perfctr.h:	 * to 64-bit accumulator for D0 counter in PIC, ARG1 is pointer
asm-sparc64/perfctr.h:	 * to 64-bit accumulator for D1 counter.  ARG2 is a pointer to
asm-sparc64/perfctr.h: * stuff when this file is included.  --DaveM
asm-sparc64/perfctr.h:/* Pic.S0 Selection Bit Field Encoding, Ultra-I/II  */
asm-sparc64/perfctr.h:/* Pic.S0 Selection Bit Field Encoding, Ultra-III  */
asm-sparc64/perfctr.h:/* Pic.S1 Selection Bit Field Encoding, Ultra-I/II  */
asm-sparc64/perfctr.h:/* Pic.S1 Selection Bit Field Encoding, Ultra-III  */
asm-sparc64/fcntl.h:/* open/fcntl - O_SYNC is only implemented on blocks devices and on files
asm-sparc64/fcntl.h:#define F_GETFL		3	/* get file->f_flags */
asm-sparc64/fcntl.h:#define F_SETFL		4	/* set file->f_flags */
asm-sparc64/estate.h:/* UltraSPARC-III E-cache Error Enable */
asm-sparc64/estate.h:/* UCEEN enables the fast_ECC_error trap for: 1) software correctable E-cache
asm-sparc64/estate.h: * errors 2) uncorrectable E-cache errors.  Such events only occur on reads
asm-sparc64/estate.h: * of the E-cache by the local processor for: 1) data loads 2) instruction
asm-sparc64/rwsem.h: * Derived from asm-i386/rwsem.h
asm-sparc64/rwsem.h:	sem->count = RWSEM_UNLOCKED_VALUE;
asm-sparc64/rwsem.h:	spin_lock_init(&sem->wait_lock);
asm-sparc64/rwsem.h:	INIT_LIST_HEAD(&sem->wait_list);
asm-sparc64/rwsem.h:		"save		%%sp, -160, %%sp\n\t"
asm-sparc64/rwsem.h:		"save		%%sp, -160, %%sp\n\t"
asm-sparc64/rwsem.h:		"save		%%sp, -160, %%sp\n\t"
asm-sparc64/rwsem.h:		"save		%%sp, -160, %%sp\n\t"
asm-sparc64/rwsem.h:	u32 old = (sem->count & 0xffff0000) | (u32) __old;
asm-sparc64/rwsem.h:	 * if only the upper 16-bits changed.
asm-sparc64/rwsem.h:	return cmpxchg(&sem->count,old,new);
asm-sparc64/audioio.h: * include/asm-sparc/audioio.h
asm-sparc64/audioio.h:	unsigned int precision;	/* bit-width of each sample */
asm-sparc64/audioio.h:	unsigned int gain;		/* gain level: 0 - 255 */
asm-sparc64/audioio.h:	unsigned char	pause;		/* non-zero for pause, zero to resume */
asm-sparc64/audioio.h:	unsigned char	error;		/* non-zero if overflow/underflow */
asm-sparc64/audioio.h:	unsigned char	waiting;	/* non-zero if a process wants access */
asm-sparc64/audioio.h:	 * The following values are read-only state flags
asm-sparc64/audioio.h:	unsigned char open;		/* non-zero if open access permitted */
asm-sparc64/audioio.h:	unsigned char active;		/* non-zero if I/O is active */
asm-sparc64/audioio.h:	 * Per-stream information
asm-sparc64/audioio.h:	 * Per-unit/channel information
asm-sparc64/audioio.h:	unsigned int monitor_gain;	/* input to output mix: 0 - 255 */
asm-sparc64/audioio.h:	unsigned char output_muted;	/* non-zero if output is muted */
asm-sparc64/audioio.h:#define	AUDIO_ENCODING_ULAW	(1)	/* u-law encoding	  */
asm-sparc64/audioio.h:#define	AUDIO_ENCODING_ALAW	(2)	/* A-law encoding	  */
asm-sparc64/audioio.h:#define AUDIO_ENCODING_FLOAT    (4)     /* IEEE float (-1. <-> +1.) */
asm-sparc64/audioio.h:#define	AUDIO_SPEAKER		0x01	/* output to built-in speaker */
asm-sparc64/audioio.h:#define	AUDIO_CD		0x04	/* input from on-board CD inputs */
asm-sparc64/audioio.h: * values are not set to the initialized value (-1) to the device state.
asm-sparc64/audioio.h: * device-dependent -- see the device specific manual pages for details.
asm-sparc64/audioio.h: * old SunOS-style AUDIO_GETDEV ioctl */
asm-sparc64/audioio.h:        /* Get and set the output volume. (0-255) */
asm-sparc64/audioio.h:        /* Get and set the input volume. (0-255) */
asm-sparc64/audioio.h:        /* Get and set the monitor volume. (0-255) */
asm-sparc64/audioio.h:        /* Get and set the output balance. (0-64) */
asm-sparc64/audioio.h:        /* Get and set the input balance. (0-64) */
asm-sparc64/audioio.h:        /* Get and set the output channels. (1-4) */
asm-sparc64/audioio.h:        /* Get and set the input channels. (1-4) */
asm-sparc64/audioio.h:        /* Get and set the output precision. (8-32) */
asm-sparc64/audioio.h:        /* Get and set the input precision. (8-32) */
asm-sparc64/audioio.h:    return ((OSS_TO_GAIN(value) - OSS_TO_LGAIN(value)) >> AUDIO_BALANCE_SHIFT)
asm-sparc64/audioio.h:    return AUDIO_MID_BALANCE - ((OSS_TO_GAIN(value) - OSS_TO_LGAIN(value)) 
asm-sparc64/audioio.h:    adj = ((AUDIO_MID_BALANCE - balance) << AUDIO_BALANCE_SHIFT);
asm-sparc64/audioio.h:      r = (int)(value - adj)
asm-sparc64/audioio.h:    adj = ((balance - AUDIO_MID_BALANCE) << AUDIO_BALANCE_SHIFT);
asm-sparc64/audioio.h:      l = (int)(value - adj)
asm-sparc64/audioio.h:  if (drv->ops->get_output_port) {
asm-sparc64/audioio.h:    p = drv->ops->get_output_port(drv);
asm-sparc64/audioio.h:  if (drv->ops->get_input_port) {
asm-sparc64/audioio.h:    p = drv->ops->get_input_port(drv);
asm-sparc64/audioio.h:    if (drv->ops->get_output_port && drv->ops->set_output_port) {
asm-sparc64/audioio.h:      p = drv->ops->get_output_port(drv);
asm-sparc64/audioio.h:	drv->ops->set_output_port(drv, p & ~(set));
asm-sparc64/audioio.h:	drv->ops->set_output_port(drv, p | set);
asm-sparc64/audioio.h:    if (drv->ops->get_input_port && drv->ops->set_input_port) {
asm-sparc64/audioio.h:      p = drv->ops->get_input_port(drv);
asm-sparc64/audioio.h:	drv->ops->set_input_port(drv, p & ~(set));
asm-sparc64/audioio.h:	drv->ops->set_input_port(drv, p | set);
asm-sparc64/spinlock.h:/* spinlock.h: 64-bit Sparc spinlock support.
asm-sparc64/spinlock.h: * in the non-contention case, we need to be extra careful about
asm-sparc64/spinlock.h: * than the traditional 32-bit sparc branch variants.  The rule
asm-sparc64/spinlock.h: * must be pre-V9 branches.
asm-sparc64/spinlock.h:do {	(__lock)->lock = 0; \
asm-sparc64/spinlock.h:	(__lock)->owner_pc = 0; \
asm-sparc64/spinlock.h:	(__lock)->owner_cpu = 0xff; \
asm-sparc64/spinlock.h:#define spin_is_locked(__lock)	(*((volatile unsigned char *)(&((__lock)->lock))) != 0)
asm-sparc64/spinlock.h:} while(*((volatile unsigned char *)(&((__lock)->lock))))
asm-sparc64/spinlock.h:/* Multi-reader locks, these are much saner than the 32-bit Sparc ones... */
asm-sparc64/openpromio.h:#define OPROMSETCUR		0x20004FF0	/* int node - Sets current node */
asm-sparc64/openpromio.h:#define OPROMPCI2NODE		0x20004FF1	/* int pci_bus, pci_devfn - Sets current node to PCI device's node */
asm-sparc64/openpromio.h:#define OPROMPATH2NODE		0x20004FF2	/* char path[] - Set current node from fully qualified PROM path */
asm-sparc64/openpromio.h:	int	op_nodeid;		/* PROM Node ID (value-result) */
asm-sparc64/openpromio.h:	int	op_buflen;		/* Length of op_buf (value-result) */
asm-sparc64/errno.h:#define	EXDEV		18	/* Cross-device link */
asm-sparc64/errno.h:#define	EROFS		30	/* Read-only file system */
asm-sparc64/errno.h:#define	ENOTSOCK	38	/* Socket operation on non-socket */
asm-sparc64/ns87303.h:		return -EINVAL;
asm-sparc64/softirq.h:/* softirq.h: 64-bit Sparc soft IRQ support.
asm-sparc64/softirq.h:#define __local_bh_enable()	(local_bh_count(smp_processor_id())--)
asm-sparc64/softirq.h:do { if (!--local_bh_count(smp_processor_id()) && \
asm-sparc64/timer.h: * 'counter-timer'.  The first of three 'reg' properties describe where
asm-sparc64/timex.h: * linux/include/asm-sparc64/timex.h
asm-sparc64/timex.h:#define FINETUNE ((((((long)LATCH * HZ - CLOCK_TICK_RATE) << SHIFT_HZ) * \
asm-sparc64/timex.h:		<< (SHIFT_SCALE-SHIFT_HZ)) / HZ)
asm-sparc64/timex.h:#define get_cycles()	tick_ops->get_tick()
asm-sparc64/bugs.h: *  include/asm-sparc64/bugs.h:  Sparc probes for various bugs.
asm-sparc64/namei.h: * linux/include/asm-sparc64/namei.h
asm-sparc64/namei.h:	switch (current->personality) {
asm-sparc64/termbits.h:#define SIZEOF_USER_TERMIOS sizeof (struct termios) - (2*sizeof (cc_t))
asm-sparc64/ebus.h:        for((bus) = ebus_chain; (bus); (bus) = (bus)->next)
asm-sparc64/ebus.h:        for((dev) = (bus)->devices; (dev); (dev) = (dev)->next)
asm-sparc64/ebus.h:        for((child) = (dev)->children; (child); (child) = (child)->next)
asm-sparc64/fbio.h:#define FBTYPE_NOTYPE           -1
asm-sparc64/fbio.h:        int     emu_type;	/* -1 if none */
asm-sparc64/fbio.h:#define CG14_XLUT        0x3000  /* X Look Up Table -- ??? */
asm-sparc64/idprom.h:/* MicroSPARC(-II) does not decode 31rd bit, but it works. */
asm-sparc64/idprom.h:	u8		id_cksum;	/* Checksum - xor of the data bytes */
asm-sparc64/mostek.h: *   7ff  -     -     -     -    -     -     -     -       Year 00-99
asm-sparc64/mostek.h: *   7fe  0     0     0     -    -     -     -     -      Month 01-12
asm-sparc64/mostek.h: *   7fd  0     0     -     -    -     -     -     -       Date 01-31
asm-sparc64/mostek.h: *   7fc  0     FT    0     0    0     -     -     -        Day 01-07
asm-sparc64/mostek.h: *   7fb  KS    0     -     -    -     -     -     -      Hours 00-23
asm-sparc64/mostek.h: *   7fa  0     -     -     -    -     -     -     -    Minutes 00-59
asm-sparc64/mostek.h: *   7f9  ST    -     -     -    -     -     -     -    Seconds 00-59
asm-sparc64/mostek.h: *   7f8  W     R     S     -    -     -     -     -    Control
asm-sparc64/mostek.h: * We now deal with physical addresses for I/O to the chip. -DaveM
asm-sparc64/init.h:#error "<asm/init.h> should never be used - use <linux/init.h> instead"
asm-sparc64/uaccess.h: * "For historical reasons, these macros are grossly misnamed." -Linus
asm-sparc64/uaccess.h:#define get_fs() (current->thread.current_ds)
asm-sparc64/uaccess.h:	current->thread.current_ds = (val);					\
asm-sparc64/uaccess.h: * (faulting_insn_address - first_insn_in_the_range_address)/4
asm-sparc64/uaccess.h:/* Uh, these should become the main single-value transfer routines..
asm-sparc64/uaccess.h:	 "i" (-EFAULT))
asm-sparc64/uaccess.h:if (__builtin_constant_p(ret) && ret == -EFAULT)			\
asm-sparc64/uaccess.h:	 "i" (-EFAULT))
asm-sparc64/uaccess.h:if (__builtin_constant_p(retval) && retval == -EFAULT)			\
asm-sparc64/bsderrno.h:#define BSD_EXDEV         18     /* Cross-device link */
asm-sparc64/bsderrno.h:#define BSD_EROFS         30     /* Read-only file system */
asm-sparc64/bsderrno.h:#define BSD_ENOTSOCK      38     /* Socket operation on non-socket */
asm-sparc64/mman.h:#define MAP_GROWSDOWN	0x0200		/* stack-like segment */
asm-sparc64/mman.h:#define MADV_NORMAL	0x0		/* default page-in behavior */
asm-sparc64/mman.h:#define MADV_RANDOM	0x1		/* page-in minimum required */
asm-sparc64/mman.h:#define MADV_SEQUENTIAL	0x2		/* read-ahead aggressively */
asm-sparc64/mman.h:#define MADV_WILLNEED	0x3		/* pre-fault pages */
asm-sparc64/posix_types.h: * This file is generally used by user-level software, so you need to
asm-sparc64/posix_types.h:	fdsetp->fds_bits[_tmp] |= (1UL<<_rem);
asm-sparc64/posix_types.h:	fdsetp->fds_bits[_tmp] &= ~(1UL<<_rem);
asm-sparc64/posix_types.h:	return (p->fds_bits[_tmp] & (1UL<<_rem)) != 0;
asm-sparc64/posix_types.h: * for 256 and 1024-bit fd_sets respectively)
asm-sparc64/posix_types.h:	unsigned long *tmp = p->fds_bits;
asm-sparc64/posix_types.h:		i--;
asm-sparc64/scatterlist.h:#define sg_dma_address(sg)	((sg)->dma_address)
asm-sparc64/scatterlist.h:#define sg_dma_len(sg)     	((sg)->dma_length)
asm-sparc64/smplock.h:	 (current->lock_depth >= 0))
asm-sparc64/smplock.h:	if (task->lock_depth >= 0) \
asm-sparc64/smplock.h: * Re-acquire the kernel lock
asm-sparc64/smplock.h:	if (task->lock_depth >= 0) \
asm-sparc64/smplock.h:	if (!++current->lock_depth) \
asm-sparc64/smplock.h:	if (--current->lock_depth < 0) \
asm-sparc64/page.h:/* I have my suspicions... -DaveM */
asm-sparc64/page.h:#define PAGE_MASK    (~(PAGE_SIZE-1))
asm-sparc64/page.h: * and thus on the stack, turn this crap off... -DaveM
asm-sparc64/page.h:/* These are used to make use of C type-checking.. */
asm-sparc64/page.h:#define TASK_UNMAPPED_BASE	((current->thread.flags & SPARC_FLAG_32BIT) ? \
asm-sparc64/page.h:#define PAGE_ALIGN(addr)	(((addr)+PAGE_SIZE-1)&PAGE_MASK)
asm-sparc64/page.h:#define __pa(x)			((unsigned long)(x) - PAGE_OFFSET)
asm-sparc64/page.h:#define virt_to_page(kaddr)	(mem_map + ((__pa(kaddr)-phys_base) >> PAGE_SHIFT))
asm-sparc64/page.h:#define VALID_PAGE(page)	((page - mem_map) < max_mapnr)
asm-sparc64/page.h:	size = (size-1) >> (PAGE_SHIFT-1);
asm-sparc64/page.h:	order = -1;
asm-sparc64/types.h: * application is Linux specific so (user-) name space pollution is
asm-sparc64/types.h:/* Dma addresses come in generic and 64-bit flavours.  */
asm-sparc64/sbus.h:  return (int) (((dev_addr)-SUN_SBUS_BVADDR)>>28);
asm-sparc64/sbus.h:        for((bus) = sbus_root; (bus); (bus)=(bus)->next)
asm-sparc64/sbus.h:        for((device) = (bus)->devices; (device); (device)=(device)->next)
asm-sparc64/sbus.h:	for ((bus) = sbus_root; (bus); (bus) = (bus)->next) \
asm-sparc64/sbus.h:		for ((device) = (bus)->devices; (device); (device) = (device)->next)
asm-sparc64/sembuf.h: * - 2 miscellaneous 64-bit values
asm-sparc64/system.h:if ((PREV)->thread.smp_lock_count) {					\
asm-sparc64/system.h:	       (PREV)->comm, (PREV)->pid,				\
asm-sparc64/system.h:	       (PREV)->thread.smp_lock_count);				\
asm-sparc64/system.h:	       (PREV)->comm, (PREV)->pid,				\
asm-sparc64/system.h:	       (PREV)->thread.smp_lock_pc);				\
asm-sparc64/system.h:	       (PREV)->comm, (PREV)->pid, rpc);				\
asm-sparc64/system.h:	 * We tell gcc we clobber all non-fixed-usage registers except
asm-sparc64/system.h:	 * and 2 stores in this critical code path.  -DaveM
asm-sparc64/system.h:	if (current->thread.flags & SPARC_FLAG_PERFCTR) {			\
asm-sparc64/system.h:		current->thread.pcr_reg = __tmp;				\
asm-sparc64/system.h:		current->thread.kernel_cntd0 += (unsigned int)(__tmp);		\
asm-sparc64/system.h:		current->thread.kernel_cntd1 += ((__tmp) >> 32);		\
asm-sparc64/system.h:			     : : "r" (next->thread.current_ds.seg));		\
asm-sparc64/system.h:	  "i" ((const unsigned long)(&((struct task_struct *)0)->thread.wstate)),\
asm-sparc64/system.h:	  "i" ((const unsigned long)(&((struct task_struct *)0)->thread.ksp)),	\
asm-sparc64/system.h:	  "i" ((const unsigned long)(&((struct task_struct *)0)->thread.flags)),\
asm-sparc64/system.h:	  "i" ((const unsigned long)(&((struct task_struct *)0)->thread.cwp)),	\
asm-sparc64/system.h:	if (current->thread.flags & SPARC_FLAG_PERFCTR) {			\
asm-sparc64/system.h:		write_pcr(current->thread.pcr_reg);				\
asm-sparc64/svr4.h:/* Solaris/SPARC constants and definitions -- 
asm-sparc64/svr4.h: * ucontext->mcontext holds a pointer to them.
asm-sparc64/checksum.h: *	Alpha checksum c-code
asm-sparc64/checksum.h: * and adds in "sum" (32-bit)
asm-sparc64/checksum.h: * returns a 32-bit number suitable for feeding into itself
asm-sparc64/checksum.h: * it's best to have buff aligned on a 32-bit boundary
asm-sparc64/checksum.h: * here even more important to align src and dst on a 32-bit (or even
asm-sparc64/checksum.h: * better 64-bit) boundary
asm-sparc64/checksum.h:	unsigned char cur_ds = current->thread.current_ds.seg;
asm-sparc64/checksum.h: * computes the checksum of the TCP/UDP pseudo-header
asm-sparc64/checksum.h: * returns a 16-bit checksum, already complemented
asm-sparc64/checksum.h:/* this routine is used for miscellaneous IP-like checksums, mainly in icmp.c */
asm-sparc64/termios.h:#define N_IRDA		11	/* Linux IrDa - http://irda.sourceforge.net/ */
asm-sparc64/termios.h:#define N_SMSBLOCK	12	/* SMS block mode - for talking to GSM data cards about SMS messages */
asm-sparc64/termios.h:	get_user(tmp, &(termio)->c_iflag); \
asm-sparc64/termios.h:	(termios)->c_iflag = (0xffff0000 & ((termios)->c_iflag)) | tmp; \
asm-sparc64/termios.h:	get_user(tmp, &(termio)->c_oflag); \
asm-sparc64/termios.h:	(termios)->c_oflag = (0xffff0000 & ((termios)->c_oflag)) | tmp; \
asm-sparc64/termios.h:	get_user(tmp, &(termio)->c_cflag); \
asm-sparc64/termios.h:	(termios)->c_cflag = (0xffff0000 & ((termios)->c_cflag)) | tmp; \
asm-sparc64/termios.h:	get_user(tmp, &(termio)->c_lflag); \
asm-sparc64/termios.h:	(termios)->c_lflag = (0xffff0000 & ((termios)->c_lflag)) | tmp; \
asm-sparc64/termios.h:	copy_from_user((termios)->c_cc, (termio)->c_cc, NCC); \
asm-sparc64/termios.h:	put_user((termios)->c_iflag, &(termio)->c_iflag); \
asm-sparc64/termios.h:	put_user((termios)->c_oflag, &(termio)->c_oflag); \
asm-sparc64/termios.h:	put_user((termios)->c_cflag, &(termio)->c_cflag); \
asm-sparc64/termios.h:	put_user((termios)->c_lflag, &(termio)->c_lflag); \
asm-sparc64/termios.h:	put_user((termios)->c_line,  &(termio)->c_line); \
asm-sparc64/termios.h:	copy_to_user((termio)->c_cc, (termios)->c_cc, NCC); \
asm-sparc64/termios.h:	if (!((termios)->c_lflag & ICANON)) { \
asm-sparc64/termios.h:		put_user((termios)->c_cc[VMIN], &(termio)->c_cc[_VMIN]); \
asm-sparc64/termios.h:		put_user((termios)->c_cc[VTIME], &(termio)->c_cc[_VTIME]); \
asm-sparc64/termios.h:	get_user((k)->c_iflag, &(u)->c_iflag); \
asm-sparc64/termios.h:	get_user((k)->c_oflag, &(u)->c_oflag); \
asm-sparc64/termios.h:	get_user((k)->c_cflag, &(u)->c_cflag); \
asm-sparc64/termios.h:	get_user((k)->c_lflag, &(u)->c_lflag); \
asm-sparc64/termios.h:	get_user((k)->c_line,  &(u)->c_line); \
asm-sparc64/termios.h:	copy_from_user((k)->c_cc, (u)->c_cc, NCCS); \
asm-sparc64/termios.h:	if((k)->c_lflag & ICANON) { \
asm-sparc64/termios.h:		get_user((k)->c_cc[VEOF], &(u)->c_cc[VEOF]); \
asm-sparc64/termios.h:		get_user((k)->c_cc[VEOL], &(u)->c_cc[VEOL]); \
asm-sparc64/termios.h:		get_user((k)->c_cc[VMIN],  &(u)->c_cc[_VMIN]); \
asm-sparc64/termios.h:		get_user((k)->c_cc[VTIME], &(u)->c_cc[_VTIME]); \
asm-sparc64/termios.h:	put_user((k)->c_iflag, &(u)->c_iflag); \
asm-sparc64/termios.h:	put_user((k)->c_oflag, &(u)->c_oflag); \
asm-sparc64/termios.h:	put_user((k)->c_cflag, &(u)->c_cflag); \
asm-sparc64/termios.h:	put_user((k)->c_lflag, &(u)->c_lflag); \
asm-sparc64/termios.h:	put_user((k)->c_line, &(u)->c_line); \
asm-sparc64/termios.h:	copy_to_user((u)->c_cc, (k)->c_cc, NCCS); \
asm-sparc64/termios.h:	if(!((k)->c_lflag & ICANON)) { \
asm-sparc64/termios.h:		put_user((k)->c_cc[VMIN],  &(u)->c_cc[_VMIN]); \
asm-sparc64/termios.h:		put_user((k)->c_cc[VTIME], &(u)->c_cc[_VTIME]); \
asm-sparc64/termios.h:		put_user((k)->c_cc[VEOF], &(u)->c_cc[VEOF]); \
asm-sparc64/termios.h:		put_user((k)->c_cc[VEOL], &(u)->c_cc[VEOL]); \
asm-sparc64/user.h: * asm-sparc64/user.h: Core file definitions for the Sparc.
asm-sparc64/user.h: * one, since we won't a.out core dump that much anyways - miguel.
asm-sparc64/psrcompat.h:/* Old 32-bit PSR fields for the compatability conversion code. */
asm-sparc64/psrcompat.h:#define PSR_EC      0x00002000         /* enable co-processor        */
asm-sparc64/psrcompat.h:#define PSR_LE      0x00008000         /* SuperSparcII little-endian */
asm-sparc64/psrcompat.h:#define PSR_VERS    0x0f000000         /* cpu-version field          */
asm-sparc64/psrcompat.h:#define PSR_IMPL    0xf0000000         /* cpu-implementation field   */
asm-sparc64/pgtable.h:/* The kernel image occupies 0x4000000 to 0x1000000 (4MB --> 16MB).
asm-sparc64/pgtable.h: * The page copy blockops use 0x1000000 to 0x18000000 (16MB --> 24MB).
asm-sparc64/pgtable.h: * XXX cheetah's full 64-bit virtual address space, ie. no more hole
asm-sparc64/pgtable.h: * XXX in the middle like on spitfire. -DaveM
asm-sparc64/pgtable.h: * into the page; the next higher PAGE_SHIFT-3 bits determine the pte#
asm-sparc64/pgtable.h: * in the proper pagetable (the -3 is from the 8 byte ptes, and each page
asm-sparc64/pgtable.h: * in the proper pmdtable (where we must have PMD_BITS <= (PAGE_SHIFT-2) 
asm-sparc64/pgtable.h:/* PMD_SHIFT determines the size of the area a second-level page table can map */
asm-sparc64/pgtable.h:#define PMD_SHIFT	(PAGE_SHIFT + (PAGE_SHIFT-3))
asm-sparc64/pgtable.h:#define PMD_MASK	(~(PMD_SIZE-1))
asm-sparc64/pgtable.h:/* PGDIR_SHIFT determines what a third-level page table entry can map */
asm-sparc64/pgtable.h:#define PGDIR_SHIFT	(PAGE_SHIFT + (PAGE_SHIFT-3) + PMD_BITS)
asm-sparc64/pgtable.h:#define PGDIR_MASK	(~(PGDIR_SIZE-1))
asm-sparc64/pgtable.h:#define PTRS_PER_PTE		(1UL << (PAGE_SHIFT-3))
asm-sparc64/pgtable.h: * is different so we can optimize correctly for 32-bit tasks.
asm-sparc64/pgtable.h:#define PTRS_PER_PMD		((const int)((current->thread.flags & SPARC_FLAG_32BIT) ? \
asm-sparc64/pgtable.h:				 (1UL << (32 - (PAGE_SHIFT-3) - PAGE_SHIFT)) : (REAL_PTRS_PER_PMD)))
asm-sparc64/pgtable.h:#define PTRS_PER_PGD	(((1UL << VA_BITS) - VPTE_SIZE + (1UL << (PAGE_SHIFT + \
asm-sparc64/pgtable.h:			(PAGE_SHIFT-3) + PMD_BITS)) - 1) / (1UL << (PAGE_SHIFT + \
asm-sparc64/pgtable.h:			(PAGE_SHIFT-3) + PMD_BITS)))
asm-sparc64/pgtable.h:#define USER_PTRS_PER_PGD	((const int)((current->thread.flags & SPARC_FLAG_32BIT) ? \
asm-sparc64/pgtable.h:#define _PAGE_CP	0x0000000000000020	/* Cacheable in P-Cache      */
asm-sparc64/pgtable.h:#define _PAGE_CV	0x0000000000000010	/* Cacheable in V-Cache      */
asm-sparc64/pgtable.h:#define _PAGE_E		0x0000000000000008	/* side-Effect               */
asm-sparc64/pgtable.h:	__pte((((page - mem_map) << PAGE_SHIFT)+phys_base) | pgprot_val(pgprot) | _PAGE_SZBITS)
asm-sparc64/pgtable.h:#define pte_page(x) (mem_map+(((pte_val(x)&_PAGE_PADDR)-phys_base)>>PAGE_SHIFT))
asm-sparc64/pgtable.h:/* to find an entry in a page-table-directory. */
asm-sparc64/pgtable.h:#define pgd_offset(mm, address)	((mm)->pgd + pgd_index(address))
asm-sparc64/pgtable.h:/* to find an entry in a kernel page-table-directory */
asm-sparc64/pgtable.h:/* Find an entry in the second-level page table.. */
asm-sparc64/pgtable.h:					((address >> PMD_SHIFT) & (REAL_PTRS_PER_PMD-1)))
asm-sparc64/pgtable.h:/* Find an entry in the third-level page table.. */
asm-sparc64/pgtable.h:					((address >> PAGE_SHIFT) & (PTRS_PER_PTE - 1)))
asm-sparc64/pgtable.h:/* Make a non-present pseudo-TTE. */
asm-sparc64/pgtable.h:/* Encode and de-code a swap entry */
asm-sparc64/pgtable.h:#include <asm-generic/pgtable.h>
asm-sparc64/utrap.h: * include/asm-sparc64/utrap.h
asm-sparc64/utrap.h:#define	UTH_NOCHANGE				(-1)
asm-sparc64/watchdog.h: * watchdog - Driver interface for the hardware watchdog timers
asm-sparc64/watchdog.h:/* Solaris compatibility ioctls--
asm-sparc64/param.h:#define NOGROUP		(-1)
asm-sparc64/oplib.h: * of the string is different on V0 vs. V2->higher proms.  The caller must
asm-sparc64/oplib.h: * These lists are returned pre-sorted, this should make your life easier
asm-sparc64/oplib.h:/* Enter the prom, with no chance of continuation for the stand-alone
asm-sparc64/oplib.h:/* Halt and power-off the machine. */
asm-sparc64/oplib.h:/* Non-blocking get character from console. */
asm-sparc64/oplib.h:/* Non-blocking put character to console. */
asm-sparc64/oplib.h:#define PROM_MAP_READ	0x0002 /* Readable - sw */
asm-sparc64/oplib.h:#define PROM_MAP_EXEC	0x0004 /* Executable - sw */
asm-sparc64/oplib.h:#define PROM_MAP_SE	0x0040 /* Side-Effects */
asm-sparc64/oplib.h:#define PROM_MAP_IE	0x0100 /* Invert-Endianness */
asm-sparc64/oplib.h: * Returns -1 on error (ie. no such property at this node).
asm-sparc64/oplib.h: * the number of bytes the prom put into your buffer or -1 on error.
asm-sparc64/auxio.h: * sbus-based NCR89C105 "Slavio"
asm-sparc64/auxio.h: * ebus-based auxio on PCIO 
asm-sparc64/auxio.h: * -------------------------------------------------
asm-sparc64/auxio.h: * -------------------------------------------------
asm-sparc64/auxio.h: * (R) - bit 7:6,4 are reserved and should be masked in s/w
asm-sparc64/auxio.h: *  D  - Floppy Density Sense (1=high density) R/O
asm-sparc64/auxio.h: *  E  - Link Test Enable, directly reflected on AT&T 7213 LTE pin
asm-sparc64/auxio.h: *  M  - Monitor/Mouse Mux, directly reflected on MON_MSE_MUX pin
asm-sparc64/auxio.h: *  T  - Terminal Count: sends TC pulse to 82077 floppy controller
asm-sparc64/auxio.h: *  L  - System LED on front panel (0=off, 1=on) 
asm-sparc64/auxio.h: * -------------------------------------------------
asm-sparc64/auxio.h: * -------------------------------------------------
asm-sparc64/auxio.h: * (R) - bits 7:6,4:2 are reserved and should be masked in s/w
asm-sparc64/auxio.h: *  D  - Power Failure Detect (1=power fail)
asm-sparc64/auxio.h: *  C  - Clear Power Failure Detect Int (1=clear)
asm-sparc64/auxio.h: *  F  - Power Off (1=power off)
asm-sparc64/auxio.h:/* Register definitions from Sun Microsystems _PCIO_ p/n 802-7837
asm-sparc64/auxio.h: * -------------------------------------------------
asm-sparc64/auxio.h: * -------------------------------------------------
asm-sparc64/auxio.h: * LED - System LED on front panel (0=off, 1=on)
asm-sparc64/auxio.h: * -------------------------------------------------
asm-sparc64/auxio.h: * -------------------------------------------------
asm-sparc64/auxio.h: * CPO - Courtesy Power Off (1=off)
asm-sparc64/auxio.h: * SPO - System Power Off   (1=off)
asm-sparc64/auxio.h:/* auxio_set_lte - Set Link Test Enable (TPE Link Detect)
asm-sparc64/auxio.h: * on - AUXIO_LTE_ON or AUXIO_LTE_OFF
asm-sparc64/auxio.h:/* auxio_set_led - Set system front panel LED 
asm-sparc64/auxio.h: * on - AUXIO_LED_ON or AUXIO_LED_OFF
asm-sparc64/cache.h: * include/asm-sparc64/cache.h
asm-sparc64/cache.h:#define        L1_CACHE_BYTES		32 /* Two 16-byte sub-blocks per line. */
asm-sparc64/cache.h:#define        L1_CACHE_ALIGN(x)       (((x)+(L1_CACHE_BYTES-1))&~(L1_CACHE_BYTES-1))
asm-sparc64/siginfo.h:#define SI_PAD_SIZE	((SI_MAX_SIZE/sizeof(int)) - 4)
asm-sparc64/siginfo.h:#define SI_PAD_SIZE32	((SI_MAX_SIZE/sizeof(int)) - 3)
asm-sparc64/siginfo.h: * Digital reserves positive values for kernel-generated signals.
asm-sparc64/siginfo.h:#define SI_QUEUE	-1		/* sent by sigqueue */
asm-sparc64/siginfo.h:#define SI_TIMER __SI_CODE(__SI_TIMER,-2) /* sent by timer expiration */
asm-sparc64/siginfo.h:#define SI_MESGQ	-3		/* sent by real time mesq state change */
asm-sparc64/siginfo.h:#define SI_ASYNCIO	-4		/* sent by AIO completion */
asm-sparc64/siginfo.h:#define SI_SIGIO	-5		/* sent by queued SIGIO */
asm-sparc64/siginfo.h:#define SI_TKILL	-6		/* sent by tkill system call */
asm-sparc64/siginfo.h:#define SI_FROMUSER(siptr)	((siptr)->si_code <= 0)
asm-sparc64/siginfo.h:#define SI_FROMKERNEL(siptr)	((siptr)->si_code > 0)
asm-sparc64/siginfo.h:#define BUS_ADRERR	(__SI_FAULT|2)	/* non-existant physical address */
asm-sparc64/siginfo.h:#define SIGEV_PAD_SIZE	((SIGEV_MAX_SIZE/sizeof(int)) - 4)
asm-sparc64/siginfo.h:#define SIGEV_PAD_SIZE32 ((SIGEV_MAX_SIZE/sizeof(int)) - 3)
asm-sparc64/siginfo.h:	if (from->si_code < 0)
asm-sparc64/siginfo.h:		memcpy(to, from, 4*sizeof(int) + sizeof(from->_sifields._sigchld));
asm-sparc64/floppy.h: * asm-sparc64/floppy.h: Sparc specific parts of the Floppy driver.
asm-sparc64/floppy.h:static struct sun_flpy_controller *sun_fdc = (struct sun_flpy_controller *)-1;
asm-sparc64/floppy.h:		return sbus_readb(&sun_fdc->status_82077) & ~STATUS_DMA;
asm-sparc64/floppy.h:		return sbus_readb(&sun_fdc->data_82077);
asm-sparc64/floppy.h:		return sbus_readb(&sun_fdc->dir_82077);
asm-sparc64/floppy.h:		sbus_writeb(value, &sun_fdc->dor_82077);
asm-sparc64/floppy.h:		sbus_writeb(value, &sun_fdc->data_82077);
asm-sparc64/floppy.h:		sbus_writeb(value, &sun_fdc->dcr_82077);
asm-sparc64/floppy.h:		sbus_writeb(value, &sun_fdc->status_82077);
asm-sparc64/floppy.h:/* For pseudo-dma (Sun floppy drives have no real DMA available to
asm-sparc64/floppy.h: * three state variables.  doing_pdma tells our inline low-level
asm-sparc64/floppy.h: * floppy interrupt c-code.  I tried very hard but I could not get the
asm-sparc64/floppy.h: * pseudo-dma to work in c-code without getting many overruns and
asm-sparc64/floppy.h: * underruns.  If non-zero, doing_pdma encodes the direction of
asm-sparc64/floppy.h:/* Our low-level entry point in arch/sparc/kernel/entry.S */
asm-sparc64/floppy.h:		return ((error == 0) ? 0 : -1);
asm-sparc64/floppy.h:static int sun_pci_broken_drive = -1;
asm-sparc64/floppy.h:static struct sun_pci_dma_op sun_pci_dma_current = { -1U, 0, 0, NULL};
asm-sparc64/floppy.h:static struct sun_pci_dma_op sun_pci_dma_pending = { -1U, 0, 0, NULL};
asm-sparc64/floppy.h:	writel(EBUS_DCSR_RESET, &sun_pci_fd_ebus_dma->dcsr);
asm-sparc64/floppy.h:	writel(dcsr, (unsigned long)&sun_pci_fd_ebus_dma->dcsr);
asm-sparc64/floppy.h:	sun_pci_dma_pending.addr = -1U;
asm-sparc64/floppy.h:	writel(sun_pci_dma_current.addr, &sun_pci_fd_ebus_dma->dacr);
asm-sparc64/floppy.h:	dcsr = readl(&sun_pci_fd_ebus_dma->dcsr);
asm-sparc64/floppy.h:	writel(dcsr, &sun_pci_fd_ebus_dma->dcsr);
asm-sparc64/floppy.h:	dcsr = readl(&sun_pci_fd_ebus_dma->dcsr);
asm-sparc64/floppy.h:			dcsr = readl(&sun_pci_fd_ebus_dma->dcsr);
asm-sparc64/floppy.h:		writel(dcsr, &sun_pci_fd_ebus_dma->dcsr);
asm-sparc64/floppy.h:			writel(dcsr, &sun_pci_fd_ebus_dma->dcsr);
asm-sparc64/floppy.h:	if (sun_pci_dma_current.addr != -1U)
asm-sparc64/floppy.h:	sun_pci_dma_current.addr = -1U;
asm-sparc64/floppy.h:	dcsr = readl(&sun_pci_fd_ebus_dma->dcsr);
asm-sparc64/floppy.h:	if (readl(&sun_pci_fd_ebus_dma->dbcr)) {
asm-sparc64/floppy.h:		writel(dcsr, &sun_pci_fd_ebus_dma->dcsr);
asm-sparc64/floppy.h:	writel(dcsr, &sun_pci_fd_ebus_dma->dcsr);
asm-sparc64/floppy.h:	writel(length, &sun_pci_fd_ebus_dma->dbcr);
asm-sparc64/floppy.h:	res = readl(&sun_pci_fd_ebus_dma->dbcr);
asm-sparc64/floppy.h:		dcsr = readl(&sun_pci_fd_ebus_dma->dcsr);
asm-sparc64/floppy.h:		writel(dcsr, &sun_pci_fd_ebus_dma->dcsr);
asm-sparc64/floppy.h:	dcsr = readl(&sun_pci_fd_ebus_dma->dcsr);
asm-sparc64/floppy.h:	writel(dcsr, &sun_pci_fd_ebus_dma->dcsr);
asm-sparc64/floppy.h:	dcsr = readl(&sun_pci_fd_ebus_dma->dcsr);
asm-sparc64/floppy.h:	writel(dcsr, &sun_pci_fd_ebus_dma->dcsr);
asm-sparc64/floppy.h:		return -1;
asm-sparc64/floppy.h:	return -EINVAL;
asm-sparc64/floppy.h:	while (!((status = inb(MSR)) & 0x80) && --timeout)
asm-sparc64/floppy.h:		while (!((status = inb(MSR)) & 0x80) && --timeout)
asm-sparc64/floppy.h:	} while ((mask != 0x0f) && --timeout);
asm-sparc64/floppy.h:	} while (((status & 0xc0) == 0x80) && --timeout);
asm-sparc64/floppy.h:	if (!strcmp(edev->prom_name, "fdthree"))
asm-sparc64/floppy.h:	if (!strcmp(edev->prom_name, "floppy")) {
asm-sparc64/floppy.h:		prom_getstring(edev->prom_node,
asm-sparc64/floppy.h:			if (!strcmp(isa_dev->prom_name, "dma")) {
asm-sparc64/floppy.h:				struct isa_device *child = isa_dev->child;
asm-sparc64/floppy.h:					if (!strcmp(child->prom_name, "floppy")) {
asm-sparc64/floppy.h:					child = child->next;
asm-sparc64/floppy.h:	sun_fdc = (struct sun_flpy_controller *)isa_dev->resource.start;
asm-sparc64/floppy.h:	FLOPPY_IRQ = isa_dev->irq;
asm-sparc64/floppy.h:        fdc_status = (unsigned long) &sun_fdc->status_82077;
asm-sparc64/floppy.h:		if (!strcmp(sdev->prom_name, "SUNW,fdtwo")) 
asm-sparc64/floppy.h:		FLOPPY_IRQ = sdev->irqs[0];
asm-sparc64/floppy.h:		prom_getproperty(edev->prom_node, "status",
asm-sparc64/floppy.h:		sun_fdc = (struct sun_flpy_controller *)edev->resource[0].start;
asm-sparc64/floppy.h:		FLOPPY_IRQ = edev->irqs[0];
asm-sparc64/floppy.h:		auxio_reg = edev->resource[2].start;
asm-sparc64/floppy.h:		sun_pci_ebus_dev = ebus->self;
asm-sparc64/floppy.h:			edev->resource[1].start;
asm-sparc64/floppy.h:        	fdc_status = (unsigned long) &sun_fdc->status_82077;
asm-sparc64/floppy.h:				if (!strcmp(edev->prom_name, "ecpp")) {
asm-sparc64/floppy.h:					config = edev->resource[1].start;
asm-sparc64/floppy.h:		/* Enable PC-AT mode. */
asm-sparc64/floppy.h:			if (sun_pci_broken_drive != -1) {
asm-sparc64/floppy.h:				sun_pci_broken_drive = 1 - sun_pci_broken_drive;
asm-sparc64/floppy.h:	prom_getproperty(sdev->prom_node, "status", state, sizeof(state));
asm-sparc64/floppy.h:		(sdev->resource[0].start +
asm-sparc64/floppy.h:		 ((sdev->resource[0].flags & 0x1ffUL) << 32UL));
asm-sparc64/floppy.h:	if(sbus_readb(&sun_fdc->status1_82077) == 0xff) {
asm-sparc64/floppy.h:		sun_fdc = (struct sun_flpy_controller *)-1;
asm-sparc64/floppy.h:        fdc_status = (unsigned long) &sun_fdc->status_82077;
asm-sparc64/sab82532.h:	u8	tsax;		/* Time-Slot Assignment Reg. Transmit	*/
asm-sparc64/sab82532.h:	u8	tsar;		/* Time-Slot Assignment Reg. Receive	*/
asm-sparc64/sockios.h:/* Socket-level I/O control calls. */
asm-sparc64/keyboard.h: * linux/include/asm-sparc64/keyboard.h
asm-sparc64/a.out.h:	RELOC_DISP32,	/* Disp's (pc-rel) */
asm-sparc64/a.out.h:	RELOC_22,	/* SR 22-bit relocs */
asm-sparc64/a.out.h:	RELOC_LO10,	/* SR 13&10-bit relocs */
asm-sparc64/a.out.h:	RELOC_PC22,	/* special pc-rel pic */
asm-sparc64/a.out.h:	RELOC_SEGOFF16,	/* ShLib offset-in-seg */
asm-sparc64/a.out.h:#define STACK_TOP (current->thread.flags & SPARC_FLAG_32BIT ? 0xf0000000 : 0x80000000000L)
asm-sparc64/ioctl.h: * a non-zero _IOC_NONE (for binary compatibility) and
asm-sparc64/ioctl.h:#define _IOC_NRMASK      ((1 << _IOC_NRBITS)-1)
asm-sparc64/ioctl.h:#define _IOC_TYPEMASK    ((1 << _IOC_TYPEBITS)-1)
asm-sparc64/ioctl.h:#define _IOC_SIZEMASK    ((1 << _IOC_SIZEBITS)-1)
asm-sparc64/ioctl.h:#define _IOC_XSIZEMASK   ((1 << (_IOC_SIZEBITS+1))-1)
asm-sparc64/ioctl.h:#define _IOC_DIRMASK     ((1 << _IOC_DIRBITS)-1)
asm-sparc64/envctrl.h: * VT - Add all ioctl commands and environment status definitions 
asm-sparc64/envctrl.h: * VT - Add application note 
asm-sparc64/iommu.h:#define IOPTE_INTRA         0x0800000000000000 /* SBUS slot-->slot direct transfer */
asm-sparc64/iommu.h:#define IOPTE_CACHE         0x0000000000000010 /* Cached (in UPA E-cache)          */
asm-sparc64/string.h:	case 1: return (src[0] - dest[0]);
asm-sparc64/string.h:	case 2: retval = (src[0] - dest[0]);
asm-sparc64/string.h:		  retval = (src[1] - dest[1]);
asm-sparc64/string.h:	case 3: retval = (src[0] - dest[0]);
asm-sparc64/string.h:		  retval = (src[1] - dest[1]);
asm-sparc64/string.h:		    retval = (src[2] - dest[2]);
asm-sparc64/string.h:	case 4: retval = (src[0] - dest[0]);
asm-sparc64/string.h:		  retval = (src[1] - dest[1]);
asm-sparc64/string.h:		    retval = (src[2] - dest[2]);
asm-sparc64/string.h:		      retval = (src[3] - dest[3]);
asm-sparc64/string.h:	case 5: retval = (src[0] - dest[0]);
asm-sparc64/string.h:		  retval = (src[1] - dest[1]);
asm-sparc64/string.h:		    retval = (src[2] - dest[2]);
asm-sparc64/string.h:		      retval = (src[3] - dest[3]);
asm-sparc64/string.h:		        retval = (src[4] - dest[4]);
asm-sparc64/string.h:		retval = (src[0] - dest[0]);
asm-sparc64/string.h:		  retval = (src[1] - dest[1]);
asm-sparc64/string.h:		    retval = (src[2] - dest[2]);
asm-sparc64/string.h:		      retval = __strncmp(src+3,dest+3,count-3);
asm-sparc64/ioctls.h:/* 118 is the non-posix setpgrp tty ioctl */
asm-sparc64/ioctls.h:/* 119 is the non-posix getpgrp tty ioctl */
asm-sparc64/ioctls.h:/* Get minor device of a pty master's FD -- Solaris equiv is ISPTM */
asm-sparc64/msgbuf.h: * - 2 miscellaneous 64-bit values
asm-sparc64/openprom.h:	/* Non-blocking variants. */
asm-sparc64/openprom.h:	/* Evaluate a forth string, not different proto for V0 and V2->up. */
asm-sparc64/openprom.h:	 * crashes the machine, have to test this. :-)
asm-sparc64/openprom.h:	/* v3_cpustart() will start the cpu 'whichcpu' in mmu-context
asm-sparc64/socket.h:/* Security levels - as per NRL IPv6 - don't actually do anything */
asm-sparc64/socket.h:/* Nast libc5 fixup - bletch */
asm-sparc64/socket.h:#define SOCK_RDM	4		/* reliably-delivered message	*/
asm-x86_64/apicdef.h: * tested, but we might eventually use this one in the future - the
asm-x86_64/apicdef.h: * errata which cannot take 8-bit reads and writes, only 32-bit ones ...
asm-x86_64/apicdef.h:/*320*/	struct { /* LVT - Timer */
asm-x86_64/apicdef.h:/*340*/	struct { /* LVT - Performance Counter */
asm-x86_64/apicdef.h:/*350*/	struct { /* LVT - LINT0 */
asm-x86_64/apicdef.h:/*360*/	struct { /* LVT - LINT1 */
asm-x86_64/apicdef.h:/*370*/	struct { /* LVT - Error */
asm-x86_64/io.h: * versions of the single-IO instructions (inb_p/inw_p/..).
asm-x86_64/io.h: * Thanks to James van Artsdalen for a better timing-fix than
asm-x86_64/io.h: * On the other hand, I'd like to be sure of a non-existent port:
asm-x86_64/io.h:  *  - Arnaldo Carvalho de Melo <acme@conectiva.com.br>
asm-x86_64/io.h:#define page_to_phys(page)	(((page) - mem_map) << PAGE_SHIFT)
asm-x86_64/io.h: * to PAGE_OFFSET is pure coincidence - it does not mean ISA values
asm-x86_64/io.h: * used as the IO-area pointer (it can be iounmapped as well, so the
asm-x86_64/io.h: * Again, x86-64 does not require mem IO specific function.
asm-x86_64/io.h:		length--;
asm-x86_64/io.h:		length--;
asm-x86_64/atomic.h: * atomic_read - read atomic variable
asm-x86_64/atomic.h:#define atomic_read(v)		((v)->counter)
asm-x86_64/atomic.h: * atomic_set - set atomic variable
asm-x86_64/atomic.h:#define atomic_set(v,i)		(((v)->counter) = (i))
asm-x86_64/atomic.h: * atomic_add - add integer to atomic variable
asm-x86_64/atomic.h:		:"=m" (v->counter)
asm-x86_64/atomic.h:		:"ir" (i), "m" (v->counter));
asm-x86_64/atomic.h: * atomic_sub - subtract the atomic variable
asm-x86_64/atomic.h:		:"=m" (v->counter)
asm-x86_64/atomic.h:		:"ir" (i), "m" (v->counter));
asm-x86_64/atomic.h: * atomic_sub_and_test - subtract value from variable and test result
asm-x86_64/atomic.h:		:"=m" (v->counter), "=qm" (c)
asm-x86_64/atomic.h:		:"ir" (i), "m" (v->counter) : "memory");
asm-x86_64/atomic.h: * atomic_inc - increment atomic variable
asm-x86_64/atomic.h:		:"=m" (v->counter)
asm-x86_64/atomic.h:		:"m" (v->counter));
asm-x86_64/atomic.h: * atomic_dec - decrement atomic variable
asm-x86_64/atomic.h:		:"=m" (v->counter)
asm-x86_64/atomic.h:		:"m" (v->counter));
asm-x86_64/atomic.h: * atomic_dec_and_test - decrement and test
asm-x86_64/atomic.h:		:"=m" (v->counter), "=qm" (c)
asm-x86_64/atomic.h:		:"m" (v->counter) : "memory");
asm-x86_64/atomic.h: * atomic_inc_and_test - increment and test 
asm-x86_64/atomic.h:		:"=m" (v->counter), "=qm" (c)
asm-x86_64/atomic.h:		:"m" (v->counter) : "memory");
asm-x86_64/atomic.h: * atomic_add_negative - add and test if negative
asm-x86_64/atomic.h:		:"=m" (v->counter), "=qm" (c)
asm-x86_64/atomic.h:		:"ir" (i), "m" (v->counter) : "memory");
asm-x86_64/atomic.h:/* These are x86-specific, used by some header files */
asm-x86_64/ipcbuf.h: * The ipc64_perm structure for x86-64 architecture.
asm-x86_64/ipcbuf.h: * - 32-bit mode_t and seq
asm-x86_64/ipcbuf.h: * - 2 miscellaneous 32-bit values
asm-x86_64/parport.h: * parport.h: ia32-specific parport initialisation
asm-x86_64/vsyscall.h:#define VSYSCALL_START (-10UL << 20)
asm-x86_64/vsyscall.h:#define VSYSCALL_END (-2UL << 20)
asm-x86_64/shmbuf.h: * - 2 miscellaneous 64-bit values
asm-x86_64/bitops.h: * These have to be done with inline assembly: that way the bit-setting
asm-x86_64/bitops.h: * set_bit - Atomically set a bit in memory
asm-x86_64/bitops.h: * restricted to acting on a single-word quantity.
asm-x86_64/bitops.h: * __set_bit - Set a bit in memory
asm-x86_64/bitops.h: * Unlike set_bit(), this function is non-atomic and may be reordered.
asm-x86_64/bitops.h: * clear_bit - Clears a bit in memory
asm-x86_64/bitops.h: * __change_bit - Toggle a bit in memory
asm-x86_64/bitops.h: * Unlike change_bit(), this function is non-atomic and may be reordered.
asm-x86_64/bitops.h: * change_bit - Toggle a bit in memory
asm-x86_64/bitops.h: * restricted to acting on a single-word quantity.
asm-x86_64/bitops.h: * test_and_set_bit - Set a bit and return its old value
asm-x86_64/bitops.h: * __test_and_set_bit - Set a bit and return its old value
asm-x86_64/bitops.h: * This operation is non-atomic and can be reordered.  
asm-x86_64/bitops.h: * test_and_clear_bit - Clear a bit and return its old value
asm-x86_64/bitops.h: * __test_and_clear_bit - Clear a bit and return its old value
asm-x86_64/bitops.h: * This operation is non-atomic and can be reordered.  
asm-x86_64/bitops.h: * test_and_change_bit - Change a bit and return its new value
asm-x86_64/bitops.h:#if 0 /* Fool kernel-doc since it doesn't do macros yet */
asm-x86_64/bitops.h: * test_bit - Determine whether a bit is set
asm-x86_64/bitops.h: * find_first_zero_bit - find the first zero bit in a memory region
asm-x86_64/bitops.h: * Returns the bit-number of the first zero bit, not the number of the byte
asm-x86_64/bitops.h: * containing a bit. -1 when none found.
asm-x86_64/bitops.h:		"movl $-1,%%eax\n\t"
asm-x86_64/bitops.h:		"xorl -4(%%rdi),%%eax\n\t"
asm-x86_64/bitops.h: * find_next_zero_bit - find the first zero bit in a memory region
asm-x86_64/bitops.h:		if (set < (32 - bit))
asm-x86_64/bitops.h:		set = 32 - bit;
asm-x86_64/bitops.h:	res = find_first_zero_bit (p, size - 32 * (p - (unsigned int *) addr));
asm-x86_64/bitops.h: * Find string of zero bits in a bitmap. -1 when not found.
asm-x86_64/bitops.h: * ffz - find first zero in word.
asm-x86_64/bitops.h: * ffs - find first bit set
asm-x86_64/bitops.h:		"movl $-1,%0\n"
asm-x86_64/bitops.h: * hweightN - returns the hamming weight of a N-bit word
asm-x86_64/div64.h: * Hey, we're already 64-bit, no
asm-x86_64/resource.h:#define RLIMIT_MEMLOCK	8		/* max locked-in-memory address space */
asm-x86_64/ptrace.h:#define user_mode(regs) (!!((regs)->cs & 3))
asm-x86_64/ptrace.h:#define instruction_pointer(regs) ((regs)->rip)
asm-x86_64/pgalloc.h:	if ((unsigned long)pmd & (PAGE_SIZE-1)) 
asm-x86_64/pgalloc.h:	if ((unsigned long)pgd & (PAGE_SIZE-1)) 
asm-x86_64/pgalloc.h:	if ((unsigned long)pte & (PAGE_SIZE-1))
asm-x86_64/pgalloc.h: *  - flush_tlb() flushes the current mm struct TLBs
asm-x86_64/pgalloc.h: *  - flush_tlb_all() flushes all processes TLBs
asm-x86_64/pgalloc.h: *  - flush_tlb_mm(mm) flushes the specified mm context TLB's
asm-x86_64/pgalloc.h: *  - flush_tlb_page(vma, vmaddr) flushes one page
asm-x86_64/pgalloc.h: *  - flush_tlb_range(mm, start, end) flushes a range of pages
asm-x86_64/pgalloc.h: *  - flush_tlb_pgtables(mm, start, end) flushes a range of page tables
asm-x86_64/pgalloc.h:	if (mm == current->active_mm)
asm-x86_64/pgalloc.h:	if (vma->vm_mm == current->active_mm)
asm-x86_64/pgalloc.h:	if (mm == current->active_mm)
asm-x86_64/unistd.h:	if ((unsigned long)(res) >= (unsigned long)(-127)) { \
asm-x86_64/unistd.h:		errno = -(res); \
asm-x86_64/unistd.h:		res = -1; \
asm-x86_64/unistd.h: * we need this inline - forking from kernel space will result
asm-x86_64/unistd.h: * calls - which means inline code for fork too, as otherwise we
asm-x86_64/unistd.h:	return waitpid(-1,wait_stat,0);
asm-x86_64/dma.h: *  controller 1: channels 0-3, byte operations, ports 00-1F
asm-x86_64/dma.h: *  controller 2: channels 4-7, word operations, ports C0-DF
asm-x86_64/dma.h: *  - ALL registers are 8 bits only, regardless of transfer size
asm-x86_64/dma.h: *  - channel 4 is not used - cascades 1 into 2.
asm-x86_64/dma.h: *  - channels 0-3 are byte - addresses/counts are for physical bytes
asm-x86_64/dma.h: *  - channels 5-7 are word - addresses/counts are for physical words
asm-x86_64/dma.h: *  - transfers must not cross physical 64K (0-3) or 128K (5-7) boundaries
asm-x86_64/dma.h: *  - transfer count loaded to registers is 1 less than actual count
asm-x86_64/dma.h: *  - controller 2 offsets are all even (2x offsets for controller 1)
asm-x86_64/dma.h: *  - page registers for 5-7 don't use data bit 0, represent 128K pages
asm-x86_64/dma.h: *  - page registers for 0-3 use bit 0, represent 64K pages
asm-x86_64/dma.h: *  Address mapping for channels 0-3:
asm-x86_64/dma.h: *  Address mapping for channels 5-7:
asm-x86_64/dma.h: * Again, channels 5-7 transfer _physical_ words (16 bits), so addresses
asm-x86_64/dma.h: * and counts _must_ be word-aligned (the lowest address bit is _ignored_ at
asm-x86_64/dma.h: * the hardware level, so odd-byte transfers aren't possible).
asm-x86_64/dma.h: * count - 1 : 64K => 0xFFFF, 1 => 0x0000.  Thus, count is always 1 or more,
asm-x86_64/dma.h: * and up to 128K bytes may be transferred on channels 5-7 in one operation. 
asm-x86_64/dma.h:#define DMA1_MASK_REG		0x0A	/* single-channel mask (w) */
asm-x86_64/dma.h:#define DMA1_CLEAR_FF_REG	0x0C	/* clear pointer flip-flop (w) */
asm-x86_64/dma.h:#define DMA1_MASK_ALL_REG       0x0F    /* all-channels mask (w) */
asm-x86_64/dma.h:#define DMA2_MASK_REG		0xD4	/* single-channel mask (w) */
asm-x86_64/dma.h:#define DMA2_CLEAR_FF_REG	0xD8	/* clear pointer flip-flop (w) */
asm-x86_64/dma.h:#define DMA2_MASK_ALL_REG       0xDE    /* all-channels mask (w) */
asm-x86_64/dma.h:#define DMA_MODE_CASCADE 0xC0   /* pass thru DREQ->HRQ, DACK<-HLDA only */
asm-x86_64/dma.h: * After that, keep track of it. :-)
asm-x86_64/dma.h: * --- In order to do that, the DMA routines below should ---
asm-x86_64/dma.h: * --- only be used while holding the DMA lock ! ---
asm-x86_64/dma.h: * Assumes dma flip-flop is clear.
asm-x86_64/dma.h: * NOTE 2: "count" represents _bytes_ and must be even for channels 5-7.
asm-x86_64/dma.h:        count--;
asm-x86_64/dma.h: * Assumes DMA flip-flop is clear.
asm-x86_64/dma.h:	/* using short to get 16-bit wrap around */
asm-x86_64/elf.h:	((x)->e_machine == EM_X86_64)
asm-x86_64/elf.h:/* SVR4/i386 ABI (pages 3-31, 3-32) says that when the program starts %edx
asm-x86_64/elf.h:	(_r)->rbx = 0; (_r)->rcx = 0; (_r)->rdx = 0; \
asm-x86_64/elf.h:	(_r)->rsi = 0; (_r)->rdi = 0; (_r)->rbp = 0; \
asm-x86_64/elf.h:	(_r)->rax = 0;				\
asm-x86_64/elf.h:	(_r)->r8 = 0;				\
asm-x86_64/elf.h:	(_r)->r9 = 0;				\
asm-x86_64/elf.h:	(_r)->r10 = 0;				\
asm-x86_64/elf.h:	(_r)->r11 = 0;				\
asm-x86_64/elf.h:	(_r)->r12 = 0;				\
asm-x86_64/elf.h:	(_r)->r13 = 0;				\
asm-x86_64/elf.h:	(_r)->r14 = 0;				\
asm-x86_64/elf.h:	(_r)->r15 = 0;				\
asm-x86_64/elf.h:        cur->thread.fs = 0; cur->thread.gs = 0; \
asm-x86_64/elf.h:	cur->thread.fsindex = 0; cur->thread.gsindex = 0; \
asm-x86_64/elf.h:        cur->thread.ds = 0; cur->thread.es = 0;  \
asm-x86_64/elf.h:	cur->thread.flags &= ~THREAD_IA32; \
asm-x86_64/elf.h:	(pr_reg)[0] = (regs)->r15;				\
asm-x86_64/elf.h:	(pr_reg)[1] = (regs)->r14;				\
asm-x86_64/elf.h:	(pr_reg)[2] = (regs)->r13;				\
asm-x86_64/elf.h:	(pr_reg)[3] = (regs)->r12;				\
asm-x86_64/elf.h:	(pr_reg)[4] = (regs)->rbp;				\
asm-x86_64/elf.h:	(pr_reg)[5] = (regs)->rbx;				\
asm-x86_64/elf.h:	(pr_reg)[6] = (regs)->r11;				\
asm-x86_64/elf.h:	(pr_reg)[7] = (regs)->r10;				\
asm-x86_64/elf.h:	(pr_reg)[8] = (regs)->r9;				\
asm-x86_64/elf.h:	(pr_reg)[9] = (regs)->r8;				\
asm-x86_64/elf.h:	(pr_reg)[10] = (regs)->rax;				\
asm-x86_64/elf.h:	(pr_reg)[11] = (regs)->rcx;				\
asm-x86_64/elf.h:	(pr_reg)[12] = (regs)->rdx;				\
asm-x86_64/elf.h:	(pr_reg)[13] = (regs)->rsi;				\
asm-x86_64/elf.h:	(pr_reg)[14] = (regs)->rdi;				\
asm-x86_64/elf.h:	(pr_reg)[15] = (regs)->orig_rax;			\
asm-x86_64/elf.h:	(pr_reg)[16] = (regs)->rip;				\
asm-x86_64/elf.h:	(pr_reg)[17] = (regs)->cs;				\
asm-x86_64/elf.h:	(pr_reg)[18] = (regs)->eflags;				\
asm-x86_64/elf.h:	(pr_reg)[19] = (regs)->rsp;				\
asm-x86_64/elf.h:	(pr_reg)[20] = (regs)->ss;				\
asm-x86_64/elf.h:	(pr_reg)[21] = current->thread.fs;			\
asm-x86_64/elf.h:	(pr_reg)[22] = current->thread.gs;			\
asm-x86_64/elf.h:/* I'm not sure if we can use '-' here */
asm-x86_64/ide.h: *  linux/include/asm-x86_64/ide.h
asm-x86_64/ide.h: *  Copyright (C) 1994-1996  Linus Torvalds & authors
asm-x86_64/ide.h:		hw->io_ports[i] = reg;
asm-x86_64/ide.h:		hw->io_ports[IDE_CONTROL_OFFSET] = ctrl_port;
asm-x86_64/ide.h:		hw->io_ports[IDE_CONTROL_OFFSET] = hw->io_ports[IDE_DATA_OFFSET] + 0x206;
asm-x86_64/ide.h:	hw->io_ports[IDE_IRQ_OFFSET] = 0;
asm-x86_64/ide.h:#include <asm-generic/ide_iops.h>
asm-x86_64/irq.h: *	<tomsoft@informatik.tu-chemnitz.de>
asm-x86_64/irq.h: * Since vectors 0x00-0x1f are used/reserved for the CPU,
asm-x86_64/irq.h: * the usable vector space is 0x20-0xff (224 vectors)
asm-x86_64/msr.h: * Access to machine-specific registers (available on 586 and better only)
asm-x86_64/msr.h:		     : "c" (msr), "0" ((__u32)val), "d" ((val)>>32), "i" (-EFAULT));\
asm-x86_64/msr.h:#define _EFER_LMA 10 /* Long mode active (read-only) */
asm-x86_64/msr.h:/* Centaur-Hauls/IDT defined MSRs. */
asm-x86_64/pci.h:   already-configured bus numbers - to be used for buggy BIOSes
asm-x86_64/pci.h: * NULL for PCI-like buses (ISA, EISA).
asm-x86_64/pci.h: * Returns non-NULL cpu-view pointer to the buffer if successful and
asm-x86_64/pci.h: * The 32-bit bus address to use is returned.
asm-x86_64/pci.h:	((PTR)->ADDR_NAME)
asm-x86_64/pci.h:	(((PTR)->ADDR_NAME) = (VAL))
asm-x86_64/pci.h:	((PTR)->LEN_NAME)
asm-x86_64/pci.h:	(((PTR)->LEN_NAME) = (VAL))
asm-x86_64/pci.h:	if ((addr+size) & ~hwdev->dma_mask) 
asm-x86_64/pci.h:	if ((addr+size) & ~hwdev->dma_mask) 
asm-x86_64/pci.h: * The same as pci_dma_sync_single but for a scatter-gather list,
asm-x86_64/pci.h: * only drive the low 24-bits during PCI bus mastering, then
asm-x86_64/pci.h:#define sg_dma_address(sg)	((sg)->dma_address)
asm-x86_64/pci.h:#define sg_dma_len(sg)		((sg)->length)
asm-x86_64/pda.h:        int irqcount;		    /* Irq nesting counter. Starts with -1 */  	
asm-x86_64/pda.h:#define sizeof_field(type,field)  (sizeof(((type *)0)->field))
asm-x86_64/pda.h:#define typeof_field(type,field)  typeof(((type *)0)->field)
asm-x86_64/pda.h:#define pda_offset(field) ((unsigned long)&((struct x8664_pda *)0)->field)
asm-x86_64/smp.h: * the real APIC ID <-> CPU # mapping.
asm-x86_64/smp.h:#define stack_smp_processor_id() (stack_current()->processor)
asm-x86_64/smp.h:	/* we don't want to mark this access volatile - bad code generation */
asm-x86_64/tlb.h:#include <asm-generic/tlb.h>
asm-x86_64/xor.h: * include/asm-x86_64/xor.h
asm-x86_64/xor.h: * Optimized RAID-5 checksumming functions for MMX and SSE.
asm-x86_64/xor.h: * High-speed RAID5 checksumming functions utilizing SSE instructions.
asm-x86_64/xor.h: * x86-64 changes / gcc fixes from Andi Kleen. 
asm-x86_64/xor.h:	} while (--lines > 0);
asm-x86_64/xor.h:	} while (--lines > 0);
asm-x86_64/xor.h:	} while (--lines > 0);
asm-x86_64/xor.h:	} while (--lines > 0);
asm-x86_64/signal.h:#define SIGRTMAX	(_NSIG-1)
asm-x86_64/signal.h: * SA_INTERRUPT is a no-op, but left due to historical reasons. Use the
asm-x86_64/signal.h:#define SA_INTERRUPT	0x20000000 /* dummy -- ignored */
asm-x86_64/signal.h:#define SIG_ERR	((__sighandler_t)-1)	/* error return from signal */
asm-x86_64/signal.h:	__asm__("btsq %1,%0" : "=m"(*set) : "Ir"(_sig - 1) : "cc");
asm-x86_64/signal.h:	__asm__("btrq %1,%0" : "=m"(*set) : "Ir"(_sig - 1) : "cc");
asm-x86_64/signal.h:	unsigned long sig = _sig - 1;
asm-x86_64/signal.h:	return 1 & (set->sig[sig / _NSIG_BPW] >> (sig & ~(_NSIG_BPW-1)));
asm-x86_64/signal.h:		: "=r"(ret) : "m"(*set), "Ir"(_sig-1) : "cc");
asm-x86_64/signal.h:#define sigmask(sig)	(1UL << ((sig) - 1))
asm-x86_64/hardirq.h:#define irq_exit(cpu, irq)	(local_irq_count(cpu)--)
asm-x86_64/hardirq.h:extern unsigned volatile long global_irq_lock; /* long for set_bit -RR */
asm-x86_64/hardirq.h:	--local_irq_count(cpu);
asm-x86_64/sigcontext.h:	__u32	st_space[32];	/* 8*16 bytes for each FP-reg */
asm-x86_64/sigcontext.h:	__u32	xmm_space[64];	/* 16*16 bytes for each XMM-reg  */
asm-x86_64/processor.h: * include/asm-x86_64/processor.h
asm-x86_64/processor.h:	int	cpuid_level;	/* Maximum supported CPUID level, -1=no CPUID */
asm-x86_64/processor.h:	int 	x86_cache_size;  /* in KB - valid for CPUS which support this
asm-x86_64/processor.h: * User space process size: 512GB - 1GB (default).
asm-x86_64/processor.h:#define IA32_PAGE_OFFSET ((current->personality & ADDR_LIMIT_3GB) ? 0xc0000000 : 0xFFFFe000)
asm-x86_64/processor.h:	((current->thread.flags & THREAD_IA32) ? TASK_UNMAPPED_32 : TASK_UNMAPPED_64)  
asm-x86_64/processor.h: * Size of io_bitmap in longwords: 32 is ports 0-0x3ff.
asm-x86_64/processor.h:	u32	st_space[32];	/* 8*16 bytes for each FP-reg = 128 bytes */
asm-x86_64/processor.h:	u32	xmm_space[64];	/* 16*16 bytes for each XMM-reg = 128 bytes */
asm-x86_64/processor.h:	unsigned long	debugreg[8];  /* %%db0-7 debug registers */
asm-x86_64/processor.h:	(regs)->rip = (new_rip);						 \
asm-x86_64/processor.h:	(regs)->rsp = (new_rsp);						 \
asm-x86_64/processor.h:	(regs)->cs = __USER_CS;							 \
asm-x86_64/processor.h:	(regs)->ss = __USER_DS;							 \
asm-x86_64/processor.h:	(regs)->eflags = 0x200;							 \
asm-x86_64/processor.h:	return *(unsigned long *)(t->rsp - 8);
asm-x86_64/processor.h:	(((struct pt_regs *)(tsk->thread.rsp0 - sizeof(struct pt_regs)))->rip)
asm-x86_64/processor.h:#define KSTK_ESP(tsk) -1 /* sorry. doesn't work for syscall. */
asm-x86_64/processor.h:#define get_task_struct(tsk)      atomic_inc(&virt_to_page(tsk)->count)
asm-x86_64/processor.h:/* REP NOP (PAUSE) is a good thing to insert into busy-wait loops. */
asm-x86_64/linux_logo.h: * include/asm-x86_64/linux_logo.h: This is a linux logo
asm-x86_64/linux_logo.h:/* We should create logo of penguin with a big hammer (-: --pavel */
asm-x86_64/linux_logo.h:#define linux_logo_banner "Linux/x86-64 version " UTS_RELEASE
asm-x86_64/mmu_context.h:#define init_new_context(tsk,mm)    ({ rwlock_init(&(mm)->context.ldtlock); 0; })
asm-x86_64/mmu_context.h:		clear_bit(cpu, &prev->cpu_vm_mask);
asm-x86_64/mmu_context.h:		 * Re-load LDT if necessary
asm-x86_64/mmu_context.h:		if (prev->context.segments != next->context.segments)
asm-x86_64/mmu_context.h:		set_bit(cpu, &next->cpu_vm_mask);
asm-x86_64/mmu_context.h:		set_bit(cpu, &next->context.cpuvalid);
asm-x86_64/mmu_context.h:		/* Re-load page tables */
asm-x86_64/mmu_context.h:		*read_pda(level4_pgt) = __pa(next->pgd) | _PAGE_TABLE;
asm-x86_64/mmu_context.h:		if(!test_and_set_bit(cpu, &next->cpu_vm_mask)) {
asm-x86_64/mmu_context.h:		if (!test_and_set_bit(cpu, &next->context.cpuvalid))
asm-x86_64/semaphore.h: * SMP- and interrupt-safe semaphores..
asm-x86_64/semaphore.h: * Modified 1996-12-23 by Dave Grothe <dave@gcom.com> to fix bugs in
asm-x86_64/semaphore.h: * Modified 1999-02-14 by Andrea Arcangeli, split the sched.c helper
asm-x86_64/semaphore.h: *		       functions in asm/sempahore-helper.h while fixing a
asm-x86_64/semaphore.h: *          1999-07-02 Artur Skawina <skawina@geocities.com>
asm-x86_64/semaphore.h: *                     Optimized "0(ecx)" -> "(ecx)" (the assembler does not
asm-x86_64/semaphore.h: * Modified 2001-01-01 Andreas Franck <afranck@gmx.de>
asm-x86_64/semaphore.h: *		       with -fomit-frame-pointer. It's not sure if this will
asm-x86_64/semaphore.h: * /pub/linux/src/semaphore/semaphore-2.0.24.tar.gz.
asm-x86_64/semaphore.h:	atomic_set(&sem->count, val);
asm-x86_64/semaphore.h:	sem->sleepers = 0;
asm-x86_64/semaphore.h:	init_waitqueue_head(&sem->wait);
asm-x86_64/semaphore.h:	sem->__magic = (int)&sem->__magic;
asm-x86_64/semaphore.h:	CHECK_MAGIC(sem->__magic);
asm-x86_64/semaphore.h:		LOCK "decl %0\n\t"     /* --sem->count */
asm-x86_64/semaphore.h:		:"=m" (sem->count)
asm-x86_64/semaphore.h: * it, return zero.  If we were interrupted, returns -EINTR
asm-x86_64/semaphore.h:	CHECK_MAGIC(sem->__magic);
asm-x86_64/semaphore.h:		LOCK "decl %1\n\t"     /* --sem->count */
asm-x86_64/semaphore.h:		:"=a" (result), "=m" (sem->count)
asm-x86_64/semaphore.h: * Non-blockingly attempt to down() a semaphore.
asm-x86_64/semaphore.h:	CHECK_MAGIC(sem->__magic);
asm-x86_64/semaphore.h:		LOCK "decl %1\n\t"     /* --sem->count */
asm-x86_64/semaphore.h:		:"=a" (result), "=m" (sem->count)
asm-x86_64/semaphore.h:	CHECK_MAGIC(sem->__magic);
asm-x86_64/semaphore.h:		LOCK "incl %0\n\t"     /* ++sem->count */
asm-x86_64/semaphore.h:		:"=m" (sem->count)
asm-x86_64/semaphore.h:	return atomic_read(&sem->count);
asm-x86_64/fcntl.h:/* open/fcntl - O_SYNC is only implemented on blocks devices and on files
asm-x86_64/fcntl.h:#define F_GETFL		3	/* get file->f_flags */
asm-x86_64/fcntl.h:#define F_SETFL		4	/* set file->f_flags */
asm-x86_64/mmzone.h: * Adapted for K8/x86-64 Jul 2002 by Andi Kleen.
asm-x86_64/mmzone.h:	(PLAT_NODE_DATA(n)->gendata.node_start_mapnr)
asm-x86_64/mmzone.h:#define PLAT_NODE_DATA_SIZE(n)		(PLAT_NODE_DATA(n)->gendata.node_size)
asm-x86_64/mmzone.h:	(((p) - PLAT_NODE_DATA(n)->gendata.node_start_paddr) >> PAGE_SHIFT)
asm-x86_64/mmzone.h:#define NODE_DATA(n)	(&((PLAT_NODE_DATA(n))->gendata))
asm-x86_64/mmzone.h:#define NODE_MEM_MAP(nid)	(NODE_DATA(nid)->node_mem_map)
asm-x86_64/mmzone.h:#define LOCAL_BASE_ADDR(kaddr)	((unsigned long)__va(NODE_DATA(KVADDR_TO_NID(kaddr))->node_start_paddr))
asm-x86_64/mmzone.h:	(((unsigned long)(kvaddr)-LOCAL_BASE_ADDR(kvaddr)) >> PAGE_SHIFT)
asm-x86_64/mmzone.h:	VIRTUAL_BUG_ON(pfn >= plat_pgdat->end_pfn);
asm-x86_64/mmzone.h:	VIRTUAL_BUG_ON(pfn < plat_pgdat->start_pfn);
asm-x86_64/mmzone.h:	*mem_map = plat_pgdat->gendata.node_mem_map; 
asm-x86_64/mmzone.h:	return pfn - plat_pgdat->start_pfn;
asm-x86_64/mmzone.h:	(page - nd->gendata.node_mem_map) + nd->start_pfn; \
asm-x86_64/mmzone.h:		struct page *lmemmap = nd->node_mem_map;		  \
asm-x86_64/mmzone.h:		     (page_ptr >= lmemmap && page_ptr < lmemmap + nd->node_size); \
asm-x86_64/locks.h:	while(lock_set_bit(0,&sp->lock))
asm-x86_64/locks.h:		if(sp->cpu==processor)
asm-x86_64/locks.h:			sp->users++;
asm-x86_64/locks.h:		while(sp->lock)
asm-x86_64/locks.h:			sp->spins++;
asm-x86_64/locks.h:	sp->users++;sp->cpu=processor;
asm-x86_64/locks.h:	if(!--sp->users)
asm-x86_64/locks.h:		sp->cpu= NO_PROC_ID;lock_clear_bit(0,&sp->lock);
asm-x86_64/locks.h:	if(lock_set_bit(0,&sp->lock))
asm-x86_64/locks.h:	sp->users++;
asm-x86_64/locks.h:	if(sp->priority<current->lock_order)
asm-x86_64/locks.h:		panic("lock order violation: %s (%d)\n", sp->name, current->lock_order);
asm-x86_64/locks.h:		sp->oldpri=current->lock_order;
asm-x86_64/locks.h:		current->lock_order=sp->priority;
asm-x86_64/locks.h:	if(current->lock_order!=sp->priority)
asm-x86_64/locks.h:		panic("lock release order violation %s (%d)\n", sp->name, current->lock_order);
asm-x86_64/locks.h:	pri=sp->oldpri;
asm-x86_64/locks.h:		current->lock_order=sp->pri;
asm-x86_64/rwsem.h: * Ported by Andi Kleen <ak@suse.de> to x86-64.
asm-x86_64/rwsem.h: * Derived from asm-i386/semaphore.h and asm-i386/rwsem.h
asm-x86_64/rwsem.h: * This should be totally fair - if anything is waiting, a process that wants a
asm-x86_64/rwsem.h:#define RWSEM_WAITING_BIAS		(-0x00010000)
asm-x86_64/rwsem.h:	sem->count = RWSEM_UNLOCKED_VALUE;
asm-x86_64/rwsem.h:	spin_lock_init(&sem->wait_lock);
asm-x86_64/rwsem.h:	INIT_LIST_HEAD(&sem->wait_list);
asm-x86_64/rwsem.h:	sem->debug = 0;
asm-x86_64/rwsem.h:		: "+m"(sem->count)
asm-x86_64/rwsem.h:	__s32 tmp = -RWSEM_ACTIVE_READ_BIAS;
asm-x86_64/rwsem.h:		: "+m"(sem->count), "+d"(tmp)
asm-x86_64/rwsem.h:LOCK_PREFIX	"  xaddl     %%edx,(%%rdi)\n\t" /* tries to transition 0xffff0001 -> 0x00000000 */
asm-x86_64/rwsem.h:		: "+m"(sem->count)
asm-x86_64/rwsem.h:		: "D"(sem), "i"(-RWSEM_ACTIVE_WRITE_BIAS)
asm-x86_64/rwsem.h:		:"=m"(sem->count)
asm-x86_64/rwsem.h:		:"ir"(delta), "m"(sem->count));
asm-x86_64/rwsem.h:		: "=r"(tmp), "=m"(sem->count)
asm-x86_64/rwsem.h:		: "r"(sem), "m"(sem->count), "0" (tmp)
asm-x86_64/spinlock.h: * Remember to turn this off in 2.4. -ben
asm-x86_64/spinlock.h:#define spin_is_locked(x)	(*(volatile signed char *)(&(x)->lock) <= 0)
asm-x86_64/spinlock.h:		:"=q" (oldval), "=m" (lock->lock)
asm-x86_64/spinlock.h:	if (lock->magic != SPINLOCK_MAGIC) {
asm-x86_64/spinlock.h:		:"=m" (lock->lock) : : "memory");
asm-x86_64/spinlock.h:	if (lock->magic != SPINLOCK_MAGIC)
asm-x86_64/spinlock.h:		:"=m" (lock->lock) : : "memory");
asm-x86_64/spinlock.h: * Read-write spinlocks, allowing multiple readers
asm-x86_64/spinlock.h: * can "mix" irq-safe locks - any writer needs to get a
asm-x86_64/spinlock.h: * irq-safe write-lock, but readers can get non-irqsafe
asm-x86_64/spinlock.h: * read-locks.
asm-x86_64/spinlock.h: * On x86, we implement read-write locks as a 32-bit counter
asm-x86_64/spinlock.h: * The inline assembly is non-obvious. Think about it.
asm-x86_64/spinlock.h: * semaphore.h for details.  -ben
asm-x86_64/spinlock.h:	if (rw->magic != RWLOCK_MAGIC)
asm-x86_64/spinlock.h:	if (rw->magic != RWLOCK_MAGIC)
asm-x86_64/spinlock.h:#define read_unlock(rw)		asm volatile("lock ; incl %0" :"=m" ((rw)->lock) : : "memory")
asm-x86_64/spinlock.h:#define write_unlock(rw)	asm volatile("lock ; addl $" RW_LOCK_BIAS_STR ",%0":"=m" ((rw)->lock) : : "memory")
asm-x86_64/errno.h:#define	EXDEV		18	/* Cross-device link */
asm-x86_64/errno.h:#define	EROFS		30	/* Read-only file system */
asm-x86_64/errno.h:#define	ENOTSOCK	88	/* Socket operation on non-socket */
asm-x86_64/io_apic.h: * Intel IO-APIC support for SMP and UP systems.
asm-x86_64/io_apic.h: * The structure of the IO-APIC:
asm-x86_64/io_apic.h: * # of IO-APICs and # of IRQ routing registers
asm-x86_64/io_apic.h: * MP-BIOS irq configuration table structures:
asm-x86_64/io_apic.h:/* non-0 if default (table-less) MP configuration */
asm-x86_64/io_apic.h: * Re-write a value: to be used for read-modify-write
asm-x86_64/io_apic.h: * Synchronize the IO-APIC and the CPU by doing
asm-x86_64/io_apic.h: * a dummy read from the IO-APIC
asm-x86_64/io_apic.h: * If we use the IO-APIC for IRQ routing, disable automatic
asm-x86_64/bootsetup.h: * This is set up by the setup-routine at boot-time
asm-x86_64/acpi.h: *  asm-x86_64/acpi.h
asm-x86_64/acpi.h: *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
asm-x86_64/acpi.h: * ACPI_SYSTEM_XFACE        - Interfaces to host OS (handlers, threads)
asm-x86_64/acpi.h: * ACPI_EXTERNAL_XFACE      - External ACPI interfaces 
asm-x86_64/acpi.h: * ACPI_INTERNAL_XFACE      - Internal ACPI interfaces
asm-x86_64/acpi.h: * ACPI_INTERNAL_VAR_XFACE  - Internal variable-parameter list interfaces
asm-x86_64/acpi.h:	return (new < 3) ? -1 : 0;
asm-x86_64/acpi.h:/* Fixmap pages to reserve for ACPI boot-time tables (see fixmap.h) */
asm-x86_64/apic.h:	 * - a single rmw on Pentium/82489DX
asm-x86_64/apic.h:	 * - a single write on P6+ cores (CONFIG_X86_GOOD_APIC)
asm-x86_64/softirq.h:		do { barrier(); local_bh_count(cpu)--; } while (0)
asm-x86_64/softirq.h: *    (char *)&local_bh_count - 8 == (char *)&softirq_pending
asm-x86_64/softirq.h:	if (!--*ptr)							\
asm-x86_64/softirq.h:			"cmpl $0, -8(%0);"				\
asm-x86_64/hw_irq.h: *	<tomsoft@informatik.tu-chemnitz.de>
asm-x86_64/hw_irq.h: *	hacked by Andi Kleen for x86-64.
asm-x86_64/hw_irq.h: * Vectors 0x20-0x2f are used for ISA interrupts.
asm-x86_64/hw_irq.h: * Special IRQ vectors used by the SMP architecture, 0xf0-0xff
asm-x86_64/hw_irq.h: *  TLB, reschedule and local APIC vectors are performance-critical.
asm-x86_64/hw_irq.h: *  Vectors 0xf0-0xf9 are free (reserved for future Linux use).
asm-x86_64/hw_irq.h: * First APIC vector available to drivers: (vectors 0x30-0xee)
asm-x86_64/hw_irq.h: * Various low-level irq details needed by irq.c, process.c,
asm-x86_64/hw_irq.h:	"push $" #nr "-256 ; " \
asm-x86_64/hw_irq.h:	eip -= (unsigned long) &_stext;
asm-x86_64/hw_irq.h:	 * Don't ignore out-of-bounds EIP values silently,
asm-x86_64/hw_irq.h:	if (eip > prof_len-1)
asm-x86_64/hw_irq.h:		eip = prof_len-1;
asm-x86_64/timex.h: * linux/include/asm-x8664/timex.h
asm-x86_64/timex.h:#define FINETUNE	((((((long)LATCH * HZ - CLOCK_TICK_RATE) << SHIFT_HZ) * \
asm-x86_64/timex.h:			1000000 / CLOCK_TICK_RATE) << (SHIFT_SCALE - SHIFT_HZ)) / HZ)
asm-x86_64/bugs.h: *  include/asm-x86_64/bugs.h
asm-x86_64/bugs.h: * This is included by init/main.c to check for architecture-dependent bugs.
asm-x86_64/namei.h: * Look at asm-sparc/namei.h for details.
asm-x86_64/i387.h: * include/asm-x86_64/i387.h
asm-x86_64/i387.h: * x86-64 work by Andi Kleen 2002
asm-x86_64/i387.h:	if ( tsk->flags & PF_USEDFPU ) \
asm-x86_64/i387.h:	if ( tsk->flags & PF_USEDFPU ) { \
asm-x86_64/i387.h:		tsk->flags &= ~PF_USEDFPU; \
asm-x86_64/i387.h:#define get_fpu_mxcsr(t) ((t)->thread.i387.fxsave.mxcsr)
asm-x86_64/i387.h:#define get_fpu_cwd(t) ((t)->thread.i387.fxsave.cwd)
asm-x86_64/i387.h:#define get_fpu_fxsr_twd(t) ((t)->thread.i387.fxsave.twd)
asm-x86_64/i387.h:#define get_fpu_swd(t) ((t)->thread.i387.fxsave.swd)
asm-x86_64/i387.h:#define set_fpu_cwd(t,val) ((t)->thread.i387.fxsave.cwd = (val))
asm-x86_64/i387.h:#define set_fpu_swd(t,val) ((t)->thread.i387.fxsave.swd = (val))
asm-x86_64/i387.h:#define set_fpu_fxsr_twd(t,val) ((t)->thread.i387.fxsave.twd = (val))
asm-x86_64/i387.h:#define set_fpu_mxcsr(t,val) ((t)->thread.i387.fxsave.mxcsr = (val)&0xffbf)
asm-x86_64/i387.h:		     "3:  movl $-1,%[err]\n"
asm-x86_64/i387.h:		     "3:  movl $-1,%[err]\n"
asm-x86_64/i387.h:	if (tsk->flags & PF_USEDFPU) {
asm-x86_64/i387.h:			      : "=m" (tsk->thread.i387.fxsave));
asm-x86_64/i387.h:		tsk->flags &= ~PF_USEDFPU;
asm-x86_64/i387.h:		      : "=m" (tsk->thread.i387.fxsave));
asm-x86_64/i387.h:	tsk->flags &= ~PF_USEDFPU;
asm-x86_64/desc.h:	dst->limit0 = size & 0xFFFF;
asm-x86_64/desc.h:	dst->base0 = PTR_LOW(ptr); 
asm-x86_64/desc.h:	dst->base1 = PTR_MIDDLE(ptr) & 0xFF; 
asm-x86_64/desc.h:	dst->type = type;
asm-x86_64/desc.h:	dst->p = 1; 
asm-x86_64/desc.h:	dst->limit1 = (size >> 16) & 0xF;
asm-x86_64/desc.h:	dst->base2 = (PTR_MIDDLE(ptr) >> 8) & 0xFF; 
asm-x86_64/desc.h:	dst->base3 = PTR_HIGH(ptr); 
asm-x86_64/desc.h:	void *segments = mm->context.segments;
asm-x86_64/cpufeature.h:#define NCAPINTS	5	/* Currently we have 5 32-bit words worth of info */
asm-x86_64/cpufeature.h:/* Intel-defined CPU features, CPUID level 0x00000001, word 0 */
asm-x86_64/cpufeature.h:#define X86_FEATURE_MSR		(0*32+ 5) /* Model-Specific Registers, RDMSR, WRMSR */
asm-x86_64/cpufeature.h:#define X86_FEATURE_PSE36	(0*32+17) /* 36-bit PSEs */
asm-x86_64/cpufeature.h:#define X86_FEATURE_XMM2	(0*32+26) /* Streaming SIMD Extensions-2 */
asm-x86_64/cpufeature.h:#define X86_FEATURE_HT 		(0*32+28) /* Hyper-Threading */
asm-x86_64/cpufeature.h:#define X86_FEATURE_IA64	(0*32+30) /* IA-64 processor */
asm-x86_64/cpufeature.h:/* AMD-defined CPU features, CPUID level 0x80000001, word 1 */
asm-x86_64/cpufeature.h:#define X86_FEATURE_LM		(1*32+29) /* Long Mode (x86-64) */
asm-x86_64/cpufeature.h:/* Transmeta-defined CPU features, CPUID level 0x80860001, word 2 */
asm-x86_64/cpufeature.h:/* Other features, Linux-defined mapping, word 3 */
asm-x86_64/cpufeature.h:/* Intel-defined CPU features, CPUID level 0x00000001, ecx, word 4 */
asm-x86_64/cpufeature.h:#define X86_FEATURE_MWAIT	(4*32+ 3) /* Monitor-Mwait Support */
asm-x86_64/cpufeature.h:#define cpu_has(c, bit)            test_bit(bit, (c)->x86_capability)
asm-x86_64/cpufeature.h:#define cpu_has(c, bit)                test_bit(bit, (c)->x86_capability)
asm-x86_64/cpufeature.h: * comment-column:42
asm-x86_64/ia32.h:	long long		st_blocks;/* Number 512-byte blocks allocated. */
asm-x86_64/ia32.h:		int _pad[((128/sizeof(int)) - 3)];
asm-x86_64/kdebug.h:/* Note - you should never unregister because that can race with NMIs.
asm-x86_64/fixmap.h: * fixmap.h: compile-time virtual memory allocation
asm-x86_64/fixmap.h: * Here we define all the compile-time 'special' virtual
asm-x86_64/fixmap.h: * these 'compile-time allocated' memory buffers are
asm-x86_64/fixmap.h: * fixed-size 4k pages. (or larger if used with an increment
asm-x86_64/fixmap.h:	VSYSCALL_FIRST_PAGE = VSYSCALL_LAST_PAGE + ((VSYSCALL_END-VSYSCALL_START) >> PAGE_SHIFT) - 1,
asm-x86_64/fixmap.h:	FIX_APIC_BASE,	/* local (CPU) APIC) -- required for SMP or not */
asm-x86_64/fixmap.h:	FIX_IO_APIC_BASE_END = FIX_IO_APIC_BASE_0 + MAX_IO_APICS-1,
asm-x86_64/fixmap.h:#define FIXADDR_TOP	(VSYSCALL_END-PAGE_SIZE)
asm-x86_64/fixmap.h:#define FIXADDR_START	(FIXADDR_TOP - FIXADDR_SIZE)
asm-x86_64/fixmap.h:#define __fix_to_virt(x)	(FIXADDR_TOP - ((x) << PAGE_SHIFT))
asm-x86_64/fixmap.h: * directly without tranlation, we catch the bug with a NULL-deference
asm-x86_64/fixmap.h:	 * out-of-range indices).
asm-x86_64/init.h:#error "<asm/init.h> should never be used - use <linux/init.h> instead"
asm-x86_64/uaccess.h:#define get_fs()	(current->addr_limit)
asm-x86_64/uaccess.h:#define set_fs(x)	(current->addr_limit = (x))
asm-x86_64/uaccess.h:#define __addr_ok(addr) (!((unsigned long)(addr) & (current->addr_limit.seg)))
asm-x86_64/uaccess.h: * Uhhuh, this needs 65-bit arithmetic. We have a carry..
asm-x86_64/uaccess.h:		:"1" (addr),"g" ((long)(size)),"g" (current->addr_limit.seg)); \
asm-x86_64/uaccess.h:	return access_ok(type,addr,size) ? 0 : -EFAULT;
asm-x86_64/uaccess.h: * These are the main single-value transfer routines.  They automatically
asm-x86_64/uaccess.h:	int __pu_err = -EFAULT;				\
asm-x86_64/uaccess.h:	  case 1: __put_user_asm(x,ptr,retval,"b","b","iq",-EFAULT); break;\
asm-x86_64/uaccess.h:	  case 2: __put_user_asm(x,ptr,retval,"w","w","ir",-EFAULT); break;\
asm-x86_64/uaccess.h:	  case 4: __put_user_asm(x,ptr,retval,"l","k","ir",-EFAULT); break;\
asm-x86_64/uaccess.h:	  case 8: __put_user_asm(x,ptr,retval,"q","","ir",-EFAULT); break;\
asm-x86_64/uaccess.h:/* FIXME: this hack is definitely wrong -AK */
asm-x86_64/uaccess.h:	  case 1: __get_user_asm(x,ptr,retval,"b","b","=q",-EFAULT); break;\
asm-x86_64/uaccess.h:	  case 2: __get_user_asm(x,ptr,retval,"w","w","=r",-EFAULT); break;\
asm-x86_64/uaccess.h:	  case 4: __get_user_asm(x,ptr,retval,"l","k","=r",-EFAULT); break;\
asm-x86_64/uaccess.h:	  case 8: __get_user_asm(x,ptr,retval,"q","","=r",-EFAULT); break;\
asm-x86_64/mman.h:#define MAP_GROWSDOWN	0x0100		/* stack-like segment */
asm-x86_64/mman.h:#define MADV_NORMAL	0x0		/* default page-in behavior */
asm-x86_64/mman.h:#define MADV_RANDOM	0x1		/* page-in minimum required */
asm-x86_64/mman.h:#define MADV_SEQUENTIAL	0x2		/* read-ahead aggressively */
asm-x86_64/mman.h:#define MADV_WILLNEED	0x3		/* pre-fault pages */
asm-x86_64/posix_types.h: * This file is generally used by user-level software, so you need to
asm-x86_64/posix_types.h:	fdsetp->fds_bits[_tmp] |= (1UL<<_rem);
asm-x86_64/posix_types.h:	fdsetp->fds_bits[_tmp] &= ~(1UL<<_rem);
asm-x86_64/posix_types.h:	return (p->fds_bits[_tmp] & (1UL<<_rem)) != 0;
asm-x86_64/posix_types.h: * for 256 and 1024-bit fd_sets respectively)
asm-x86_64/posix_types.h:	unsigned long *tmp = p->fds_bits;
asm-x86_64/posix_types.h:		i--;
asm-x86_64/socket32.h:/* XXX This really belongs in some header file... -DaveM */
asm-x86_64/socket32.h:#define MAX_SOCK_ADDR	128		/* 108 for Unix domain - 
asm-x86_64/socket32.h:	fput(sock->file);
asm-x86_64/socket32.h:#define CMSG32_ALIGN(len) ( ((len)+sizeof(int)-1) & ~(sizeof(int)-1) )
asm-x86_64/socket32.h:#define CMSG32_FIRSTHDR(msg)	__CMSG32_FIRSTHDR((msg)->msg_control, (msg)->msg_controllen)
asm-x86_64/socket32.h:	 ((mhdr)->msg_controllen - \
asm-x86_64/socket32.h:	  ((char *)(ucmsg) - (char *)(mhdr)->msg_control)))
asm-x86_64/socket32.h:	if ((unsigned long)((char*)(__ptr+1) - (char *) __ctl) > __size)
asm-x86_64/socket32.h:	return __cmsg32_nxthdr(__msg->msg_control, __msg->msg_controllen,
asm-x86_64/mtrr.h:    Copyright (C) 1997-1999  Richard Gooch
asm-x86_64/mtrr.h:    "write-combining",          /* 1 */
asm-x86_64/mtrr.h:    "write-through",            /* 4 */
asm-x86_64/mtrr.h:    "write-protect",            /* 5 */
asm-x86_64/mtrr.h:    "write-back",               /* 6 */
asm-x86_64/mtrr.h:    return -ENODEV;
asm-x86_64/mtrr.h:    return -ENODEV;
asm-x86_64/mtrr.h:    return -ENODEV;
asm-x86_64/mtrr.h:    return -ENODEV;
asm-x86_64/smplock.h:	if (task->lock_depth >= 0) \
asm-x86_64/smplock.h: * Re-acquire the kernel lock
asm-x86_64/smplock.h:	if (task->lock_depth >= 0) \
asm-x86_64/smplock.h:	if (!++current->lock_depth)
asm-x86_64/smplock.h:		 "=m" (current->lock_depth));
asm-x86_64/smplock.h:	if (current->lock_depth < 0)
asm-x86_64/smplock.h:	if (--current->lock_depth < 0)
asm-x86_64/smplock.h:		 "=m" (current->lock_depth));
asm-x86_64/page.h:#define PAGE_MASK	(~(PAGE_SIZE-1))
asm-x86_64/page.h:#define LARGE_PAGE_MASK (~(LARGE_PAGE_SIZE-1))
asm-x86_64/page.h:#define CURRENT_MASK (~(THREAD_SIZE-1))
asm-x86_64/page.h: * These are used to make use of C type-checking..
asm-x86_64/page.h:#define PAGE_ALIGN(addr)	(((addr)+PAGE_SIZE-1)&PAGE_MASK)
asm-x86_64/page.h:	size = (size-1) >> (PAGE_SHIFT-1);
asm-x86_64/page.h:	order = -1;
asm-x86_64/page.h:#define __pa(x)			(((unsigned long)(x)>=__START_KERNEL_map)?(unsigned long)(x) - (unsigned long)__START_KERNEL_map:(unsigned long)(x) - PAGE_OFFSET)
asm-x86_64/page.h:	 v - __START_KERNEL_map; })
asm-x86_64/page.h:#define page_to_pfn(page)   ((page) - mem_map)
asm-x86_64/page.h:#define page_to_phys(page)	(((page) - mem_map) << PAGE_SHIFT)
asm-x86_64/page.h:#define VALID_PAGE(page)	(((page) - mem_map) < max_mapnr)
asm-x86_64/page.h:	((current->thread.flags & THREAD_IA32) ? vm_data_default_flags32 : \
asm-x86_64/hdreg.h: *  linux/include/asm-x86_64/hdreg.h
asm-x86_64/hdreg.h: *  Copyright (C) 1994-1996  Linus Torvalds & authors
asm-x86_64/poll.h:/* The rest seem to be more-or-less nonstandard. Check them! */
asm-x86_64/current.h:		: "0" (~(unsigned long)(THREAD_SIZE-1)));
asm-x86_64/calling.h:	movq $(1<<9),3*8(%rsp)  /* eflags - enable interrupts */
asm-x86_64/sembuf.h: * - 64-bit time_t to solve y2038 problem
asm-x86_64/sembuf.h: * - 2 miscellaneous 32-bit values
asm-x86_64/system.h:		     :"=m" (prev->thread.rsp),"=m" (prev->thread.rip), "=a" (l) \
asm-x86_64/system.h:		     :"m" (next->thread.rsp),"m" (next->thread.rip),	\
asm-x86_64/system.h: *	  but generally the primitive is invalid, *ptr is output argument. --ANK
asm-x86_64/stat.h:	long		st_blocks;	/* Number 512-byte blocks allocated. */
asm-x86_64/checksum.h: * Checksums for x86-64 
asm-x86_64/checksum.h: * with some code from asm-i386/checksum.h
asm-x86_64/checksum.h: * csum_fold - Fold and invert a 32bit checksum.
asm-x86_64/checksum.h: * ip_fast_csum - Compute the IPv4 header checksum efficiently.
asm-x86_64/checksum.h: * csum_tcpup_nofold - Compute an IPv4 pseudo header checksum.
asm-x86_64/checksum.h: * csum_tcpup_magic - Compute an IPv4 pseudo header checksum.
asm-x86_64/checksum.h: * csum_partial - Compute an internet checksum.
asm-x86_64/checksum.h: * ip_compute_csum - Compute an 16bit IP checksum.
asm-x86_64/checksum.h: * csum_ipv6_magic - Compute checksum of an IPv6 pseudo header.
asm-x86_64/rwlock.h:/* include/asm-x86_64/rwlock.h
asm-x86_64/termios.h:#define N_IRDA		11	/* Linux IR - http://irda.sourceforge.net/ */
asm-x86_64/termios.h:#define N_SMSBLOCK	12	/* SMS block mode - for talking to GSM data cards about SMS messages */
asm-x86_64/termios.h:	get_user(__tmp,&(termio)->x); \
asm-x86_64/termios.h:	*(unsigned short *) &(termios)->x = __tmp; \
asm-x86_64/termios.h:	copy_from_user((termios)->c_cc, (termio)->c_cc, NCC); \
asm-x86_64/termios.h:	put_user((termios)->c_iflag, &(termio)->c_iflag); \
asm-x86_64/termios.h:	put_user((termios)->c_oflag, &(termio)->c_oflag); \
asm-x86_64/termios.h:	put_user((termios)->c_cflag, &(termio)->c_cflag); \
asm-x86_64/termios.h:	put_user((termios)->c_lflag, &(termio)->c_lflag); \
asm-x86_64/termios.h:	put_user((termios)->c_line,  &(termio)->c_line); \
asm-x86_64/termios.h:	copy_to_user((termio)->c_cc, (termios)->c_cc, NCC); \
asm-x86_64/user.h:   DATA: The data area is stored.  We use current->end_text to
asm-x86_64/user.h:   current->brk to pick up all of the user variables, plus any memory
asm-x86_64/user.h:   is demand-zero or if a page is totally unused, we just cover the entire
asm-x86_64/user.h:   current->start_stack, so we round each of these off in order to be able
asm-x86_64/user.h: * interacting with the FXSR-format floating point environment.  Floating
asm-x86_64/user.h: * x86-64 support by Andi Kleen.
asm-x86_64/user.h:	__u32	st_space[32];	/* 8*16 bytes for each FP-reg = 128 bytes */
asm-x86_64/user.h:	__u32	xmm_space[64];	/* 16*16 bytes for each XMM-reg = 256 bytes */
asm-x86_64/user.h:/* When the kernel dumps core, it starts by dumping the user struct -
asm-x86_64/user.h:  int u_fpvalid;		/* True if math co-processor being used. */
asm-x86_64/user.h:  struct user_i387_struct i387;	/* Math Co-processor registers. */
asm-x86_64/user.h:  struct user_i387_struct* u_fpstate;	/* Math Co-processor pointer. */
asm-x86_64/serial.h: * include/asm-x86_64/serial.h
asm-x86_64/serial.h:	{ 0, BASE_BAUD, -1, 0, STD_COM_FLAGS},		/* ttySx device
asm-x86_64/pgtable.h: * the x86-64 page table tree.
asm-x86_64/pgtable.h: * x86-64 has a 4 level table setup. Generic linux MM only supports
asm-x86_64/pgtable.h:/* Caches aren't brain-dead on the intel. */
asm-x86_64/pgtable.h: * for zero-mapped memory areas etc..
asm-x86_64/pgtable.h: * PMD_SHIFT determines the size of the area a middle-level
asm-x86_64/pgtable.h:/* Find an entry in the second-level page table.. */
asm-x86_64/pgtable.h:#define ptep_get_and_clear(xp)	__pte(xchg(&(xp)->pte, 0))
asm-x86_64/pgtable.h:#define PML4_MASK	(~(PML4_SIZE-1))
asm-x86_64/pgtable.h:#define PMD_MASK	(~(PMD_SIZE-1))
asm-x86_64/pgtable.h:#define PGDIR_MASK	(~(PGDIR_SIZE-1))
asm-x86_64/pgtable.h:#define KERNEL_PGD_PTRS (PTRS_PER_PGD-USER_PGD_PTRS)
asm-x86_64/pgtable.h:#define MODULES_LEN   (MODULES_END - MODULES_VADDR)
asm-x86_64/pgtable.h:#define pages_to_mb(x) ((x) >> (20-PAGE_SHIFT))
asm-x86_64/pgtable.h:/* to find an entry in a page-table-directory. */
asm-x86_64/pgtable.h:#define pgd_index(address) ((address >> PGDIR_SHIFT) & (PTRS_PER_PGD-1))
asm-x86_64/pgtable.h:#define pgd_offset(mm, address) ((mm)->pgd+pgd_index(address))
asm-x86_64/pgtable.h:		(((address) >> PMD_SHIFT) & (PTRS_PER_PMD-1))
asm-x86_64/pgtable.h:/* Find an entry in the third-level page table.. */
asm-x86_64/pgtable.h:		((address >> PAGE_SHIFT) & (PTRS_PER_PTE - 1))
asm-x86_64/pgtable.h:#define pml4_index(address) (((address) >> PML4_SHIFT) & (PTRS_PER_PML4-1))
asm-x86_64/pgtable.h:/* Encode and de-code a swap entry */
asm-x86_64/unaligned.h: * The x86-64 can do unaligned accesses itself. 
asm-x86_64/unaligned.h: * get_unaligned - get value from possibly mis-aligned location
asm-x86_64/unaligned.h: * e.g. retrieving a u16 value from a location not u16-aligned.
asm-x86_64/unaligned.h: * put_unaligned - put value to a possibly mis-aligned location
asm-x86_64/unaligned.h: * e.g. writing a u16 value to a location not u16-aligned.
asm-x86_64/param.h:#define NOGROUP		(-1)
asm-x86_64/user32.h:	u32	st_space[20];   /* 8*10 bytes for each FP-reg = 80 bytes */
asm-x86_64/user32.h:	int	st_space[32];	/* 8*16 bytes for each FP-reg = 128 bytes */
asm-x86_64/user32.h:	int	xmm_space[32];	/* 8*16 bytes for each XMM-reg = 128 bytes */
asm-x86_64/user32.h:  int u_fpvalid;		/* True if math co-processor being used. */
asm-x86_64/user32.h:  struct user_i387_ia32_struct i387;	/* Math Co-processor registers. */
asm-x86_64/user32.h:  __u32 u_fpstate;	/* Math Co-processor pointer. */
asm-x86_64/cache.h: * include/asm-x8664/cache.h
asm-x86_64/siginfo.h:#define SI_PAD_SIZE	((SI_MAX_SIZE/sizeof(int)) - 4)
asm-x86_64/siginfo.h: * Digital reserves positive values for kernel-generated signals.
asm-x86_64/siginfo.h: * ... And Linux ignores that convention -AK.
asm-x86_64/siginfo.h:#define SI_QUEUE	-1		/* sent by sigqueue */
asm-x86_64/siginfo.h:#define SI_TIMER __SI_CODE(__SI_TIMER,-2) /* sent by timer expiration */
asm-x86_64/siginfo.h:#define SI_MESGQ	-3		/* sent by real time mesq state change */
asm-x86_64/siginfo.h:#define SI_ASYNCIO	-4		/* sent by AIO completion */
asm-x86_64/siginfo.h:#define SI_SIGIO	-5		/* sent by queued SIGIO */
asm-x86_64/siginfo.h:#define SI_TKILL	-6		/* sent by tkill system call */
asm-x86_64/siginfo.h:#define SI_FROMUSER(siptr)	((siptr)->si_code <= 0)
asm-x86_64/siginfo.h:#define SI_FROMKERNEL(siptr)	((siptr)->si_code > 0)
asm-x86_64/siginfo.h:#define BUS_ADRERR	(__SI_FAULT|2)	/* non-existant physical address */
asm-x86_64/siginfo.h:#define SIGEV_PAD_SIZE	((SIGEV_MAX_SIZE/sizeof(int)) - 4)
asm-x86_64/siginfo.h:	if (from->si_code < 0)
asm-x86_64/siginfo.h:		memcpy(to, from, 3*sizeof(int) + sizeof(from->_sifields._sigchld));
asm-x86_64/floppy.h:(!(vdma) && ((unsigned long)(a)/K_64 != ((unsigned long)(a) + (s) - 1) / K_64))
asm-x86_64/floppy.h:		    lcount; lcount--, lptr++) {
asm-x86_64/floppy.h:		printk("DMA crossing 64-K boundary %p-%p\n", addr, addr+size);
asm-x86_64/floppy.h:		return -1;
asm-x86_64/floppy.h:static int FDC2 = -1;
asm-x86_64/sockios.h:/* Socket-level I/O control calls. */
asm-x86_64/keyboard.h: *  linux/include/asm-x8664/keyboard.h
asm-x86_64/ioctl.h: * NOTE: This limits the max parameter size to 16kB -1 !
asm-x86_64/ioctl.h:#define _IOC_NRMASK	((1 << _IOC_NRBITS)-1)
asm-x86_64/ioctl.h:#define _IOC_TYPEMASK	((1 << _IOC_TYPEBITS)-1)
asm-x86_64/ioctl.h:#define _IOC_SIZEMASK	((1 << _IOC_SIZEBITS)-1)
asm-x86_64/ioctl.h:#define _IOC_DIRMASK	((1 << _IOC_DIRBITS)-1)
asm-x86_64/ioctls.h:#define TIOCGPTN	_IOR('T',0x30, unsigned int) /* Get Pty Number (of pty-mux device) */
asm-x86_64/msgbuf.h: * The msqid64_ds structure for x86-64 architecture.
asm-x86_64/msgbuf.h: * - 2 miscellaneous 64-bit values
asm-x86_64/proto.h:#define round_up(x,y) (((x) + (y) - 1) & ~((y)-1))
asm-x86_64/proto.h:#define round_down(x,y) ((x) & ~((y)-1))
asm-x86_64/socket.h:/* Security levels - as per NRL IPv6 - don't actually do anything */
asm-x86_64/socket.h:/* Nasty libc5 fixup - bletch */
asm-x86_64/socket.h:#define SOCK_RDM	4		/* reliably-delivered message	*/
asm-x86_64/debugreg.h:   debug registers.  Registers 0-3 contain the addresses we wish to trap on */
asm-x86_64/debugreg.h:#define DR_STEP		(0x4000)	/* single-step */
asm-x86_64/debugreg.h:   bits - each field corresponds to one of the four debug registers,
linux/mtd/cfi.h:/* The default case - support all but 64-bit, which has
linux/mtd/cfi.h:/* All others can use 32-bits. It's probably more efficient than
linux/mtd/cfi.h: * The exception to this is the 64-bit versions, which need an extension
linux/mtd/cfi.h:#  define CFIDEV_INTERLEAVE (cfi->interleave)
linux/mtd/cfi.h:#  define CFIDEV_INTERLEAVE (cfi->interleave)
linux/mtd/cfi.h:#  define CFIDEV_INTERLEAVE (cfi->interleave)
linux/mtd/cfi.h:#  define CFIDEV_INTERLEAVE (cfi->interleave)
linux/mtd/cfi.h:#  define CFIDEV_BUSWIDTH (map->buswidth)
linux/mtd/cfi.h:#  define CFIDEV_BUSWIDTH (map->buswidth)
linux/mtd/cfi.h:#  define CFIDEV_BUSWIDTH (map->buswidth)
linux/mtd/cfi.h:#  define CFIDEV_BUSWIDTH (map->buswidth)
linux/mtd/cfi.h:/* Vendor-Specific PRI for Intel/Sharp Extended Command Set (0x0001) */
linux/mtd/cfi.h:	struct flchip chips[0];  /* per-chip data structure for each chip */
linux/mtd/cfi.h:		return map->read8(map, addr);
linux/mtd/cfi.h:		return map->read16(map, addr);
linux/mtd/cfi.h:		return map->read32(map, addr);
linux/mtd/cfi.h:		return map->read64(map, addr);
linux/mtd/cfi.h:		map->write8(map, val, addr);
linux/mtd/cfi.h:		map->write16(map, val, addr);
linux/mtd/cfi.h:		map->write32(map, val, addr);
linux/mtd/cfi.h:		map->write64(map, val, addr);
linux/mtd/cfi.h: * If prev_val is non-null, it will be set to the value at the command address,
linux/mtd/cfi.h:	return addr - base;
linux/mtd/cfi.h:		return map->read8(map, addr);
linux/mtd/cfi.h:		return cfi16_to_cpu(map->read16(map, addr));
linux/mtd/cfi.h:		return cfi32_to_cpu(map->read32(map, addr));
linux/mtd/cfi.h:		return cfi64_to_cpu(map->read64(map, addr));
linux/mtd/map.h:   to a chip driver which deals with a mapped device - generally either
linux/mtd/map.h:   fill in the mtd->module with your own module address, and register 
linux/mtd/map.h:   The mtd->priv field will point to the struct map_info, and any further
linux/mtd/map.h:   mtd->priv->fldrv_priv field. This allows the map driver to get at 
linux/mtd/map.h:   the destructor function map->fldrv_destroy() when it's tired
linux/mtd/map.h:	   because we want mappers to be able to have quickly-accessible
linux/mtd/map.h:	   cache for the 'currently-mapped page' without the _extra_
linux/mtd/map.h:	struct map_info *map = mtd->priv;
linux/mtd/map.h:	if (map->fldrv->destroy)
linux/mtd/map.h:		map->fldrv->destroy(mtd);
linux/mtd/map.h:	if (map->fldrv->module)
linux/mtd/map.h:		__MOD_DEC_USE_COUNT(map->fldrv->module);
linux/mtd/map.h:#define ENABLE_VPP(map) do { if(map->set_vpp) map->set_vpp(map, 1); } while(0)
linux/mtd/map.h:#define DISABLE_VPP(map) do { if(map->set_vpp) map->set_vpp(map, 0); } while(0)
linux/mtd/mtd.h:#define MTD_XIP			32	// eXecute-In-Place possible
linux/mtd/mtd.h:#define MTD_OOB			64	// Out-of-band data (NAND flash)
linux/mtd/mtd.h:	/* User-space ioctl definitions */
linux/mtd/mtd.h:	// Kernel-only stuff starts here.
linux/mtd/mtd.h:	/* This stuff for eXecute-In-Place */
linux/mtd/mtd.h:	/* iovec-based read/write methods. We need these especially for NAND flash,
linux/mtd/mtd.h:	/* Chip-supported device locking */
linux/mtd/mtd.h:	/* Kernel-side ioctl definitions */
linux/mtd/mtd.h:	if (ret && ret->module && !try_inc_mod_count(ret->module))
linux/mtd/mtd.h:       if (mtd->module)
linux/mtd/mtd.h:	       __MOD_DEC_USE_COUNT(mtd->module);
linux/mtd/mtd.h:#define MTD_ERASE(mtd, args...) (*(mtd->erase))(mtd, args)
linux/mtd/mtd.h:#define MTD_POINT(mtd, a,b,c,d) (*(mtd->point))(mtd, a,b,c, (u_char **)(d))
linux/mtd/mtd.h:#define MTD_UNPOINT(mtd, arg) (*(mtd->unpoint))(mtd, (u_char *)arg)
linux/mtd/mtd.h:#define MTD_READ(mtd, args...) (*(mtd->read))(mtd, args)
linux/mtd/mtd.h:#define MTD_WRITE(mtd, args...) (*(mtd->write))(mtd, args)
linux/mtd/mtd.h:#define MTD_READV(mtd, args...) (*(mtd->readv))(mtd, args)
linux/mtd/mtd.h:#define MTD_WRITEV(mtd, args...) (*(mtd->writev))(mtd, args)
linux/mtd/mtd.h:#define MTD_READECC(mtd, args...) (*(mtd->read_ecc))(mtd, args)
linux/mtd/mtd.h:#define MTD_WRITEECC(mtd, args...) (*(mtd->write_ecc))(mtd, args)
linux/mtd/mtd.h:#define MTD_READOOB(mtd, args...) (*(mtd->read_oob))(mtd, args)
linux/mtd/mtd.h:#define MTD_WRITEOOB(mtd, args...) (*(mtd->write_oob))(mtd, args)
linux/mtd/mtd.h:#define MTD_SYNC(mtd) do { if (mtd->sync) (*(mtd->sync))(mtd);  } while (0) 
linux/mtd/compatmac.h: * becomes fully-featured.
linux/mtd/compatmac.h:/* from sysdep-2.1.h */
linux/mtd/compatmac.h:#define tty_flip_buffer_push(tty)    queue_task_irq_off(&tty->flip.tqueue, &tq_timer)
linux/mtd/compatmac.h:#define signal_pending(current)      (current->signal & ~current->blocked)
linux/mtd/compatmac.h:#define schedule_timeout(to)         do {current->timeout = jiffies + (to);schedule ();} while (0)
linux/mtd/compatmac.h:#define time_after(t1,t2)            (((long)t1-t2) > 0)
linux/mtd/compatmac.h:/* Other change in the fops are solved using pseudo-types */
linux/mtd/compatmac.h:#define blkdev_dequeue_request(req) do {CURRENT = req->next;} while (0)
linux/mtd/compatmac.h:        (atomic_inc(&(mod)->uc.usecount), (mod)->flags |= MOD_VISITED|MOD_USED_ONCE)
linux/mtd/compatmac.h:        (atomic_dec(&(mod)->uc.usecount), (mod)->flags |= MOD_VISITED)
linux/mtd/compatmac.h:        do { current->state = (state_value); } while (0)
linux/mtd/compatmac.h: * strict type-checking.. See the
linux/mtd/compatmac.h:#define complete(c) up(&(c)->s)
linux/mtd/compatmac.h:#define wait_for_completion(c) down(&(c)->s)
linux/mtd/compatmac.h:#define init_completion(c) init_MUTEX_LOCKED(&(c)->s);
linux/mtd/compatmac.h:	gp->next = gendisk_head;
linux/mtd/compatmac.h:	for (gdp = &gendisk_head; *gdp; gdp = &((*gdp)->next))
linux/mtd/compatmac.h:			gd = *gdp; *gdp = gd->next;
linux/mtd/compatmac.h:   when it was changed -- this is a PITA */
linux/mtd/compatmac.h:#define parent_ino(d) ((d)->d_parent->d_inode->i_ino)
linux/mtd/compatmac.h:#define need_resched() (current->need_resched)
linux/mtd/compatmac.h:#define set_user_nice(tsk, n) do { (tsk)->priority = 20-(n); } while(0) 
linux/mtd/compatmac.h:#define set_user_nice(tsk, n) do { (tsk)->nice = n; } while(0)
linux/mtd/compatmac.h:#define rq_data_dir(x)	((x)->cmd)
linux/mtd/compatmac.h:#define IS_REQ_CMD(req) ((req)->flags & REQ_CMD)
linux/mtd/compatmac.h:#define QUEUE_LOCK(q) ((q)->queue_lock)
linux/mtd/flashchip.h: * happens to be in - so we don't have to care whether we're on 2.2, which
linux/mtd/flashchip.h:	   a given offset, and we'll want to add the per-chip length field
linux/mtd/doc2000.h:/* Linux driver for Disk-On-Chip 2000       */
linux/mtd/doc2000.h: * On ARM, it'll be mmap'd directly with 32-bit wide accesses. 
linux/mtd/doc2000.h: * On PPC, it's mmap'd and 16-bit wide.
linux/mtd/doc2000.h:	unsigned long mfr; /* Flash IDs - only one type of flash per device */
linux/mtd/nand.h: *   01-31-2000 DMW     Created
linux/mtd/nand.h: *   09-18-2000 SJH     Moved structure out of the Disk-On-Chip drivers
linux/mtd/nand.h: *   10-11-2000 SJH     Added private NAND flash structure for driver
linux/mtd/nand.h: *   10-24-2000 SJH     Added prototype for 'nand_scan' function
linux/mtd/nand.h: *   10-29-2001 TG	changed nand_chip structure to support 
linux/mtd/nand.h: *   02-21-2002 TG	added support for different read/write adress and
linux/mtd/nand.h: *   02-26-2002 TG	added chip_delay to nand_chip structure to optimize
linux/mtd/nand.h: *   04-28-2002 TG	OOB config defines moved from nand.c to avoid duplicate
linux/mtd/nand.h: *   08-07-2002 TG	forced bad block location to byte 5 of OOB, even if
linux/mtd/nand.h: *   08-10-2002 TG	extensions to nand_chip structure to support HW-ECC
linux/mtd/nand.h: *   08-29-2002 tglx 	nand_chip structure: data_poi for selecting 
linux/mtd/nand.h: *			internal / fs-driver buffer
linux/mtd/nand.h: *			read_ecc, write_ecc extended for different oob-layout
linux/mtd/nand.h: *  11-25-2002 tglx	Added Manufacturer code FUJITSU, NATIONAL
linux/mtd/nand.h: *  IO_ADDR_R - address to read the 8 I/O lines of the flash device 
linux/mtd/nand.h: *  IO_ADDR_W - address to write the 8 I/O lines of the flash device 
linux/mtd/nand.h: *  hwcontrol - hardwarespecific function for accesing control-lines
linux/mtd/nand.h: *  dev_ready - hardwarespecific function for accesing device ready/busy line
linux/mtd/nand.h: *  waitfunc - hardwarespecific function for wait on ready
linux/mtd/nand.h: *  calculate_ecc - function for ecc calculation or readback from ecc hardware
linux/mtd/nand.h: *  correct_data - function for ecc correction, matching to ecc generator (sw/hw)
linux/mtd/nand.h: *  enable_hwecc - function to enable (reset) hardware ecc generator
linux/mtd/nand.h: *  eccmod - mode of ecc: see constants
linux/mtd/nand.h: *  eccsize - databytes used per ecc-calculation
linux/mtd/nand.h: *  chip_delay - chip dependent delay for transfering data from array to read regs (tR)
linux/mtd/nand.h: *  chip_lock - spinlock used to protect access to this structure
linux/mtd/nand.h: *  wq - wait queue to sleep on if a NAND operation is in progress
linux/mtd/nand.h: *  state - give the current state of the NAND device
linux/mtd/nand.h: *  page_shift - number of address bits in a page (column address bits)
linux/mtd/nand.h: *  data_buf - data buffer passed to/from MTD user modules
linux/mtd/nand.h: *  data_cache - data cache for redundant page access and shadow for
linux/mtd/nand.h: *  cache_page - number of last valid page in page_cache 
linux/mtd/nand.h: *  name - Identify the device type
linux/mtd/nand.h: *  id -  device ID code
linux/mtd/nand.h: *  chipshift - total number of address bits for the device which
linux/mtd/nand.h: *  page256 - denotes if flash device has 256 byte pages or not.
linux/mtd/nand.h: *  pageadrlen - number of bytes minus one needed to hold the
linux/mtd/nand.h: *  erasesize - size of an erase block in the flash device.
linux/mtd/nand.h: *  name - Manufacturer name
linux/mtd/nand.h: *  id - manufacturer ID code of device.
linux/mtd/nftl.h:#define MAX_ERASE_ZONES (8192 - 512)
linux/mtd/iflash.h:/* 28F008SA-Compatible Command Set */
linux/mtd/partitions.h: * 	For example, to force a read-only partition, simply adding 
linux/mtd/partitions.h:#define MTDPART_OFS_NXTBLK	(-2)
linux/mtd/partitions.h:#define MTDPART_OFS_APPEND	(-1)
linux/mtd/nand_ecc.h: * Creates non-inverted ECC code from line parity
linux/mtd/nand_ids.h: *   01-31-2000 DMW     Created
linux/mtd/nand_ids.h: *   09-18-2000 SJH     Moved structure out of the Disk-On-Chip drivers
linux/mtd/nand_ids.h: *   10-11-2000 SJH     Added private NAND flash structure for driver
linux/mtd/nand_ids.h: *   2000-10-13 BE      Moved out of 'nand.h' - avoids duplication.
linux/cd1400.h: *	cd1400.h  -- cd1400 UART hardware info.
linux/cd1400.h: *	Copyright (C) 1996-1998  Stallion Technologies
linux/cd1400.h: *	Copyright (C) 1994-1996  Greg Ungerer.
linux/cd1400.h: *	Define the clock pre-scalar value to be a 5 ms clock. This should be
linux/securebits.h:   inheritance of root-permissions and suid-root executablew under
linux/securebits.h:/* When set, setuid to/from uid 0 does not trigger capability-"fixes"
linux/securebits.h:   from user-level. */
linux/jffs2_fs_sb.h:					   out-of-order writing of nodes.
linux/jffs2_fs_sb.h:	struct jffs2_eraseblock *gcblock;	/* The block we're currently garbage-collecting */
linux/jffs2_fs_sb.h:#define JFFS2_SB_INFO(sb) ((struct jffs2_sb_info *) &(sb)->u)
linux/jffs2_fs_sb.h:#define JFFS2_SB_INFO(sb) (&sb->u.jffs2_sb)
linux/jffs2_fs_sb.h:#define OFNI_BS_2SFFJ(c)  ((struct super_block *) ( ((char *)c) - ((char *)(&((struct super_block *)NULL)->u)) ) )
linux/atmioc.h:/* atmioc.h - ranges for ATM-related ioctl numbers */
linux/atmioc.h:/* Written 1995-1999 by Werner Almesberger, EPFL LRC/ICA */
linux/atmioc.h: * See http://icawww1.epfl.ch/linux-atm/magic.html for the complete list of
linux/atmioc.h:/* 0xb0-0xbf: Reserved for future use */
linux/atmioc.h:#define	ATMIOC_SPECIAL	  0xf0 /* Special-purpose controls, globally unique */
linux/atmlec.h: * E.g. if MAX_LEC_ITF = 48 and NUM_TR_DEVS = 8, then lec0-lec39 are for
linux/atmlec.h: * Ethernet ELANs and lec40-lec47 are for Token Ring ELANS.
linux/ext2_fs.h: * Laboratoire MASI - Institut Blaise Pascal
linux/ext2_fs.h:					printk ("EXT2-fs DEBUG (%s, %d): %s:", \
linux/ext2_fs.h:/* First non-reserved inode for old ext2 filesystems */
linux/ext2_fs.h: * Macro-instructions used to manage several block sizes
linux/ext2_fs.h:# define EXT2_BLOCK_SIZE(s)		((s)->s_blocksize)
linux/ext2_fs.h:# define EXT2_BLOCK_SIZE(s)		(EXT2_MIN_BLOCK_SIZE << (s)->s_log_block_size)
linux/ext2_fs.h:# define EXT2_BLOCK_SIZE_BITS(s)	((s)->s_blocksize_bits)
linux/ext2_fs.h:# define EXT2_BLOCK_SIZE_BITS(s)	((s)->s_log_block_size + 10)
linux/ext2_fs.h:#define	EXT2_ADDR_PER_BLOCK_BITS(s)	((s)->u.ext2_sb.s_addr_per_block_bits)
linux/ext2_fs.h:#define EXT2_INODE_SIZE(s)		((s)->u.ext2_sb.s_inode_size)
linux/ext2_fs.h:#define EXT2_FIRST_INO(s)		((s)->u.ext2_sb.s_first_ino)
linux/ext2_fs.h:#define EXT2_INODE_SIZE(s)	(((s)->s_rev_level == EXT2_GOOD_OLD_REV) ? \
linux/ext2_fs.h:				 (s)->s_inode_size)
linux/ext2_fs.h:#define EXT2_FIRST_INO(s)	(((s)->s_rev_level == EXT2_GOOD_OLD_REV) ? \
linux/ext2_fs.h:				 (s)->s_first_ino)
linux/ext2_fs.h: * Macro-instructions used to manage fragments
linux/ext2_fs.h:# define EXT2_FRAG_SIZE(s)		((s)->u.ext2_sb.s_frag_size)
linux/ext2_fs.h:# define EXT2_FRAGS_PER_BLOCK(s)	((s)->u.ext2_sb.s_frags_per_block)
linux/ext2_fs.h:# define EXT2_FRAG_SIZE(s)		(EXT2_MIN_FRAG_SIZE << (s)->s_log_frag_size)
linux/ext2_fs.h: * Macro-instructions used to manage group descriptors
linux/ext2_fs.h:# define EXT2_BLOCKS_PER_GROUP(s)	((s)->u.ext2_sb.s_blocks_per_group)
linux/ext2_fs.h:# define EXT2_DESC_PER_BLOCK(s)		((s)->u.ext2_sb.s_desc_per_block)
linux/ext2_fs.h:# define EXT2_INODES_PER_GROUP(s)	((s)->u.ext2_sb.s_inodes_per_group)
linux/ext2_fs.h:# define EXT2_DESC_PER_BLOCK_BITS(s)	((s)->u.ext2_sb.s_desc_per_block_bits)
linux/ext2_fs.h:# define EXT2_BLOCKS_PER_GROUP(s)	((s)->s_blocks_per_group)
linux/ext2_fs.h:# define EXT2_INODES_PER_GROUP(s)	((s)->s_inodes_per_group)
linux/ext2_fs.h:/* End compression flags --- maybe not all used */	
linux/ext2_fs.h:#define EXT2_MOUNT_CHECK		0x0001	/* Do mount-time checks */
linux/ext2_fs.h:#define EXT2_MOUNT_NO_UID32		0x0200  /* Disable 32-bit UIDs */
linux/ext2_fs.h:#define test_opt(sb, opt)		((sb)->u.ext2_sb.s_mount_opt & \
linux/ext2_fs.h:#define EXT2_ERRORS_RO			2	/* Remount fs read-only */
linux/ext2_fs.h:	__u32	s_first_ino; 		/* First non-reserved inode */
linux/ext2_fs.h:	__u32	s_feature_ro_compat; 	/* readonly-compatible feature set */
linux/ext2_fs.h:	__u8	s_uuid[16];		/* 128-bit uuid for volume */
linux/ext2_fs.h:#define EXT2_SB(sb)	(&((sb)->u.ext2_sb))
linux/ext2_fs.h: * a kernel struct super_block.  This will allow us to call the feature-test
linux/ext2_fs.h:	( EXT2_SB(sb)->s_es->s_feature_compat & cpu_to_le32(mask) )
linux/ext2_fs.h:	( EXT2_SB(sb)->s_es->s_feature_ro_compat & cpu_to_le32(mask) )
linux/ext2_fs.h:	( EXT2_SB(sb)->s_es->s_feature_incompat & cpu_to_le32(mask) )
linux/ext2_fs.h:	EXT2_SB(sb)->s_es->s_feature_compat |= cpu_to_le32(mask)
linux/ext2_fs.h:	EXT2_SB(sb)->s_es->s_feature_ro_compat |= cpu_to_le32(mask)
linux/ext2_fs.h:	EXT2_SB(sb)->s_es->s_feature_incompat |= cpu_to_le32(mask)
linux/ext2_fs.h:	EXT2_SB(sb)->s_es->s_feature_compat &= ~cpu_to_le32(mask)
linux/ext2_fs.h:	EXT2_SB(sb)->s_es->s_feature_ro_compat &= ~cpu_to_le32(mask)
linux/ext2_fs.h:	EXT2_SB(sb)->s_es->s_feature_incompat &= ~cpu_to_le32(mask)
linux/ext2_fs.h:#define EXT2_DIR_ROUND 			(EXT2_DIR_PAD - 1)
linux/atmmpc.h:        uint16_t mpc_p1;   /* Shortcut-Setup Frame Count    */
linux/atmmpc.h:        uint16_t mpc_p2;   /* Shortcut-Setup Frame Time     */
linux/atmmpc.h:        uint8_t mpc_p3[8]; /* Flow-detection Protocols      */
linux/atmmpc.h:#define MPC_P1 10  /* Shortcut-Setup Frame Count  */ 
linux/atmmpc.h:#define MPC_P2 1   /* Shortcut-Setup Frame Time   */
linux/atmmpc.h:#define MPC_P3 0   /* Flow-detection Protocols    */
linux/atmmpc.h:#define HOLDING_TIME_DEFAULT 1200 /* same as MPS-p7 */
linux/atmmpc.h:#define MPC_C2 60  /* Initial Keep-Alive Lifetime */
linux/atmmpc.h:/* Message types - to MPOA daemon */
linux/atmmpc.h:/* Message types - from MPOA daemon */
linux/atmmpc.h:/* Message types - bidirectional */       
linux/atmmpc.h:#define RELOAD                301 /* kill -HUP the daemon for reload */
linux/dn.h: * SET/GET Socket options  - must match the DSO_ numbers below
linux/dn.h:#define SDF_UICPROXY    4                  /* Use uic-based proxy       */
linux/fb.h:/* 0x4607-0x460B are defined below */
linux/fb.h: * big-endian byte order if bits_per_pixel is greater than 8.
linux/fb.h:#define FB_NONSTD_HAM		1	/* Hold-And-Modify (HAM)        */
linux/fb.h:#define FBINFO_FLAG_MODULE	1	/* Low-level driver is a module */
linux/fb.h:					/* arg > 0: VESA level (arg-1) */
linux/fb.h:     *         default_mode is non-NULL?
linux/fd.h:#define FD_SIZECODE(floppy) (((((floppy)->rate&FD_SIZECODEMASK)>> 3)+ 2) %8)
linux/fd.h:#define FD_SECTSIZE(floppy) ( (floppy)->rate & FD_2M ? \
linux/fd.h:/* clear user-defined parameters */
linux/fd.h:/* set user-defined parameters for current media */
linux/fd.h:	   * ultra cheap floppies ;-)
linux/fd.h: * Auto-detection. Each drive type has eight formats which are
linux/fd.h: * (User-provided) media information is _not_ discarded after a media change
linux/fd.h: * if the corresponding keep_data flag is non-zero. Positive values are
linux/fd.h:/* flicker motor-on bit before reading a sector. Experimental */
linux/fs.h: * the file limit at runtime and only root can increase the per-process
linux/fs.h: * upper limit on files-per-process.
linux/fs.h:/* And dynamically-tunable limits and defaults: */
linux/fs.h:#define READA 2		/* read-ahead  - don't block if no resources */
linux/fs.h:#define SPECIAL 4	/* For non-blockdevice requests in request queue */
linux/fs.h: * These are the fs-independent mount-flags: up to 32 flags are supported
linux/fs.h:#define MS_RDONLY	 1	/* Mount read-only */
linux/fs.h:/* Inode flags - they have nothing to superblock flags now */
linux/fs.h:#define S_APPEND	8	/* Append-only file */
linux/fs.h: * Note that nosuid etc flags are inode-specific: setting some file-system
linux/fs.h: * flags, so these have to be checked separately. -- rmk@arm.uk.linux.org
linux/fs.h:#define __IS_FLG(inode,flg) ((inode)->i_sb->s_flags & (flg))
linux/fs.h:#define IS_RDONLY(inode) ((inode)->i_sb->s_flags & MS_RDONLY)
linux/fs.h:#define IS_SYNC(inode)		(__IS_FLG(inode, MS_SYNCHRONOUS) || ((inode)->i_flags & S_SYNC))
linux/fs.h:#define IS_QUOTAINIT(inode)	((inode)->i_flags & S_QUOTA)
linux/fs.h:#define IS_NOQUOTA(inode)	((inode)->i_flags & S_NOQUOTA)
linux/fs.h:#define IS_APPEND(inode)	((inode)->i_flags & S_APPEND)
linux/fs.h:#define IS_IMMUTABLE(inode)	((inode)->i_flags & S_IMMUTABLE)
linux/fs.h:#define IS_NOATIME(inode)	(__IS_FLG(inode, MS_NOATIME) || ((inode)->i_flags & S_NOATIME))
linux/fs.h:#define IS_DEADDIR(inode)	((inode)->i_flags & S_DEAD)
linux/fs.h:/* the read-only stuff doesn't really belong here, but any other place is
linux/fs.h:#define BLKROSET   _IO(0x12,93)	/* set device read-only (0 = read-write) */
linux/fs.h:#define BLKROGET   _IO(0x12,94)	/* get read-only status (0 = read_write) */
linux/fs.h:#define BLKRRPART  _IO(0x12,95)	/* re-read partition table */
linux/fs.h:#define BLKFRASET  _IO(0x12,100)/* set filesystem (mm/filemap.c) read-ahead */
linux/fs.h:#define BLKFRAGET  _IO(0x12,101)/* get filesystem (mm/filemap.c) read-ahead */
linux/fs.h:/* This was here just to show that the number is taken -
linux/fs.h:/* A jump here: 108-111 have been used for various private purposes. */
linux/fs.h:#define BMAP_IOCTL 1		/* obsolete - kept for compatibility */
linux/fs.h: * particularly beneficial on 32-bit processors.
linux/fs.h: * sync_buffers() and refill_freelist().  -- sct
linux/fs.h:	struct buffer_head **b_pprev;	/* doubly linked list of hash-queue */
linux/fs.h:#define __buffer_state(bh, state)	(((bh)->b_state & (1UL << BH_##state)) != 0)
linux/fs.h:#define bh_offset(bh)		((unsigned long)(bh)->b_data & ~PAGE_MASK)
linux/fs.h:#define touch_buffer(bh)	mark_page_accessed(bh->b_page)
linux/fs.h: * Attribute flags.  These should be or-ed together to figure out what
linux/fs.h: * Derek Atkins <warlord@MIT.EDU> 94-10-20
linux/fs.h:#define ATTR_FLAG_APPEND	4 	/* Append-only file */
linux/fs.h:	 * by a commit_write() call - they must be balanced
linux/fs.h:	dev_t			bd_dev;  /* not a kdev_t - it's a search key */
linux/fs.h:	struct file_operations	*i_fop;	/* former ->i_op->default_file_ops */
linux/fs.h:	inode->i_blocks += bytes >> 9;
linux/fs.h:	inode->i_bytes += bytes;
linux/fs.h:	if (inode->i_bytes >= 512) {
linux/fs.h:		inode->i_blocks++;
linux/fs.h:		inode->i_bytes -= 512;
linux/fs.h:	inode->i_blocks -= bytes >> 9;
linux/fs.h:	if (inode->i_bytes < bytes) {
linux/fs.h:		inode->i_blocks--;
linux/fs.h:		inode->i_bytes += 512;
linux/fs.h:	inode->i_bytes -= bytes;
linux/fs.h:	return (((loff_t)inode->i_blocks) << 9) + inode->i_bytes;
linux/fs.h:	inode->i_blocks = bytes >> 9;
linux/fs.h:	inode->i_bytes = bytes & 511;
linux/fs.h:	int pid;		/* pid or -pgrp where SIGIO should be sent */
linux/fs.h:#define get_file(x)	atomic_inc(&(x)->f_count)
linux/fs.h:#define file_count(x)	atomic_read(&(x)->f_count)
linux/fs.h:#define	MAX_NON_LFS	((1UL<<31) - 1)
linux/fs.h:#define MAX_LFS_FILESIZE	(((u64)PAGE_CACHE_SIZE << (BITS_PER_LONG-1))-1) 
linux/fs.h: * (or NULL for no owner - BSD locks).
linux/fs.h:#define INT_LIMIT(x)	(~((x)1 << (sizeof(x)*8 - 1)))
linux/fs.h:	 * non-directories) are allowed, but not unconnected diretories.
linux/fs.h:#define I_DIRTY_DATASYNC	2 /* Data-related inode changes pending */
linux/fs.h:#define I_DIRTY_PAGES		4 /* Data-related inode changes pending */
linux/fs.h:	(((fops) && (fops)->owner)	\
linux/fs.h:		? ( try_inc_mod_count((fops)->owner) ? (fops) : NULL ) \
linux/fs.h:	if ((fops) && (fops)->owner) \
linux/fs.h:		__MOD_DEC_USE_COUNT((fops)->owner);	\
linux/fs.h:/* Return value for VFS lock functions - tells locks.c to lock conventionally
linux/fs.h: * but no group execute bit -  an otherwise meaningless combination.
linux/fs.h:	(IS_MANDLOCK(inode) && ((inode)->i_mode & (S_ISGID | S_IXGRP)) == S_ISGID)
linux/fs.h:	if (inode->i_flock && MANDATORY_LOCK(inode))
linux/fs.h:			size < inode->i_size ? size : inode->i_size,
linux/fs.h:			(size < inode->i_size ? inode->i_size - size
linux/fs.h:			 : size - inode->i_size)
linux/fs.h:	if (inode->i_flock)
linux/fs.h:/* Invalid inode operations -- fs/bad_inode.c */
linux/fs.h:        atomic_inc(&(bh)->b_count);
linux/fs.h:        atomic_dec(&bh->b_count);
linux/fs.h: * This is called by bh->b_end_io() handlers when I/O has completed.
linux/fs.h:		set_bit(BH_Uptodate, &bh->b_state);
linux/fs.h:		clear_bit(BH_Uptodate, &bh->b_state);
linux/fs.h:#define atomic_set_buffer_clean(bh) test_and_clear_bit(BH_Dirty, &(bh)->b_state)
linux/fs.h:	buffer_insert_list(bh, &inode->i_dirty_buffers);
linux/fs.h:	buffer_insert_list(bh, &inode->i_dirty_data_buffers);
linux/fs.h:	return test_and_set_bit(BH_Dirty, &bh->b_state);
linux/fs.h:		set_bit(BH_Async, &bh->b_state);
linux/fs.h:		clear_bit(BH_Async, &bh->b_state);
linux/fs.h:	set_bit(BH_Attached, &bh->b_state);
linux/fs.h:	clear_bit(BH_Attached, &bh->b_state);
linux/fs.h:	return test_bit(BH_Attached, &bh->b_state);
linux/fs.h:	bh->b_end_io(bh, 0);
linux/fs.h:	return fsync_buffers_list(&inode->i_dirty_buffers);
linux/fs.h:	return fsync_buffers_list(&inode->i_dirty_data_buffers);
linux/fs.h:	atomic_dec(&inode->i_writecount);
linux/fs.h:		atomic_inc(&file->f_dentry->d_inode->i_writecount);
linux/fs.h:/* fs/dcache.c -- generic fs support functions */
linux/fs.h: * This should be a per-architecture thing, to allow different
linux/fs.h:	return (unsigned long)ptr > (unsigned long)-1000L;
linux/fs.h: *  - follow links at the end
linux/fs.h: *  - require a directory
linux/fs.h: *  - ending slashes ok even for nonexistent files
linux/fs.h: *  - internal "there are more path compnents" flag
linux/fs.h:	if (inode && (inode->i_state & I_NEW)) {
linux/fs.h:		 * reiserfs-specific kludge that is expected to go away ASAP.
linux/fs.h:		if (sb->s_op->read_inode2)
linux/fs.h:			sb->s_op->read_inode2(inode, opaque);
linux/fs.h:			sb->s_op->read_inode(inode);
linux/fs.h:	if (inode && (inode->i_state & I_NEW)) {
linux/fs.h:		sb->s_op->read_inode(inode);
linux/fs.h:	return bread(sb->s_dev, block, sb->s_blocksize);
linux/fs.h:	return getblk(sb->s_dev, block, sb->s_blocksize);
linux/fs.h:	return get_hash_table(sb->s_dev, block, sb->s_blocksize);
linux/fs.h: *  - serialize directory operations
linux/fs.h: *  - make sure the parent doesn't change from
linux/fs.h:	struct dentry *dir = dget(dentry->d_parent);
linux/fs.h:	down(&dir->d_inode->i_sem);
linux/fs.h:	return dget(dentry->d_parent);
linux/fs.h:	up(&dir->d_inode->i_sem);
linux/fs.h: * not equal to 1st and not equal to 2nd - the first case (target is parent of
linux/fs.h: * I _think_ that it works, but no warranties - please, look it through.
linux/fs.h:	double_down(&d1->d_inode->i_sem, &d2->d_inode->i_sem);
linux/fs.h:	double_up(&d1->d_inode->i_sem,&d2->d_inode->i_sem);
linux/hdlc/ioctl.h:	unsigned int clock_type; /* internal, external, TX-internal etc. */
linux/hdlc/ioctl.h:	unsigned int clock_type; /* internal, external, TX-internal etc. */
linux/hdlc/ioctl.h:/* PPP doesn't need any info now - supply length = 0 to ioctl */
linux/if.h: * Authors:	Original taken from Berkeley UNIX 4.3, (c) UCB 1982-1988
linux/if.h:/* Standard interface flags (netdevice->flags). */
linux/if.h:#define	IFF_POINTOPOINT	0x10		/* interface is has p-p link	*/
linux/if.h:/* Private (from user) interface flags (netdevice->priv_flags). */
linux/if.h:#define IF_PROTO_FR_ADD_ETH_PVC 0x2008	/*  Create FR Ethernet-bridged PVC */
linux/if.h:#define IF_PROTO_FR_DEL_ETH_PVC 0x2009	/*  Delete FR Ethernet-bridged PVC */
linux/if.h:#define	ifr_dstaddr	ifr_ifru.ifru_dstaddr	/* other end of p-p lnk	*/
linux/in.h:/* Standard well-defined IP protocols.  */
linux/in.h:  IPPROTO_IPV6	 = 41,		/* IPv6-in-IPv4 tunnelling		*/
linux/in.h:	(sizeof(struct ip_msfilter) - sizeof(__u32) \
linux/in.h:	(sizeof(struct group_filter) - sizeof(struct __kernel_sockaddr_storage) \
linux/in.h:  unsigned char		__pad[__SOCK_SIZE__ - sizeof(short int) -
linux/in.h:			sizeof(unsigned short int) - sizeof(struct in_addr)];
linux/in.h:#define sin_zero	__pad		/* for BSD UNIX comp. -FvK	*/
linux/ip.h:   - MAX_ROUTES value was wrong.
linux/ip.h:   - "struct route" was wrong.
linux/ip.h:   - "struct timestamp" had fatally misaligned bitfields and was completely unusable.
linux/ip.h:#define optlength(opt) (sizeof(struct ip_options) + opt->optlen)
linux/kd.h:	unsigned short charheight;	/* scan lines per character (1-32) */
linux/kd.h:#define GIO_UNIMAP	0x4B66	/* get unicode-to-font mapping from kernel */
linux/kd.h:#define PIO_UNIMAP	0x4B67	/* put unicode-to-font mapping in kernel */
linux/kd.h:/* note: 0x4B00-0x4B4E all have had a value at some time;
linux/kd.h:/* note: 0x4B60-0x4B6D, 0x4B70-0x4B72 used above */
linux/lp.h: * usr/include/linux/lp.h c.1991-1992 James Wiegand
linux/lp.h:#define LP_CAREFUL 0x0080 /* obsoleted -arca */
linux/lp.h:/* timeout for each character.  This is relative to bus cycles -- it
linux/lp.h:/* NOTE: LPCAREFUL is obsoleted and it' s always the default right now -arca */
linux/lp.h:#define LPCAREFUL   0x0609  /* call with TRUE arg to require out-of-paper, off-
linux/lp.h:   This is also used for re-checking error conditions if LP_ABORT is
linux/lp.h:/* Magic numbers for defining port-device mappings */
linux/lp.h:#define LP_PARPORT_UNSPEC -4
linux/lp.h:#define LP_PARPORT_AUTO -3
linux/lp.h:#define LP_PARPORT_OFF -2
linux/lp.h:#define LP_PARPORT_NONE -1
linux/lp.h:#define LP_IRQ(minor)	lp_table[(minor)].dev->port->irq /* interrupt # */
linux/lp.h:#define LP_BASE(x)	lp_table[(x)].dev->port->base
linux/lp.h:#define LP_PINTEN	0x10  /* high to read data in or-ed with data out */
linux/lp.h: * the value written to ports to test existence. PC-style ports will 
linux/lp.h: * return the value written. AT-style ports will return 0. so why not
linux/mm.h: * we have a virtual fs - giving a cleaner interface to the
linux/mm.h: * per VM-area/task.  A VM area is any part of the process virtual memory
linux/mm.h: * space that has a special rule for the page-fault handlers (ie a shared
linux/mm.h:	 * one of the address_space->i_mmap{,shared} lists,
linux/mm.h:#define VM_ClearReadHint(v)		(v)->vm_flags &= ~VM_READHINTMASK
linux/mm.h:#define VM_NormalReadHint(v)		(!((v)->vm_flags & VM_READHINTMASK))
linux/mm.h:#define VM_SequentialReadHint(v)	((v)->vm_flags & VM_SEQ_READ)
linux/mm.h:#define VM_RandomReadHint(v)		((v)->vm_flags & VM_RAND_READ)
linux/mm.h: * These are the virtual MM functions - opening of an area, closing and
linux/mm.h: * unmapping it (needed to keep files on disk up-to-date etc), pointer
linux/mm.h: * to the functions called when a no-page or a wp-page exception occurs. 
linux/mm.h: * beneficial on 32-bit processors.
linux/mm.h:	struct list_head list;		/* ->mapping has some page lists. */
linux/mm.h: * - cache mapping   (page->mapping)
linux/mm.h: * - disk mapping    (page->buffers)
linux/mm.h: * - page mapped in a task's page tables, each mapping
linux/mm.h:#define get_page(p)		atomic_inc(&(p)->count)
linux/mm.h:#define put_page_testzero(p) 	atomic_dec_and_test(&(p)->count)
linux/mm.h:#define page_count(p)		atomic_read(&(p)->count)
linux/mm.h:#define set_page_count(p,v) 	atomic_set(&(p)->count, v)
linux/mm.h: * Various page->flags bits:
linux/mm.h: * For the non-reserved pages, page->count denotes a reference count.
linux/mm.h: *   page->count == 0 means the page is free.
linux/mm.h: *   page->count == 1 means the page is used for exactly one purpose
linux/mm.h: * __get_free_page(). In this case the page->count is at least 1, and
linux/mm.h: * page->mapping is the pointer to the inode, and page->index is the
linux/mm.h: * page->buffers is a circular list of these buffer heads. Else,
linux/mm.h: * page->buffers == NULL.
linux/mm.h: * For pages belonging to inodes, the page->count is the number of
linux/mm.h: * mapping->clean_pages, mapping->dirty_pages and mapping->locked_pages;
linux/mm.h: * using the page->list list_head. These fields are also used for
linux/mm.h: * freelist managemet (when page->count==0).
linux/mm.h: * page->next_hash and page->pprev_hash.
linux/mm.h: * - inode pages may need to be read from disk,
linux/mm.h: * - inode pages which have been modified and are MAP_SHARED may need
linux/mm.h: * - private pages which have been modified may need to be swapped out
linux/mm.h: * to manipulate page->age and move the page across the active,
linux/mm.h: * Note that the referenced bit, the page->lru list_head and the
linux/mm.h:#define Page_Uptodate(page)	test_bit(PG_uptodate, &(page)->flags)
linux/mm.h:#define SetPageUptodate(page)	set_bit(PG_uptodate, &(page)->flags)
linux/mm.h:#define ClearPageUptodate(page)	clear_bit(PG_uptodate, &(page)->flags)
linux/mm.h:#define PageDirty(page)		test_bit(PG_dirty, &(page)->flags)
linux/mm.h:#define SetPageDirty(page)	set_bit(PG_dirty, &(page)->flags)
linux/mm.h:#define ClearPageDirty(page)	clear_bit(PG_dirty, &(page)->flags)
linux/mm.h:#define PageLocked(page)	test_bit(PG_locked, &(page)->flags)
linux/mm.h:#define LockPage(page)		set_bit(PG_locked, &(page)->flags)
linux/mm.h:#define TryLockPage(page)	test_and_set_bit(PG_locked, &(page)->flags)
linux/mm.h:#define PageChecked(page)	test_bit(PG_checked, &(page)->flags)
linux/mm.h:#define SetPageChecked(page)	set_bit(PG_checked, &(page)->flags)
linux/mm.h:#define ClearPageChecked(page)	clear_bit(PG_checked, &(page)->flags)
linux/mm.h:#define PageLaunder(page)	test_bit(PG_launder, &(page)->flags)
linux/mm.h:#define SetPageLaunder(page)	set_bit(PG_launder, &(page)->flags)
linux/mm.h:#define ClearPageLaunder(page)	clear_bit(PG_launder, &(page)->flags)
linux/mm.h:#define ClearPageArch1(page)	clear_bit(PG_arch_1, &(page)->flags)
linux/mm.h:#define ZONE_SHIFT (BITS_PER_LONG - 8)
linux/mm.h:	return zone_table[page->flags >> ZONE_SHIFT];
linux/mm.h:	page->flags &= ~(~0UL << ZONE_SHIFT);
linux/mm.h:	page->flags |= zone_num << ZONE_SHIFT;
linux/mm.h: * set_page_address to a noop for non-highmem machines, where
linux/mm.h: * The same is true for page_address() in arch-dependent code.
linux/mm.h:		(page)->virtual = (address);		\
linux/mm.h:#define page_address(page) ((page)->virtual)
linux/mm.h:	__va( (((page) - page_zone(page)->zone_mem_map) << PAGE_SHIFT)	\
linux/mm.h:			+ page_zone(page)->zone_start_paddr)
linux/mm.h:#define PageError(page)		test_bit(PG_error, &(page)->flags)
linux/mm.h:#define SetPageError(page)	set_bit(PG_error, &(page)->flags)
linux/mm.h:#define ClearPageError(page)	clear_bit(PG_error, &(page)->flags)
linux/mm.h:#define PageReferenced(page)	test_bit(PG_referenced, &(page)->flags)
linux/mm.h:#define SetPageReferenced(page)	set_bit(PG_referenced, &(page)->flags)
linux/mm.h:#define ClearPageReferenced(page)	clear_bit(PG_referenced, &(page)->flags)
linux/mm.h:#define PageTestandClearReferenced(page)	test_and_clear_bit(PG_referenced, &(page)->flags)
linux/mm.h:#define PageSlab(page)		test_bit(PG_slab, &(page)->flags)
linux/mm.h:#define PageSetSlab(page)	set_bit(PG_slab, &(page)->flags)
linux/mm.h:#define PageClearSlab(page)	clear_bit(PG_slab, &(page)->flags)
linux/mm.h:#define PageReserved(page)	test_bit(PG_reserved, &(page)->flags)
linux/mm.h:#define PageActive(page)	test_bit(PG_active, &(page)->flags)
linux/mm.h:#define SetPageActive(page)	set_bit(PG_active, &(page)->flags)
linux/mm.h:#define ClearPageActive(page)	clear_bit(PG_active, &(page)->flags)
linux/mm.h:#define PageLRU(page)		test_bit(PG_lru, &(page)->flags)
linux/mm.h:#define TestSetPageLRU(page)	test_and_set_bit(PG_lru, &(page)->flags)
linux/mm.h:#define TestClearPageLRU(page)	test_and_clear_bit(PG_lru, &(page)->flags)
linux/mm.h:#define PageHighMem(page)		test_bit(PG_highmem, &(page)->flags)
linux/mm.h:#define SetPageReserved(page)		set_bit(PG_reserved, &(page)->flags)
linux/mm.h:#define ClearPageReserved(page)		clear_bit(PG_reserved, &(page)->flags)
linux/mm.h:#define NOPAGE_OOM	((struct page *) (-1))
linux/mm.h: * There is only one page-allocator function, and two main namespaces to
linux/mm.h: * There is only one 'core' page-freeing function.
linux/mm.h: * On a two-level page table, this ends up being trivial. Thus the
linux/mm.h: * of this out-of-line.
linux/mm.h:#define PageSwapCache(page) ((page)->mapping == &swapper_space)
linux/mm.h:	return page_count(page) - !!page->buffers == 1;
linux/mm.h:	unsigned long ret = -EINVAL;
linux/mm.h:	prev->vm_next = vma->vm_next;
linux/mm.h:	rb_erase(&vma->vm_rb, &mm->mm_rb);
linux/mm.h:	if (mm->mmap_cache == vma)
linux/mm.h:		mm->mmap_cache = prev;
linux/mm.h:	if (!vma->vm_file && vma->vm_flags == vm_flags)
linux/mm.h:/* Zone modifiers in GFP_ZONEMASK (see linux/mmzone.h - low four bits) */
linux/mm.h:/* Action modifiers - doesn't change the zoning */
linux/mm.h:#define __GFP_FS	0x100	/* Can call down to low-level FS? */
linux/mm.h:/* Flag - indicates that the buffer will be suitable for DMA.  Ignored on some
linux/mm.h:	if (current->flags & PF_NOIO)
linux/mm.h:/* vma is the first one with  address < vma->vm_end,
linux/mm.h: * and even  address < vma->vm_start. Have to extend vma. */
linux/mm.h:	 * vma->vm_start/vm_end cannot change under us because the caller
linux/mm.h: 	spin_lock(&vma->vm_mm->page_table_lock);
linux/mm.h:	if (vma->vm_start <= address) {
linux/mm.h:		spin_unlock(&vma->vm_mm->page_table_lock);
linux/mm.h:	grow = (vma->vm_start - address) >> PAGE_SHIFT;
linux/mm.h:	if (vma->vm_end - address > current->rlim[RLIMIT_STACK].rlim_cur ||
linux/mm.h:	    ((vma->vm_mm->total_vm + grow) << PAGE_SHIFT) > current->rlim[RLIMIT_AS].rlim_cur) {
linux/mm.h:		spin_unlock(&vma->vm_mm->page_table_lock);
linux/mm.h:		return -ENOMEM;
linux/mm.h:	if ((vma->vm_flags & VM_LOCKED) &&
linux/mm.h:      	    ((vma->vm_mm->locked_vm + grow) << PAGE_SHIFT) > current->rlim[RLIMIT_MEMLOCK].rlim_cur) {
linux/mm.h:		spin_unlock(&vma->vm_mm->page_table_lock);
linux/mm.h:		return -ENOMEM;
linux/mm.h:	vma->vm_start = address;
linux/mm.h:	vma->vm_pgoff -= grow;
linux/mm.h:	vma->vm_mm->total_vm += grow;
linux/mm.h:	if (vma->vm_flags & VM_LOCKED)
linux/mm.h:		vma->vm_mm->locked_vm += grow;
linux/mm.h:	spin_unlock(&vma->vm_mm->page_table_lock);
linux/mm.h:/* Look up the first VMA which intersects the interval start_addr..end_addr-1,
linux/mm.h:	if (vma && end_addr <= vma->vm_start)
linux/nfsd/export.h: * Copyright (C) 1995-1997 Olaf Kirch <okir@monad.swb.de>
linux/nfsd/export.h:#define	NFSEXP_NOAUTHNLM	0x0800		/* Don't authenticate NLM requests - just trust */
linux/nfsd/export.h:#define EX_SECURE(exp)		(!((exp)->ex_flags & NFSEXP_INSECURE_PORT))
linux/nfsd/export.h:#define EX_ISSYNC(exp)		(!((exp)->ex_flags & NFSEXP_ASYNC))
linux/nfsd/export.h:#define EX_RDONLY(exp)		((exp)->ex_flags & NFSEXP_READONLY)
linux/nfsd/export.h:#define EX_NOHIDE(exp)		((exp)->ex_flags & NFSEXP_NOHIDE)
linux/nfsd/export.h:#define EX_SUNSECURE(exp)	((exp)->ex_flags & NFSEXP_SUNSECURE)
linux/nfsd/export.h:#define EX_WGATHER(exp)		((exp)->ex_flags & NFSEXP_GATHERED_WRITES)
linux/nfsd/debug.h: * Debugging-related stuff for nfsd
linux/nfsd/const.h: * Copyright (C) 1995-1997 Olaf Kirch <okir@monad.swb.de>
linux/nfsd/syscall.h: * Copyright (C) 1995-1997 Olaf Kirch <okir@monad.swb.de>
linux/nfsd/syscall.h:/* GETFS - GET Filehandle with Size */
linux/nfsd/auth.h: * nfsd-specific authentication stuff.
linux/nfsd/auth.h:#define UGID_MASK		((1 << UGID_SHIFT) - 1)
linux/nfsd/auth.h:#define UGID_NRENTRIES		((1 << (UGID_BITS - UGID_SHIFT)) + 1)
linux/nfsd/auth.h:#define UGID_NONE		((unsigned short)-1)
linux/nfsd/nfsfh.h:	__u32		fb_dcookie;	/* dentry cookie - always 0xfeebbaca */
linux/nfsd/nfsfh.h: * by Neil Brown <neilb@cse.unsw.edu.au> - March 2000
linux/nfsd/nfsfh.h: * All 4byte values are in host-byte-order.
linux/nfsd/nfsfh.h: *     0  - No authentication.  fb_auth is 0 bytes long
linux/nfsd/nfsfh.h: *     1  - 4 bytes taken from MD5 hash of the remainer of the file handle
linux/nfsd/nfsfh.h: *     0  - 4 byte device id (ms-2-bytes major, ls-2-bytes minor), 4byte inode number
linux/nfsd/nfsfh.h: *     1  - 4 byte user specified identifier
linux/nfsd/nfsfh.h: *    0   - The root, or export point, of the filesystem.  fb_fileid is 0 bytes.
linux/nfsd/nfsfh.h: *    1   - 32bit inode number, 32 bit generation number.
linux/nfsd/nfsfh.h: *    2   - 32bit inode number, 32 bit generation number, 32 bit parent directory inode number.
linux/nfsd/nfsfh.h:	unsigned char		fh_post_saved;	/* post-op attrs saved */
linux/nfsd/nfsfh.h:	unsigned char		fh_pre_saved;	/* pre-op attrs saved */
linux/nfsd/nfsfh.h:	/* Pre-op attributes saved during fh_lock */
linux/nfsd/nfsfh.h:	/* Post-op attributes saved in fh_unlock */
linux/nfsd/nfsfh.h:	struct knfsd_fh *fh = &fhp->fh_handle;
linux/nfsd/nfsfh.h:		fh->fh_size,
linux/nfsd/nfsfh.h:		fh->fh_base.fh_pad[0],
linux/nfsd/nfsfh.h:		fh->fh_base.fh_pad[1],
linux/nfsd/nfsfh.h:		fh->fh_base.fh_pad[2],
linux/nfsd/nfsfh.h:		fh->fh_base.fh_pad[3],
linux/nfsd/nfsfh.h:		fh->fh_base.fh_pad[4],
linux/nfsd/nfsfh.h:		fh->fh_base.fh_pad[5]);
linux/nfsd/nfsfh.h:	if (src->fh_dentry || src->fh_locked) {
linux/nfsd/nfsfh.h:		struct dentry *dentry = src->fh_dentry;
linux/nfsd/nfsfh.h:			dentry->d_parent->d_name.name, dentry->d_name.name);
linux/nfsd/nfsfh.h:	fhp->fh_maxsize = maxsize;
linux/nfsd/nfsfh.h:	inode = fhp->fh_dentry->d_inode;
linux/nfsd/nfsfh.h:	if (!fhp->fh_pre_saved) {
linux/nfsd/nfsfh.h:		fhp->fh_pre_mtime = inode->i_mtime;
linux/nfsd/nfsfh.h:			fhp->fh_pre_ctime = inode->i_ctime;
linux/nfsd/nfsfh.h:			fhp->fh_pre_size  = inode->i_size;
linux/nfsd/nfsfh.h:			fhp->fh_pre_saved = 1;
linux/nfsd/nfsfh.h:	struct inode    *inode = fhp->fh_dentry->d_inode;
linux/nfsd/nfsfh.h:	if (fhp->fh_post_saved)
linux/nfsd/nfsfh.h:	fhp->fh_post_mode       = inode->i_mode;
linux/nfsd/nfsfh.h:	fhp->fh_post_nlink      = inode->i_nlink;
linux/nfsd/nfsfh.h:	fhp->fh_post_uid	= inode->i_uid;
linux/nfsd/nfsfh.h:	fhp->fh_post_gid	= inode->i_gid;
linux/nfsd/nfsfh.h:	fhp->fh_post_size       = inode->i_size;
linux/nfsd/nfsfh.h:	if (inode->i_blksize) {
linux/nfsd/nfsfh.h:		fhp->fh_post_blksize    = inode->i_blksize;
linux/nfsd/nfsfh.h:		fhp->fh_post_blocks     = inode->i_blocks;
linux/nfsd/nfsfh.h:		fhp->fh_post_blksize    = BLOCK_SIZE;
linux/nfsd/nfsfh.h:		fhp->fh_post_blocks     = (inode->i_size+511) >> 9;
linux/nfsd/nfsfh.h:	fhp->fh_post_rdev       = inode->i_rdev;
linux/nfsd/nfsfh.h:	fhp->fh_post_atime      = inode->i_atime;
linux/nfsd/nfsfh.h:	fhp->fh_post_mtime      = inode->i_mtime;
linux/nfsd/nfsfh.h:	fhp->fh_post_ctime      = inode->i_ctime;
linux/nfsd/nfsfh.h:	fhp->fh_post_saved      = 1;
linux/nfsd/nfsfh.h:	struct dentry	*dentry = fhp->fh_dentry;
linux/nfsd/nfsfh.h:			SVCFH_fmt(fhp), fhp->fh_locked);
linux/nfsd/nfsfh.h:	if (!fhp->fh_dentry) {
linux/nfsd/nfsfh.h:	if (fhp->fh_locked) {
linux/nfsd/nfsfh.h:			dentry->d_parent->d_name.name, dentry->d_name.name);
linux/nfsd/nfsfh.h:	inode = dentry->d_inode;
linux/nfsd/nfsfh.h:	down(&inode->i_sem);
linux/nfsd/nfsfh.h:	fhp->fh_locked = 1;
linux/nfsd/nfsfh.h:	if (!fhp->fh_dentry)
linux/nfsd/nfsfh.h:	if (fhp->fh_locked) {
linux/nfsd/nfsfh.h:		up(&fhp->fh_dentry->d_inode->i_sem);
linux/nfsd/nfsfh.h:		fhp->fh_locked = 0;
linux/nfsd/nfsd.h: * Hodge-podge collection of knfsd-related stuff.
linux/nfsd/nfsd.h: * Copyright (C) 1995-1997 Olaf Kirch <okir@monad.swb.de>
linux/nfsd/nfsd.h:	u32 *			offset;		/* previous dirent->d_next */
linux/nfsd/nfsd.h: * These macros provide pre-xdr'ed values for faster operation.
linux/nfsd/nfsd.h:/* error code for internal use - if a request fails due to
linux/nfsd/xdr3.h: * Copyright (C) 1996-1998, Olaf Kirch <okir@monad.swb.de>
linux/pm.h: *  pm.h - Power management interface
linux/pm.h: *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
linux/pm.h:	PM_SUSPEND, /* enter D1-D3 */
linux/pm.h:	/* enable wake-on */
linux/pm.h:#define PM_PCI_ID(dev) ((dev)->bus->number << 16 | (dev)->devfn)
linux/raid/md.h:          Copyright (C) 1996-98 Ingo Molnar, Gadi Oxman
linux/raid/md.h:          Copyright (C) 1994-96 Marc ZYNGIER
linux/raid/md.h:	  <zyngier@ufr-info-p7.ibp.fr> or
linux/raid/multipath.h:	/* buffer_heads that we have pre-allocated have b_pprev -> &freebh
linux/raid/multipath.h:	 * multipath_bh that are pre-allocated have MPBH_PreAlloc set.
linux/raid/multipath.h: * C type safety. mddev->private is an 'opaque' pointer.
linux/raid/multipath.h:#define mddev_to_conf(mddev) ((multipath_conf_t *) mddev->private)
linux/raid/multipath.h:#define	MPBH_PreAlloc	3	/* this was pre-allocated, add to free list */
linux/raid/raid0.h:#define mddev_to_conf(mddev) ((raid0_conf_t *) mddev->private)
linux/raid/raid1.h:	/* buffer_heads that we have pre-allocated have b_pprev -> &freebh
linux/raid/raid1.h:	 * raid1_bh that are pre-allocated have R1BH_PreAlloc set.
linux/raid/raid1.h: * C type safety. mddev->private is an 'opaque' pointer.
linux/raid/raid1.h:#define mddev_to_conf(mddev) ((raid1_conf_t *) mddev->private)
linux/raid/raid1.h:#define	R1BH_PreAlloc	3	/* this was pre-allocated, add to free list */
linux/raid/raid5.h: * these states happen *almost* exclusively under a per-stripe
linux/raid/raid5.h: *  Empty -> Want   - on read or write to get old data for  parity calc
linux/raid/raid5.h: *  Empty -> Dirty  - on compute_parity to satisfy write/sync request.(RECONSTRUCT_WRITE)
linux/raid/raid5.h: *  Empty -> Clean  - on compute_block when computing a block for failed drive
linux/raid/raid5.h: *  Want  -> Empty  - on failed read
linux/raid/raid5.h: *  Want  -> Clean  - on successful completion of read request
linux/raid/raid5.h: *  Dirty -> Clean  - on successful completion of write request
linux/raid/raid5.h: *  Dirty -> Clean  - on failed write
linux/raid/raid5.h: *  Clean -> Dirty  - on compute_parity to satisfy write/sync (RECONSTRUCT or RMW)
linux/raid/raid5.h: * The Want->Empty, Want->Clean, Dirty->Clean, transitions
linux/raid/raid5.h: * This leaves one multi-stage transition:
linux/raid/raid5.h: *    Want->Dirty->Clean
linux/raid/raid5.h: *  - stripes on the inactive_list never have their stripe_lock held.
linux/raid/raid5.h: *  - stripes have a reference counter. If count==0, they are on a list.
linux/raid/raid5.h: *  - If a stripe might need handling, STRIPE_HANDLE is set.
linux/raid/raid5.h: *  - When refcount reaches zero, then if STRIPE_HANDLE it is put on
linux/raid/raid5.h: * cleared while a stripe has a non-zero count means that if the
linux/raid/raid5.h: *     lockdev check-hash unlink-stripe cnt++ clean-stripe hash-stripe unlockdev
linux/raid/raid5.h: *     lockdev check-hash if(!cnt++)unlink-stripe unlockdev
linux/raid/raid5.h: *     lockdev attach-buffer unlockdev
linux/raid/raid5.h: *     lockstripe clrSTRIPE_HANDLE ... (lockdev check-buffers unlockdev) .. change-state .. record io needed unlockstripe schedule io
linux/raid/raid5.h: *     lockdev if (!--cnt) { if  STRIPE_HANDLE, add to handle_list else add to inactive-list } unlockdev
linux/raid/raid5.h:	struct page		*bh_page[MD_SB_DISKS];	/* saved bh_cache[n]->b_page when reading around the cache */
linux/raid/raid5.h: * In particular, any write request that would require pre-reading
linux/raid/raid5.h: * in a pre-read phase.  Further, if the "delayed" queue is empty when
linux/raid/raid5.h: * In stripe_handle, if we find pre-reading is necessary, we do it if
linux/raid/raid5.h:#define mddev_to_conf(mddev) ((raid5_conf_t *) mddev->private)
linux/raid/md_k.h:          Copyright (C) 1996-98 Ingo Molnar, Gadi Oxman
linux/raid/md_k.h:		case MULTIPATH:		return -4;
linux/raid/md_k.h:		case HSM:		return -3;
linux/raid/md_k.h:		case TRANSLUCENT:	return -2;
linux/raid/md_k.h:		case LINEAR:		return -1;
linux/raid/md_k.h:		case -4: return MULTIPATH;
linux/raid/md_k.h:		case -3: return HSM;
linux/raid/md_k.h:		case -2: return TRANSLUCENT;
linux/raid/md_k.h:		case -1: return LINEAR;
linux/raid/md_k.h:	return d->state & (1 << MD_DISK_FAULTY);
linux/raid/md_k.h:	return d->state & (1 << MD_DISK_ACTIVE);
linux/raid/md_k.h:	return d->state & (1 << MD_DISK_SYNC);
linux/raid/md_k.h:	return d->state & (1 << MD_DISK_REMOVED);
linux/raid/md_k.h:	d->state |= (1 << MD_DISK_FAULTY);
linux/raid/md_k.h:	d->state |= (1 << MD_DISK_ACTIVE);
linux/raid/md_k.h:	d->state |= (1 << MD_DISK_SYNC);
linux/raid/md_k.h:	d->state = 0;
linux/raid/md_k.h:	d->state = (1 << MD_DISK_FAULTY) | (1 << MD_DISK_REMOVED);
linux/raid/md_k.h:	d->state &= ~(1 << MD_DISK_ACTIVE);
linux/raid/md_k.h:	d->state &= ~(1 << MD_DISK_SYNC);
linux/raid/md_k.h: * Some personalities (RAID-1, RAID-5) can have disks hot-added and
linux/raid/md_k.h: * hot-removed. Hot removal is different from failure. (failure marks
linux/raid/md_k.h: * to such operations is the 'pers->diskop()' function, can be NULL.
linux/raid/md_k.h:	return mddev->__minor;
linux/raid/md_k.h:			tmp = tmp->next, tmp->prev != &head		\
linux/raid/md_k.h:	ITERATE_RDEV_GENERIC((mddev)->disks,same_set,rdev,tmp)
linux/raid/md_k.h: * Same as above, but assumes that the device has rdev->desc_nr numbered
linux/raid/md_k.h: * from 0 to mddev->nb_dev, and iterates through rdevs in ascending order.
linux/raid/md_k.h:	for (i = 0; rdev = find_rdev_nr(mddev, i), i < mddev->nb_dev; i++)
linux/raid/md_k.h:			tmp = tmp->next, tmp->prev != &all_mddevs	\
linux/raid/md_k.h:	return down_interruptible(&mddev->reconfig_sem);
linux/raid/md_k.h:	up(&mddev->reconfig_sem);
linux/raid/md_k.h:	current->state = TASK_RUNNING;					\
linux/raid/md_k.h:	current->state = TASK_RUNNING;					\
linux/raid/md_p.h:          Copyright (C) 1996-98 Ingo Molnar, Gadi Oxman
linux/raid/md_p.h: *	   0  -    31	Constant generic RAID device information.
linux/raid/md_p.h: *        32  -    63   Generic state information.
linux/raid/md_p.h: *	  64  -   127	Personality specific information.
linux/raid/md_p.h: *	 128  -   511	12 32-words descriptors of the disks in the raid set.
linux/raid/md_p.h: *	 512  -   911	Reserved.
linux/raid/md_p.h: *	 912  -  1023	Disk specific descriptor.
linux/raid/md_p.h: *	y = (x & ~(MD_RESERVED_BYTES - 1)) - MD_RESERVED_BYTES
linux/raid/md_p.h:#define MD_NEW_SIZE_SECTORS(x)		((x & ~(MD_RESERVED_SECTORS - 1)) - MD_RESERVED_SECTORS)
linux/raid/md_p.h:#define MD_NEW_SIZE_BLOCKS(x)		((x & ~(MD_RESERVED_BLOCKS - 1)) - MD_RESERVED_BLOCKS)
linux/raid/md_p.h: * The following are counted in 32-bit words
linux/raid/md_p.h:#define MD_SB_RESERVED_WORDS		(1024 - MD_SB_GENERIC_WORDS - MD_SB_PERSONALITY_WORDS - MD_SB_DISKS_WORDS - MD_SB_DESCRIPTOR_WORDS)
linux/raid/md_p.h:	__u32 reserved[MD_SB_DESCRIPTOR_WORDS - 5];
linux/raid/md_p.h:	__u32 gstate_creserved[MD_SB_GENERIC_CONSTANT_WORDS - 16];
linux/raid/md_p.h:	__u32 events_hi;	/*  7 high-order of superblock update count   */
linux/raid/md_p.h:	__u32 events_lo;	/*  8 low-order of superblock update count    */
linux/raid/md_p.h:	__u32 events_lo;	/*  7 low-order of superblock update count    */
linux/raid/md_p.h:	__u32 events_hi;	/*  8 high-order of superblock update count   */
linux/raid/md_p.h:	__u32 gstate_sreserved[MD_SB_GENERIC_STATE_WORDS - 9];
linux/raid/md_p.h:	__u32 pstate_reserved[MD_SB_PERSONALITY_WORDS - 4];
linux/raid/md_p.h:	__u64 ev = sb->events_hi;
linux/raid/md_p.h:	return (ev<<32)| sb->events_lo;
linux/raid/md_compatible.h:#define MD_FILE_TO_INODE(file) ((file)->f_dentry->d_inode)
linux/raid/md_compatible.h:	spin_lock(&current->sigmask_lock);
linux/raid/md_compatible.h:	spin_unlock(&current->sigmask_lock);
linux/raid/md_compatible.h:        current->exit_signal = SIGCHLD;
linux/raid/md_compatible.h:        siginitsetinv(&current->blocked, sigmask(SIGKILL));
linux/raid/md_compatible.h:/* 012 - md_set_global_readahead - nowhere used */
linux/raid/md_compatible.h:#define md_need_resched(tsk) ((tsk)->need_resched)
linux/raid/linear.h:#define mddev_to_conf(mddev) ((linear_conf_t *) mddev->private)
linux/atmppp.h:/* atmppp.h - RFC2364 PPPoATM */
linux/atmppp.h: * This is for the ATM_SETBACKEND call - these are like socket families:
linux/atmppp.h: * is per-backend specific
linux/atmsap.h:/* atmsap.h - ATM Service Access Point addressing definitions */
linux/atmsap.h:/* Written 1995-1999 by Werner Almesberger, EPFL LRC/ICA */
linux/atmsap.h:#define ATM_L2_Q291	0x02	/* ITU-T Q.291 (Rec. I.441) */
linux/atmsap.h:#define ATM_L2_X25_LL	0x06	/* ITU-T X.25, link layer */
linux/atmsap.h:#define ATM_L2_X25_ML	0x07	/* ITU-T X.25, multilink */
linux/atmsap.h:#define ATM_L2_LAPB	0x08	/* Extended LAPB, half-duplex (Rec. T.71) */
linux/atmsap.h:#define ATM_L2_X75	0x0d	/* ITU-T X.75, SLP */
linux/atmsap.h:#define ATM_L2_Q922	0x0e	/* ITU-T Q.922 */
linux/atmsap.h:#define ATM_L2_USER	0x10	/* user-specified */
linux/atmsap.h:#define ATM_L2_ISO7776	0x11	/* ISO 7776 DTE-DTE */
linux/atmsap.h:#define ATM_L3_X25	0x06	/* ITU-T X.25, packet layer */
linux/atmsap.h:#define ATM_L3_X223	0x08	/* ITU-T X.223 | ISO/IEC 8878 */
linux/atmsap.h:#define ATM_L3_ISO8473	0x09	/* ITU-T X.233 | ISO/IEC 8473 */
linux/atmsap.h:#define ATM_L3_T70	0x0a	/* ITU-T T.70 minimum network layer */
linux/atmsap.h:#define ATM_L3_H310	0x0c	/* ITU-T Recommendation H.310 */
linux/atmsap.h:#define ATM_L3_H321	0x0d	/* ITU-T Recommendation H.321 */
linux/atmsap.h:#define ATM_L3_USER	0x10	/* user-specified */
linux/atmsap.h:#define ATM_HL_USER	0x02	/* user-specific */
linux/atmsap.h:#define ATM_HL_HLP	0x03	/* high layer profile - UNI 3.0 only */
linux/atmsap.h:#define ATM_HL_VENDOR	0x04	/* vendor-specific application identifier */
linux/atmsap.h: * ITU-T coded mode of operation
linux/atmsap.h:#define ATM_MC_H221	5	/* ITU-T Rec. H.221 */
linux/atmsap.h:#define ATM_MAX_HLI	8	/* maximum high-layer information length */
linux/atmsap.h:	    unsigned char window; /* window size (k), 1-127 (0 to omit) */
linux/atmsap.h:	} itu;			/* ITU-T encoding */
linux/atmsap.h:	unsigned char user;	/* user-specified l2 information */
linux/atmsap.h:	    unsigned char def_size; /* default packet size (log2), 4-12 (0 to */
linux/atmsap.h:	    unsigned char window;/* packet window size, 1-127 (0 to omit) */
linux/atmsap.h:	} itu;			/* ITU-T encoding */
linux/atmsap.h:	struct atm_bhli bhli;		/* local SAP, high-layer information */
linux/atmsap.h:					/* local SAP, low-layer info */
linux/atmsvc.h:/* atmsvc.h - ATM signaling kernel-demon interface definitions */
linux/atmsvc.h:/* Written 1995-2000 by Werner Almesberger, EPFL LRC/ICA */
linux/atmsvc.h: * Message contents: see ftp://icaftp.epfl.ch/pub/linux/atm/docs/isp-*.tar.gz
linux/ext3_fs.h: * Laboratoire MASI - Institut Blaise Pascal
linux/ext3_fs.h:#define EXT3FS_VERSION		"2.4-0.9.19"
linux/ext3_fs.h:		printk (KERN_DEBUG "EXT3-fs DEBUG (%s, %d): %s:",	\
linux/ext3_fs.h:/* First non-reserved inode for old ext3 filesystems */
linux/ext3_fs.h: * Macro-instructions used to manage several block sizes
linux/ext3_fs.h:# define EXT3_BLOCK_SIZE(s)		((s)->s_blocksize)
linux/ext3_fs.h:# define EXT3_BLOCK_SIZE(s)		(EXT3_MIN_BLOCK_SIZE << (s)->s_log_block_size)
linux/ext3_fs.h:# define EXT3_BLOCK_SIZE_BITS(s)	((s)->s_blocksize_bits)
linux/ext3_fs.h:# define EXT3_BLOCK_SIZE_BITS(s)	((s)->s_log_block_size + 10)
linux/ext3_fs.h:#define	EXT3_ADDR_PER_BLOCK_BITS(s)	((s)->u.ext3_sb.s_addr_per_block_bits)
linux/ext3_fs.h:#define EXT3_INODE_SIZE(s)		((s)->u.ext3_sb.s_inode_size)
linux/ext3_fs.h:#define EXT3_FIRST_INO(s)		((s)->u.ext3_sb.s_first_ino)
linux/ext3_fs.h:#define EXT3_INODE_SIZE(s)	(((s)->s_rev_level == EXT3_GOOD_OLD_REV) ? \
linux/ext3_fs.h:				 (s)->s_inode_size)
linux/ext3_fs.h:#define EXT3_FIRST_INO(s)	(((s)->s_rev_level == EXT3_GOOD_OLD_REV) ? \
linux/ext3_fs.h:				 (s)->s_first_ino)
linux/ext3_fs.h: * Macro-instructions used to manage fragments
linux/ext3_fs.h:# define EXT3_FRAG_SIZE(s)		((s)->u.ext3_sb.s_frag_size)
linux/ext3_fs.h:# define EXT3_FRAGS_PER_BLOCK(s)	((s)->u.ext3_sb.s_frags_per_block)
linux/ext3_fs.h:# define EXT3_FRAG_SIZE(s)		(EXT3_MIN_FRAG_SIZE << (s)->s_log_frag_size)
linux/ext3_fs.h: * Macro-instructions used to manage group descriptors
linux/ext3_fs.h:# define EXT3_BLOCKS_PER_GROUP(s)	((s)->u.ext3_sb.s_blocks_per_group)
linux/ext3_fs.h:# define EXT3_DESC_PER_BLOCK(s)		((s)->u.ext3_sb.s_desc_per_block)
linux/ext3_fs.h:# define EXT3_INODES_PER_GROUP(s)	((s)->u.ext3_sb.s_inodes_per_group)
linux/ext3_fs.h:# define EXT3_DESC_PER_BLOCK_BITS(s)	((s)->u.ext3_sb.s_desc_per_block_bits)
linux/ext3_fs.h:# define EXT3_BLOCKS_PER_GROUP(s)	((s)->s_blocks_per_group)
linux/ext3_fs.h:# define EXT3_INODES_PER_GROUP(s)	((s)->s_inodes_per_group)
linux/ext3_fs.h:/* End compression flags --- maybe not all used */
linux/ext3_fs.h:#define EXT3_INDEX_FL			0x00001000 /* hash-indexed directory */
linux/ext3_fs.h:#define EXT3_MOUNT_CHECK		0x0001	/* Do mount-time checks */
linux/ext3_fs.h:#define EXT3_MOUNT_NO_UID32		0x2000  /* Disable 32-bit UIDs */
linux/ext3_fs.h:#define test_opt(sb, opt)		((sb)->u.ext3_sb.s_mount_opt & \
linux/ext3_fs.h:#define EXT3_ERRORS_RO			2	/* Remount fs read-only */
linux/ext3_fs.h:	__u32	s_first_ino;		/* First non-reserved inode */
linux/ext3_fs.h:	__u32	s_feature_ro_compat;	/* readonly-compatible feature set */
linux/ext3_fs.h:/*68*/	__u8	s_uuid[16];		/* 128-bit uuid for volume */
linux/ext3_fs.h:#define EXT3_SB(sb)	(&((sb)->u.ext3_sb))
linux/ext3_fs.h:#define EXT3_I(inode)	(&((inode)->u.ext3_i))
linux/ext3_fs.h: * a kernel struct super_block.  This will allow us to call the feature-test
linux/ext3_fs.h:#define NEXT_ORPHAN(inode) (inode)->u.ext3_i.i_dtime
linux/ext3_fs.h:	( EXT3_SB(sb)->s_es->s_feature_compat & cpu_to_le32(mask) )
linux/ext3_fs.h:	( EXT3_SB(sb)->s_es->s_feature_ro_compat & cpu_to_le32(mask) )
linux/ext3_fs.h:	( EXT3_SB(sb)->s_es->s_feature_incompat & cpu_to_le32(mask) )
linux/ext3_fs.h:	EXT3_SB(sb)->s_es->s_feature_compat |= cpu_to_le32(mask)
linux/ext3_fs.h:	EXT3_SB(sb)->s_es->s_feature_ro_compat |= cpu_to_le32(mask)
linux/ext3_fs.h:	EXT3_SB(sb)->s_es->s_feature_incompat |= cpu_to_le32(mask)
linux/ext3_fs.h:	EXT3_SB(sb)->s_es->s_feature_compat &= ~cpu_to_le32(mask)
linux/ext3_fs.h:	EXT3_SB(sb)->s_es->s_feature_ro_compat &= ~cpu_to_le32(mask)
linux/ext3_fs.h:	EXT3_SB(sb)->s_es->s_feature_incompat &= ~cpu_to_le32(mask)
linux/ext3_fs.h:#define EXT3_DIR_ROUND			(EXT3_DIR_PAD - 1)
linux/quotaops.h: * Definitions for diskquota-operations. When diskquota is configured these
linux/quotaops.h: * macros expand to the right source-code.
linux/quotaops.h:	if (!inode->i_sb)
linux/quotaops.h:	if (sb_any_quota_enabled(inode->i_sb) && !IS_NOQUOTA(inode))
linux/quotaops.h:		inode->i_sb->dq_op->initialize(inode, -1);
linux/quotaops.h:		if (!inode->i_sb)
linux/quotaops.h:		inode->i_sb->dq_op->drop(inode);	/* Ops must be set when there's any quota... */
linux/quotaops.h:	if (sb_any_quota_enabled(inode->i_sb)) {
linux/quotaops.h:		if (inode->i_sb->dq_op->alloc_space(inode, nr, 1) == NO_QUOTA) {
linux/quotaops.h:	if (sb_any_quota_enabled(inode->i_sb)) {
linux/quotaops.h:		if (inode->i_sb->dq_op->alloc_space(inode, nr, 0) == NO_QUOTA) {
linux/quotaops.h:	if (sb_any_quota_enabled(inode->i_sb)) {
linux/quotaops.h:		if (inode->i_sb->dq_op->alloc_inode(inode, 1) == NO_QUOTA) {
linux/quotaops.h:	if (sb_any_quota_enabled(inode->i_sb))
linux/quotaops.h:		inode->i_sb->dq_op->free_space(inode, nr);
linux/quotaops.h:	if (sb_any_quota_enabled(inode->i_sb))
linux/quotaops.h:		inode->i_sb->dq_op->free_inode(inode, 1);
linux/quotaops.h:	if (sb_any_quota_enabled(inode->i_sb) && !IS_NOQUOTA(inode)) {
linux/quotaops.h:		if (inode->i_sb->dq_op->transfer(inode, iattr) == NO_QUOTA) {
linux/quotaops.h:#define DQUOT_SYNC_DEV(dev)	sync_dquots_dev(dev, -1)
linux/quotaops.h:#define DQUOT_SYNC_SB(sb)	sync_dquots_sb(sb, -1)
linux/quotaops.h:	int ret = -ENOSYS;
linux/quotaops.h:	if (sb->s_qcop && sb->s_qcop->quota_off)
linux/quotaops.h:		ret = sb->s_qcop->quota_off(sb, -1);
linux/quotaops.h: * NO-OP when quota not configured.
linux/quotaops.h:#define DQUOT_PREALLOC_BLOCK_NODIRTY(inode, nr)	DQUOT_PREALLOC_SPACE_NODIRTY(inode, ((qsize_t)(nr)) << (inode)->i_sb->s_blocksize_bits)
linux/quotaops.h:#define DQUOT_PREALLOC_BLOCK(inode, nr)	DQUOT_PREALLOC_SPACE(inode, ((qsize_t)(nr)) << (inode)->i_sb->s_blocksize_bits)
linux/quotaops.h:#define DQUOT_ALLOC_BLOCK_NODIRTY(inode, nr) DQUOT_ALLOC_SPACE_NODIRTY(inode, ((qsize_t)(nr)) << (inode)->i_sb->s_blocksize_bits)
linux/quotaops.h:#define DQUOT_ALLOC_BLOCK(inode, nr) DQUOT_ALLOC_SPACE(inode, ((qsize_t)(nr)) << (inode)->i_sb->s_blocksize_bits)
linux/quotaops.h:#define DQUOT_FREE_BLOCK_NODIRTY(inode, nr) DQUOT_FREE_SPACE_NODIRTY(inode, ((qsize_t)(nr)) << (inode)->i_sb->s_blocksize_bits)
linux/quotaops.h:#define DQUOT_FREE_BLOCK(inode, nr) DQUOT_FREE_SPACE(inode, ((qsize_t)(nr)) << (inode)->i_sb->s_blocksize_bits)
linux/netfilter_arp/arp_tables.h:#define ARPT_RETURN (-NF_MAX_VERDICT - 1)
linux/netfilter_arp/arp_tables.h:	return (void *)e + e->target_offset;
linux/netfilter_arp/arp_tables.h:	for (__i = 0; __i < (size); __i += __entry->next_offset) { \
linux/netfilter_arp/arp_tables.h:#define ARPT_ALIGN(s) (((s) + (__alignof__(struct arpt_entry)-1)) & ~(__alignof__(struct arpt_entry)-1))
linux/adb_mouse.h: * 27-10-97 Michael Schmitz
linux/bfs_fs_sb.h: * BFS file system in-core superblock info
linux/bfs_fs_sb.h:	struct bfs_super_block * si_bfs_sb;	/* superblock in si_sbh->b_data */
linux/intermezzo_idl.h:/* -*- mode: c; c-basic-offset: 8; indent-tabs-mode: nil; -*-
linux/intermezzo_idl.h: *   This file is part of InterMezzo, http://www.inter-mezzo.org.
linux/intermezzo_idl.h: * - upcalls
linux/intermezzo_idl.h: * - ioctl's
linux/intermezzo_idl.h: * - KML records
linux/intermezzo_idl.h: * - RCVD records
linux/intermezzo_idl.h: * - rpc's
linux/intermezzo_idl.h:/* XXX - document how clean shutdowns are recorded */
linux/if_hippi.h:#define HIPPI_ALEN	6		/* Bytes in one HIPPI hw-addr	   */
linux/umsdos_fs.h:#define UMSDOS_EMD_FILE		"--linux-.---"
linux/umsdos_fs.h:#define UMSDOS_DOS_SETUP   _IO(0x04,219)	/* Set the defaults of the MS-DOS driver. */
linux/umsdos_fs.h:#define EDM_ENTRY_ISUSED(e) ((e)->name_len!=0)
linux/intermezzo_lib.h:/* -*- mode: c; c-basic-offset: 8; indent-tabs-mode: nil; -*-
linux/intermezzo_lib.h: *   This file is part of InterMezzo, http://www.inter-mezzo.org.
linux/intermezzo_lib.h:                return -EFAULT;                 \
linux/intermezzo_lib.h:                return -EFAULT;                 \
linux/intermezzo_lib.h:                return -EFAULT;                 \
linux/intermezzo_lib.h:                return -EFAULT;                         \
linux/intermezzo_lib.h:        if ( *((char *)ptr - size_round(len+1) + len) != '\0')  \
linux/intermezzo_lib.h:                        return -EFAULT;                         \
linux/coda_cache.h:/* Coda filesystem -- Linux Minicache
linux/coda_cache.h: * Copyright (C) 1989 - 1997 Carnegie Mellon University
linux/delay.h: * Delay routines, using a pre-computed "loops_per_jiffy" value.
linux/delay.h:	return (j + (HZ / 1000) - 1)/(HZ / 1000);
linux/delay.h:	return (j*1000 + (HZ - 1000))/(HZ / 1000);
linux/delay.h:	return (m + (1000 / HZ) - 1) / (1000 / HZ);
linux/delay.h: * specific values can be defined in asm-???/delay.h as an override.
linux/delay.h: * while loop for the common cases where n <= MAX_UDELAY_MS  --  Paul G.
linux/delay.h:	{unsigned long msec=(n); while (msec--) udelay(1000);})
linux/delay.h:	({unsigned long msec=(n); while (msec--) udelay(1000);}))
linux/atm_idt77105.h:/* atm_idt77105.h - Driver-specific declarations of the IDT77105 driver (for
linux/atm_idt77105.h: * use by driver-specific utilities) */
linux/atari_rootsec.h: * by Andreas Schwab (schwab@ls5.informatik.uni-dortmund.de)
linux/atari_rootsec.h: * by Guenther Kelleter (guenther@pool.informatik.rwth-aachen.de)
linux/atari_rootsec.h:  struct partition_info icdpart[8];	/* info for ICD-partitions 5..12 */
linux/serialP.h:#define CONFIGURED_SERIAL_PORT(info) ((info)->port || ((info)->iomem_base))
linux/serialP.h: * Events are used to schedule things to happen at timer-interrupt
linux/serialP.h: * Multiport serial configuration structure --- internal structure
linux/serialP.h:/* Use the irq resource table instead of dev->irq */
linux/sysv_fs_sb.h: * SystemV/V7/Coherent super-block data in memory
linux/sysv_fs_sb.h:	unsigned int   s_inodes_per_block_1;	/* inodes_per_block - 1 */
linux/sysv_fs_sb.h:	u16            *s_sb_fic_count;	/* pointer to s_sbd->s_ninode */
linux/sysv_fs_sb.h:        u16            *s_sb_fic_inodes; /* pointer to s_sbd->s_inode */
linux/sysv_fs_sb.h:	u16            *s_sb_total_free_inodes; /* pointer to s_sbd->s_tinode */
linux/sysv_fs_sb.h:	u16            *s_bcache_count;	/* pointer to s_sbd->s_nfree */
linux/sysv_fs_sb.h:	u32	       *s_bcache;	/* pointer to s_sbd->s_free */
linux/sysv_fs_sb.h:	u32            *s_free_blocks;	/* pointer to s_sbd->s_tfree */
linux/sysv_fs_sb.h:	u32            *s_sb_time;	/* pointer to s_sbd->s_time */
linux/sysv_fs_sb.h:	u32            *s_sb_state;	/* pointer to s_sbd->s_state, only FSTYPE_SYSV */
linux/sysv_fs_sb.h:	u32            s_firstdatazone;	/* same as s_sbd->s_isize */
linux/sysv_fs_sb.h:	u32            s_nzones;	/* same as s_sbd->s_fsize */
linux/kbd_kern.h: * kbd->xxx contains the VC-local things (flag settings etc..)
linux/kbd_kern.h:/* 8 modifiers - the names do not have any meaning at all;
linux/kbd_kern.h:	unsigned char ledmode:2; 	/* one 2-bit value */
linux/kbd_kern.h:#define VC_SCROLLOCK	0	/* scroll-lock mode */
linux/kbd_kern.h:	unsigned char kbdmode:2;	/* one 2-bit value */
linux/kbd_kern.h:#define VC_CRLF		3	/* 0 - enter sends CR, 1 - enter sends CRLF */
linux/kbd_kern.h:#define VC_META		4	/* 0 - meta, 1 - meta=prefix with ESC */
linux/kbd_kern.h:	return ((kbd->modeflags >> flag) & 1);
linux/kbd_kern.h:	return ((kbd->ledflagstate >> flag) & 1);
linux/kbd_kern.h:	kbd->modeflags |= 1 << flag;
linux/kbd_kern.h:	kbd->ledflagstate |= 1 << flag;
linux/kbd_kern.h:	kbd->modeflags &= ~(1 << flag);
linux/kbd_kern.h:	kbd->ledflagstate &= ~(1 << flag);
linux/kbd_kern.h:	kbd->lockstate ^= 1 << flag;
linux/kbd_kern.h:	kbd->slockstate ^= 1 << flag;
linux/kbd_kern.h:	kbd->modeflags ^= 1 << flag;
linux/kbd_kern.h:	kbd->ledflagstate ^= 1 << flag;
linux/kbd_kern.h:	schedule_task(&t->flip.tqueue);
linux/mc146818rtc.h:/* mc146818rtc.h - register definitions for the Real-Time-Clock / CMOS RAM
linux/mc146818rtc.h: * Copyright Torsten Duwe <duwe@informatik.uni-erlangen.de> 1993
linux/mc146818rtc.h:#include <linux/rtc.h>			/* get the user-level API */
linux/mc146818rtc.h:/* control registers - Moto names
linux/mc146818rtc.h:/* update-in-progress  - set to "1" 244 microsecs before RTC goes off the bus,
linux/mc146818rtc.h:# define RTC_UIE 0x10		/* update-finished interrupt enable */
linux/mc146818rtc.h:# define RTC_SQWE 0x08		/* enable square-wave output */
linux/mc146818rtc.h:# define RTC_24H 0x02		/* 24 hour mode - else hours bit 7 means pm */
linux/mc146818rtc.h:# define RTC_DST_EN 0x01	/* auto switch DST - works f. USA only */
linux/mc146818rtc.h:/* caution - cleared by read */
linux/ac97_codec.h:/* range 0x3c-0x58 - MODEM */
linux/ac97_codec.h:/* registers 0x005a - 0x007a are vendor reserved */
linux/ac97_codec.h:#define AC97_GP_RLBK              0x0400       /* Remote Loopback - Modem line codec */
linux/ac97_codec.h:#define AC97_GP_LLBK              0x0800       /* Local Loopback - Modem Line codec */
linux/ac97_codec.h:#define AC97_EA_DRA               0x0002       /* Double-rate audio enable bit */
linux/ac97_codec.h:#define AC97_PWR_PR4              0x1000       /* AC-link powerdown */
linux/ac97_codec.h:#define AC97_PWR_PR7              0x8000       /* Modem off - if supported */
linux/ac97_codec.h:                                    (CODEC)->supported_mixers & (1<<FOO) )
linux/ac97_codec.h:	   must be re-entrant safe */
linux/ac97_codec.h:	/* Wait for codec-ready.  Ok to sleep here.  */
linux/vt_kern.h:#define vc_resize_all(l, c) vc_resize(l, c, 0, MAX_NR_CONSOLES-1)
linux/ufs_fs.h: * Adrian Rodriguez (adrian@franklins-tower.rutgers.edu)
linux/ufs_fs.h: * 64-bit clean thanks to Maciej W. Rozycki <macro@ds2.pg.gda.pl>
linux/ufs_fs.h: * on code by Martin von Loewis <martin@mira.isdn.cs.tu-berlin.de>.
linux/ufs_fs.h:#define UFS_NDIR_FRAGMENT (UFS_NDADDR << uspi->s_fpbshift)
linux/ufs_fs.h:#define UFS_IND_FRAGMENT (UFS_IND_BLOCK << uspi->s_fpbshift)
linux/ufs_fs.h:#define UFS_DIND_FRAGMENT (UFS_DIND_BLOCK << uspi->s_fpbshift)
linux/ufs_fs.h:#define UFS_TIND_FRAGMENT (UFS_TIND_BLOCK << uspi->s_fpbshift)
linux/ufs_fs.h:#define UFS_42INODEFMT	-1
linux/ufs_fs.h:#define ufs_fsbtodb(uspi, b)	((b) << (uspi)->s_fsbtodb)
linux/ufs_fs.h:#define	ufs_dbtofsb(uspi, b)	((b) >> (uspi)->s_fsbtodb)
linux/ufs_fs.h:#define	ufs_cgbase(c)	(uspi->s_fpg * (c))
linux/ufs_fs.h:#define ufs_cgstart(c)	(ufs_cgbase(c)  + uspi->s_cgoffset * ((c) & ~uspi->s_cgmask))
linux/ufs_fs.h:#define	ufs_cgsblock(c)	(ufs_cgstart(c) + uspi->s_sblkno)	/* super blk */
linux/ufs_fs.h:#define	ufs_cgcmin(c)	(ufs_cgstart(c) + uspi->s_cblkno)	/* cg block */
linux/ufs_fs.h:#define	ufs_cgimin(c)	(ufs_cgstart(c) + uspi->s_iblkno)	/* inode blk */
linux/ufs_fs.h:#define	ufs_cgdmin(c)	(ufs_cgstart(c) + uspi->s_dblkno)	/* 1st data */
linux/ufs_fs.h:#define	ufs_inotocg(x)		((x) / uspi->s_ipg)
linux/ufs_fs.h:#define	ufs_inotocgoff(x)	((x) % uspi->s_ipg)
linux/ufs_fs.h:#define	ufs_inotofsba(x)	(ufs_cgimin(ufs_inotocg(x)) + ufs_inotocgoff(x) / uspi->s_inopf)
linux/ufs_fs.h:#define	ufs_inotofsbo(x)	((x) % uspi->s_inopf)
linux/ufs_fs.h:#define	ufs_dtog(d)	((d) / uspi->s_fpg)
linux/ufs_fs.h:#define	ufs_dtogd(d)	((d) % uspi->s_fpg)
linux/ufs_fs.h:	((bno) * uspi->s_nspf / uspi->s_spc)
linux/ufs_fs.h:	((((bno) * uspi->s_nspf % uspi->s_spc / uspi->s_nsect \
linux/ufs_fs.h:	* uspi->s_trackskew + (bno) * uspi->s_nspf % uspi->s_spc \
linux/ufs_fs.h:	% uspi->s_nsect * uspi->s_interleave) % uspi->s_nsect \
linux/ufs_fs.h:	* uspi->s_nrpos) / uspi->s_npsect)
linux/ufs_fs.h:#define ufs_blkoff(loc)		((loc) & uspi->s_qbmask)
linux/ufs_fs.h:#define ufs_fragoff(loc)	((loc) & uspi->s_qfmask)
linux/ufs_fs.h:#define ufs_lblktosize(blk)	((blk) << uspi->s_bshift)
linux/ufs_fs.h:#define ufs_lblkno(loc)		((loc) >> uspi->s_bshift)
linux/ufs_fs.h:#define ufs_numfrags(loc)	((loc) >> uspi->s_fshift)
linux/ufs_fs.h:#define ufs_blkroundup(size)	(((size) + uspi->s_qbmask) & uspi->s_bmask)
linux/ufs_fs.h:#define ufs_fragroundup(size)	(((size) + uspi->s_qfmask) & uspi->s_fmask)
linux/ufs_fs.h:#define ufs_fragstoblks(frags)	((frags) >> uspi->s_fpbshift)
linux/ufs_fs.h:#define ufs_blkstofrags(blks)	((blks) << uspi->s_fpbshift)
linux/ufs_fs.h:#define ufs_fragnum(fsb)	((fsb) & uspi->s_fpbmask)
linux/ufs_fs.h:#define ufs_blknum(fsb)		((fsb) & ~uspi->s_fpbmask)
linux/ufs_fs.h:#define UFS_DIR_ROUND			(UFS_DIR_PAD - 1)
linux/ufs_fs.h:	__u32	fs_sblkno;	/* addr of super-block in filesys */
linux/ufs_fs.h:	__u32	fs_cblkno;	/* offset of cyl-block in filesys */
linux/ufs_fs.h:	__u32	fs_iblkno;	/* offset of inode-blocks in filesys */
linux/ufs_fs.h:	__u32	fs_time;	/* last time written -- time_t */
linux/ufs_fs.h:/* this data must be re-computed after crashes */
linux/ufs_fs.h:	__s8	fs_ronly;	/* mounted read-only flag */
linux/ufs_fs.h:			__s32	fs_inodefmt;	/* format of on-disk inodes */
linux/ufs_fs.h:#define UFS_42POSTBLFMT		-1	/* 4.2BSD rotational table format */
linux/ufs_fs.h:	u.ufs_sb.s_csp[(indx) >> uspi->s_csshift][(indx) & ~uspi->s_csmask]
linux/ufs_fs.h: * super block lock fs->fs_lock.
linux/ufs_fs.h:	(fs32_to_cpu((sb), (ucg)->cg_magic) == CG_MAGIC)
linux/ufs_fs.h: * structure of an on-disk inode
linux/ufs_fs.h:	__u32	ui_flags;		/* 0x64 immutable, append-only... */
linux/ufs_fs.h:#define UFS_UF_APPEND     0x00000004  /* append-only */
linux/ufs_fs.h:#define UFS_SF_APPEND     0x00040000  /* append-only */
linux/if_packet.h:/* Value 4 is still used by obsolete turbo-packet. */
linux/if_packet.h:#define TPACKET_ALIGN(x)	(((x)+TPACKET_ALIGNMENT-1)&~(TPACKET_ALIGNMENT-1))
linux/if_packet.h:   - Start. Frame must be aligned to TPACKET_ALIGNMENT=16
linux/if_packet.h:   - struct tpacket_hdr
linux/if_packet.h:   - pad to TPACKET_ALIGNMENT=16
linux/if_packet.h:   - struct sockaddr_ll
linux/if_packet.h:   - Gap, chosen so that packet data (Start+tp_net) alignes to TPACKET_ALIGNMENT=16
linux/if_packet.h:   - Start+tp_mac: [ Optional MAC header ]
linux/if_packet.h:   - Start+tp_net: Packet data, aligned to TPACKET_ALIGNMENT=16.
linux/if_packet.h:   - Pad to align to TPACKET_ALIGNMENT=16
linux/parport.h:/* Start off with user-visible constants */
linux/parport.h:#define PARPORT_IRQ_NONE  -1
linux/parport.h:#define PARPORT_DMA_NONE  -1
linux/parport.h:#define PARPORT_IRQ_AUTO  -2
linux/parport.h:#define PARPORT_DMA_AUTO  -2
linux/parport.h:#define PARPORT_DMA_NOFIFO -3
linux/parport.h:#define PARPORT_DISABLE   -2
linux/parport.h:#define PARPORT_IRQ_PROBEONLY -3
linux/parport.h:#define PARPORT_IOHI_AUTO -1
linux/parport.h:/* Type classes for Plug-and-Play probe.  */
linux/parport.h:	PARPORT_CLASS_LEGACY = 0,       /* Non-IEEE1284 device */
linux/parport.h:#define IEEE1284_MODE_ECPSWE            (1<<10) /* Software-emulated */
linux/parport.h:#define IEEE1284_MODE_EPPSWE            (1<<12) /* Software-emulated */
linux/parport.h:						 * bits 0-6. */
linux/parport.h:	/* IBM PC-style virtual registers. */
linux/parport.h: *     refuses.  Do not call parport_release() - the kernel will do this
linux/parport.h: *  2) a wake-up function, called by the resource manager to tell drivers
linux/parport.h:	unsigned long waiting;		 /* long req'd for set_bit --RR */
linux/parport.h:	unsigned long base_hi;  /* base address (hi - ECR) */
linux/parport.h:	int irq;		/* interrupt (or -1 for none) */
linux/parport.h:				/* If this is a non-default mux
linux/parport.h:	struct parport_device_info probe_info[5]; /* 0-3 + non-IEEE1284.3 */
linux/parport.h:	int number;		/* port index - the `n' in `parportn' */
linux/parport.h:/* Once a registered port is ready for high-level drivers to use, the
linux/parport.h:   low-level driver that registered it should announce it.  This will
linux/parport.h:   call the high-level drivers' attach() functions (after things like
linux/parport.h:/* Register a new high-level driver. */
linux/parport.h:/* Unregister a high-level driver. */
linux/parport.h:   - pf is the preemption function (may be NULL for no callback)
linux/parport.h:   - kf is the wake-up function (may be NULL for no callback)
linux/parport.h:   - irq_func is the interrupt handler (may be NULL for no interrupts)
linux/parport.h:   - handle is a user pointer that gets handed to callback functions.  */
linux/parport.h:   driver.  This may fail (return non-zero) if another driver is busy.
linux/parport.h:   be claimed.  Return value is 1 if it slept, 0 normally and -errno
linux/parport.h:   re-claiming the port.  If you mess with the port state (enabling
linux/parport.h: * parport_yield - relinquish a parallel port temporarily
linux/parport.h:	unsigned long int timeslip = (jiffies - dev->time);
linux/parport.h:	if ((dev->port->waithead == NULL) || (timeslip < dev->timeslice))
linux/parport.h: * parport_yield_blocking - relinquish a parallel port temporarily
linux/parport.h:	unsigned long int timeslip = (jiffies - dev->time);
linux/parport.h:	if ((dev->port->waithead == NULL) || (timeslip < dev->timeslice))
linux/parport.h:   int devnum = -1;
linux/parport.h:   while ((devnum = parport_find_class (PARPORT_CLASS_DIGCAM, devnum)) != -1) {
linux/parport.h:	read_lock(&port->cad_lock);
linux/parport.h:	if (port->cad && port->cad->irq_func)
linux/parport.h:		port->cad->irq_func(irq, port->cad->private, regs);
linux/parport.h:	read_unlock(&port->cad_lock);
linux/parport.h:#define parport_write_data(p,x)            (p)->ops->write_data(p,x)
linux/parport.h:#define parport_read_data(p)               (p)->ops->read_data(p)
linux/parport.h:#define parport_write_control(p,x)         (p)->ops->write_control(p,x)
linux/parport.h:#define parport_read_control(p)            (p)->ops->read_control(p)
linux/parport.h:#define parport_frob_control(p,m,v)        (p)->ops->frob_control(p,m,v)
linux/parport.h:#define parport_read_status(p)             (p)->ops->read_status(p)
linux/parport.h:#define parport_enable_irq(p)              (p)->ops->enable_irq(p)
linux/parport.h:#define parport_disable_irq(p)             (p)->ops->disable_irq(p)
linux/parport.h:#define parport_data_forward(p)            (p)->ops->data_forward(p)
linux/parport.h:#define parport_data_reverse(p)            (p)->ops->data_reverse(p)
linux/b1lli.h: * ISDN lowlevel-module for AVM B1-card.
linux/b1lli.h: * Copyright 1996 by Carsten Paeth (calle@calle.in-berlin.de)
linux/zftape.h: * Copyright (C) 1996, 1997 Claus-Justus Heine.
linux/zftape.h: * $Source: /home/cvsroot/RT288x_SDK/source/linux-2.4.x/include/ack,v $
linux/zftape.h: *      interface for the QIC-40/80/3010/3020 floppy-tape driver for
linux/zftape.h:#define ZFTAPE_LABEL       "Ftape - The Linux Floppy Tape Project!"
linux/zftape.h:		return (__s64)(((__u32)(value >> 10) + (blk_sz >> 10) - 1) 
linux/binfmts.h:/* sizeof(linux_binprm->buf) */
linux/if_frad.h: *					re-arranged flags
linux/crypto.h: * Transforms: user-instantiated objects which encapsulate algorithms
linux/crypto.h:	return tfm->__crt_alg->cra_name;
linux/crypto.h:	struct crypto_alg *alg = tfm->__crt_alg;
linux/crypto.h:	if (alg->cra_module)
linux/crypto.h:		return alg->cra_module->name;
linux/crypto.h:	return tfm->__crt_alg->cra_flags & CRYPTO_ALG_TYPE_MASK;
linux/crypto.h:	return tfm->__crt_alg->cra_cipher.cia_min_keysize;
linux/crypto.h:	return tfm->__crt_alg->cra_cipher.cia_max_keysize;
linux/crypto.h:	return tfm->crt_cipher.cit_ivsize;
linux/crypto.h:	return tfm->__crt_alg->cra_blocksize;
linux/crypto.h:	return tfm->__crt_alg->cra_digest.dia_digestsize;
linux/crypto.h:	tfm->crt_digest.dit_init(tfm);
linux/crypto.h:	tfm->crt_digest.dit_update(tfm, sg, nsg);
linux/crypto.h:	tfm->crt_digest.dit_final(tfm, out);
linux/crypto.h:	tfm->crt_digest.dit_digest(tfm, sg, nsg, out);
linux/crypto.h:	if (tfm->crt_digest.dit_setkey == NULL)
linux/crypto.h:		return -ENOSYS;
linux/crypto.h:	return tfm->crt_digest.dit_setkey(tfm, key, keylen);
linux/crypto.h:	return tfm->crt_cipher.cit_setkey(tfm, key, keylen);
linux/crypto.h:	return tfm->crt_cipher.cit_encrypt(tfm, dst, src, nbytes);
linux/crypto.h:	BUG_ON(tfm->crt_cipher.cit_mode == CRYPTO_TFM_MODE_ECB);
linux/crypto.h:	return tfm->crt_cipher.cit_encrypt_iv(tfm, dst, src, nbytes, iv);
linux/crypto.h:	return tfm->crt_cipher.cit_decrypt(tfm, dst, src, nbytes);
linux/crypto.h:	BUG_ON(tfm->crt_cipher.cit_mode == CRYPTO_TFM_MODE_ECB);
linux/crypto.h:	return tfm->crt_cipher.cit_decrypt_iv(tfm, dst, src, nbytes, iv);
linux/crypto.h:	memcpy(tfm->crt_cipher.cit_iv, src, len);
linux/crypto.h:	memcpy(dst, tfm->crt_cipher.cit_iv, len);
linux/crypto.h:	return tfm->crt_compress.cot_compress(tfm, src, slen, dst, dlen);
linux/crypto.h:	return tfm->crt_compress.cot_decompress(tfm, src, slen, dst, dlen);
linux/romfs_fs_sb.h:/* romfs superblock in-core data */
linux/ext3_fs_sb.h: * Laboratoire MASI - Institut Blaise Pascal
linux/ext3_fs_sb.h: * third extended-fs super-block data in memory
linux/ext3_fs_sb.h:	struct timer_list turn_ro_timer;	/* For turning read-only (crash simulation) */
linux/ext3_fs_sb.h:	wait_queue_head_t ro_wait_queue;	/* For people waiting for the fs to go read-only */
linux/nfs_fs_i.h:	 * read_cache_jiffies is when we started read-caching this inode,
linux/nfs_fs_i.h:	 *	jiffies - read_cache_jiffies > attrtimeo
linux/elevator.h: * over writes any more --- although reads are more time-critical than
linux/elevator.h: * This turns out to give better overall performance.  -- sct
linux/elevator.h:	((((s1)->rq_dev == (s2)->rq_dev &&	\
linux/elevator.h:	   (s1)->sector < (s2)->sector)) ||	\
linux/elevator.h:	 (s1)->rq_dev < (s2)->rq_dev)
linux/elevator.h:	((((bh)->b_rdev == (rq)->rq_dev &&	\
linux/elevator.h:	   (bh)->b_rsector < (rq)->sector)) ||	\
linux/elevator.h:	 (bh)->b_rdev < (rq)->rq_dev)
linux/elevator.h:	latency = elevator->read_latency;
linux/elevator.h:		latency = elevator->write_latency;
linux/atmbr2684.h:#define BR2684_MEDIA_TR		(2)	/* 802.5 - token ring */
linux/atmbr2684.h:#define BR2684_ENCAPS_VC	(0)	/* VC-mux */
linux/atmbr2684.h: * This is for the ATM_NEWBACKENDIF call - these are like socket families:
linux/atmbr2684.h: * is per-backend specific
linux/atmbr2684.h: * This structure is used to specify a br2684 interface - either by a
linux/atmbr2684.h: * This is for the ATM_SETBACKEND call - these are like socket families:
linux/atmbr2684.h: * is per-backend specific
linux/atmbr2684.h:	int	has_vpiid;	/* 1: use vpn_id - Unsupported */
linux/atmbr2684.h: * terminating a large number of IP-only vcc's.  When netfilter allows
linux/atmbr2684.h: * efficient per-if in/out filters, this support will be removed
linux/intermezzo_upcall.h: * Kernel <--> Lento communications.
linux/intermezzo_upcall.h:/*         Lento <-> Presto  RPC arguments       */
linux/bfs_fs_i.h: * BFS file system in-core inode info
linux/pkt_cls.h:#define TC_POLICE_UNSPEC	(-1)
linux/pkt_cls.h:#define TCA_POLICE_MAX (__TCA_POLICE_MAX - 1)
linux/pkt_cls.h:#define TCA_U32_MAX (__TCA_U32_MAX - 1)
linux/pkt_cls.h:#define TCA_RSVP_MAX (__TCA_RSVP_MAX - 1)
linux/pkt_cls.h:#define TCA_ROUTE4_MAX (__TCA_ROUTE4_MAX - 1)
linux/pkt_cls.h:#define TCA_FW_MAX (__TCA_FW_MAX - 1)
linux/pkt_cls.h:#define TCA_TCINDEX_MAX        (__TCA_TCINDEX_MAX - 1)
linux/ioport.h: * Resources are tree-like, allowing
linux/ioport.h:#define IORESOURCE_BITS		0x000000ff	/* Bus-specific bits */
linux/ioport.h:/* PC/ISA/whatever - the normal PC address spaces: IO and memory */
linux/bitops.h: * of bits set) of a N-bit word
linux/hil_mlc.h: * HP-HIL Technical Reference Manual.  Hewlett Packard Product No. 45918A
linux/hil_mlc.h:  	/* HILSE_IN simply expects any non-errored packet to arrive 
linux/hil_mlc.h:/* Methods for back-end drivers, e.g. hp_sdc_mlc */
linux/nfs_flushd.h:#define REQUEST_HASH(ino, off)	(((ino) ^ REQUEST_NR(off)) & (REQUEST_HASH_SIZE - 1))
linux/nfs_flushd.h: * This is the per-mount writeback cache.
linux/wanrouter.h:*		Drivers and is completely hardware-independent.
linux/wanrouter.h:* Copyright:	(c) 1995-2000 Sangoma Technologies Inc.
linux/wanrouter.h:	ROUTER_USER	= (ROUTER_IOCTL<<8)+16,	/* driver-specific calls */
linux/wanrouter.h:/*----------------------------------------------------------------------------
linux/wanrouter.h: * X.25-specific link-level configuration.
linux/wanrouter.h:/*----------------------------------------------------------------------------
linux/wanrouter.h: * Frame relay specific link-level configuration.
linux/wanrouter.h:	unsigned signalling;	/* local in-channel signalling type */
linux/wanrouter.h:/*----------------------------------------------------------------------------
linux/wanrouter.h: * PPP-specific link-level configuration.
linux/wanrouter.h:/*----------------------------------------------------------------------------
linux/wanrouter.h: * CHDLC-specific link-level configuration.
linux/wanrouter.h:/*----------------------------------------------------------------------------
linux/wanrouter.h:	unsigned long maddr;	/* dual-port memory address */
linux/wanrouter.h:	unsigned msize;		/* dual-port memory size */
linux/wanrouter.h:        char interface;		/* RS-232/V.35, etc. */
linux/wanrouter.h:	char connection;	/* permanent/switched/on-demand */
linux/wanrouter.h:	union			/****** protocol-specific ************/
linux/wanrouter.h:#define	WANOPT_SWITCHED		1	/* use DTR to setup link (dial-up) */
linux/wanrouter.h:/* frame relay in-channel signalling */
linux/wanrouter.h:/*----------------------------------------------------------------------------
linux/wanrouter.h:	unsigned connection;	/* permanent/switched/on-demand */
linux/wanrouter.h:	unsigned tx_retries;	/* frames re-transmitted */
linux/wanrouter.h:/*----------------------------------------------------------------------------
linux/wanrouter.h:	unsigned hold_timeout;		/* sec, before re-connecting */
linux/wanrouter.h:	char interface;			/* RS-232/V.35, etc. */
linux/wanrouter.h:	unsigned char true_if_encoding;	/* Set the dev->type to true board protocol */
linux/wanrouter.h:/*----------------------------------------------------------------------------
linux/wanrouter.h:	char* name;			/* -> WAN device name (ASCIIZ) */
linux/wanrouter.h:	void* private;			/* -> driver private data */
linux/wanrouter.h:	unsigned long maddr;		/* dual-port memory address */
linux/wanrouter.h:	unsigned msize;			/* dual-port memory size */
linux/wanrouter.h:	char interface;			/* RS-232/V.35, etc. */
linux/wanrouter.h:	char connection;		/* permanent/switched/on-demand */
linux/wanrouter.h:	struct wan_device* next;	/* -> next device */
linux/vmalloc.h:/* bits in vm_struct->flags */
linux/vmalloc.h: *	vmalloc 32bit PA addressable pages - eg for PCI 32bit devices
linux/vmalloc.h: * vmlist_lock is a read-write spinlock that protects vmlist
linux/resource.h:#define	RUSAGE_CHILDREN	(-1)
linux/resource.h:#define RUSAGE_BOTH	(-2)		/* sys_wait4() uses this */
linux/resource.h:#define	PRIO_MIN	(-20)
linux/tqueue.h: * tqueue.h --- task queue handling for Linux.
linux/tqueue.h: * Mostly based on a proposed bottom-half replacement code written by
linux/tqueue.h: * Kai Petzke, wpp@marie.physik.tu-berlin.de.
linux/tqueue.h: * (C) 1994 Kai Petzke, wpp@marie.physik.tu-berlin.de
linux/tqueue.h: * - Bottom halfs are implemented as a linked list.  You can have as many
linux/tqueue.h: * - No more scanning of a bit field is required upon call of a bottom half.
linux/tqueue.h: * - Support for chained bottom half lists.  The run_task_queue() function can be
linux/tqueue.h: * - Bottom halfs are called in the reverse order that they were linked into
linux/tqueue.h:		(_tq)->routine = _routine;			\
linux/tqueue.h:		(_tq)->data = _data;				\
linux/tqueue.h:		INIT_LIST_HEAD(&(_tq)->list);			\
linux/tqueue.h:		(_tq)->sync = 0;				\
linux/tqueue.h: * Queue a task on a tq.  Return non-zero if it was successfully
linux/tqueue.h:	if (!test_and_set_bit(0,&bh_pointer->sync)) {
linux/tqueue.h:		list_add_tail(&bh_pointer->list, bh_list);
linux/cycx_cfm.h:* Copyright:	(c) 1998-2000 Arnaldo Carvalho de Melo
linux/cycx_cfm.h:#define	CFM_SIGNATURE	"CFM - Cyclades CYCX Firmware Module"
linux/cycx_cfm.h:	unsigned short	winoffs;	/* dual-port memory window offset */
linux/rpcsock.h: * The rpcsock code maintains an estimate on the maximum number of out-
linux/rpcsock.h:#define RPC_CONGESTED(rsock)	((rsock)->cong >= (rsock)->cwnd)
linux/ptrace.h: * is a no-op and the spurious error condition needs to be filtered out by some
linux/ptrace.h: * other means (e.g., in user-level, by passing an extra argument to the
linux/cycx_drv.h:* Copyright:	(c) 1998-2000 Arnaldo Carvalho de Melo
linux/cycx_drv.h:#define	CYCX_WINDOWSIZE	0x4000	/* default dual-port memory window size */
linux/cycx_drv.h:	u32 dpmbase;		/* dual-port memory base */
linux/cycx_drv.h:	u32 dpmsize;		/* dual-port memory size */
linux/ctype.h:		c -= 'A'-'a';
linux/ctype.h:		c -= 'a'-'A';
linux/prefetch.h: *  Generic cache management functions. Everything is arch-specific,  
linux/prefetch.h: *  2000-11-13  Arjan van de Ven   <arjan@fenrus.demon.nl>
linux/prefetch.h:	prefetch(x) attempts to pre-emptively get the memory pointed to
linux/prefetch.h:	#define below provides a no-op define.	
linux/prefetch.h:	prefetch(x)  	- prefetches the cacheline at "x" for read
linux/prefetch.h:	prefetchw(x)	- prefetches the cacheline at "x" for write
linux/prefetch.h:	spin_lock_prefetch(x) - prefectches the spinlock *x for taking
linux/prefetch.h:	there is also PREFETCH_STRIDE which is the architecure-prefered 
linux/minix_fs.h: * minix filesystem (aka V2) with bigger inodes and 32-bit block
linux/minix_fs.h:#define INODE_VERSION(inode)	inode->i_sb->u.minix_sb.s_version
linux/minix_fs.h: * Note the 8-bit gid and atime and ctime.
linux/minix_fs.h: * instead of 7+1+1). Also, some previously 8-bit values are
linux/minix_fs.h: * now 16-bit. The inode is now 64 bytes instead of 32.
linux/minix_fs.h: * minix super-block data on disk
linux/minix_fs.h: * change the define below to 0 if you want names > info->s_namelen chars to be
linux/adb.h:/* Structure which encapsulates a low-level ADB driver */
linux/adb.h:    ADB_MSG_POST_RESET	/* Called after resetting the bus (re-do init & register) */
linux/smb_fs_i.h: *  Copyright (C) 1995 by Paal-Kr. Engstad and Volker Lendecke
linux/ata.h:   Copyright 2003-2004 Red Hat, Inc.  All rights reserved.
linux/ata.h:   Copyright 2003-2004 Jeff Garzik
linux/ata.h:   http://www.opensource.org/licenses/osl-1.1.txt and is included herein
linux/ata.h:	ATA_UDMA_MASK_40C	= ATA_UDMA2,	/* udma0-2 */
linux/ata.h:	/* DMA-related */
linux/ata.h:	ATA_PRD_EOT		= (1 << 31),	/* end-of-table flag */
linux/ata.h:	ATA_NIEN		= (1 << 1),	/* disable-irq flag */
linux/ata.h:	ATA_TFLAG_LBA48		= (1 << 0), /* enable 48-bit LBA and "HOB" */
linux/ata.h:	ATA_TFLAG_WRITE		= (1 << 3), /* data dir: host->dev==1 (write) */
linux/ata.h:	default:	return -1;
linux/ata.h:	return (tf->protocol == ATA_PROT_ATAPI) ||
linux/ata.h:	       (tf->protocol == ATA_PROT_ATAPI_NODATA) ||
linux/ata.h:	       (tf->protocol == ATA_PROT_ATAPI_DMA);
linux/atm.h:/* atm.h - general ATM declarations */
linux/atm.h:/* Written 1995-2000 by Werner Almesberger, EPFL LRC/ICA */
linux/atm.h: * WARNING: User-space programs should not #include <linux/atm.h> directly.
linux/atm.h:#define ATM_NOT_RSV_VCI		    32	/* first non-reserved VCI value */
linux/atm.h:			    /* set CLP bit value - TODO */
linux/atm.h: * the data plane but generally seems to be data plane-centric, any layer is
linux/atm.h:#define ATM_PTI_US0	0  /* user data cell, congestion not exp, SDU-type 0 */
linux/atm.h:#define ATM_PTI_US1	1  /* user data cell, congestion not exp, SDU-type 1 */
linux/atm.h:#define ATM_PTI_UCES0	2  /* user data cell, cong. experienced, SDU-type 0 */
linux/atm.h:#define ATM_PTI_UCES1	3  /* user data cell, cong. experienced, SDU-type 1 */
linux/atm.h:#define ATM_PTI_E2EF5	5  /* end-to-end OAM F5 flow related cell */
linux/atm.h:#define ATM_MAX_PCR	-1		/* maximum available PCR */
linux/atm.h:        unsigned int 	icr;         	/* Initial Cell Rate (24-bit) */
linux/atm.h:        unsigned int	tbe;		/* Transient Buffer Exposure (24-bit) */ 
linux/atm.h:        unsigned int 	frtt : 24;	/* Fixed Round Trip Time (24-bit) */
linux/atm.h:        unsigned int 	rif  : 4;       /* Rate Increment Factor (4-bit) */
linux/atm.h:        unsigned int 	rdf  : 4;       /* Rate Decrease Factor (4-bit) */
linux/atm.h:        unsigned int nrm       :3;     	/* Max # of Cells for each forward RM cell (3-bit) */
linux/atm.h:        unsigned int trm       :3;    	/* Time between forward RM cells (3-bit) */    
linux/atm.h:	unsigned int adtf      :10;     /* ACR Decrease Time Factor (10-bit) */
linux/atm.h:	unsigned int cdf       :3;      /* Cutoff Decrease Factor (3-bit) */
linux/atm.h:#define ATM_ITF_ANY	-1		/* "magic" PVC address values */
linux/atm.h:#define ATM_VPI_ANY	-1
linux/atm.h:#define ATM_VCI_ANY	-1
linux/atm.h:#define ATM_VPI_UNSPEC	-2
linux/atm.h:#define ATM_VCI_UNSPEC	-2
linux/atm.h:#define ATM_LIJ_NONE	0		/* no leaf-initiated join */
linux/atm.h:#define ATM_LIJ_RPJ	2		/* set to root-prompted join */
linux/blk.h:	list_del(&req->queue);
linux/blk.h:#define DEVICE_NR(device) (((MAJOR(device) & SD_MAJOR_MASK) << (8 - 4)) + (MINOR(device) >> 4))
linux/blk.h:#define DEVICE_NAME "CD-ROM"
linux/blk.h:#define DEVICE_NAME "Mitsumi CD-ROM"
linux/blk.h:#define DEVICE_NAME "Mitsumi CD-ROM"
linux/blk.h:#define DEVICE_NAME "Matsushita CD-ROM controller #1"
linux/blk.h:#define DEVICE_NAME "Matsushita CD-ROM controller #2"
linux/blk.h:#define DEVICE_NAME "Matsushita CD-ROM controller #3"
linux/blk.h:#define DEVICE_NAME "Matsushita CD-ROM controller #4"
linux/blk.h:#define DEVICE_NAME "Aztech CD-ROM"
linux/blk.h:#define DEVICE_NAME "SONY-CDU535"
linux/blk.h:#define DEVICE_NAME "Philips/LMS CD-ROM cm206"
linux/blk.h:#define DEVICE_NAME "DOLPHIN 8000AT CD-ROM"
linux/blk.h:#define DEVICE_NAME "Sanyo H94A CD-ROM"
linux/blk.h: * above in the MAJOR_NR==xxx if-elif tree */
linux/blk.h:#define CURRENT_DEV DEVICE_NR(CURRENT->rq_dev)
linux/blk.h:	if (MAJOR(CURRENT->rq_dev) != MAJOR_NR) \
linux/blk.h:	if (CURRENT->bh) { \
linux/blk.h:		if (!buffer_locked(CURRENT->bh)) \
linux/blk.h:	add_blkdev_randomness(MAJOR(req->rq_dev));
linux/blk.h:	DEVICE_OFF(req->rq_dev);
linux/cdk.h: *	cdk.h  -- CDK interface definitions.
linux/cdk.h: *	Copyright (C) 1996-1998  Stallion Technologies
linux/cdk.h: *	Copyright (C) 1994-1996  Greg Ungerer.
linux/cdk.h:#define	BREAKON		-1
linux/cdk.h:#define	BREAKOFF	-2
linux/i2c.h:/* ------------------------------------------------------------------------- */
linux/i2c.h:/* i2c.h - definitions for the i2c-bus interface			     */
linux/i2c.h:/* ------------------------------------------------------------------------- */
linux/i2c.h:/*   Copyright (C) 1995-2000 Simon G. Vogl
linux/i2c.h:/* ------------------------------------------------------------------------- */
linux/i2c.h:#include <linux/i2c-id.h>	/* id values of adapters et. al. 	*/
linux/i2c.h:/* --- Includes and compatibility declarations ------------------------ */
linux/i2c.h:/* --- General options ------------------------------------------------	*/
linux/i2c.h:	unsigned int addr;		/* chip address - NOTE: 7bit 	*/
linux/i2c.h:	/* addr: unsigned int to make lm_sensors i2c-isa adapter work
linux/i2c.h: * be addressed using the same bus algorithms - i.e. bit-banging or the PCF8584
linux/i2c.h:	/* If an adapter algorithm can't to I2C-level access, set master_xfer
linux/i2c.h:	/* --- these optional/future use for some adapter types.*/
linux/i2c.h:	/* --- ioctl like call to set div. parameters. */
linux/i2c.h:	unsigned int id;/* == is algo->id | hwdep.struct->id, 		*/
linux/i2c.h:	/* --- These may be NULL, but should increase the module use count */
linux/i2c.h:	/* --- administration stuff. */
linux/i2c.h:#define I2C_CLIENT_ALLOW_MULTIPLE_USE 	0x02  	/* Allow multiple access-locks */
linux/i2c.h:/* ----- functions exported by i2c.o */
linux/i2c.h:/* New function: This is to get an i2c_client-struct for controlling the 
linux/i2c.h:   client either by using i2c_control-function or having the 
linux/i2c.h:   client-module export functions that can be used with the i2c_client
linux/i2c.h:   -struct. */
linux/i2c.h:   to make sure that client-struct is valid and that it is okay to access
linux/i2c.h:   the i2c-client. 
linux/i2c.h:   returns -EACCES if client doesn't allow use (default)
linux/i2c.h:   returns -EBUSY if client doesn't allow multiple use (default) and 
linux/i2c.h:/* returns -EBUSY if address has been taken, 0 if not. Note that the only
linux/i2c.h: * or -1 if the adapter was not registered. 
linux/i2c.h: * I2C Message - used for pure i2c transaction, also from /dev interface
linux/i2c.h:#define I2C_FUNC_SMBUS_READ_I2C_BLOCK	0x04000000 /* New I2C-like block */
linux/i2c.h:/* ----- commands for the ioctl like i2c_command call:
linux/i2c.h: *	dependent layers - these can be listed here, or see the 
linux/i2c.h:				/* -> bit-adapter specific ioctls	*/
linux/i2c.h:#define I2C_TIMEOUT	0x0702	/* set timeout - call with int 		*/
linux/i2c.h:/* this is for i2c-dev.c	*/
linux/i2c.h:#define I2C_SMBUS	0x0720	/* SMBus-level access */
linux/i2c.h:/* ... algo-bit.c recognizes */
linux/i2c.h:/* ----- I2C-DEV: char device interface stuff ------------------------- */
linux/i2c.h:#define I2C_CLIENT_MODPARM_AUX1(x) "1-" #x "h"
linux/i2c.h:                      "List of adapter,start-addr,end-addr triples to scan " \
linux/i2c.h:                      "List of adapter,start-addr,end-addr triples not to " \
linux/i2c.h:        ((clientptr)->adapter->algo->id == I2C_ALGO_ISA)
linux/i2c.h:        ((adapptr)->algo->id == I2C_ALGO_ISA)
linux/i2o.h:#include <linux/i2o-dev.h>
linux/i2o.h:	return readl(c->post_port);
linux/i2o.h:	writel(val, c->post_port);
linux/i2o.h:	return readl(c->reply_port);
linux/i2o.h:	writel(val, c->reply_port);
linux/i2o.h:	return readl(c->irq_mask);
linux/i2o.h:	writel(val, c->irq_mask);
linux/i2o.h:	/* The second line isnt spurious - thats forcing PCI posting */
linux/i2o.h: *	Endian handling wrapped into the macro - keeps the core code
linux/i2o.h: * messages: Table 3-2 Detailed Status Codes.*/
linux/i2o.h:/* FailureStatusCodes, Table 3-3 Message Failure Codes */
linux/i2o.h:#define I2O_POST_WAIT_TIMEOUT	-ETIMEDOUT
linux/dio.h: * Maybe this should handle DIO-II later?
linux/dio.h: * range from 0-63 (DIO) and 132-255 (DIO-II). 
linux/dio.h: * So DIO cards cover [0x600000-0x800000); the areas [0x200000-0x400000) and
linux/dio.h: * [0x800000-0x1000000) are for additional space required by things
linux/dio.h: * like framebuffers. [0x400000-0x600000) is for miscellaneous internal I/O.
linux/dio.h: * DIO-II boards are at 0x1000000 + (sc - 132) * 0x400000
linux/dio.h: * which is address range [0x1000000-0x20000000) -- too big to map completely,
linux/dio.h: * so currently we just don't handle DIO-II boards.  It wouldn't be hard to 
linux/dio.h:/* DIO/DIO-II boards all have the following 8bit registers.
linux/dio.h:#define DIOII_SIZEOFF 0x101                       /* device size, DIO-II only */
linux/dio.h: * select code 7 is the internal HPIB regardless of the ID register :-<
linux/dio.h:#define DIOII_BASE              0x01000000      /* start of DIO-II space */
linux/dio.h:#define DIOII_END               0x20000000      /* end of DIO-II space */
linux/dio.h:#define DIOII_DEVSIZE           0x00400000      /* size of a DIO-II device */
linux/dio.h:/* Highest valid select code. If we add DIO-II support this should become
linux/dio.h:#define DIOII_SCBASE 132 /* lowest DIO-II select code */
linux/dio.h:/* find the size of a DIO-II board's address space.
linux/dio.h:/* general purpose macro for both DIO and DIO-II */
linux/dio.h:#define DIO_ID_FHPIB    0x08 /* 98625A/98625B fast HP-IB */
linux/dio.h:#define DIO_ID_NHPIB    0x80 /* 98624A HP-IB (normal ie slow) */
linux/dio.h:/* the NetBSD kernel source is a bit unsure as to what these next IDs actually do :-> */
linux/dio.h:#define DIO_ID_MISC8    0x1a /* quad-wide card */
linux/dio.h:#define DIO_DESC_MISC8 "quad-wide card"
linux/dio.h:#define DIO_DESC2_LRCATSEYE      "low-res catseye display"
linux/dio.h:#define DIO_DESC2_HRCCATSEYE     "high-res color catseye display"
linux/dio.h:#define DIO_DESC2_HRMCATSEYE     "high-res mono catseye display"
linux/dio.h:#define DIO_ID2_XGENESIS    0x0b /* "x-genesis"; no NetBSD support */
linux/dio.h:#define DIO_DESC2_XGENESIS       "\"x-genesis\" display"
linux/dio.h:#define DIO_ID2_YGENESIS    0x0d /* "y-genesis"; no NetBSD support */
linux/dio.h:#define DIO_DESC2_YGENESIS       "\"y-genesis\" display"
linux/i8k.h: * i8k.h -- Linux driver for accessing the SMM BIOS on Dell laptops
linux/efi.h: * Copyright (C) 1999, 2002 Hewlett-Packard Co.
linux/efi.h: *	David Mosberger-Tang <davidm@hpl.hp.com>
linux/efi.h:#define EFI_MEMORY_WC		0x0000000000000002	/* write-coalescing */
linux/efi.h:#define EFI_MEMORY_WT		0x0000000000000004	/* write-through */
linux/efi.h:#define EFI_MEMORY_WB		0x0000000000000008	/* write-back */
linux/efi.h:#define EFI_MEMORY_WP		0x0000000000001000	/* write-protect */
linux/efi.h:#define EFI_MEMORY_RP		0x0000000000002000	/* read-protect */
linux/efi.h:#define EFI_MEMORY_XP		0x0000000000004000	/* execute-protect */
linux/efi.h:	sprintf(out, "%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x",
linux/efi.h:		guid->b[3], guid->b[2], guid->b[1], guid->b[0],
linux/efi.h:		guid->b[5], guid->b[4], guid->b[7], guid->b[6],
linux/efi.h:		guid->b[8], guid->b[9], guid->b[10], guid->b[11],
linux/efi.h:		guid->b[12], guid->b[13], guid->b[14], guid->b[15]);
linux/elf.h:/* 32-bit ELF base types. */
linux/elf.h:/* 64-bit ELF base types. */
linux/elf.h:#define EM_MIPS		8	/* MIPS R3000 (officially, big-endian only) */
linux/elf.h:#define EM_MIPS_RS3_LE 10	/* MIPS R3000 little-endian */
linux/elf.h:#define EM_SPARCV9     43	/* SPARC v9 64-bit */
linux/elf.h:#define EM_IA_64	50	/* HP/Intel IA-64 */
linux/elf.h:#define EM_X86_64	62	/* AMD x86-64 */
linux/elf.h:#define EM_CRIS         76      /* Axis Communications 32-bit embedded processor */
linux/cycx_x25.h:* Copyright:	(c) 1998-2000 Arnaldo Carvalho de Melo
linux/cycx_x25.h:	u8  pktlen	PACKED; /* level 3 packet lenght - log base 2 of size */
linux/ext2_fs_i.h: * Laboratoire MASI - Institut Blaise Pascal
linux/hil.h: * Hewlett Packard Human Interface Loop (HP-HIL) Protocol -- header.
linux/hil.h: * HP-HIL Technical Reference Manual.  Hewlett Packard Product No. 45918A
linux/hil.h: * implementing a software MLC to run HIL devices on a non-parisc machine.
linux/hil.h:	HIL_ERR_OB	= 0x00000800, /* MLC is busy sending an auto-poll, 
linux/hil.h:/* This gives us a 32-bit "packet" 
linux/hil.h:	HIL_CMD_EPT	= 0x01,	/* Enter Pass-Thru Mode */
linux/hil.h:	HIL_CMD_ELB	= 0x02,	/* Enter Loop-Back Mode */
linux/hil.h:	/* 0x80 to 0xEF device-specific commands */
linux/hil.h:#define HIL_IDD_HEADER_2X_AXIS		0x80	/* Two sets of 1-3 axis */
linux/hil.h:(2 - !((header_packet) & HIL_IDD_HEADER_2X_AXIS))
linux/hil.h:((4 - !(header_packet & HIL_IDD_HEADER_IOD) -			\
linux/hil.h: * packets and/or unpacked 8-bit data in the order that they 
linux/hil.h:(!(HIL_IDD_NUM_AXSETS(*(header_ptr))) ? -1 :			\
linux/hil.h:(*(header_ptr + HIL_IDD_LEN((*header_ptr)) - 1))
linux/hil.h:/* The response to HIL EXD commands -- the "extended describe record" */
linux/hil.h: (*(header_ptr + 2 - !(*header_ptr & HIL_EXD_HEADER_RRG)) &	\
linux/hil.h:(!(*header_ptr & HIL_EXD_HEADER_LOCALE) ? -1 :			\
linux/hil.h: (*(header_ptr + HIL_EXD_LEN(header_ptr) - 1) & HIL_PKT_DATA_MASK))
linux/hil.h:(!(*header_ptr & HIL_EXD_HEADER_WRG_TYPE2) ? -1	:			\
linux/hil.h: (*(header_ptr + HIL_EXD_LEN(header_ptr) - 2 -                  	\
linux/hil.h: ((*(header_ptr + HIL_EXD_LEN(header_ptr) - 1 -				\
linux/hil.h:"chinese",		/* 0x10 Chinese-PRC */		\
linux/hil.h:"chinese",		/* 0x11 Chinese-ROC */		\
linux/ide.h: *  Copyright (C) 1994-2002  Linus Torvalds & authors
linux/ide.h: * There can be up to two drives per interface, as per the ATA-2 spec.
linux/ide.h: * REALLY_SLOW_IO can be defined in ide.c and ide-cd.c, if necessary
linux/ide.h:#ifndef SUPPORT_VLB_SYNC		/* 1 to support weird 32-bit chips */
linux/ide.h:#ifndef FANCY_STATUS_DUMPS		/* 1 for human-readable drive errors */
linux/ide.h:#define IDE_NO_IRQ		(-1)
linux/ide.h: *  "No user-serviceable parts" beyond this point  :)
linux/ide.h:#define HWIF(drive)		((ide_hwif_t *)((drive)->hwif))
linux/ide.h:#define HWGROUP(drive)		((ide_hwgroup_t *)(HWIF(drive)->hwgroup))
linux/ide.h:#define IDE_DATA_REG		(HWIF(drive)->io_ports[IDE_DATA_OFFSET])
linux/ide.h:#define IDE_ERROR_REG		(HWIF(drive)->io_ports[IDE_ERROR_OFFSET])
linux/ide.h:#define IDE_NSECTOR_REG		(HWIF(drive)->io_ports[IDE_NSECTOR_OFFSET])
linux/ide.h:#define IDE_SECTOR_REG		(HWIF(drive)->io_ports[IDE_SECTOR_OFFSET])
linux/ide.h:#define IDE_LCYL_REG		(HWIF(drive)->io_ports[IDE_LCYL_OFFSET])
linux/ide.h:#define IDE_HCYL_REG		(HWIF(drive)->io_ports[IDE_HCYL_OFFSET])
linux/ide.h:#define IDE_SELECT_REG		(HWIF(drive)->io_ports[IDE_SELECT_OFFSET])
linux/ide.h:#define IDE_STATUS_REG		(HWIF(drive)->io_ports[IDE_STATUS_OFFSET])
linux/ide.h:#define IDE_CONTROL_REG		(HWIF(drive)->io_ports[IDE_CONTROL_OFFSET])
linux/ide.h:#define IDE_IRQ_REG		(HWIF(drive)->io_ports[IDE_IRQ_OFFSET])
linux/ide.h:#define IDE_DATA_REG_HOB	(HWIF(drive)->io_ports[IDE_DATA_OFFSET])
linux/ide.h:#define IDE_ERROR_REG_HOB	(HWIF(drive)->io_ports[IDE_ERROR_OFFSET])
linux/ide.h:#define IDE_NSECTOR_REG_HOB	(HWIF(drive)->io_ports[IDE_NSECTOR_OFFSET])
linux/ide.h:#define IDE_SECTOR_REG_HOB	(HWIF(drive)->io_ports[IDE_SECTOR_OFFSET])
linux/ide.h:#define IDE_LCYL_REG_HOB	(HWIF(drive)->io_ports[IDE_LCYL_OFFSET])
linux/ide.h:#define IDE_HCYL_REG_HOB	(HWIF(drive)->io_ports[IDE_HCYL_OFFSET])
linux/ide.h:#define IDE_SELECT_REG_HOB	(HWIF(drive)->io_ports[IDE_SELECT_OFFSET])
linux/ide.h:#define IDE_STATUS_REG_HOB	(HWIF(drive)->io_ports[IDE_STATUS_OFFSET])
linux/ide.h:#define IDE_CONTROL_REG_HOB	(HWIF(drive)->io_ports[IDE_CONTROL_OFFSET])
linux/ide.h:#define SATA_STATUS_REG		(HWIF(drive)->sata_scr[SATA_STATUS_OFFSET])
linux/ide.h:#define SATA_ERROR_REG		(HWIF(drive)->sata_scr[SATA_ERROR_OFFSET])
linux/ide.h:#define SATA_CONTROL_REG	(HWIF(drive)->sata_scr[SATA_CONTROL_OFFSET])
linux/ide.h:#define SATA_MISC_REG		(HWIF(drive)->sata_misc[SATA_MISC_OFFSET])
linux/ide.h:#define SATA_PHY_REG		(HWIF(drive)->sata_misc[SATA_PHY_OFFSET])
linux/ide.h:#define SATA_IEN_REG		(HWIF(drive)->sata_misc[SATA_IEN_OFFSET])
linux/ide.h:#define PARTN_MASK	((1<<PARTN_BITS)-1)	/* a useful bit mask */
linux/ide.h:#define WAIT_DRQ	(5*HZ/100)	/* 50msec - spec allows up to 20ms */
linux/ide.h:#define WAIT_READY	(5*HZ)		/* 5sec - some laptops are very slow */
linux/ide.h:#define WAIT_READY	(3*HZ/100)	/* 30msec - should be instantaneous */
linux/ide.h:#define WAIT_PIDENTIFY	(10*HZ)	/* 10sec  - should be less than 3ms (?), if all ATAPI CD is closed at boot */
linux/ide.h:#define WAIT_WORSTCASE	(30*HZ)	/* 30sec  - worst case when spinning up */
linux/ide.h:#define WAIT_CMD	(10*HZ)	/* 10sec  - maximum wait for an IRQ to happen */
linux/ide.h:#define WAIT_MIN_SLEEP	(2*HZ/100)	/* 20msec - minimum sleep time */
linux/ide.h:	return ((hwif)->chipset == chipset) ? 1 : 0;		\
linux/ide.h: * Now for the data we need to maintain per-drive:  ide_drive_t
linux/ide.h: * ATA-IDE Error Register
linux/ide.h: * ATA-IDE Select Register, aka Device-Head
linux/ide.h: * The ATA-IDE Status Register.
linux/ide.h: * ATA-IDE Control Register
linux/ide.h: * bit3		: ATA-2 thingy, Should be set to 1
linux/ide.h: * HOB		: 48-bit address ordering, High Ordered Bit
linux/ide.h: * abrt		: Aborted command - As defined by ATA
linux/ide.h: * mcr		: Media Change Requested - As defined by ATA
linux/ide.h:					 *  0=28-bit
linux/ide.h:					 *  1=48-bit
linux/ide.h:					 *  2=48-bit doing 28-bit
linux/ide.h:					 *  3=64-bit
linux/ide.h:	u8	scsi;		/* 0=default, 1=skip current ide-subdriver for ide-scsi emulation */
linux/ide.h:        u8	suspend_reset;	/* drive suspend mode flag, soft-reset recovers */
linux/ide.h:	u8	io_32bit;	/* 0=16-bit, 1=32-bit, 2/3=32bit+sync */
linux/ide.h:	(((rq)->hard_cur_sectors - (rq)->current_nr_sectors) << 9)
linux/ide.h:	return bh_kmap_irq(rq->bh, flags) + ide_rq_offset(rq);
linux/ide.h:	struct hwif_s *next;		/* for linked-list in ide_hwgroup_t */
linux/ide.h:	u8 channel;	/* for dual-port chips: 0=primary, 1=secondary */
linux/ide.h:	hwif_chipset_t chipset;	/* sub-module for tuning.. */
linux/ide.h:	/* chipset specific changes to default for device-hba resets */
linux/ide.h:	/* driver soft-power interface */
linux/ide.h:	/* Scatter-gather list used to build the above */
linux/ide.h:	unsigned long	config_data;	/* for use by chipset-specific code */
linux/ide.h:	unsigned long	select_data;	/* for use by chipset-specific code */
linux/ide.h:	unsigned	autodma    : 1;	/* auto-attempt using DMA at boot */
linux/ide.h:	unsigned	udma_four  : 1;	/* 1=ATA-66 capable, 0=default */
linux/ide.h:	unsigned	highmem    : 1;	/* can do full 32-bit dma */
linux/ide.h:		/* ptr to current hwif in linked-list */
linux/ide.h:	len -= off;			\
linux/ide.h:#define DRIVER(drive)		((drive)->driver)
linux/ide.h: * ide_fixstring() cleans up and (optionally) byte-swaps a text string,
linux/ide.h: * This routine busy-waits for the drive status to be not "busy".
linux/ide.h: * This routine is called from the partition-table code in genhd.c
linux/ide.h: * the request queue, displacing the currently-being-processed
linux/ide.h: * the currently-being-processed-request (if any), and the function
linux/ide.h: * stat/err are used only when (HWGROUP(drive)->rq->cmd == IDE_DRIVE_CMD).
linux/ide.h: * stat/err are used only when (HWGROUP(drive)->rq->cmd == IDE_DRIVE_TASK_MASK).
linux/ide.h:ide-cd orthoginal :-/
linux/ide.h:	u8	reg;	/* byte pci reg holding the enable-bit */
linux/ide.h:	u8	mask;	/* mask to isolate the enable-bit */
linux/ide.h:	return hwif->hwif_data;
linux/ide.h:	hwif->hwif_data = data;
linux/ide.h:/* ide-lib.c */
linux/ide.h:#define DRIVE_LOCK(drive)       ((drive)->queue.queue_lock)
linux/in6.h: *      <draft-ietf-ipngwg-bsd-api-05.txt>
linux/in6.h: *	<draft-stevens-advanced-api-00.txt>
linux/in6.h:#define IPPROTO_HOPOPTS		0	/* IPv6 hop-by-hop options	*/
linux/jbd.h: * Copyright 1998-2000 Red Hat, Inc --- All Rights Reserved
linux/jbd.h:#include <linux/journal-head.h>
linux/jbd.h: * known-good hardware we may want to trap these errors.
linux/jbd.h: * typedef handle_t - The handle_t type represents a single atomic update being performed by some process.
linux/jbd.h: * typedef journal_t - The journal_t maintains all of the journaling state information for a single filesystem.
linux/jbd.h: * On-disk structures
linux/jbd.h:	__u32		t_blocknr;	/* The on-disk block number */
linux/jbd.h:#define JFS_FLAG_ESCAPE		1	/* on-disk block is escaped */
linux/jbd.h: * The journal superblock.  All fields are in big-endian byte order.
linux/jbd.h:	/* Remaining fields are only valid in a version-2 superblock */
linux/jbd.h:	__u32	s_feature_ro_compat; 	/* readonly-compatible feature set */
linux/jbd.h:	__u8	s_uuid[16];		/* 128-bit uuid for journal */
linux/jbd.h:	((j)->j_format_version >= 2 &&					\
linux/jbd.h:	 ((j)->j_superblock->s_feature_compat & cpu_to_be32((mask))))
linux/jbd.h:	((j)->j_format_version >= 2 &&					\
linux/jbd.h:	 ((j)->j_superblock->s_feature_ro_compat & cpu_to_be32((mask))))
linux/jbd.h:	((j)->j_format_version >= 2 &&					\
linux/jbd.h:	 ((j)->j_superblock->s_feature_incompat & cpu_to_be32((mask))))
linux/jbd.h:			printk(KERN_ERR "EXT3-fs unexpected failure: %s;\n", # expr); \
linux/jbd.h:	return jh->b_bh;
linux/jbd.h:	return bh->b_private;
linux/jbd.h: * struct handle_s - The handle_s type is the concrete type associated with handle_t.
linux/jbd.h: * @h_sync: flag for sync-on-close
linux/jbd.h:	unsigned int	h_sync:		1;	/* sync-on-close */
linux/jbd.h:	/* Doubly-linked circular list of all inodes owned by this
linux/jbd.h:	/* Doubly-linked circular list of all buffers reserved but not
linux/jbd.h:	/* Doubly-linked circular list of all metadata buffers owned by this
linux/jbd.h:	 * Doubly-linked circular list of all data buffers still to be
linux/jbd.h:	 * Doubly-linked circular list of all writepage data buffers
linux/jbd.h:	/* Doubly-linked circular list of all forget buffers (superceded
linux/jbd.h:           buffers which we can un-checkpoint once this transaction
linux/jbd.h:	 * Doubly-linked circular list of all buffers still to be
linux/jbd.h:	/* Doubly-linked circular list of temporary buffers currently
linux/jbd.h:	/* Doubly-linked circular list of metadata buffers being
linux/jbd.h:	/* Doubly-linked circular list of control buffers being written
linux/jbd.h: * struct journal_s - The journal_s type is the concrete type associated with journal_t.
linux/jbd.h: * @j_head: Journal head - identifies the first unused block in the journal
linux/jbd.h: * @j_tail: Journal tail - identifies the oldest still-used block in the journal.
linux/jbd.h: * @j_free: Journal free - how many free blocks are there in the journal?
linux/jbd.h: * @j_all_journals:  Link all journals together - system-wide 
linux/jbd.h: * @j_revoke: The revoke table - maintains the list of revoked blocks in the current transaction.
linux/jbd.h:	/* Journal tail: identifies the oldest still-used block in the */
linux/jbd.h:	/* Link all journals together - system-wide */
linux/jbd.h:	down(&journal->j_sem);
linux/jbd.h:	return down_trylock(&journal->j_sem);
linux/jbd.h:	up(&journal->j_sem);
linux/jbd.h:	return current->journal_info;
linux/jbd.h:	current->state = TASK_UNINTERRUPTIBLE;			      \
linux/jbd.h:	return journal->j_flags & JFS_ABORT;
linux/jbd.h:	if (handle->h_aborted)
linux/jbd.h:	return is_journal_aborted(handle->h_transaction->t_journal);
linux/jbd.h:	handle->h_aborted = 1;
linux/jbd.h:	int difference = (x - y);
linux/jbd.h:	int difference = (x - y);
linux/jbd.h:	return SPLICE_LOCK(buffer_jbd(bh), bh2jh(bh)->b_jlist == list);
linux/jbd.h:			bh2jh(bh)->b_jlist == BJ_SyncData ||
linux/jbd.h:			bh2jh(bh)->b_jlist == BJ_AsyncData);
linux/jbd.h: * Compatibility no-ops which allow the kernel to compile without CONFIG_JBD
linux/ipc.h: * These are passed as bitflags or-ed with the actual command
linux/ipc.h:#define IPC_OLD 0	/* Old version (no 32-bit UID support on many
linux/ipc.h:#define IPC_64  0x0100  /* New version (support 32-bit UIDs, bigger
linux/ipc.h:/* used by in-kernel data structures */
linux/irq.h: * Thanks. --rmk
linux/irq.h:#define IRQ_INPROGRESS	1	/* IRQ handler active - do not enter! */
linux/irq.h:#define IRQ_DISABLED	2	/* IRQ disabled - do not enter! */
linux/irq.h:#define IRQ_PENDING	4	/* IRQ pending - replay on enable */
linux/irq.h:#define IRQ_WAITING	32	/* IRQ not yet seen - for autodetection */
linux/irq.h:#define IRQ_MASKED	128	/* IRQ masked - shouldn't be seen again */
linux/irq.h: * to describe about the low-level hardware. 
linux/hfs_sysdep.h: * Copyright (C) 1996-1997  Paul H. Hargrove
linux/hfs_sysdep.h: * a structure means that the pointer is non-NULL and the structure it
linux/hfs_sysdep.h:#define offsetof(TYPE, MEMB) ((size_t) &((TYPE *)0)->MEMB)
linux/hfs_sysdep.h:		  (hfs_alloc -= ptr ? size : 0), __FILE__, __LINE__);
linux/hfs_sysdep.h:	return time - sys_tz.tz_minuteswest*60; 
linux/hfs_sysdep.h:	sys_mdb->s_dirt = 1;
linux/hfs_sysdep.h:	return kdevname(sys_mdb->s_dev);
linux/hfs_sysdep.h:	return buffer->b_data;
linux/hfs_sysdep.h:#	error "Don't know if bytes are big- or little-endian!"
linux/hfs_sysdep.h: * HFS structures have fields aligned to 16-bit boundaries.
linux/hfs_sysdep.h: * So, 16-bit get/put are easy while 32-bit get/put need
linux/hfs_sysdep.h: *	ns  = 16-bit integer in network byte-order w/ 16-bit alignment
linux/hfs_sysdep.h: *	hs  = 16-bit integer in host byte-order w/ 16-bit alignment
linux/hfs_sysdep.h: *	nl  = 32-bit integer in network byte-order w/ unknown alignment
linux/hfs_sysdep.h: *	hl  = 32-bit integer in host byte-order w/ unknown alignment
linux/hfs_sysdep.h: *	anl = 32-bit integer in network byte-order w/ 32-bit alignment
linux/hfs_sysdep.h: *	ahl = 32-bit integer in host byte-order w/ 32-bit alignment
linux/hfs_sysdep.h: * Example: hfs_get_hl() gets an unaligned 32-bit integer converting
linux/hfs_sysdep.h: *	it to host byte-order.
linux/tpqic02.h: * Include file for QIC-02 driver for Linux.
linux/tpqic02.h: * Copyright (c) 1992--1995 by H. H. Bergman. All rights reserved.
linux/tpqic02.h: * and severely hacked by me.   -- hhb
linux/tpqic02.h: * with more hacks by me.   -- hhb
linux/tpqic02.h:#define WANGTEK		1		   /* don't know about Wangtek QIC-36 */
linux/tpqic02.h:#define ARCHIVE_SC400	ARCHIVE	       /* rumoured to be from the pre-SMD-age */
linux/tpqic02.h: *	- Wangtek 5150, format: up to QIC-150.
linux/tpqic02.h: *	- Enables some optional QIC02 commands that some drives may lack.
linux/tpqic02.h: * If you have an EVEREX EV-831 card and you are using DMA channel 3,
linux/tpqic02.h: * Wangtek/Everex card, you can try #define-ing the flag
linux/tpqic02.h: * NOTE: Drive select is not implemented -- I have only one tape streamer,
linux/tpqic02.h: *	 so I'm unable and unmotivated to test and implement that. ;-) ;-)
linux/tpqic02.h:#elif QIC02_TAPE_DRIVE == MT_ISARCHIVESC499	/* Archive SC-499 QIC-36 controller */
linux/tpqic02.h:#define TP_HAVE_DENS	1	/* can do set density (QIC-11 / QIC-24) */
linux/tpqic02.h:#define TP_HAVE_DENS	1	/* can do set density (QIC-24 / QIC-120 / QIC-150) */
linux/tpqic02.h:#define TP_HAVE_DENS	1	/* can do set density?? (QIC-24??) */
linux/tpqic02.h:#define TP_HAVE_DENS	0	/* cannot do set density?? (QIC-150?) */
linux/tpqic02.h:#error No QIC-02 tape drive type defined!
linux/tpqic02.h:#define AR_CTL_DNIEN		0x10	/* done-interrupt enable */
linux/tpqic02.h:#define MTN_CTL_DNIEN		 0x01	/* done-interrupt enable */
linux/tpqic02.h:   * static, non-Wangtek case. The alternative was even worse.
linux/tpqic02.h:/* Standard QIC-02 commands -- rev F.  All QIC-02 drives must support these */
linux/tpqic02.h:#define QCMD_DENS_11	0x26		/* QIC-11 */
linux/tpqic02.h:#define QCMD_DENS_24	0x27		/* QIC-24: 9 track 60MB */
linux/tpqic02.h:#define QCMD_DENS_120	0x28		/* QIC-120: 15 track 120MB */
linux/tpqic02.h:#define QCMD_DENS_150	0x29		/* QIC-150: 18 track 150MB */
linux/tpqic02.h:#define QCMD_DENS_300	0x2A		/* QIC-300/QIC-2100 */
linux/tpqic02.h:#define QCMD_DENS_600	0x2B		/* QIC-600/QIC-2200 */
linux/tpqic02.h:/* don't know about QIC-1000 and QIC-1350 */
linux/tpqic02.h:#define QCMD_SPACE_BCK	0x89		/* move tape head one block back -- very useful! */
linux/tpqic02.h: * to implement semi-non-sequential access. `mt fsf` would benefit from this.
linux/tpqic02.h: * causing some incompatibility problems wrt std QIC-02 data exchange.
linux/tpqic02.h: * to do in kernel-space. [Size constraints.]
linux/tpqic02.h: * Refer to the QIC-02 specs, appendix A for more information.
linux/tpqic02.h: *  |  \|/    |_________ Density: 000=none, 001=QIC-11, 010=24, 011=120,
linux/tpqic02.h: *  |   |                100=QIC-150, 101..111 reserved.
linux/tpqic02.h:/* defines for tpstatus.exs -- taken from 386BSD wt driver */
linux/tpqic02.h:/* timeout timer values -- check these! */
linux/tpqic02.h: * buffer blocks result in more context-switching.
linux/mca.h:/* Maximal number of MCA slots - actually, some machines have less, but
linux/mca.h:#define MCA_NOTFOUND	(-1)
linux/mca.h:/* adapter state info - returns 0 if no */
linux/lockd/xdr.h: *	FreeBSD uses 16, Apple Mac OS-X 10.3 uses 20.
linux/lockd/lockd.h: * General-purpose lockd include file.
linux/lockd/lockd.h:	u32			h_state;	/* pseudo-state counter */
linux/lockd/lockd.h:	unsigned long		b_when;		/* next re-xmit */
linux/lockd/lockd.h:	unsigned char		b_queued;	/* re-queued */
linux/lockd/lockd.h: * Server-side lock handling
linux/lockd/lockd.h:	return file->f_file.f_dentry->d_inode;
linux/lockd/lockd.h:	return sin1->sin_addr.s_addr == sin2->sin_addr.s_addr;
linux/lockd/lockd.h:	return	fl1->fl_pid   == fl2->fl_pid
linux/lockd/lockd.h:	     && fl1->fl_start == fl2->fl_start
linux/lockd/lockd.h:	     && fl1->fl_end   == fl2->fl_end
linux/lockd/lockd.h:	     &&(fl1->fl_type  == fl2->fl_type || fl2->fl_type == F_UNLCK);
linux/lockd/bind.h: * This is the set of functions for lockd->nfsd communication
linux/mii.h: * linux/mii.h: definitions for MII-compatible transceivers
linux/mii.h:#define MII_NWAYTEST        0x14        /* N-way auto-neg test reg     */
linux/mii.h:#define BMSR_ERCAP              0x0001  /* Ext-reg capability          */
linux/mii.h:#define BMSR_ANEGCAPABLE        0x0008  /* Able to do auto-negotiation */
linux/mii.h:#define BMSR_ANEGCOMPLETE       0x0020  /* Auto-negotiation complete   */
linux/mii.h:#define BMSR_10HALF             0x0800  /* Can do 10mbps, half-duplex  */
linux/mii.h:#define BMSR_10FULL             0x1000  /* Can do 10mbps, full-duplex  */
linux/mii.h:#define BMSR_100HALF            0x2000  /* Can do 100mbps, half-duplex */
linux/mii.h:#define BMSR_100FULL            0x4000  /* Can do 100mbps, full-duplex */
linux/mii.h:#define ADVERTISE_10HALF        0x0020  /* Try for 10mbps half-duplex  */
linux/mii.h:#define ADVERTISE_10FULL        0x0040  /* Try for 10mbps full-duplex  */
linux/mii.h:#define ADVERTISE_100HALF       0x0080  /* Try for 100mbps half-duplex */
linux/mii.h:#define ADVERTISE_100FULL       0x0100  /* Try for 100mbps full-duplex */
linux/mii.h:#define LPA_10HALF              0x0020  /* Can do 10mbps half-duplex   */
linux/mii.h:#define LPA_10FULL              0x0040  /* Can do 10mbps full-duplex   */
linux/mii.h:#define LPA_100HALF             0x0080  /* Can do 100mbps half-duplex  */
linux/mii.h:#define LPA_100FULL             0x0100  /* Can do 100mbps full-duplex  */
linux/mii.h:/* Expansion register for auto-negotiation. */
linux/mii.h:#define EXPANSION_NWAY          0x0001  /* Can do N-way auto-nego      */
linux/mii.h:/* N-way test register. */
linux/mii.h:#define NWAYTEST_LOOPBACK       0x0100  /* Enable loopback for N-way   */
linux/mii.h:	return (struct mii_ioctl_data *) &rq->ifr_ifru;
linux/mii.h: * between 100T-full and 100T-half.  If your phy does not support
linux/mii.h: * @duplex_lock: Non-zero if duplex is locked at full
linux/lvm.h: * Copyright (C) 1997 - 2002  Heinz Mauelshagen, Sistina Software
linux/lvm.h: * February-November 1997
linux/lvm.h: * May-July 1998
linux/lvm.h: * January-March,July,September,October,Dezember 1999
linux/lvm.h: * January-March,June,July 2001
linux/lvm.h: * the Free Software Foundation, 59 Temple Place - Suite 330,
linux/lvm.h: * Boston, MA 02111-1307, USA.
linux/lvm.h: *    10/10/1997 - beginning of new structure creation
linux/lvm.h: *    12/05/1998 - incorporated structures from lvm_v1.h and deleted lvm_v1.h
linux/lvm.h: *    07/06/1998 - avoided LVM_KMALLOC_MAX define by using vmalloc/vfree
linux/lvm.h: *    01/07/1998 - fixed wrong LVM_MAX_SIZE
linux/lvm.h: *    07/07/1998 - extended pe_t structure by ios member (for statistic)
linux/lvm.h: *    02/08/1998 - changes for official char/block major numbers
linux/lvm.h: *    07/08/1998 - avoided init_module() and cleanup_module() to be static
linux/lvm.h: *    29/08/1998 - seprated core and disk structure type definitions
linux/lvm.h: *    01/09/1998 - merged kernel integration version (mike)
linux/lvm.h: *    20/01/1999 - added LVM_PE_DISK_OFFSET macro for use in
linux/lvm.h: *    18/02/1999 - added definition of time_disk_t structure for;
linux/lvm.h: *    15/03/1999 - corrected LV() and VG() macro definition to use argument
linux/lvm.h: *    03/07/1999 - define for genhd.c name handling
linux/lvm.h: *    23/07/1999 - implemented snapshot part
linux/lvm.h: *    08/12/1999 - changed LVM_LV_SIZE_MAX macro to reflect current 1TB limit
linux/lvm.h: *    01/01/2000 - extended lv_v2 core structure by wait_queue member
linux/lvm.h: *    12/02/2000 - integrated Andrea Arcagnelli's snapshot work
linux/lvm.h: *    18/02/2000 - seperated user and kernel space parts by
linux/lvm.h: *    08/03/2000 - implemented cluster/shared bits for vg_access
linux/lvm.h: *    26/06/2000 - implemented snapshot persistency and resizing support
linux/lvm.h: *    02/11/2000 - added hash table size member to lv structure
linux/lvm.h: *    12/11/2000 - removed unneeded timestamp definitions
linux/lvm.h: *    24/12/2000 - removed LVM_TO_{CORE,DISK}*, use cpu_{from, to}_le*
linux/lvm.h: *                 instead - Christoph Hellwig
linux/lvm.h: *    22/01/2001 - Change ulong to uint32_t
linux/lvm.h: *    14/02/2001 - changed LVM_SNAPSHOT_MIN_CHUNK to 1 page
linux/lvm.h: *    20/02/2001 - incremented IOP version to 11 because of incompatible
linux/lvm.h: *    01/03/2001 - Revert to IOP10 and add VG_CREATE_OLD call for compatibility
linux/lvm.h: *    08/03/2001 - new lv_t (in core) version number 5: changed page member
linux/lvm.h: *    26/03/2001 - changed lv_v4 to lv_v5 in structure definition (HM)
linux/lvm.h: *    21/06/2001 - changed BLOCK_SIZE back to 1024 for non S/390
linux/lvm.h: *    22/06/2001 - added Andreas Dilger's PE on 4k boundary alignment enhancements
linux/lvm.h: *    19/07/2001 - added rwsem compatibility macros for 2.2 kernels
linux/lvm.h: *    13/11/2001 - reduced userspace inclusion of kernel headers to a minimum
linux/lvm.h:#error Bad include/linux/major.h - LVM MAJOR undefined
linux/lvm.h: *   ---------------   ----------------------------------  ------------
linux/lvm.h: *   End of disk -     first physical extent               typically 4 megabyte
linux/lvm.h:#define	LVM_PE_T_MAX		( ( 1 << ( sizeof ( uint16_t) * 8)) - 2)
linux/lvm.h:#define	LVM_LV_SIZE_MAX(a)	( ( long long) LVM_PE_T_MAX * (a)->pe_size > ( long long) 1024*1024/SECTOR_SIZE*1024*1024 ? ( long long) 1024*1024/SECTOR_SIZE*1024*1024 : ( long long) LVM_PE_T_MAX * (a)->pe_size)
linux/lvm.h:#define	UNDEF	-1
linux/lvm.h: *	  because sizeof(1) = sizeof(int) = sizeof(2) = 4 on a 32-bit machine!
linux/lvm.h:	uint8_t vg_name_dummy[NAME_LEN - UUID_LEN];	/* rest of v1 VG name */
linux/lvm.h:	size--;
linux/lvm.h:	return vg->pe_size / lv->lv_chunk_size;
linux/lvm.h:	ulong chunks = vg->pe_size / lv->lv_chunk_size;
linux/lvm.h:	ulong chunk_size = lv->lv_chunk_size * SECTOR_SIZE;
linux/lvm.h:	ulong entries = (vg->pe_size * SECTOR_SIZE) /
linux/lvm.h:	for (; entries; entries--)
linux/nbd.h:	int uptodate = (req->errors == 0) ? 1 : 0;
linux/nbd.h:	while((bh = req->bh) != NULL) {
linux/nbd.h:		nsect = bh->b_size >> 9;
linux/nbd.h:		req->bh = bh->b_reqnext;
linux/nbd.h:		bh->b_reqnext = NULL;
linux/nbd.h:		bh->b_end_io(bh, uptodate);
linux/ncp.h:/* modify mask - use with MODIFY_DOS_INFO structure */
linux/net.h:#define SOCK_INODE(S)	((S)->inode)
linux/nfs.h:#define NFS_FIFO_DEV	(-1)
linux/nfs.h: * no-one uses anyway), so we can happily mix code as long as we make sure
linux/nfs.h: * Error codes that have a `--' in the v2 column are not part of the
linux/nfs.h:/* NFSv2 file types - beware, these are not the same in NFSv3 */
linux/nls.h:#define NLS_MAX_CHARSET_SIZE 6 /* for UTF-8 */
linux/nmi.h: * touch_nmi_watchdog - restart NMI watchdog timeout.
linux/nmi.h: * may be used to reset the timeout - for code which intentionally
linux/pci.h: *	Copyright 1997--1999 Martin Mares <mj@ucw.cz>
linux/pci.h:#define  PCI_COMMAND_FAST_BACK	0x200	/* Enable back-to-back writes */
linux/pci.h:#define  PCI_STATUS_FAST_BACK	0x80	/* Accept fast-back to back */
linux/pci.h:/* 0x35-0x3b are reserved */
linux/pci.h:/* Header type 1 (PCI-to-PCI bridges) */
linux/pci.h:/* 0x35-0x3b is reserved */
linux/pci.h:/* 0x3c-0x3d are same as for htype 0 */
linux/pci.h:/* 0x3c-0x3d are same as for htype 0 */
linux/pci.h:#define  PCI_CB_BRIDGE_CTL_16BIT_INT	0x80	/* Enable interrupt for 16-bit cards */
linux/pci.h:#define PCI_CB_LEGACY_MODE_BASE	0x44	/* 16-bit PC Card legacy mode base address (ExCa) */
linux/pci.h:/* 0x48-0x7f reserved */
linux/pci.h:#define  PCI_CAP_ID_PCIX	0x07	/* PCI-X */
linux/pci.h:#define  PCI_CAP_ID_SHPC	0x0C    /* PCI Standard Hot-Plug Controller */	
linux/pci.h:#define  PCI_CAP_ID_EXP		0x10    /* PCI-EXPRESS */	
linux/pci.h:#define  PCI_AGP_STATUS_RQ_MASK	0xff000000	/* Maximum number of requests - 1 */
linux/pci.h:#define  PCI_AGP_STATUS_64BIT	0x0020	/* 64-bit addressing supported */
linux/pci.h:#define  PCI_AGP_COMMAND_64BIT	0x0020 	/* Allow processing of 64-bit addresses */
linux/pci.h:#define  PCI_MSI_FLAGS_64BIT	0x80	/* 64-bit addresses allowed */
linux/pci.h:#define PCI_MSI_DATA_32		8	/* 16 bits of data for 32-bit devices */
linux/pci.h:#define PCI_MSI_DATA_64		12	/* 16 bits of data for 64-bit devices */
linux/pci.h:#define  PCI_CHSWP_EXT		0x40	/* ENUM# status - extraction */
linux/pci.h:#define  PCI_CHSWP_INS		0x80	/* ENUM# status - insertion */
linux/pci.h:/* PCI-X registers */
linux/pci.h:#define PCI_X_STATUS		6	/* PCI-X capabilities */
linux/pci.h:#define  PCI_X_STATUS_64BIT	0x0001	/* 64-bit device */
linux/pci.h: * The PCI interface treats multi-function devices as independent
linux/pci.h:#define PCIIOC_WRITE_COMBINE	(PCIIOC_BASE | 0x03)	/* Enable/disable write-combining. */
linux/pci.h:	for(dev = pci_dev_g(pci_devices.prev); dev != pci_dev_g(&pci_devices); dev = pci_dev_g(dev->global_list.prev))
linux/pci.h:for(bus = pci_bus_b(pci_root_buses.next); bus != pci_bus_b(&pci_root_buses); bus = pci_bus_b(bus->node.next))
linux/pci.h:	struct list_head bus_list;	/* node in per-bus list */
linux/pci.h:	void		*sysdata;	/* hook for sys-specific extension */
linux/pci.h:	unsigned int	class;		/* 3 bytes: (base,sub,prog-if) */
linux/pci.h:					   or supports 64-bit transfers.  */
linux/pci.h:	u32             current_state;  /* Current operating state. In ACPI-speak,
linux/pci.h:					   this is D0-D3, D0 being fully functional,
linux/pci.h: *	0-5	standard PCI regions
linux/pci.h: *	7-10	bridges: address space assigned to buses behind the bridge
linux/pci.h:	void		*sysdata;	/* hook for sys-specific extension */
linux/pci.h:	unsigned char	checksum;	/* if zero - checksum passed */
linux/pci.h:/* Low-level architecture-dependent routines */
linux/pci.h:	unsigned int class, class_mask;		/* (class,subclass,prog-if) triplet */
linux/pci.h:	void (*remove) (struct pci_dev *dev);	/* Device removed (NULL if not a hot-plug capable driver) */
linux/pci.h: * PCI_DEVICE - macro used to describe a specific pci device
linux/pci.h: * PCI_DEVICE_CLASS - macro used to describe a specific pci device class
linux/pci.h: * @dev_class: the class, subclass, prog-if triple for this device
linux/pci.h:	for(dev = pci_dev_g(pci_devices.next); dev != pci_dev_g(&pci_devices); dev = pci_dev_g(dev->global_list.next))
linux/pci.h:/* Helper functions for low-level code (drivers/pci/setup-[bus,res].c) */
linux/pci.h:/* New-style probing supporting hot-pluggable devices */
linux/pci.h:/* Include architecture-dependent settings and functions */
linux/pci.h:static inline int pci_enable_device_bars(struct pci_dev *dev, int mask) { return -EBUSY; }
linux/pci.h:static inline int pci_enable_device(struct pci_dev *dev) { return -EIO; }
linux/pci.h:static inline int pci_module_init(struct pci_driver *drv) { return -ENODEV; }
linux/pci.h:static inline int pci_set_dma_mask(struct pci_dev *dev, u64 mask) { return -EIO; }
linux/pci.h:static inline int pci_dac_set_dma_mask(struct pci_dev *dev, u64 mask) { return -EIO; }
linux/pci.h:static inline int pci_assign_resource(struct pci_dev *dev, int i) { return -EBUSY;}
linux/pci.h: * setup and cleanup for commonly-encountered hotplug/modular cases
linux/pci.h: * This MUST stay in a header, as it checks for -DMODULE
linux/pci.h:		rc = -ENODEV;		
linux/pci.h:#define pci_resource_start(dev,bar)   ((dev)->resource[(bar)].start)
linux/pci.h:#define pci_resource_end(dev,bar)     ((dev)->resource[(bar)].end)
linux/pci.h:#define pci_resource_flags(dev,bar)   ((dev)->resource[(bar)].flags)
linux/pci.h:	 (pci_resource_end((dev),(bar)) -		\
linux/pci.h:/* Similar to the helpers above, these manipulate per-pci_dev
linux/pci.h: * driver-specific data.  Currently stored as pci_dev::driver_data,
linux/pci.h:	return pdev->driver_data;
linux/pci.h:	pdev->driver_data = data;
linux/pci.h:	return pdev->slot_name;
linux/pci.h: *  For at least a part of these bugs we need a work-around, so both
linux/pci.h: *  generic (drivers/pci/quirks.c) and per-architecture code can define
linux/pmu.h:#define PMU_ADB_POLL_OFF	0x21	/* disable ADB auto-poll */
linux/pmu.h:#define PMU_WRITE_NVRAM		0x33	/* write non-volatile RAM */
linux/pmu.h:#define PMU_READ_NVRAM		0x3b	/* read non-volatile RAM */
linux/pmu.h:#define PMU_SET_RTC		0x30	/* set real-time clock */
linux/pmu.h:#define PMU_READ_RTC		0x38	/* read real-time clock */
linux/pmu.h:#define PMU_PCEJECT		0x4c	/* eject PC-card from slot */
linux/pmu.h:#define PMU_POWER_EVENTS	0x8f	/* Send power-event commands to PMU */
linux/pmu.h:#define PMU_INT_PCEJECT		0x04	/* PC-card eject buttons */
linux/pmu.h:#define PMU_INT_TICK		0x80	/* 1-second tick interrupt */
linux/pmu.h:#define PBOOK_SLEEP_REFUSE	-1
linux/iso_fs_sb.h: * iso9660 super-block data in memory
linux/scc.h:#define PRIMUS		0x04	/* hardware type for PRIMUS-PC (DG9BL) card */
linux/scc.h:	int  	 command;	/* one of the KISS-Commands defined above */
linux/scc.h:	unsigned param;		/* KISS-Param */
linux/scc.h:	io_port vector_latch;	/* INTACK-Latch (#) */
linux/scc.h:	unsigned char persist;		/* Persistence (0-255) as a % */
linux/x25.h: *      The somewhat ugly dimension 200-sizeof() is needed to maintain
linux/x25.h:	char device[200-sizeof(unsigned long)];
linux/sem.h:	struct sem_queue **	prev;	 /* previous entry in the queue, *(q->prev) == q */
linux/shm.h:	void 			*shm_unused2;	/* ditto - used by DIPC */
linux/shm.h:#define	SHM_RDONLY	010000	/* read-only access */
linux/shm.h:#define	SHM_REMAP	040000	/* take-over region on attach */
linux/rtc.h: * Struct rtc_time and first 12 ioctl by Paul Gortmaker, 1996 - separated out
linux/rtc.h: * Copyright (C) 1999 Hewlett-Packard Co.
linux/rtc.h: * source is self contained, allowing cross-compiles, etc. etc.
linux/rtc.h: * -ve pll_value means clock will run slower by
linux/rtc.h:	int pll_min;        /* max -ve (slower) adjustment value */
linux/rtc.h:	int pll_negmult;    /* factor for -ve correction */
linux/smb.h: *  Copyright (C) 1995, 1996 by Paal-Kr. Engstad and Volker Lendecke
linux/smb.h:	/* Connection-Options */
linux/sonypi.h: * Copyright (C) 2001-2003 Stelian Pop <stelian@popies.net>
linux/sonypi.h: * Copyright (C) 2001-2002 Alcve <www.alcove.com>
linux/sonypi.h: * Copyright (C) 2000 Takaya Kinjo <t-kinjo@tc4.so-net.ne.jp>
linux/smp.h: * main cross-CPU interfaces, handles INIT, TLB flush, STOP, etc.
linux/tcp.h: *  This means this part of the code is -fstrict-aliasing safe now.
linux/tcp.h:#define tcp_flag_word(tp) ( ((union tcp_word_hdr *)(tp))->words [3]) 
linux/tcp.h:#define TCP_LINGER2		8	/* Life time of orphaned FIN-WAIT-2 state */
linux/som.h:	short		system_id;		/* magic number - system */
linux/som.h:	short		a_magic;		/* magic number - file type */
linux/som.h:/* The Exec Auxiliary Header.  Called The HP-UX Header within HP apparently. */
linux/sys.h: * (please be careful - ibcs2 may need some of these).
linux/uio.h: *	Berkeley style UIO structures	-	Alan Cox 1994.
linux/uio.h:                                /* Beg pardon: BSD has 1024 --ANK */
linux/tty.h: * These constants are also useful for user-level apps (e.g., VC
linux/tty.h:# define UNIX98_NR_MAJORS ((CONFIG_UNIX98_PTY_COUNT+NR_PTYS-1)/NR_PTYS)
linux/tty.h: * These are set up by the setup-routine at boot-time:
linux/tty.h:	u16 dontuse1;		/* 0x02 -- EXT_MEM_K sits here */
linux/tty.h:	/* VESA graphic mode -- linear frame buffer */
linux/tty.h:	u16 dontuse2, dontuse3;	/* 0x20 -- CL_MAGIC and CL_OFFSET here */
linux/tty.h:						/* 0x34 -- 0x3f reserved for future expansion */
linux/tty.h:#define VIDEO_TYPE_PICA_S3	0x30	/* ACER PICA-61 local S3 video	*/
linux/tty.h:#define INTR_CHAR(tty) ((tty)->termios->c_cc[VINTR])
linux/tty.h:#define QUIT_CHAR(tty) ((tty)->termios->c_cc[VQUIT])
linux/tty.h:#define ERASE_CHAR(tty) ((tty)->termios->c_cc[VERASE])
linux/tty.h:#define KILL_CHAR(tty) ((tty)->termios->c_cc[VKILL])
linux/tty.h:#define EOF_CHAR(tty) ((tty)->termios->c_cc[VEOF])
linux/tty.h:#define TIME_CHAR(tty) ((tty)->termios->c_cc[VTIME])
linux/tty.h:#define MIN_CHAR(tty) ((tty)->termios->c_cc[VMIN])
linux/tty.h:#define SWTC_CHAR(tty) ((tty)->termios->c_cc[VSWTC])
linux/tty.h:#define START_CHAR(tty) ((tty)->termios->c_cc[VSTART])
linux/tty.h:#define STOP_CHAR(tty) ((tty)->termios->c_cc[VSTOP])
linux/tty.h:#define SUSP_CHAR(tty) ((tty)->termios->c_cc[VSUSP])
linux/tty.h:#define EOL_CHAR(tty) ((tty)->termios->c_cc[VEOL])
linux/tty.h:#define REPRINT_CHAR(tty) ((tty)->termios->c_cc[VREPRINT])
linux/tty.h:#define DISCARD_CHAR(tty) ((tty)->termios->c_cc[VDISCARD])
linux/tty.h:#define WERASE_CHAR(tty) ((tty)->termios->c_cc[VWERASE])
linux/tty.h:#define LNEXT_CHAR(tty)	((tty)->termios->c_cc[VLNEXT])
linux/tty.h:#define EOL2_CHAR(tty) ((tty)->termios->c_cc[VEOL2])
linux/tty.h:#define _I_FLAG(tty,f)	((tty)->termios->c_iflag & (f))
linux/tty.h:#define _O_FLAG(tty,f)	((tty)->termios->c_oflag & (f))
linux/tty.h:#define _C_FLAG(tty,f)	((tty)->termios->c_cflag & (f))
linux/tty.h:#define _L_FLAG(tty,f)	((tty)->termios->c_lflag & (f))
linux/tty.h: * has been closed --- for things like the baud rate, etc --- it is
linux/tty.h: * 						- TYT, 9/14/92
linux/tty.h:	/* If the tty has a pending do_SAK, queue it here - akpm */
linux/tty.h: * tty->write.  Thus, you must use the inline functions set_bit() and
linux/tty.h:#define TTY_CLOSING 		7	/* ->close() in progress */
linux/tty.h:#define TTY_HUPPED 		18	/* Post driver->hangup() */
linux/dcache.h: * (C) Copyright 1997 Thomas Schoebel-Theuer,
linux/dcache.h:#define IS_ROOT(x) ((x) == (x)->d_parent)
linux/dcache.h: * "quick string" -- eases parameter passing, but more importantly
linux/dcache.h:	while (len--)
linux/dcache.h:	struct inode  * d_inode;	/* Where the name belongs to - NULL is negative */
linux/dcache.h:	void * d_fsdata;		/* fs-specific data */
linux/dcache.h: * d_drop - drop a dentry
linux/dcache.h: * from deleting the dentry - d_delete will try to
linux/dcache.h:	list_del(&dentry->d_hash);
linux/dcache.h:	INIT_LIST_HEAD(&dentry->d_hash);
linux/dcache.h:	return d->d_name.name != d->d_iname; 
linux/dcache.h: * These are the low-level FS interfaces to the dcache..
linux/dcache.h:/* allocate/de-allocate */
linux/dcache.h:/* only used at mount-time */
linux/dcache.h:/* <clickety>-<click> the ramfs-type tree */
linux/dcache.h: * d_add - add dentry to hash queues
linux/dcache.h: *	dget, dget_locked	-	get a reference to a dentry
linux/dcache.h:		if (!atomic_read(&dentry->d_count))
linux/dcache.h:		atomic_inc(&dentry->d_count);
linux/dcache.h: *	d_unhashed -	is dentry hashed
linux/dcache.h:	return list_empty(&dentry->d_hash);
linux/dcache.h:	return dentry->d_mounted;
linux/usb.h:		current->state = TASK_UNINTERRUPTIBLE;
linux/usb.h: * struct usb_ctrlrequest - structure used to make USB device control requests easier to create and decode
linux/usb.h: * the different fields of the USB 2.0 Spec section 9.3, table 9-2.  See the
linux/usb.h: * USB-status codes:
linux/usb.h: * USB_ST* maps to -E* and should go away in the future
linux/usb.h:#define USB_ST_CRC		(-EILSEQ)
linux/usb.h:#define USB_ST_BITSTUFF		(-EPROTO)
linux/usb.h:#define USB_ST_NORESPONSE	(-ETIMEDOUT)			/* device not responding/handshaking */
linux/usb.h:#define USB_ST_DATAOVERRUN	(-EOVERFLOW)
linux/usb.h:#define USB_ST_DATAUNDERRUN	(-EREMOTEIO)
linux/usb.h:#define USB_ST_BUFFEROVERRUN	(-ECOMM)
linux/usb.h:#define USB_ST_BUFFERUNDERRUN	(-ENOSR)
linux/usb.h:#define USB_ST_INTERNALERROR	(-EPROTO) 			/* unknown error */
linux/usb.h:#define USB_ST_SHORT_PACKET	(-EREMOTEIO)
linux/usb.h:#define USB_ST_PARTIAL_ERROR	(-EXDEV)			/* ISO transfer only partially completed */
linux/usb.h:#define USB_ST_URB_KILLED	(-ENOENT)			/* URB canceled by user */
linux/usb.h:#define USB_ST_URB_PENDING	(-EINPROGRESS)
linux/usb.h:#define USB_ST_REMOVED		(-ENODEV) 			/* device not existing or removed */
linux/usb.h:#define USB_ST_TIMEOUT		(-ETIMEDOUT)			/* communication timed out, also in urb->status**/
linux/usb.h:#define USB_ST_NOTSUPPORTED	(-ENOSYS)			
linux/usb.h:#define USB_ST_BANDWIDTH_ERROR	(-ENOSPC)			/* too much bandwidth used */
linux/usb.h:#define USB_ST_URB_INVALID_ERROR  (-EINVAL)			/* invalid value/transfer type */
linux/usb.h:#define USB_ST_URB_REQUEST_ERROR  (-ENXIO)			/* invalid endpoint */
linux/usb.h:#define USB_ST_STALL		(-EPIPE) 			/* pipe stalled, also in urb->status*/
linux/usb.h: * Device table entry for "new style" table-driven USB drivers.
linux/usb.h: * Terminate the driver's table with an all-zeroes entry.
linux/usb.h: * struct usb_driver - identifies USB driver to usbcore
linux/usb.h: *      The handle is normally a pointer to driver-specific data.
linux/usb.h:/*----------------------------------------------------------------------------* 
linux/usb.h: *----------------------------------------------------------------------------*/
linux/usb.h: * urb->transfer_flags:
linux/usb.h:#define URB_NO_INTERRUPT	0x0080	/* HINT: no non-error interrupt needed */
linux/usb.h: * FILL_CONTROL_URB - macro to help initialize a control urb
linux/usb.h:	spin_lock_init(&(URB)->lock);\
linux/usb.h:	(URB)->dev=DEV;\
linux/usb.h:	(URB)->pipe=PIPE;\
linux/usb.h:	(URB)->setup_packet=SETUP_PACKET;\
linux/usb.h:	(URB)->transfer_buffer=TRANSFER_BUFFER;\
linux/usb.h:	(URB)->transfer_buffer_length=BUFFER_LENGTH;\
linux/usb.h:	(URB)->complete=COMPLETE;\
linux/usb.h:	(URB)->context=CONTEXT;\
linux/usb.h: * FILL_BULK_URB - macro to help initialize a bulk urb
linux/usb.h:	spin_lock_init(&(URB)->lock);\
linux/usb.h:	(URB)->dev=DEV;\
linux/usb.h:	(URB)->pipe=PIPE;\
linux/usb.h:	(URB)->transfer_buffer=TRANSFER_BUFFER;\
linux/usb.h:	(URB)->transfer_buffer_length=BUFFER_LENGTH;\
linux/usb.h:	(URB)->complete=COMPLETE;\
linux/usb.h:	(URB)->context=CONTEXT;\
linux/usb.h: * FILL_INT_URB - macro to help initialize a interrupt urb
linux/usb.h:	spin_lock_init(&(URB)->lock);\
linux/usb.h:	(URB)->dev=DEV;\
linux/usb.h:	(URB)->pipe=PIPE;\
linux/usb.h:	(URB)->transfer_buffer=TRANSFER_BUFFER;\
linux/usb.h:	(URB)->transfer_buffer_length=BUFFER_LENGTH;\
linux/usb.h:	(URB)->complete=COMPLETE;\
linux/usb.h:	(URB)->context=CONTEXT;\
linux/usb.h:	(URB)->interval=INTERVAL;\
linux/usb.h:	(URB)->start_frame=-1;\
linux/usb.h:	spin_lock_init(&(a)->lock);\
linux/usb.h:	(a)->dev=aa;\
linux/usb.h:	(a)->pipe=b;\
linux/usb.h:	(a)->setup_packet=c;\
linux/usb.h:	(a)->transfer_buffer=d;\
linux/usb.h:	(a)->transfer_buffer_length=e;\
linux/usb.h:	(a)->complete=f;\
linux/usb.h:	(a)->context=g;\
linux/usb.h:	(a)->timeout=h;\
linux/usb.h:	spin_lock_init(&(a)->lock);\
linux/usb.h:	(a)->dev=aa;\
linux/usb.h:	(a)->pipe=b;\
linux/usb.h:	(a)->transfer_buffer=c;\
linux/usb.h:	(a)->transfer_buffer_length=d;\
linux/usb.h:	(a)->complete=e;\
linux/usb.h:	(a)->context=f;\
linux/usb.h:	(a)->timeout=g;\
linux/usb.h: * usb_fill_control_urb - initializes a control urb
linux/usb.h:	spin_lock_init(&urb->lock);
linux/usb.h:	urb->dev = dev;
linux/usb.h:	urb->pipe = pipe;
linux/usb.h:	urb->setup_packet = setup_packet;
linux/usb.h:	urb->transfer_buffer = transfer_buffer;
linux/usb.h:	urb->transfer_buffer_length = buffer_length;
linux/usb.h:	urb->complete = complete;
linux/usb.h:	urb->context = context;
linux/usb.h: * usb_fill_bulk_urb - macro to help initialize a bulk urb
linux/usb.h:	spin_lock_init(&urb->lock);
linux/usb.h:	urb->dev = dev;
linux/usb.h:	urb->pipe = pipe;
linux/usb.h:	urb->transfer_buffer = transfer_buffer;
linux/usb.h:	urb->transfer_buffer_length = buffer_length;
linux/usb.h:	urb->complete = complete;
linux/usb.h:	urb->context = context;
linux/usb.h: * usb_fill_int_urb - macro to help initialize a interrupt urb
linux/usb.h:	spin_lock_init(&urb->lock);
linux/usb.h:	urb->dev = dev;
linux/usb.h:	urb->pipe = pipe;
linux/usb.h:	urb->transfer_buffer = transfer_buffer;
linux/usb.h:	urb->transfer_buffer_length = buffer_length;
linux/usb.h:	urb->complete = complete;
linux/usb.h:	urb->context = context;
linux/usb.h:	urb->interval = interval;
linux/usb.h:	urb->start_frame = -1;
linux/usb.h:/*-------------------------------------------------------------------*
linux/usb.h: *-------------------------------------------------------------------*/
linux/usb.h:/* -------------------------------------------------------------------------- */
linux/usb.h:	int devnum_next;                /* Next open device number in round-robin allocation */
linux/usb.h:					  /* 90% of a 1-millisecond frame */
linux/usb.h: * From USB 2.0 spec Table 11-13, offset 7, a hub can
linux/usb.h:	 * Child devices - these can be either new devices
linux/usb.h:/* used these for multi-interface device registration */
linux/usb.h: * usb_make_path - returns stable device path in the usb tree
linux/usb.h: * reconfigured, by re-cabling a tree of USB devices or by moving USB host
linux/usb.h: * neither does rebooting or re-enumerating.  These are more useful identifiers
linux/usb.h:	actual = snprintf (buf, size, "usb-%s-%s",
linux/usb.h:		dev->bus->bus_name, dev->devpath);
linux/usb.h:	return (actual >= size) ? -1 : actual;
linux/usb.h: *  - device number (7 bits)
linux/usb.h: *  - endpoint number (4 bits)
linux/usb.h: *  - current Data0/1 state (1 bit)
linux/usb.h: *  - direction (1 bit)
linux/usb.h: *  - speed (1 bit)
linux/usb.h: *  - max packet size (2 bits: 8, 16, 32 or 64) [Historical; now gone.]
linux/usb.h: *  - pipe type (2 bits: control, interrupt, bulk, isochronous)
linux/usb.h: *  - max size:		bits 0-1	(00 = 8, 01 = 16, 10 = 32, 11 = 64) [Historical; now gone.]
linux/usb.h: *  - direction:	bit 7		(0 = Host-to-Device [Out], 1 = Device-to-Host [In])
linux/usb.h: *  - device:		bits 8-14
linux/usb.h: *  - endpoint:		bits 15-18
linux/usb.h: *  - Data0/1:		bit 19
linux/usb.h: *  - speed:		bit 26		(0 = Full, 1 = Low Speed)
linux/usb.h: *  - pipe type:	bits 30-31	(00 = isochronous, 01 = interrupt, 10 = control, 11 = bulk)
linux/usb.h:				? (dev)->epmaxpacketout[usb_pipeendpoint(pipe)] \
linux/usb.h:				: (dev)->epmaxpacketin [usb_pipeendpoint(pipe)] )
linux/usb.h:#define usb_gettoggle(dev, ep, out) (((dev)->toggle[out] >> (ep)) & 1)
linux/usb.h:#define	usb_dotoggle(dev, ep, out)  ((dev)->toggle[out] ^= (1 << (ep)))
linux/usb.h:	dev->toggle[out] &= ~(1 << ep);
linux/usb.h:	dev->toggle[out] |= bit << ep;
linux/usb.h:#define usb_endpoint_halt(dev, ep, out) ((dev)->halted[out] |= (1 << (ep)))
linux/usb.h:#define usb_endpoint_running(dev, ep, out) ((dev)->halted[out] &= ~(1 << (ep)))
linux/usb.h:#define usb_endpoint_halted(dev, ep, out) ((dev)->halted[out] & (1 << (ep)))
linux/usb.h:	return (dev->devnum << 8) | (endpoint << 15) |
linux/usb.h:		((dev->speed == USB_SPEED_LOW) << 26);
linux/usb.h:	return ((dev->speed == USB_SPEED_LOW) << 26);
linux/usb.h:	__usb_get_extra_descriptor((ifpoint)->extra,(ifpoint)->extralen,type,(void**)ptr)
linux/yam.h: *	yam.h  -- YAM radio modem driver.
linux/yam.h:#define YAM_BITRATE  (1 << 2) /* Bit rate of radio port ->57600 */
linux/yam.h:#define YAM_BAUDRATE (1 << 9) /* Baud rate of rs232 port ->115200 */
linux/hdlcdrv.h: * hdlcdrv.h  -- HDLC packet radio network driver.
linux/hdlcdrv.h: * (C) 1996-1998 by Thomas Sailer, HB9JNX/AE4WA
linux/hdlcdrv.h:/* -------------------------------------------------------------------- */
linux/hdlcdrv.h:	int ppersist;  /* the p-persistence 0..255 */
linux/hdlcdrv.h:/* -------------------------------------------------------------------- */
linux/hdlcdrv.h:/* -------------------------------------------------------------------- */
linux/hdlcdrv.h:	new = buf->shreg & 1;
linux/hdlcdrv.h:	buf->shreg >>= 1;
linux/hdlcdrv.h:	buf->shreg |= (!!bit) << 7;
linux/hdlcdrv.h:		buf->buffer[buf->wr] = buf->shreg;
linux/hdlcdrv.h:		buf->wr = (buf->wr+1) % sizeof(buf->buffer);
linux/hdlcdrv.h:		buf->shreg = 0x80;
linux/hdlcdrv.h:	buf->buffer[buf->wr] = bits & 0xff;
linux/hdlcdrv.h:	buf->wr = (buf->wr+1) % sizeof(buf->buffer);
linux/hdlcdrv.h:	buf->buffer[buf->wr] = (bits >> 8) & 0xff;
linux/hdlcdrv.h:	buf->wr = (buf->wr+1) % sizeof(buf->buffer);
linux/hdlcdrv.h:/* -------------------------------------------------------------------- */
linux/hdlcdrv.h:/* -------------------------------------------------------------------- */
linux/hdlcdrv.h:	spin_lock_irqsave(&hb->lock, flags);
linux/hdlcdrv.h:	ret = !((HDLCDRV_HDLCBUFFER - 1 + hb->rd - hb->wr) % HDLCDRV_HDLCBUFFER);
linux/hdlcdrv.h:	spin_unlock_irqrestore(&hb->lock, flags);
linux/hdlcdrv.h:/* -------------------------------------------------------------------- */
linux/hdlcdrv.h:	spin_lock_irqsave(&hb->lock, flags);
linux/hdlcdrv.h:	ret = (hb->rd == hb->wr);
linux/hdlcdrv.h:	spin_unlock_irqrestore(&hb->lock, flags);
linux/hdlcdrv.h:/* -------------------------------------------------------------------- */
linux/hdlcdrv.h:	spin_lock_irqsave(&hb->lock, flags);
linux/hdlcdrv.h:	if (hb->rd == hb->wr)
linux/hdlcdrv.h:		newr = (hb->rd+1) % HDLCDRV_HDLCBUFFER;
linux/hdlcdrv.h:		val = hb->buf[hb->rd];
linux/hdlcdrv.h:		hb->rd = newr;
linux/hdlcdrv.h:	spin_unlock_irqrestore(&hb->lock, flags);
linux/hdlcdrv.h:/* -------------------------------------------------------------------- */
linux/hdlcdrv.h:	spin_lock_irqsave(&hb->lock, flags);
linux/hdlcdrv.h:	newp = (hb->wr+1) % HDLCDRV_HDLCBUFFER;
linux/hdlcdrv.h:	if (newp != hb->rd) { 
linux/hdlcdrv.h:		hb->buf[hb->wr] = val & 0xffff;
linux/hdlcdrv.h:		hb->wr = newp;
linux/hdlcdrv.h:	spin_unlock_irqrestore(&hb->lock, flags);
linux/hdlcdrv.h:/* -------------------------------------------------------------------- */
linux/hdlcdrv.h:	hdlcdrv_hbuf_put(&s->hdlcrx.hbuf, bits);
linux/hdlcdrv.h:	if (hdlcdrv_hbuf_empty(&s->hdlctx.hbuf)) {
linux/hdlcdrv.h:		if (s->hdlctx.calibrate > 0)
linux/hdlcdrv.h:			s->hdlctx.calibrate--;
linux/hdlcdrv.h:			s->hdlctx.ptt = 0;
linux/hdlcdrv.h:		ret = hdlcdrv_hbuf_get(&s->hdlctx.hbuf);
linux/hdlcdrv.h:	hdlcdrv_hbuf_put(&s->hdlcrx.hbuf, ret);
linux/hdlcdrv.h:	hdlcdrv_add_bitbuffer(&s->bitbuf_channel, bit);
linux/hdlcdrv.h:	s->hdlcrx.dcd = !!dcd;
linux/hdlcdrv.h:	return s->hdlctx.ptt || (s->hdlctx.calibrate > 0);
linux/hdlcdrv.h:/* -------------------------------------------------------------------- */
linux/hdlcdrv.h:/* -------------------------------------------------------------------- */
linux/hdlcdrv.h:/* -------------------------------------------------------------------- */
linux/hdlcdrv.h:/* -------------------------------------------------------------------- */
linux/i2c-algo-bit.h:/* ------------------------------------------------------------------------- */
linux/i2c-algo-bit.h:/* i2c-algo-bit.h i2c driver algorithms for bit-shift adapters               */
linux/i2c-algo-bit.h:/* ------------------------------------------------------------------------- */
linux/i2c-algo-bit.h:/*   Copyright (C) 1995-99 Simon G. Vogl
linux/i2c-algo-bit.h:/* ------------------------------------------------------------------------- */
linux/i2c-algo-bit.h:/* $Id: ack,v 1.1.1.1 2006-10-13 02:42:37 steven Exp $ */
linux/i2c-algo-bit.h:/* --- Defines for bit-adapters ---------------------------------------	*/
linux/i2c-algo-bit.h: * This struct contains the hw-dependent functions of bit-style adapters to 
linux/i2c-algo-bit.h: * manipulate the line states, and to init any hw-specific features. This is
linux/i2c-algo-bit.h: * only used if you have more than one hw-type of adapter running. 
linux/compatmac.h:   * This header tries to allow you to write 2.3-compatible drivers, 
linux/compatmac.h:   * -- R.E.Wolff@BitWizard.nl
linux/compatmac.h:#define tty_flip_buffer_push(tty)    queue_task(&tty->flip.tqueue, &tq_timer)
linux/compatmac.h:#define signal_pending(current)      (current->signal & ~current->blocked)
linux/compatmac.h:#define schedule_timeout(to)         do {current->timeout = jiffies + (to);schedule ();} while (0)
linux/compatmac.h:#define time_after(t1,t2)            (((long)t1-t2) > 0)
linux/compatmac.h:#define ASYNC_SPD_SHI  -1
linux/compatmac.h:#define ASYNC_SPD_WARP -1
linux/compatmac.h:#define TTY_HW_COOK_IN        15 /* in hardware - output and input       */
linux/compatmac.h:#define get_irq(pdev)         pdev->irq
linux/quota.h:#define qb2kb(x) ((x) << (QUOTABLOCK_BITS-10))
linux/quota.h:#define kb2qb(x) ((x) >> (QUOTABLOCK_BITS-10))
linux/quota.h:#define toqb(x) (((x) + QUOTABLOCK_SIZE - 1) >> QUOTABLOCK_BITS)
linux/quota.h:	info->dqi_flags |= DQF_INFO_DIRTY;
linux/quota.h:#define info_dirty(info) ((info)->dqi_flags & DQF_INFO_DIRTY)
linux/quota.h:#define info_any_dirty(info) ((info)->dqi_flags & DQF_INFO_DIRTY ||\
linux/quota.h:			      (info)->dqi_flags & DQF_ANY_DQUOT_DIRTY)
linux/quota.h:#define sb_dqopt(sb) (&(sb)->s_dquot)
linux/quota.h:	int (*read_file_info)(struct super_block *sb, int type);	/* Read main info about file - called on quotaon() */
linux/quota.h:	dquot->dq_flags |= DQ_MOD;\
linux/quota.h:	sb_dqopt(dquot->dq_sb)->info[dquot->dq_type].dqi_flags |= DQF_ANY_DQUOT_DIRTY;\
linux/quota.h:#define dquot_dirty(dquot) ((dquot)->dq_flags & DQ_MOD)
linux/quota.h:			return dqopt->flags & DQUOT_USR_ENABLED;
linux/quota.h:			return dqopt->flags & DQUOT_GRP_ENABLED;
linux/istallion.h: *	istallion.h  -- stallion intelligent multiport serial driver.
linux/istallion.h: *	Copyright (C) 1996-1998  Stallion Technologies
linux/istallion.h: *	Copyright (C) 1994-1996  Greg Ungerer.
linux/signal.h:	unsigned long sig = _sig - 1;
linux/signal.h:		set->sig[0] |= 1UL << sig;
linux/signal.h:		set->sig[sig / _NSIG_BPW] |= 1UL << (sig % _NSIG_BPW);
linux/signal.h:	unsigned long sig = _sig - 1;
linux/signal.h:		set->sig[0] &= ~(1UL << sig);
linux/signal.h:		set->sig[sig / _NSIG_BPW] &= ~(1UL << (sig % _NSIG_BPW));
linux/signal.h:	unsigned long sig = _sig - 1;
linux/signal.h:		return 1 & (set->sig[0] >> sig);
linux/signal.h:		return 1 & (set->sig[sig / _NSIG_BPW] >> (sig % _NSIG_BPW));
linux/signal.h:#define sigmask(sig)	(1UL << ((sig) - 1))
linux/signal.h:		a0 = a->sig[4*i+0]; a1 = a->sig[4*i+1];			\
linux/signal.h:		a2 = a->sig[4*i+2]; a3 = a->sig[4*i+3];			\
linux/signal.h:		b0 = b->sig[4*i+0]; b1 = b->sig[4*i+1];			\
linux/signal.h:		b2 = b->sig[4*i+2]; b3 = b->sig[4*i+3];			\
linux/signal.h:		r->sig[4*i+0] = op(a0, b0);				\
linux/signal.h:		r->sig[4*i+1] = op(a1, b1);				\
linux/signal.h:		r->sig[4*i+2] = op(a2, b2);				\
linux/signal.h:		r->sig[4*i+3] = op(a3, b3);				\
linux/signal.h:		a0 = a->sig[4*i+0]; a1 = a->sig[4*i+1]; a2 = a->sig[4*i+2]; \
linux/signal.h:		b0 = b->sig[4*i+0]; b1 = b->sig[4*i+1]; b2 = b->sig[4*i+2]; \
linux/signal.h:		r->sig[4*i+0] = op(a0, b0);				\
linux/signal.h:		r->sig[4*i+1] = op(a1, b1);				\
linux/signal.h:		r->sig[4*i+2] = op(a2, b2);				\
linux/signal.h:		a0 = a->sig[4*i+0]; a1 = a->sig[4*i+1];			\
linux/signal.h:		b0 = b->sig[4*i+0]; b1 = b->sig[4*i+1];			\
linux/signal.h:		r->sig[4*i+0] = op(a0, b0);				\
linux/signal.h:		r->sig[4*i+1] = op(a1, b1);				\
linux/signal.h:		a0 = a->sig[4*i+0]; b0 = b->sig[4*i+0];			\
linux/signal.h:		r->sig[4*i+0] = op(a0, b0);				\
linux/signal.h:		set->sig[4*i+0] = op(set->sig[4*i+0]);			\
linux/signal.h:		set->sig[4*i+1] = op(set->sig[4*i+1]);			\
linux/signal.h:		set->sig[4*i+2] = op(set->sig[4*i+2]);			\
linux/signal.h:		set->sig[4*i+3] = op(set->sig[4*i+3]);			\
linux/signal.h:	    case 3: set->sig[4*i+2] = op(set->sig[4*i+2]);		\
linux/signal.h:	    case 2: set->sig[4*i+1] = op(set->sig[4*i+1]);		\
linux/signal.h:	    case 1: set->sig[4*i+0] = op(set->sig[4*i+0]);		\
linux/signal.h:	case 2: set->sig[1] = 0;
linux/signal.h:	case 1:	set->sig[0] = 0;
linux/signal.h:		memset(set, -1, sizeof(sigset_t));
linux/signal.h:	case 2: set->sig[1] = -1;
linux/signal.h:	case 1:	set->sig[0] = -1;
linux/signal.h:	set->sig[0] |= mask;
linux/signal.h:	set->sig[0] &= ~mask;
linux/signal.h:	return (set->sig[0] & mask) != 0;
linux/signal.h:	set->sig[0] = mask;
linux/signal.h:		memset(&set->sig[1], 0, sizeof(long)*(_NSIG_WORDS-1));
linux/signal.h:	case 2: set->sig[1] = 0;
linux/signal.h:	set->sig[0] = ~mask;
linux/signal.h:		memset(&set->sig[1], -1, sizeof(long)*(_NSIG_WORDS-1));
linux/signal.h:	case 2: set->sig[1] = -1;
linux/signal.h:	sigemptyset(&sig->signal);
linux/signal.h:	sig->head = NULL;
linux/signal.h:	sig->tail = &sig->head;
linux/arcdevice.h: * necessary transmits - don't set this too high.
linux/arcdevice.h:#define D_EXTRA		2	/* useful, but non-vital information      */
linux/arcdevice.h:#define D_PROTO		64	/* debug auto-protocol support            */
linux/arcdevice.h:	    dev->name , ## args)
linux/arcdevice.h:		   name, bytes, _y - _x, \
linux/arcdevice.h:		   100000000 / 1024 * bytes / (_y - _x + 1));\
linux/arcdevice.h: * Time needed to reset the card - in ms (milliseconds).  This works on my
linux/arcdevice.h: * In non-RFC1201 protocols, we have to just tack some extra bytes on the
linux/arcdevice.h:#define RESETflag       0x10	/* power-on-reset */
linux/arcdevice.h:#define RES1flag        0x20	/* reserved - usually set by jumper */
linux/arcdevice.h:#define RES2flag        0x40	/* reserved - usually set by jumper */
linux/arcdevice.h:/* Flags used for IO-mapped memory operations */
linux/arcdevice.h:#define ENABLE16flag    0x80	/* (for 90xx) Enable 16-bit mode */
linux/arcdevice.h: *                0-2     command
linux/arcdevice.h: *                3-4     page number (for enable rcv/xmt command)
linux/arcdevice.h:#define RESETclear      0x08	/* power-on-reset */
linux/arcdevice.h:#define NORMALconf      0x00	/* 1-249 byte packets */
linux/arcdevice.h:#define EXTconf         0x08	/* 250-504 byte packets */
linux/arcdevice.h:/* card feature flags, set during auto-detection.
linux/arcdevice.h:	char suffix;		/* a for RFC1201, e for ether-encap, etc. */
linux/arcdevice.h: * to us.  Mostly for partially-received split packets.
linux/arcdevice.h:	int	cur_tx,		/* buffer used by current transmit, or -1 */
linux/arcdevice.h:	 * Buffer management: an ARCnet card has 4 x 512-byte buffers, each of
linux/arcdevice.h:	 * situations in which we (for example) want to pre-load a transmit
linux/arcdevice.h:	/* hardware-specific functions */
linux/arcdevice.h:#define ARCRESET(x)  (lp->hw.reset(dev, (x)))
linux/arcdevice.h:#define ACOMMAND(x)  (lp->hw.command(dev, (x)))
linux/arcdevice.h:#define ASTATUS()    (lp->hw.status(dev))
linux/arcdevice.h:#define AINTMASK(x)  (lp->hw.intmask(dev, (x)))
linux/arcdevice.h:#define ARCOPEN(x)   (lp->hw.open_close(dev, (x)))
linux/sdla_asy.h:/* ----------------------------------------------------------------------------
linux/sdla_asy.h: * --------------------------------------------------------------------------*/
linux/sdla_asy.h:/* ----------------------------------------------------------------------------
linux/sdla_asy.h: * --------------------------------------------------------------------------*/
linux/sdla_asy.h:/* ----------------------------------------------------------------------------
linux/sdla_asy.h: * --------------------------------------------------------------------------*/
linux/sdla_asy.h:	unsigned short asy_Rx_inter_char_timer	PACKED;	/* the receive inter-character timer */
linux/sdla_asy.h:#define MIN_ASY_RX_INTER_CHAR_TMR	0	/* minimum receive inter-character timer */
linux/sdla_asy.h:#define MAX_ASY_RX_INTER_CHAR_TMR	30000	/* maximum receive inter-character timer */
linux/sdla_asy.h:/* ----------------------------------------------------------------------------
linux/sdla_asy.h: * --------------------------------------------------------------------------*/
linux/sdla_asy.h:/* ----------------------------------------------------------------------------
linux/sdla_asy.h: * --------------------------------------------------------------------------*/
linux/sdla_asy.h:/* ----------------------------------------------------------------------------
linux/sdla_asy.h: * --------------------------------------------------------------------------*/
linux/sdla_asy.h:/* ----------------------------------------------------------------------------
linux/sdla_asy.h: * --------------------------------------------------------------------------*/
linux/i2c-algo-ite.h:/* ------------------------------------------------------------------------- */
linux/i2c-algo-ite.h:/* i2c-algo-ite.h i2c driver algorithms for ITE IIC adapters                 */
linux/i2c-algo-ite.h:/* ------------------------------------------------------------------------- */
linux/i2c-algo-ite.h:/*   Copyright (C) 1995-97 Simon G. Vogl
linux/i2c-algo-ite.h:                   1998-99 Hans Berglund
linux/i2c-algo-ite.h:/* ------------------------------------------------------------------------- */
linux/i2c-algo-pcf.h:/* ------------------------------------------------------------------------- */
linux/i2c-algo-pcf.h:/* adap-pcf.h i2c driver algorithms for PCF8584 adapters                     */
linux/i2c-algo-pcf.h:/* ------------------------------------------------------------------------- */
linux/i2c-algo-pcf.h:/*   Copyright (C) 1995-97 Simon G. Vogl
linux/i2c-algo-pcf.h:                   1998-99 Hans Berglund
linux/i2c-algo-pcf.h:/* ------------------------------------------------------------------------- */
linux/i2c-algo-pcf.h:/* $Id: ack,v 1.1.1.1 2006-10-13 02:42:37 steven Exp $ */
linux/i2c-algo-pcf.h:/* --- Defines for pcf-adapters ---------------------------------------	*/
linux/personality.h:	PER_IRIX32 =		0x0009 | STICKY_TIMEOUTS,/* IRIX5 32-bit */
linux/personality.h:	PER_IRIXN32 =		0x000a | STICKY_TIMEOUTS,/* IRIX6 new 32-bit */
linux/personality.h:	PER_IRIX64 =		0x000b | STICKY_TIMEOUTS,/* IRIX6 64-bit */
linux/personality.h:#define get_personality		(current->personality)
linux/personality.h:	((current->personality == pers) ? 0 : __set_personality(pers))
linux/personality.h:	if (ep != NULL && ep->module != NULL)		\
linux/personality.h:		__MOD_INC_USE_COUNT(ep->module);	\
linux/personality.h:	if (ep != NULL && ep->module != NULL)		\
linux/personality.h:		__MOD_DEC_USE_COUNT(ep->module);	\
linux/i2c-algo-sgi.h: * Copyright (C) 2003 Ladislav Michl <ladis@linux-mips.org>
linux/coda_psdev.h:    return ((struct coda_sb_info *)((sb)->u.generic_sbp));
linux/usb_ch9.h: * - the master/host side Linux-USB kernel driver API;
linux/usb_ch9.h: * - the "usbfs" user space API; and
linux/usb_ch9.h: * - (eventually) a Linux "gadget" slave/device side driver API.
linux/usb_ch9.h:/*-------------------------------------------------------------------------*/
linux/usb_ch9.h: * struct usb_ctrlrequest - SETUP data for a USB device control request
linux/usb_ch9.h: * the different fields of the USB 2.0 Spec section 9.3, table 9-2.  See the
linux/usb_ch9.h:/*-------------------------------------------------------------------------*/
linux/usb_ch9.h: * Note that all multi-byte values here are encoded in little endian
linux/usb_ch9.h: * byte order "on the wire".  But when exposed through Linux-USB APIs,
linux/usb_ch9.h:/* conventional codes for class-specific descriptors */
linux/usb_ch9.h:/*-------------------------------------------------------------------------*/
linux/usb_ch9.h:/*-------------------------------------------------------------------------*/
linux/usb_ch9.h: * descriptor type is different.  Highspeed-capable devices can look
linux/usb_ch9.h:/*-------------------------------------------------------------------------*/
linux/usb_ch9.h:	__u16 wData[1];		/* UTF-16LE encoded */
linux/usb_ch9.h:/*-------------------------------------------------------------------------*/
linux/usb_ch9.h:/*-------------------------------------------------------------------------*/
linux/usb_ch9.h:/*-------------------------------------------------------------------------*/
linux/usb_ch9.h:/*-------------------------------------------------------------------------*/
linux/usb_ch9.h:/*-------------------------------------------------------------------------*/
linux/usb_ch9.h:/*-------------------------------------------------------------------------*/
linux/usb_ch9.h:/*-------------------------------------------------------------------------*/
linux/sdla_ppp.h:* Copyright:	(c) 1995-1997 Sangoma Technologies Inc.
linux/sdla_ppp.h:/*----------------------------------------------------------------------------
linux/sdla_ppp.h: * ------
linux/sdla_ppp.h: * 1. All structures defined in this file are byte-alined.  
linux/sdla_ppp.h: *	--------	--------
linux/sdla_ppp.h:/*----------------------------------------------------------------------------
linux/sdla_ppp.h:/*----------------------------------------------------------------------------
linux/sdla_ppp.h:/*----------------------------------------------------------------------------
linux/sdla_ppp.h:/*----------------------------------------------------------------------------
linux/sdla_ppp.h:/*----------------------------------------------------------------------------
linux/sdla_ppp.h:/*----------------------------------------------------------------------------
linux/sdla_ppp.h:/*----------------------------------------------------------------------------
linux/sdla_ppp.h:	unsigned short 	mru		PACKED;	/* 00-01 Remote Max Rec' Unit */
linux/sdla_ppp.h:	unsigned long  	ip_local	PACKED;	/* 03-06: local IP address    */
linux/sdla_ppp.h:	unsigned long  	ip_remote	PACKED;	/* 07-0A: remote IP address   */
linux/sdla_ppp.h:	unsigned char  	ipx_netno[4]	PACKED;	/* 0C-0F: IPX net number      */
linux/sdla_ppp.h:	unsigned char  	ipx_local[6]	PACKED;	/* 10-1F: local IPX node #    */
linux/sdla_ppp.h:	unsigned char  	ipx_remote[6]	PACKED;	/* 16-1B: remote IPX node #   */
linux/sdla_ppp.h:	unsigned char  	ipx_router[48]	PACKED;	/* 1C-4B: IPX router name     */
linux/sdla_ppp.h:#define	PPP_IGNORE_TX_ABORT	0x01	/* don't re-transmit aborted frames */
linux/sdla_ppp.h:/*----------------------------------------------------------------------------
linux/sdla_ppp.h:/*----------------------------------------------------------------------------
linux/sdla_ppp.h:/*----------------------------------------------------------------------------
linux/sdla_ppp.h:/*----------------------------------------------------------------------------
linux/sdla_ppp.h:/*----------------------------------------------------------------------------
linux/sdla_ppp.h:	unsigned short rx_conf_rqst	PACKED;	/* 02: Configure-Request */
linux/sdla_ppp.h:	unsigned short rx_conf_ack	PACKED;	/* 04: Configure-Ack */
linux/sdla_ppp.h:	unsigned short rx_conf_nak	PACKED;	/* 06: Configure-Nak */
linux/sdla_ppp.h:	unsigned short rx_conf_rej	PACKED;	/* 08: Configure-Reject */
linux/sdla_ppp.h:	unsigned short rx_term_rqst	PACKED;	/* 0A: Terminate-Request */
linux/sdla_ppp.h:	unsigned short rx_term_ack	PACKED;	/* 0C: Terminate-Ack */
linux/sdla_ppp.h:	unsigned short rx_code_rej	PACKED;	/* 0E: Code-Reject */
linux/sdla_ppp.h:	unsigned short rx_proto_rej	PACKED;	/* 10: Protocol-Reject */
linux/sdla_ppp.h:	unsigned short rx_echo_rqst	PACKED;	/* 12: Echo-Request */
linux/sdla_ppp.h:	unsigned short rx_echo_reply	PACKED;	/* 14: Echo-Reply */
linux/sdla_ppp.h:	unsigned short rx_disc_rqst	PACKED;	/* 16: Discard-Request */
linux/sdla_ppp.h:	unsigned short tx_conf_rqst	PACKED;	/* 18: Configure-Request */
linux/sdla_ppp.h:	unsigned short tx_conf_ack	PACKED;	/* 1A: Configure-Ack */
linux/sdla_ppp.h:	unsigned short tx_conf_nak	PACKED;	/* 1C: Configure-Nak */
linux/sdla_ppp.h:	unsigned short tx_conf_rej	PACKED;	/* 1E: Configure-Reject */
linux/sdla_ppp.h:	unsigned short tx_term_rqst	PACKED;	/* 20: Terminate-Request */
linux/sdla_ppp.h:	unsigned short tx_term_ack	PACKED;	/* 22: Terminate-Ack */
linux/sdla_ppp.h:	unsigned short tx_code_rej	PACKED;	/* 24: Code-Reject */
linux/sdla_ppp.h:	unsigned short tx_proto_rej	PACKED;	/* 26: Protocol-Reject */
linux/sdla_ppp.h:	unsigned short tx_echo_rqst	PACKED;	/* 28: Echo-Request */
linux/sdla_ppp.h:	unsigned short tx_echo_reply	PACKED;	/* 2A: Echo-Reply */
linux/sdla_ppp.h:	unsigned short tx_disc_rqst	PACKED;	/* 2E: Discard-Request */
linux/sdla_ppp.h:	unsigned short rx_ack_inval	PACKED;	/* 32: invalid Conf-Ack */
linux/sdla_ppp.h:	unsigned short rx_rej_inval	PACKED;	/* 34: invalid Conf-Reject */
linux/sdla_ppp.h:	unsigned short rx_rej_badid	PACKED;	/* 36: Conf-Reject w/bad ID */
linux/sdla_ppp.h:/*----------------------------------------------------------------------------
linux/sdla_ppp.h:/*----------------------------------------------------------------------------
linux/sdla_ppp.h:	unsigned short rx_conf_rqst	PACKED;	/* 02: Configure-Request */
linux/sdla_ppp.h:	unsigned short rx_conf_ack	PACKED;	/* 04: Configure-Ack */
linux/sdla_ppp.h:	unsigned short rx_conf_nak	PACKED;	/* 06: Configure-Nak */
linux/sdla_ppp.h:	unsigned short rx_conf_rej	PACKED;	/* 08: Configure-Reject */
linux/sdla_ppp.h:	unsigned short rx_term_rqst	PACKED;	/* 0A: Terminate-Request */
linux/sdla_ppp.h:	unsigned short rx_term_ack	PACKED;	/* 0C: Terminate-Ack */
linux/sdla_ppp.h:	unsigned short rx_code_rej	PACKED;	/* 0E: Code-Reject */
linux/sdla_ppp.h:	unsigned short tx_conf_rqst	PACKED;	/* 12: Configure-Request */
linux/sdla_ppp.h:	unsigned short tx_conf_ack	PACKED;	/* 14: Configure-Ack */
linux/sdla_ppp.h:	unsigned short tx_conf_nak	PACKED;	/* 16: Configure-Nak */
linux/sdla_ppp.h:	unsigned short tx_conf_rej	PACKED;	/* 18: Configure-Reject */
linux/sdla_ppp.h:	unsigned short tx_term_rqst	PACKED;	/* 1A: Terminate-Request */
linux/sdla_ppp.h:	unsigned short tx_term_ack	PACKED;	/* 1C: Terminate-Ack */
linux/sdla_ppp.h:	unsigned short tx_code_rej	PACKED;	/* 1E: Code-Reject */
linux/sdla_ppp.h:	unsigned short rx_ack_inval	PACKED;	/* 22: invalid Conf-Ack */
linux/sdla_ppp.h:	unsigned short rx_rej_inval	PACKED;	/* 24: invalid Conf-Reject */
linux/sdla_ppp.h:	unsigned short rx_rej_badid	PACKED;	/* 26: Conf-Reject w/bad ID */
linux/sdla_ppp.h:/*----------------------------------------------------------------------------
linux/sdla_ppp.h:	unsigned short rx_auth_rqst	PACKED;	/* 02: Authenticate-Request */
linux/sdla_ppp.h:	unsigned short rx_auth_ack	PACKED;	/* 04: Authenticate-Ack */
linux/sdla_ppp.h:	unsigned short rx_auth_nak	PACKED;	/* 06: Authenticate-Nak */
linux/sdla_ppp.h:	unsigned short tx_auth_rqst	PACKED;	/* 0A: Authenticate-Request */
linux/sdla_ppp.h:	unsigned short tx_auth_ack	PACKED;	/* 0C: Authenticate-Ack */
linux/sdla_ppp.h:	unsigned short tx_auth_nak	PACKED;	/* 0E: Authenticate-Nak */
linux/sdla_ppp.h:/*----------------------------------------------------------------------------
linux/sdla_ppp.h:	unsigned short rx_challenge	PACKED;	/* 02: Authenticate-Request */
linux/sdla_ppp.h:	unsigned short rx_response	PACKED;	/* 04: Authenticate-Ack */
linux/sdla_ppp.h:	unsigned short rx_success	PACKED;	/* 06: Authenticate-Nak */
linux/sdla_ppp.h:	unsigned short rx_failure	PACKED;	/* 08: Authenticate-Nak */
linux/sdla_ppp.h:	unsigned short tx_challenge	PACKED;	/* 0C: Authenticate-Request */
linux/sdla_ppp.h:	unsigned short tx_response	PACKED;	/* 0E: Authenticate-Ack */
linux/sdla_ppp.h:	unsigned short tx_success	PACKED;	/* 10: Authenticate-Nak */
linux/sdla_ppp.h:	unsigned short tx_failure	PACKED;	/* 12: Authenticate-Nak */
linux/sdla_ppp.h:/*----------------------------------------------------------------------------
linux/nfs_page.h:#define NFS_WBACK_BUSY(req)	(test_bit(PG_BUSY,&(req)->wb_flags))
linux/nfs_page.h:	if (test_and_set_bit(PG_BUSY, &req->wb_flags))
linux/nfs_page.h:	if (test_and_set_bit(PG_BUSY, &req->wb_flags))
linux/nfs_page.h:	req->wb_count++;
linux/nfs_page.h:	clear_bit(PG_BUSY, &req->wb_flags);
linux/nfs_page.h:	if (waitqueue_active(&req->wb_wait))
linux/nfs_page.h:		wake_up_all(&req->wb_wait);
linux/nfs_page.h: * nfs_list_remove_request - Remove a request from its wb_list
linux/nfs_page.h:	if (list_empty(&req->wb_list))
linux/nfs_page.h:	list_del_init(&req->wb_list);
linux/nfs_page.h:	req->wb_list_head = NULL;
linux/nfs_page.h:	list_add_tail(&req->wb_lru, head);
linux/nfs_page.h:	if (list_empty(&req->wb_lru))
linux/nfs_page.h:	list_del_init(&req->wb_lru);
linux/sdla_x25.h:* Copyright:	(c) 1995-2000 Sangoma Technologies Inc.
linux/sdla_x25.h:/*----------------------------------------------------------------------------
linux/sdla_x25.h: * ------
linux/sdla_x25.h: * 1. All structures defined in this file are byte-alined.  
linux/sdla_x25.h: *	--------	--------
linux/sdla_x25.h:/*----------------------------------------------------------------------------
linux/sdla_x25.h:/*----- General commands --------------*/
linux/sdla_x25.h:/*----- HDLC-level commands -----------*/
linux/sdla_x25.h:#define X25_HDLC_FLUSH_BUFFERS	0x0D	/* flush HDLC-level data buffers */
linux/sdla_x25.h:/*----- X.25-level commands -----------*/
linux/sdla_x25.h:#define X25_FLUSH_DATA_BUFFERS	0x45	/* flush X.25-level data buffers */
linux/sdla_x25.h:#define	X25_GET_TX_D_BIT_STATUS	0x48	/* is packet with D-bit acknowleged */
linux/sdla_x25.h:#define	X25_READ_STATISTICS	0x49	/* read X.25-level statistics */
linux/sdla_x25.h:#define	X25_FLUSH_STATISTICS	0x4A	/* flush X.25-level statistics */
linux/sdla_x25.h:/*----- General results ---------------*/
linux/sdla_x25.h:#define X25RES_D_BIT_NOT_SUPPRT	0x38	/* D-bit pragmatics not supported */
linux/sdla_x25.h:/*----- Command-dependant results -----*/
linux/sdla_x25.h:/*----- Asynchronous events ------*/
linux/sdla_x25.h:/*----- Time-Out events ----------*/
linux/sdla_x25.h:/*----- Protocol Violation events */
linux/sdla_x25.h:/*----------------------------------------------------------------------------
linux/sdla_x25.h:/*----------------------------------------------------------------------------
linux/sdla_x25.h:/*----------------------------------------------------------------------------
linux/sdla_x25.h:	unsigned short twc_map	PACKED;	/* 04h: Two-way Cnan. map */
linux/sdla_x25.h:/* ---------------------------------------------------------------------------
linux/sdla_x25.h:	unsigned char resErr	PACKED;	/* 01h: '1' - reset modem error */
linux/sdla_x25.h:/* ---------------------------------------------------------------------------
linux/sdla_x25.h:/* ---------------------------------------------------------------------------
linux/sdla_x25.h:	unsigned char txQueued	PACKED;	/* 00h: queued Tx I-frames*/
linux/sdla_x25.h:	unsigned char rxQueued	PACKED;	/* 01h: queued Rx I-frames*/
linux/sdla_x25.h:/* ---------------------------------------------------------------------------
linux/sdla_x25.h:	unsigned short rxIFrames	PACKED;	/* 00h: ready Rx I-frames */
linux/sdla_x25.h:	unsigned short rxNoseq		PACKED;	/* 02h: frms out-of-sequence */
linux/sdla_x25.h:	unsigned short rxNodata		PACKED;	/* 04h: I-frms without data */
linux/sdla_x25.h:	unsigned short txAcked		PACKED;	/* 0Ch: acknowledged I-frms */
linux/sdla_x25.h:	unsigned short txRetransm	PACKED;	/* 0Eh: re-transmit. I-frms */
linux/sdla_x25.h:/* ---------------------------------------------------------------------------
linux/sdla_x25.h:/* ---------------------------------------------------------------------------
linux/sdla_x25.h:/* ---------------------------------------------------------------------------
linux/sdla_x25.h:typedef struct X25ChanAlloc			/*----- Channel allocation -*/
linux/sdla_x25.h:	unsigned short loTwoWaySVC	PACKED;	/* 08h: lowest two-way SVC */
linux/sdla_x25.h:	unsigned short hiTwoWaySVC	PACKED;	/* 0Ah: highest two-way SVC */
linux/sdla_x25.h:typedef struct X25ChanCfg		/*------ Channel configuration -----*/
linux/sdla_x25.h:#define	X25_SVC_TWOWAY	0x07	/* Two-way SVC */
linux/sdla_x25.h:/*----------------------------------------------------------------------------
linux/sdla_x25.h:/*----------------------------------------------------------------------------
linux/sdla_x25.h:/* ---------------------------------------------------------------------------
linux/sdla_x25.h:#define X25_TRC_ENABLE		0x01	/* bit0: '1' - trace enabled */
linux/sdla_x25.h:#define X25_TRC_TIMESTAMP	0x02	/* bit1: '1' - time stamping enabled*/
linux/sdla_x25.h:#define X25_TRC_DELAY		0x04	/* bit2: '1' - trace delay enabled */
linux/sdla_x25.h:#define X25_TRC_DATA		0x08	/* bit3: '1' - trace data packets */
linux/sdla_x25.h:#define X25_TRC_SUPERVISORY	0x10    /* bit4: '1' - trace suprvisory pkts*/
linux/sdla_x25.h:#define X25_TRC_ASYNCHRONOUS	0x20	/* bit5: '1' - trace asynch. packets*/
linux/sdla_x25.h:#define X25_TRC_HDLC		0x40	/* bit6: '1' - trace all packets */
linux/sdla_x25.h:#define X25_TRC_READ		0x80	/* bit7: '1' - get current config. */
linux/sdla_x25.h:/* ---------------------------------------------------------------------------
linux/sdla_x25.h:typedef struct X25Trace			/*----- Trace data structure -------*/
linux/sdla_x25.h:typedef struct HDLCFrame		/*----- DHLC Frame Format ----------*/
linux/sdla_x25.h:typedef struct X25Pkt			/*----- X.25 Paket Format ----------*/
linux/i2c-proc.h:    sensors.h - Part of lm_sensors, Linux kernel modules for hardware
linux/i2c-proc.h:     the ISA bus, -1 for any I2C bus), the second is the address. 
linux/i2c-proc.h:     the ISA bus, -1 for any I2C bus), the second is the address. These
linux/i2c-proc.h:     the ISA bus, -1 for any I2C bus), the second and third are addresses. 
linux/i2c-proc.h:     the ISA bus, -1 for any I2C bus), the second is the I2C address. These
linux/i2c-proc.h:     the ISA bus, -1 for any I2C bus), the second and third are addresses. 
linux/i2c-proc.h:#define SENSORS_MODPARM_AUX1(x) "1-" #x "h"
linux/i2c-proc.h:                      "List of adapter,start-addr,end-addr triples to scan " \
linux/i2c-proc.h:                      "List of adapter,start-addr,end-addr triples not to " \
linux/i2c-proc.h:/* This macro is used to scale user-input to sensible values in almost all
linux/adfs_fs_sb.h: * Copyright (C) 1997-1999 Russell King
linux/adfs_fs_sb.h: * Forward-declare this
linux/adfs_fs_sb.h:	umode_t		s_owner_mask;	/* ADFS owner perm -> unix perm		 */
linux/adfs_fs_sb.h:	umode_t		s_other_mask;	/* ADFS other perm -> unix perm		 */
linux/adfs_fs_sb.h:	signed int	s_map2blk;	/* shift left by this for map->sector	 */
linux/netdevice.h: *		Corey Minyard <wf-rch!minyard@relay.EU.net>
linux/netdevice.h:					/* source back-compat hooks */
linux/netdevice.h:	( (netdev)->ethtool_ops = (ops) )
linux/netdevice.h:					   (TC use only - dev_queue_xmit
linux/netdevice.h:#define net_xmit_errno(e)	((e) != NET_XMIT_CN ? -ENOBUFS : 0)
linux/netdevice.h:                                         *  encapuslated type. --BLG
linux/netdevice.h:	(HH_DATA_MOD - ((__len) & (HH_DATA_MOD - 1)))
linux/netdevice.h:	(((__len)+(HH_DATA_MOD-1))&~(HH_DATA_MOD - 1))
linux/netdevice.h: *	data with strictly "high-level" data, and it has to know about
linux/netdevice.h:	/* ------- Fields preinitialized in Space.c finish here ------- */
linux/netdevice.h:	/* These may be needed for future network-power-down code. */
linux/netdevice.h:                                                         * and we want to be 32-bit aligned.
linux/netdevice.h:	/* cpu id of processor entered to hard_start_xmit or -1,
linux/netdevice.h:#define NETIF_F_DYNALLOC	16	/* Self-dectructable device. */
linux/netdevice.h:	/* Semi-private data. Keep it at the end of device struct. */
linux/netdevice.h:	return dev->priv;
linux/netdevice.h: * Incoming packets are placed on per-cpu queues so that
linux/netdevice.h:	if (!test_and_set_bit(__LINK_STATE_SCHED, &dev->state)) {
linux/netdevice.h:		dev->next_sched = softnet_data[cpu].output_queue;
linux/netdevice.h:	if (!test_bit(__LINK_STATE_XOFF, &dev->state))
linux/netdevice.h:	clear_bit(__LINK_STATE_XOFF, &dev->state);
linux/netdevice.h:	if (test_and_clear_bit(__LINK_STATE_XOFF, &dev->state))
linux/netdevice.h:	set_bit(__LINK_STATE_XOFF, &dev->state);
linux/netdevice.h:	return test_bit(__LINK_STATE_XOFF, &dev->state);
linux/netdevice.h:	return test_bit(__LINK_STATE_START, &dev->state);
linux/netdevice.h:	if (atomic_dec_and_test(&skb->users)) {
linux/netdevice.h:		skb->next = softnet_data[cpu].completion_queue;
linux/netdevice.h: * either from interrupt or non-interrupt context.
linux/netdevice.h:	if (atomic_dec_and_test(&dev->refcnt))
linux/netdevice.h:#define __dev_put(dev) atomic_dec(&(dev)->refcnt)
linux/netdevice.h:#define dev_hold(dev) atomic_inc(&(dev)->refcnt)
linux/netdevice.h:	return !test_bit(__LINK_STATE_NOCARRIER, &dev->state);
linux/netdevice.h:	clear_bit(__LINK_STATE_NOCARRIER, &dev->state);
linux/netdevice.h:	set_bit(__LINK_STATE_NOCARRIER, &dev->state);
linux/netdevice.h:/* Hot-plugging. */
linux/netdevice.h:	return test_bit(__LINK_STATE_PRESENT, &dev->state);
linux/netdevice.h:	if (test_and_clear_bit(__LINK_STATE_PRESENT, &dev->state) &&
linux/netdevice.h:	if (!test_and_set_bit(__LINK_STATE_PRESENT, &dev->state) &&
linux/netdevice.h:#define netif_msg_drv(p)	((p)->msg_enable & NETIF_MSG_DRV)
linux/netdevice.h:#define netif_msg_probe(p)	((p)->msg_enable & NETIF_MSG_PROBE)
linux/netdevice.h:#define netif_msg_link(p)	((p)->msg_enable & NETIF_MSG_LINK)
linux/netdevice.h:#define netif_msg_timer(p)	((p)->msg_enable & NETIF_MSG_TIMER)
linux/netdevice.h:#define netif_msg_ifdown(p)	((p)->msg_enable & NETIF_MSG_IFDOWN)
linux/netdevice.h:#define netif_msg_ifup(p)	((p)->msg_enable & NETIF_MSG_IFUP)
linux/netdevice.h:#define netif_msg_rx_err(p)	((p)->msg_enable & NETIF_MSG_RX_ERR)
linux/netdevice.h:#define netif_msg_tx_err(p)	((p)->msg_enable & NETIF_MSG_TX_ERR)
linux/netdevice.h:#define netif_msg_tx_queued(p)	((p)->msg_enable & NETIF_MSG_TX_QUEUED)
linux/netdevice.h:#define netif_msg_intr(p)	((p)->msg_enable & NETIF_MSG_INTR)
linux/netdevice.h:#define netif_msg_tx_done(p)	((p)->msg_enable & NETIF_MSG_TX_DONE)
linux/netdevice.h:#define netif_msg_rx_status(p)	((p)->msg_enable & NETIF_MSG_RX_STATUS)
linux/netdevice.h:#define netif_msg_pktdata(p)	((p)->msg_enable & NETIF_MSG_PKTDATA)
linux/netdevice.h:#define netif_msg_hw(p)		((p)->msg_enable & NETIF_MSG_HW)
linux/netdevice.h:#define netif_msg_wol(p)	((p)->msg_enable & NETIF_MSG_WOL)
linux/netdevice.h:	return (1 << debug_value) - 1;
linux/netdevice.h:		!test_and_set_bit(__LINK_STATE_RX_SCHED, &dev->state);
linux/netdevice.h:	list_add_tail(&dev->poll_list, &softnet_data[cpu].poll_list);
linux/netdevice.h:	if (dev->quota < 0)
linux/netdevice.h:		dev->quota += dev->weight;
linux/netdevice.h:		dev->quota = dev->weight;
linux/netdevice.h:/* Try to reschedule poll. Called by dev->poll() after netif_rx_complete().
linux/netdevice.h:		dev->quota += undo;
linux/netdevice.h:		list_add_tail(&dev->poll_list, &softnet_data[cpu].poll_list);
linux/netdevice.h: * on current cpu. This primitive is called by dev->poll(), when
linux/netdevice.h:	if (!test_bit(__LINK_STATE_RX_SCHED, &dev->state)) BUG();
linux/netdevice.h:	list_del(&dev->poll_list);
linux/netdevice.h:	clear_bit(__LINK_STATE_RX_SCHED, &dev->state);
linux/netdevice.h:	while (test_and_set_bit(__LINK_STATE_RX_SCHED, &dev->state)) {
linux/netdevice.h:		current->state = TASK_INTERRUPTIBLE;
linux/netdevice.h:	clear_bit(__LINK_STATE_RX_SCHED, &dev->state);
linux/netdevice.h:	if (!test_bit(__LINK_STATE_RX_SCHED, &dev->state)) BUG();
linux/netdevice.h:	list_del(&dev->poll_list);
linux/netdevice.h:	clear_bit(__LINK_STATE_RX_SCHED, &dev->state);
linux/netdevice.h:	spin_lock_bh(&dev->xmit_lock);
linux/netdevice.h:	spin_unlock_bh(&dev->xmit_lock);
linux/netdevice.h:/* Support for loadable net-drivers */
linux/compile.h:#define LINUX_COMPILER "gcc version 3.3.3 (DENX ELDK 3.1.1 3.3.3-9)"
linux/sched.h: * These are the constant used to fake the fixed-point load-average
linux/sched.h: *  - 11 bit fractions expand to 22 bits by the multiplies: this gives
linux/sched.h: *    a load-average precision of 10 bits integer + 11 bits fractional
linux/sched.h: *  - if you want to count load-averages more often, you need more
linux/sched.h: *    precision, or rounding will get you. With 2-second counting freq,
linux/sched.h:#define FIXED_1		(1<<FSHIFT)	/* 1.0 as fixed-point */
linux/sched.h:#define EXP_1		1884		/* 1/exp(5sec/1min) as fixed-point */
linux/sched.h:	load += n*(FIXED_1-exp); \
linux/sched.h:	do { (tsk)->state = (state_value); } while (0)
linux/sched.h:	set_mb((tsk)->state, (state_value))
linux/sched.h:	do { current->state = (state_value); } while (0)
linux/sched.h:	set_mb(current->state, (state_value))
linux/sched.h: * yield the CPU for one re-schedule..
linux/sched.h: * the run-queue from deletions/modifications (but
linux/sched.h: * _adding_ to the beginning of the run-queue has
linux/sched.h:	rwlock_t file_lock;	/* Protects all the below members.  Nests inside tsk->alloc_lock */
linux/sched.h:	spinlock_t page_table_lock;		/* Protects task page tables and mm->rss */
linux/sched.h:	/* Architecture-specific MM context */
linux/sched.h: * Some day this will be a full-fledged user tracking system..
linux/sched.h:	struct user_struct *__tmp_user = current->user;	\
linux/sched.h:	atomic_inc(&__tmp_user->__count);		\
linux/sched.h:	 * offsets of these are hardcoded elsewhere - touch with care
linux/sched.h:	volatile long state;	/* -1 unrunnable, 0 runnable, >0 stopped */
linux/sched.h:					 	0-0xBFFFFFFF for user-thead
linux/sched.h:						0-0xFFFFFFFF for kernel-thread
linux/sched.h: * offset 32 begins here on 32-bit platforms. We keep
linux/sched.h:	 * mask is AND-ed with cpus_allowed.
linux/sched.h:	 * older sibling, respectively.  (p->father can be replaced with 
linux/sched.h:	 * p->p_pptr->pid)
linux/sched.h:/* mm fault and swap info: this can arguably be seen as either mm-specific or thread-specific */
linux/sched.h:/* CPU-specific state of this task */
linux/sched.h:/* Protection of (de-)allocation: mm, files, fs, tty */
linux/sched.h:#define PF_SUPERPRIV	0x00000100	/* used super-user privileges */
linux/sched.h:#define PF_MEMDIE      0x00001000       /* Killed for out-of-memory */
linux/sched.h:#define PT_PTRACE_CAP	0x00000010	/* ptracer can follow suid-exec */
linux/sched.h:#define is_dumpable(tsk)    ((tsk)->task_dumpable && (tsk)->mm && (tsk)->mm->dumpable)
linux/sched.h:    lock_depth:		-1,						\
linux/sched.h:#define pid_hashfn(x)	((((x) >> 8) ^ (x)) & (PIDHASH_SZ - 1))
linux/sched.h:	struct task_struct **htable = &pidhash[pid_hashfn(p->pid)];
linux/sched.h:	if((p->pidhash_next = *htable) != NULL)
linux/sched.h:		(*htable)->pidhash_pprev = &p->pidhash_next;
linux/sched.h:	p->pidhash_pprev = htable;
linux/sched.h:	if(p->pidhash_next)
linux/sched.h:		p->pidhash_next->pidhash_pprev = p->pidhash_pprev;
linux/sched.h:	*p->pidhash_pprev = p->pidhash_next;
linux/sched.h:	for(p = *htable; p && p->pid != pid; p = p->pidhash_next)
linux/sched.h:#define task_has_cpu(tsk) ((tsk)->cpus_runnable != ~0UL)
linux/sched.h:	tsk->processor = cpu;
linux/sched.h:	tsk->cpus_runnable = 1UL << cpu;
linux/sched.h:	tsk->cpus_runnable = ~0UL;
linux/sched.h:/* per-UID process charging. */
linux/sched.h:	return (p->sigpending != 0);
linux/sched.h: * Re-calculate pending state from the set of locally pending
linux/sched.h:		for (i = _NSIG_WORDS, ready = 0; --i >= 0 ;)
linux/sched.h:			ready |= signal->sig[i] &~ blocked->sig[i];
linux/sched.h:	case 4: ready  = signal->sig[3] &~ blocked->sig[3];
linux/sched.h:		ready |= signal->sig[2] &~ blocked->sig[2];
linux/sched.h:		ready |= signal->sig[1] &~ blocked->sig[1];
linux/sched.h:		ready |= signal->sig[0] &~ blocked->sig[0];
linux/sched.h:	case 2: ready  = signal->sig[1] &~ blocked->sig[1];
linux/sched.h:		ready |= signal->sig[0] &~ blocked->sig[0];
linux/sched.h:	case 1: ready  = signal->sig[0] &~ blocked->sig[0];
linux/sched.h:   All callers should have t->sigmask_lock.  */
linux/sched.h:	t->sigpending = has_pending_signals(&t->pending.signal, &t->blocked);
linux/sched.h:	return (sp - current->sas_ss_sp < current->sas_ss_size);
linux/sched.h:	return (current->sas_ss_size == 0 ? SS_DISABLE
linux/sched.h: * it returns true (to do BSD-style accounting where the process is flagged
linux/sched.h: * [Dec 1997 -- Chris Evans]
linux/sched.h:	if (!issecure(SECURE_NOROOT) && current->euid == 0) { 
linux/sched.h:		current->flags |= PF_SUPERPRIV;
linux/sched.h:	if (!issecure(SECURE_NOROOT) && current->fsuid == 0) {
linux/sched.h:		current->flags |= PF_SUPERPRIV;
linux/sched.h:	if (cap_raised(current->cap_effective, cap))
linux/sched.h:	if (cap_is_fs_cap(cap) ? current->fsuid == 0 : current->euid == 0)
linux/sched.h:		current->flags |= PF_SUPERPRIV;
linux/sched.h:	if (atomic_dec_and_test(&mm->mm_count))
linux/sched.h:/* mmput gets rid of the mappings and all user-space */
linux/sched.h:	current->state = TASK_RUNNING;					\
linux/sched.h:		ret = -ERESTARTSYS;					\
linux/sched.h:	current->state = TASK_RUNNING;					\
linux/sched.h:	(p)->next_task->prev_task = (p)->prev_task; \
linux/sched.h:	(p)->prev_task->next_task = (p)->next_task; \
linux/sched.h:	if ((p)->p_osptr) \
linux/sched.h:		(p)->p_osptr->p_ysptr = (p)->p_ysptr; \
linux/sched.h:	if ((p)->p_ysptr) \
linux/sched.h:		(p)->p_ysptr->p_osptr = (p)->p_osptr; \
linux/sched.h:		(p)->p_pptr->p_cptr = (p)->p_osptr; \
linux/sched.h:	(p)->next_task = &init_task; \
linux/sched.h:	(p)->prev_task = init_task.prev_task; \
linux/sched.h:	init_task.prev_task->next_task = (p); \
linux/sched.h:	(p)->p_ysptr = NULL; \
linux/sched.h:	if (((p)->p_osptr = (p)->p_pptr->p_cptr) != NULL) \
linux/sched.h:		(p)->p_osptr->p_ysptr = p; \
linux/sched.h:	(p)->p_pptr->p_cptr = p; \
linux/sched.h:	for (p = &init_task ; (p = p->next_task) != &init_task ; )
linux/sched.h:	list_entry((p)->thread_group.next, struct task_struct, thread_group)
linux/sched.h:#define thread_group_leader(p)	(p->pid == p->tgid)
linux/sched.h:	nr_running--;
linux/sched.h:	p->sleep_time = jiffies;
linux/sched.h:	list_del(&p->run_list);
linux/sched.h:	p->run_list.next = NULL;
linux/sched.h:	return (p->run_list.next != NULL);
linux/sched.h:	nr_threads--;
linux/sched.h:	list_del(&p->thread_group);
linux/sched.h:/* Protects ->fs, ->files, ->mm, and synchronises with wait4().  Nests inside tasklist_lock */
linux/sched.h:	spin_lock(&p->alloc_lock);
linux/sched.h:	spin_unlock(&p->alloc_lock);
linux/sched.h:	read_lock(&current->fs->lock);
linux/sched.h:	rootmnt = mntget(current->fs->rootmnt);
linux/sched.h:	root = dget(current->fs->root);
linux/sched.h:	read_unlock(&current->fs->lock);
linux/sched.h:	return (unlikely(current->need_resched));
linux/hfs_fs.h: * Copyright (C) 1995-1997  Paul H. Hargrove
linux/hfs_fs.h:#define HFS_HDR_FNAME	3   /* full (31-character) name */
linux/hfs_fs.h: *	Unix:	unsigned lil-endian since 00:00 GMT, Jan. 1, 1970
linux/hfs_fs.h: *	mac:	unsigned big-endian since 00:00 GMT, Jan. 1, 1904
linux/hfs_fs.h: *	header:	  SIGNED big-endian since 00:00 GMT, Jan. 1, 2000
linux/hfs_fs.h:#define hfs_m_to_htime(ARG)	((hfs_s32)htonl(ntohl(ARG)-3029529600U))
linux/hfs_fs.h:#define hfs_u_to_htime(ARG)	((hfs_s32)htonl(hfs_from_utc(ARG)-946684800U))
linux/hfs_fs.h:#define hfs_m_to_utime(ARG)	(hfs_to_utc(ntohl(ARG)-2082844800U))
linux/hfs_fs.h:#define	HFS_I(X)	(&((X)->u.hfs_i))
linux/hfs_fs.h:#define	HFS_SB(X)	(&((X)->u.hfs_sb))
linux/hfs_fs.h:	HFS_SB(dir->i_sb)->s_nameout(out, in, len);
linux/hfs_fs.h:	int len = HFS_SB(dir->i_sb)->s_namein(out, in);
linux/hfs_fs.h:	if (HFS_SB(dir->i_sb)->s_lowercase) {
linux/interrupt.h:/* Tasklets --- multithreaded analogue of BHs.
linux/interrupt.h:	return !test_and_set_bit(TASKLET_STATE_RUN, &(t)->state);
linux/interrupt.h:	clear_bit(TASKLET_STATE_RUN, &(t)->state);
linux/interrupt.h:	while (test_bit(TASKLET_STATE_RUN, &(t)->state)) { barrier(); }
linux/interrupt.h:	if (!test_and_set_bit(TASKLET_STATE_SCHED, &t->state))
linux/interrupt.h:	if (!test_and_set_bit(TASKLET_STATE_SCHED, &t->state))
linux/interrupt.h:	atomic_inc(&t->count);
linux/interrupt.h:	atomic_dec(&t->count);
linux/interrupt.h:	atomic_dec(&t->count);
linux/interrupt.h: * 5. wait for the device to interrupt, using non-intrusive polling or a delay.
linux/qnx4_fs_sb.h: *  Last modified                : 2000-01-06
linux/qnx4_fs_sb.h: *  History                      : 23-03-1998 created
linux/qnx4_fs_sb.h: * qnx4 super-block data in memory
linux/kbd_ll.h: *	Interface between the low-level keyboard driver and the keymapper
linux/zconf.h:/* zconf.h -- configuration of the zlib compression library
linux/zconf.h: * Copyright (C) 1995-1998 Jean-loup Gailly.
linux/zconf.h:     make CFLAGS="-O -DMAX_WBITS=14 -DMAX_MEM_LEVEL=7"
linux/route.h: * Authors:	Original taken from Berkeley UNIX 4.3, (c) UCB 1986-1988
linux/route.h:#define rt_mss	rt_mtu			/* Compatibility :-(            */
linux/route.h:#define RTF_MSS		RTF_MTU		/* Compatibility :-(		*/
linux/notifier.h:				   - we can use this eg to kick tcp sessions
linux/usb_gadget.h: * We call the USB code inside a Linux-based peripheral device a "gadget"
linux/usb_gadget.h: * driver, except for the hardware-specific bus glue.  One USB host can
linux/usb_gadget.h: * (C) Copyright 2002-2004 by David Brownell
linux/usb_gadget.h: * struct usb_request - describes one i/o request
linux/usb_gadget.h: *	its buffer may be re-used.
linux/usb_gadget.h: * 	Code "-ESHUTDOWN" indicates completion caused by device disconnect,
linux/usb_gadget.h: * 	reside in a device-side FIFO when the request is reported as
linux/usb_gadget.h: * hardware's driver can add extra per-request data to the memory it returns,
linux/usb_gadget.h: * transfers. interrupt-only endpoints can be much less functional.
linux/usb_gadget.h:	// except that it's thinner and promotes more pre-allocation.
linux/usb_gadget.h:/*-------------------------------------------------------------------------*/
linux/usb_gadget.h:/* endpoint-specific parts of the api to the usb controller hardware.
linux/usb_gadget.h: * struct usb_ep - device side representation of USB endpoint
linux/usb_gadget.h: * @name:identifier for the endpoint, such as "ep-a" or "ep9in-bulk"
linux/usb_gadget.h: * @ops: Function pointers used to access hardware-specific operations.
linux/usb_gadget.h: * 	read-only to gadget drivers.
linux/usb_gadget.h: * gadget->ep_list.  the control endpoint (gadget->ep0) is not in that list,
linux/usb_gadget.h:/*-------------------------------------------------------------------------*/
linux/usb_gadget.h: * usb_ep_enable - configure endpoint, making it usable
linux/usb_gadget.h: * 	is little-endian (usb-standard).
linux/usb_gadget.h: * for it.  for example, an endpoint named "ep2in-bulk" would be usable
linux/usb_gadget.h: * configurable, with more generic names like "ep-a".  (remember that for
linux/usb_gadget.h:	return ep->ops->enable (ep, desc);
linux/usb_gadget.h: * usb_ep_disable - endpoint is no longer usable
linux/usb_gadget.h: * indicating disconnect (-ESHUTDOWN) before this call returns.
linux/usb_gadget.h:	return ep->ops->disable (ep);
linux/usb_gadget.h: * usb_ep_alloc_request - allocate a request object to use with this endpoint
linux/usb_gadget.h: * need controller-specific setup and may even need endpoint-specific
linux/usb_gadget.h:	return ep->ops->alloc_request (ep, gfp_flags);
linux/usb_gadget.h: * usb_ep_free_request - frees a request object
linux/usb_gadget.h:	ep->ops->free_request (ep, req);
linux/usb_gadget.h: * usb_ep_alloc_buffer - allocate an I/O buffer
linux/usb_gadget.h: * and the caller won't have to care about dma-inconsistency
linux/usb_gadget.h: * or any hidden "bounce buffer" mechanism.  No additional per-request
linux/usb_gadget.h: * copies or per-request DMA mappings.
linux/usb_gadget.h:	return ep->ops->alloc_buffer (ep, len, dma, gfp_flags);
linux/usb_gadget.h: * usb_ep_free_buffer - frees an i/o buffer
linux/usb_gadget.h:	ep->ops->free_buffer (ep, buf, dma, len);
linux/usb_gadget.h: * usb_ep_queue - queues (submits) an I/O request to an endpoint.
linux/usb_gadget.h: * 	pre-allocate all necessary memory with the request.
linux/usb_gadget.h: * Interrupt-only endpoints are less functional than bulk endpoints, for
linux/usb_gadget.h:	return ep->ops->queue (ep, req, gfp_flags);
linux/usb_gadget.h: * usb_ep_dequeue - dequeues (cancels, unlinks) an I/O request from an endpoint
linux/usb_gadget.h: * completion routine is called (with status -ECONNRESET); else a negative
linux/usb_gadget.h:	return ep->ops->dequeue (ep, req);
linux/usb_gadget.h: * usb_ep_set_halt - sets the endpoint halt feature.
linux/usb_gadget.h: * @ep: the non-isochronous endpoint being stalled
linux/usb_gadget.h: * Attempts to halt IN endpoints will fail (returning -EAGAIN) if any
linux/usb_gadget.h:	return ep->ops->set_halt (ep, 1);
linux/usb_gadget.h: * usb_ep_clear_halt - clears endpoint halt, and resets toggle
linux/usb_gadget.h:	return ep->ops->set_halt (ep, 0);
linux/usb_gadget.h: * usb_ep_fifo_status - returns number of bytes in fifo, or error
linux/usb_gadget.h:	if (ep->ops->fifo_status)
linux/usb_gadget.h:		return ep->ops->fifo_status (ep);
linux/usb_gadget.h:		return -EOPNOTSUPP;
linux/usb_gadget.h: * usb_ep_fifo_flush - flushes contents of a fifo
linux/usb_gadget.h:	if (ep->ops->fifo_flush)
linux/usb_gadget.h:		ep->ops->fifo_flush (ep);
linux/usb_gadget.h:/*-------------------------------------------------------------------------*/
linux/usb_gadget.h: * struct usb_gadget - represents a usb slave device
linux/usb_gadget.h: * @ops: Function pointers used to access hardware-specific operations.
linux/usb_gadget.h: * @is_otg: True if the USB device port uses a Mini-AB jack, so that the
linux/usb_gadget.h: *	is in the Mini-AB jack, and HNP has been used to switch roles
linux/usb_gadget.h: *	so that the "A" device currently acts as A-Peripheral, not A-Host.
linux/usb_gadget.h: * @a_hnp_support: OTG device feature flag, indicating that the A-Host
linux/usb_gadget.h: * @a_alt_hnp_support: OTG device feature flag, indicating that the A-Host
linux/usb_gadget.h: * @b_hnp_enable: OTG device feature flag, indicating that the A-Host
linux/usb_gadget.h: * Gadgets have a mostly-portable "gadget driver" implementing device
linux/usb_gadget.h: * drivers talk to hardware-specific code indirectly, through ops vectors.
linux/usb_gadget.h: * read-only to the gadget driver.  That driver data is part of the
linux/usb_gadget.h: * device is acting as a B-Peripheral (so is_a_peripheral is false).
linux/usb_gadget.h:	{ gadget->dev.driver_data = data; }
linux/usb_gadget.h:	{ return gadget->dev.driver_data; }
linux/usb_gadget.h:/* iterates the non-control endpoints; 'tmp' is a struct usb_ep pointer */
linux/usb_gadget.h:	list_for_each_entry(tmp, &(gadget)->ep_list, ep_list)
linux/usb_gadget.h:	for (pos = list_entry((head)->next, typeof(*pos), member),	\
linux/usb_gadget.h:		     prefetch(pos->member.next);			\
linux/usb_gadget.h:	     &pos->member != (head); 					\
linux/usb_gadget.h:	     pos = list_entry(pos->member.next, typeof(*pos), member),	\
linux/usb_gadget.h:		     prefetch(pos->member.next))
linux/usb_gadget.h: * usb_gadget_frame_number - returns the current frame number
linux/usb_gadget.h:	return gadget->ops->get_frame (gadget);
linux/usb_gadget.h: * usb_gadget_wakeup - tries to wake up the host connected to this gadget
linux/usb_gadget.h:	if (!gadget->ops->wakeup)
linux/usb_gadget.h:		return -EOPNOTSUPP;
linux/usb_gadget.h:	return gadget->ops->wakeup (gadget);
linux/usb_gadget.h: * usb_gadget_set_selfpowered - sets the device selfpowered feature.
linux/usb_gadget.h: * @gadget:the device being declared as self-powered
linux/usb_gadget.h:	if (!gadget->ops->set_selfpowered)
linux/usb_gadget.h:		return -EOPNOTSUPP;
linux/usb_gadget.h:	return gadget->ops->set_selfpowered (gadget, 1);
linux/usb_gadget.h: * usb_gadget_clear_selfpowered - clear the device selfpowered feature.
linux/usb_gadget.h: * @gadget:the device being declared as bus-powered
linux/usb_gadget.h: * some hardware may not support bus-powered operation, in which
linux/usb_gadget.h:	if (!gadget->ops->set_selfpowered)
linux/usb_gadget.h:		return -EOPNOTSUPP;
linux/usb_gadget.h:	return gadget->ops->set_selfpowered (gadget, 0);
linux/usb_gadget.h: * usb_gadget_vbus_connect - Notify controller that VBUS is powered
linux/usb_gadget.h: * resuming the controller, activating the D+ (or D-) pullup to let the
linux/usb_gadget.h:	if (!gadget->ops->vbus_session)
linux/usb_gadget.h:		return -EOPNOTSUPP;
linux/usb_gadget.h:	return gadget->ops->vbus_session (gadget, 1);
linux/usb_gadget.h: * usb_gadget_vbus_draw - constrain controller's VBUS power usage
linux/usb_gadget.h:	if (!gadget->ops->vbus_draw)
linux/usb_gadget.h:		return -EOPNOTSUPP;
linux/usb_gadget.h:	return gadget->ops->vbus_draw (gadget, mA);
linux/usb_gadget.h: * usb_gadget_vbus_disconnect - notify controller about VBUS session end
linux/usb_gadget.h:	if (!gadget->ops->vbus_session)
linux/usb_gadget.h:		return -EOPNOTSUPP;
linux/usb_gadget.h:	return gadget->ops->vbus_session (gadget, 0);
linux/usb_gadget.h: * usb_gadget_connect - software-controlled connect to USB host
linux/usb_gadget.h: * Enables the D+ (or potentially D-) pullup.  The host will start
linux/usb_gadget.h:	if (!gadget->ops->pullup)
linux/usb_gadget.h:		return -EOPNOTSUPP;
linux/usb_gadget.h:	return gadget->ops->pullup (gadget, 1);
linux/usb_gadget.h: * usb_gadget_disconnect - software-controlled disconnect from USB host
linux/usb_gadget.h: * Disables the D+ (or potentially D-) pullup, which the host may see
linux/usb_gadget.h:	if (!gadget->ops->pullup)
linux/usb_gadget.h:		return -EOPNOTSUPP;
linux/usb_gadget.h:	return gadget->ops->pullup (gadget, 0);
linux/usb_gadget.h:/*-------------------------------------------------------------------------*/
linux/usb_gadget.h: * struct usb_gadget_driver - driver for usb 'slave' devices
linux/usb_gadget.h: * 	the currently-available endpoints.
linux/usb_gadget.h: * If gadget->is_otg is true, the gadget driver must provide an OTG
linux/usb_gadget.h: * Drivers use hardware-specific knowledge to configure the usb hardware.
linux/usb_gadget.h: * local controls (buttons, dials, etc) may need to be re-enabled since
linux/usb_gadget.h:/*-------------------------------------------------------------------------*/
linux/usb_gadget.h: * these will usually be implemented directly by the hardware-dependent
linux/usb_gadget.h: * usb_gadget_register_driver - register a gadget driver
linux/usb_gadget.h: * usb_gadget_unregister_driver - unregister a gadget driver
linux/usb_gadget.h:/*-------------------------------------------------------------------------*/
linux/usb_gadget.h: * struct usb_string - wraps a C string and its USB id
linux/usb_gadget.h: * @s:the string, in UTF-8 encoding
linux/usb_gadget.h: * struct usb_gadget_strings - a set of USB strings in a given language
linux/usb_gadget.h: * @language:identifies the strings' language (0x0409 for en-us)
linux/usb_gadget.h:	u16			language;	/* 0x0409 for en-us */
linux/usb_gadget.h:/*-------------------------------------------------------------------------*/
linux/usb_gadget.h:/*-------------------------------------------------------------------------*/
linux/serio.h: * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
linux/serio.h: * e-mail - mail your message to <vojtech@ucw.cz>, or by paper mail:
linux/serio.h:	return serio->write(serio, data);
linux/netfilter_ipv4.h:/* IPv4-specific defines for netfilter. 
linux/netfilter_ipv4.h: * (C)1998 Rusty Russell -- This code is GPL.
linux/netfilter_ipv4.h:/* Per-protocol information: only matters if proto match. */
linux/netfilter_ipv4.h:	NF_IP_PRI_CONNTRACK = -200,
linux/netfilter_ipv4.h:	NF_IP_PRI_MANGLE = -150,
linux/netfilter_ipv4.h:	NF_IP_PRI_NAT_DST = -100,
linux/netfilter_ipv6.h:/* IPv6-specific defines for netfilter. 
linux/netfilter_ipv6.h: * (C)1998 Rusty Russell -- This code is GPL.
linux/netfilter_ipv6.h:/* Per-protocol information: only matters if proto match. */
linux/netfilter_ipv6.h:	NF_IP6_PRI_CONNTRACK = -200,
linux/netfilter_ipv6.h:	NF_IP6_PRI_MANGLE = -150,
linux/netfilter_ipv6.h:	NF_IP6_PRI_NAT_DST = -100,
linux/ext3_jbd.h: * Copyright 1998--1999 Red Hat corp --- All Rights Reserved
linux/ext3_jbd.h: * Ext3-specific journaling extensions.
linux/ext3_jbd.h:#define EXT3_JOURNAL(inode)	(EXT3_SB((inode)->i_sb)->s_journal)
linux/ext3_jbd.h:#define EXT3_DATA_TRANS_BLOCKS		(3 * EXT3_SINGLEDATA_TRANS_BLOCKS - 2)
linux/ext3_jbd.h: * iloc->bh.  This _must_ be cleaned up later. 
linux/ext3_jbd.h:	if (!handle->h_err)
linux/ext3_jbd.h:		handle->h_err = err;
linux/ext3_jbd.h:	if (inode->i_sb->s_flags & MS_RDONLY)
linux/ext3_jbd.h:		return ERR_PTR(-EROFS);
linux/ext3_jbd.h:		ext3_abort(inode->i_sb, __FUNCTION__,
linux/ext3_jbd.h:		return ERR_PTR(-EROFS);
linux/ext3_jbd.h:	if (inode->i_sb->s_flags & MS_RDONLY)
linux/ext3_jbd.h:		return ERR_PTR(-EROFS);
linux/ext3_jbd.h:	int err = handle->h_err;
linux/ext3_jbd.h:	inode->i_sb->s_dirt = 1;
linux/ext3_jbd.h:		__ext3_std_error(inode->i_sb, where, err);
linux/ext3_jbd.h:	if (!S_ISREG(inode->i_mode))
linux/ext3_jbd.h:	if (test_opt(inode->i_sb, DATA_FLAGS) == EXT3_MOUNT_JOURNAL_DATA)
linux/ext3_jbd.h:	if (inode->u.ext3_i.i_flags & EXT3_JOURNAL_DATA_FL)
linux/ext3_jbd.h:	return (test_opt(inode->i_sb, DATA_FLAGS) == EXT3_MOUNT_ORDERED_DATA);
linux/fsfilter.h:/* -*- mode: c; c-basic-offset: 8; indent-tabs-mode: nil; -*-
linux/fsfilter.h:#define D_MALLOC    16  /* print malloc, de-alloc information */
linux/fsfilter.h:                printk("Process %d entered %s\n", current->pid, __FUNCTION__)
linux/fsfilter.h:                printk("Process %d leaving %s at %d\n", current->pid,   \
linux/efs_fs_sb.h:	int32_t		fs_time;        /* last super-block update */
linux/efs_fs_sb.h:	char		fs_spare[20];   /* space for expansion - MUST BE ZERO */
linux/eeprom.h:/* credit winbond-840.c
linux/eeprom.h:/* The EEPROM commands include the alway-set leading bit. */
linux/eeprom.h:	ee->addr = memaddr;
linux/eeprom.h:	ee->eesel = 1 << eesel_bit;
linux/eeprom.h:	ee->eeclk = 1 << eeclk_bit;
linux/eeprom.h:	ee->eedo = 1 << eedo_bit;
linux/eeprom.h:	ee->eedi = 1 << eedi_bit;
linux/eeprom.h:	ee->polarity = polarity;
linux/eeprom.h:	*ee->cache = readl(ee->addr);
linux/eeprom.h:	spin_lock_irqsave(ee->lock, flags);
linux/eeprom.h:	data = *ee->cache;
linux/eeprom.h:	*ee->cache = data;
linux/eeprom.h:	writel(data, ee->addr);
linux/eeprom.h:	spin_unlock_irqrestore(ee->lock, flags);
linux/eeprom.h:	int pol = !!(ee->polarity & EEPOL_EECLK);
linux/eeprom.h:	eeprom_update(ee, ee->eeclk, pol);
linux/eeprom.h:	int pol = !!(ee->polarity & EEPOL_EECLK);
linux/eeprom.h:	eeprom_update(ee, ee->eeclk, !pol);
linux/eeprom.h:	int pol = !!(ee->polarity & EEPOL_EEDI);
linux/eeprom.h:		eeprom_update(ee, ee->eedi, ((address >> 10) & 1) ^ pol);
linux/eeprom.h:	eeprom_update(ee, ee->eedi, pol);
linux/eeprom.h:	eeprom_update(ee, ee->eesel, 1 ^ !!(ee->polarity & EEPOL_EESEL));
linux/eeprom.h:		data = readl(ee->addr);
linux/eeprom.h:		res |= !!(data & ee->eedo) ^ !!(ee->polarity & EEPOL_EEDO);
linux/eeprom.h:	eeprom_update(ee, ee->eesel, 0 ^ !!(ee->polarity & EEPOL_EESEL));
linux/tty_flip.h:	if (tty->flip.count < TTY_FLIPBUF_SIZE) {
linux/tty_flip.h:		tty->flip.count++;
linux/tty_flip.h:		*tty->flip.flag_buf_ptr++ = flag;
linux/tty_flip.h:		*tty->flip.char_buf_ptr++ = ch;
linux/tty_flip.h:	queue_task(&tty->flip.tqueue, &tq_timer);
linux/if_vlan.h: * According to 802.3ac, the packet can be 4 bytes longer. --Klika Jan
linux/if_vlan.h: * it gives constant time look-up, but in many cases it wastes memory.
linux/if_vlan.h:				  * ((skb->priority << 13) & 0xE000)
linux/if_vlan.h:	/** This will be the mapping that correlates skb->priority to
linux/if_vlan.h:                                        *   like DHCP that use packet-filtering and don't understand
linux/if_vlan.h:	struct dev_mc_list *old_mc_list;  /* old multi-cast list for the VLAN interface..
linux/if_vlan.h:	struct net_device_stats dev_stats; /* Device stats (rx-bytes, tx-pkts, etc...) */
linux/if_vlan.h:#define VLAN_DEV_INFO(x) ((struct vlan_dev_info *)(x->priv))
linux/if_vlan.h:	return &(VLAN_DEV_INFO(dev)->dev_stats);
linux/if_vlan.h:	return vip->ingress_priority_map[(vlan_tag >> 13) & 0x7];
linux/if_vlan.h:#define VLAN_TX_SKB_CB(__skb)	((struct vlan_skb_tx_cookie *)&((__skb)->cb[0]))
linux/if_vlan.h:	(VLAN_TX_SKB_CB(__skb)->magic == VLAN_TX_COOKIE_MAGIC)
linux/if_vlan.h:#define vlan_tx_tag_get(__skb)	(VLAN_TX_SKB_CB(__skb)->vlan_tag)
linux/if_vlan.h:	skb->real_dev = skb->dev;
linux/if_vlan.h:	skb->dev = grp->vlan_devices[vlan_tag & VLAN_VID_MASK];
linux/if_vlan.h:	if (skb->dev == NULL) {
linux/if_vlan.h:	skb->dev->last_rx = jiffies;
linux/if_vlan.h:	stats = vlan_dev_get_stats(skb->dev);
linux/if_vlan.h:	stats->rx_packets++;
linux/if_vlan.h:	stats->rx_bytes += skb->len;
linux/if_vlan.h:	skb->priority = vlan_get_ingress_priority(skb->dev, vlan_tag);
linux/if_vlan.h:	switch (skb->pkt_type) {
linux/if_vlan.h:		stats->multicast++;
linux/if_vlan.h:		if (!memcmp(skb->mac.ethernet->h_dest, skb->dev->dev_addr, ETH_ALEN))
linux/if_vlan.h:			skb->pkt_type = PACKET_HOST;
linux/if_vlan.h: * __vlan_put_tag - regular VLAN tag inserting
linux/if_vlan.h:	memmove(skb->data, skb->data + VLAN_HLEN, 2 * VLAN_ETH_ALEN);
linux/if_vlan.h:	veth->h_vlan_proto = __constant_htons(ETH_P_8021Q);
linux/if_vlan.h:	veth->h_vlan_TCI = htons(tag);
linux/if_vlan.h: * __vlan_hwaccel_put_tag - hardware accelerated VLAN inserting
linux/if_vlan.h: * Puts the VLAN tag in @skb->cb[] and lets the device do the rest
linux/if_vlan.h:	cookie->magic = VLAN_TX_COOKIE_MAGIC;
linux/if_vlan.h:	cookie->vlan_tag = tag;
linux/if_vlan.h: * vlan_put_tag - inserts VLAN tag according to device features
linux/if_vlan.h: * Assumes skb->dev is the target that will xmit this frame.
linux/if_vlan.h:	if (skb->dev->features & NETIF_F_HW_VLAN_TX) {
linux/if_vlan.h: * __vlan_get_tag - get the VLAN ID that is part of the payload
linux/if_vlan.h:	struct vlan_ethhdr *veth = (struct vlan_ethhdr *)skb->data;
linux/if_vlan.h:	if (veth->h_vlan_proto != __constant_htons(ETH_P_8021Q)) {
linux/if_vlan.h:		return -EINVAL;
linux/if_vlan.h:	*tag = ntohs(veth->h_vlan_TCI);
linux/if_vlan.h: * __vlan_hwaccel_get_tag - get the VLAN ID that is in @skb->cb[]
linux/if_vlan.h: * Returns error if @skb->cb[] is not set correctly
linux/if_vlan.h:	if (cookie->magic == VLAN_TX_COOKIE_MAGIC) {
linux/if_vlan.h:		*tag = cookie->vlan_tag;
linux/if_vlan.h:		return -EINVAL;
linux/if_vlan.h: * vlan_get_tag - get the VLAN ID from the skb
linux/if_vlan.h:	if (skb->dev->features & NETIF_F_HW_VLAN_TX) {
linux/sdla_chdlc.h: Copyright:	(c) 1995-2000 Sangoma Technologies Inc.
linux/sdla_chdlc.h:	- Compatibility notes
linux/sdla_chdlc.h:	- Constants defining the shared memory control block (mailbox)
linux/sdla_chdlc.h:	- Interface commands
linux/sdla_chdlc.h:	- Return code from interface commands
linux/sdla_chdlc.h:	- Constants for the commands (structures for casting data)
linux/sdla_chdlc.h:	- UDP Management constants and structures
linux/sdla_chdlc.h:/*------------------------------------------------------------------------
linux/sdla_chdlc.h:	All structres defined in this file are byte-aligned.  
linux/sdla_chdlc.h:	------------------------
linux/sdla_chdlc.h:------------------------------------------------------------------------*/
linux/sdla_chdlc.h:/* ----------------------------------------------------------------------------
linux/sdla_chdlc.h: * --------------------------------------------------------------------------*/
linux/sdla_chdlc.h:#define PRI_MAX_NO_DATA_BYTES_IN_FRAME  15354 /* PRIMARY - max length of the CHDLC data field */
linux/sdla_chdlc.h:/* ----------------------------------------------------------------------------
linux/sdla_chdlc.h: * --------------------------------------------------------------------------*/
linux/sdla_chdlc.h:/* CHDLC-level interface commands */
linux/sdla_chdlc.h:/* ----------------------------------------------------------------------------
linux/sdla_chdlc.h: * --------------------------------------------------------------------------*/
linux/sdla_chdlc.h:/* return codes from CHDLC-level interface commands */
linux/sdla_chdlc.h:#define S514_BOTH_PORTS_SAME_CLK_MODE		0x26	/* S514 - both ports must have same clock mode */
linux/sdla_chdlc.h:/* ----------------------------------------------------------------------------
linux/sdla_chdlc.h: * --------------------------------------------------------------------------*/
linux/sdla_chdlc.h:/* ----------------------------------------------------------------------------
linux/sdla_chdlc.h: * --------------------------------------------------------------------------*/
linux/sdla_chdlc.h:/* ----------------------------------------------------------------------------
linux/sdla_chdlc.h: * --------------------------------------------------------------------------*/
linux/sdla_chdlc.h:	unsigned short sec_Tx_abort_msd_Tx_int_count PACKED; /* secondary - abort frames transmitted count (missed Tx interrupt) */
linux/sdla_chdlc.h:        unsigned short sec_Tx_abort_count PACKED;   /*secondary-abort frames tx count */
linux/sdla_chdlc.h:/* ----------------------------------------------------------------------------
linux/sdla_chdlc.h: * --------------------------------------------------------------------------*/
linux/sdla_chdlc.h:/* ----------------------------------------------------------------------------
linux/sdla_chdlc.h: * --------------------------------------------------------------------------*/
linux/sdla_chdlc.h:/* ----------------------------------------------------------------------------
linux/sdla_chdlc.h: * --------------------------------------------------------------------------*/
linux/sdla_chdlc.h:#define INTERFACE_LEVEL_RS232					0x0001 /* RS-232 interface level */
linux/sdla_chdlc.h:#define PRI_MAX_BAUD_RATE_S508	2666666 /* PRIMARY   - maximum baud rate (S508) */
linux/sdla_chdlc.h:#define SEC_MAX_BAUD_RATE_S508	258064 	/* SECONDARY - maximum baud rate (S508) */
linux/sdla_chdlc.h:#define PRI_MAX_BAUD_RATE_S514  2750000 /* PRIMARY   - maximum baud rate (S508) */
linux/sdla_chdlc.h:#define SEC_MAX_BAUD_RATE_S514  515625  /* SECONDARY - maximum baud rate (S508) */
linux/sdla_chdlc.h:#define SEC_MAX_NO_DATA_BYTES_IN_FRAME  2048 /* SECONDARY - max length of the CHDLC data field */
linux/sdla_chdlc.h:#define DEFAULT_SLARP_REQ_TIMER	0	  /* default value -- no SLARP */
linux/sdla_chdlc.h:/* ----------------------------------------------------------------------------
linux/sdla_chdlc.h: * --------------------------------------------------------------------------*/
linux/sdla_chdlc.h:/* ----------------------------------------------------------------------------
linux/sdla_chdlc.h: * --------------------------------------------------------------------------*/
linux/sdla_chdlc.h:	unsigned short Rx_SLARP_Reply_bad_IP_addr PACKED;	/* SLARP Reply received - bad IP address */
linux/sdla_chdlc.h:	unsigned short Rx_SLARP_Reply_bad_netmask PACKED;	/* SLARP Reply received - bad netmask */
linux/sdla_chdlc.h:/* ----------------------------------------------------------------------------
linux/sdla_chdlc.h: * --------------------------------------------------------------------------*/
linux/sdla_chdlc.h:/* ----------------------------------------------------------------------------
linux/sdla_chdlc.h: * --------------------------------------------------------------------------*/
linux/sdla_chdlc.h:/* ----------------------------------------------------------------------------
linux/sdla_chdlc.h: * --------------------------------------------------------------------------*/
linux/sdla_chdlc.h:/* ----------------------------------------------------------------------------
linux/sdla_chdlc.h: * --------------------------------------------------------------------------*/
linux/sdla_chdlc.h: 	unsigned char parallel_port_A_input PACKED;	/* input - parallel port A */
linux/sdla_chdlc.h: 	unsigned char parallel_port_B_input PACKED;	/* input - parallel port B */
linux/sdla_chdlc.h:/* ----------------------------------------------------------------------------
linux/sdla_chdlc.h: * --------------------------------------------------------------------------*/
linux/sdla_chdlc.h:/* ----------------------------------------------------------------------------
linux/sdla_chdlc.h: * --------------------------------------------------------------------------*/
linux/sdla_chdlc.h:#define LN_BLD_CSU_0dB_DSX1_0_to_133	0x00	/* set build out to CSU (0db) or DSX-1 (0-133ft) */
linux/sdla_chdlc.h:#define LN_BLD_DSX1_133_to_266		0x01	/* set build out DSX-1 (133-266ft) */
linux/sdla_chdlc.h:#define LN_BLD_DSX1_266_to_399		0x02	/* set build out DSX-1 (266-399ft) */
linux/sdla_chdlc.h:#define LN_BLD_DSX1_399_to_533		0x03	/* set build out DSX-1 (399-533ft) */
linux/sdla_chdlc.h:#define LN_BLD_DSX1_533_to_655		0x04	/* set build out DSX-1 (533-655ft) */
linux/sdla_chdlc.h:#define LN_BLD_CSU_NEG_7dB		0x05	/* set build out to CSU (-7.5db) */
linux/sdla_chdlc.h:#define LN_BLD_CSU_NEG_15dB		0x06	/* set build out to CSU (-15db) */
linux/sdla_chdlc.h:#define LN_BLD_CSU_NEG_22dB		0x07	/* set build out to CSU (-22.5db) */
linux/auto_fs4.h:/* -*- c -*-
linux/auto_fs4.h: * Copyright 1999-2000 Jeremy Fitzhardinge <jeremy@goop.org>
linux/i2o-dev.h:/* Event data size = frame size - message header + evt indicator */
linux/i2o-dev.h: *  (from v1.5 Table 6-1 Class Code Assignments.)
linux/i2o-dev.h: *  Rest of 0x092 - 0x09f reserved for peer-to-peer classes
linux/agp_backend.h: * It returns -EINVAL if the pointer == NULL.
linux/agp_backend.h: * It returns -EBUSY if the area of the table
linux/agp_backend.h: * It returns -EINVAL if this piece of agp_memory
linux/agp_backend.h: * This function initializes the agp point-to-point
linux/agp_backend.h: * returns -EBUSY if agp is in use,
linux/sisfb.h: * Copyright (C) 2001-2004 by Thomas Winischhofer, Vienna, Austria.
linux/sisfb.h: * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA
linux/sisfb.h: 	__u32   chip_id;		/* PCI-ID of detected chip */
linux/sisfb.h:	__u8 	sisfb_lcdpdca;		/* PanelDelayCompensation for LCD-via-CRT1 */
linux/sisfb.h:/* ioctl to enable/disable panning auto-maximize (like nomax parameter) */
linux/sisfb.h:/* ioctl to enable/disable panning auto-maximize (like nomax parameter) */
linux/sisfb.h:/*         (for IN-KERNEL usage only)         */
linux/ipmi_smi.h:/* Structure for the low-level drivers. */
linux/ipmi_smi.h:	   message will go into a high-priority queue and be sent
linux/ipmi_smi.h:	   first.  Otherwise, it goes into a normal-priority queue. */
linux/ipmi_smi.h:/* Add a low-level interface to the IPMI driver. */
linux/ipmi_smi.h: * Remove a low-level interface from the IPMI driver.  This will
linux/ipmi_smi.h:/* The lower layer received a watchdog pre-timeout on interface. */
linux/ipmi_smi.h:	msg->done(msg);
linux/brlock.h: * 'Big Reader' read-write spinlocks.
linux/brlock.h: * super-fast read/write locks, with write-side penalty. The point
linux/brlock.h: * is to have a per-CPU read/write lock. Readers lock their CPU-local
linux/brlock.h: * CPU-read-write locks are semantically identical to normal rwlocks.
linux/brlock.h: * cacheline ping-pong in the 'most readonly data' case.
linux/brlock.h: * Registry idea and naming [ crutial! :-) ] by:
linux/brlock.h:	(((sizeof(brlock_read_lock_t)*__BR_END + SMP_CACHE_BYTES-1) & ~(SMP_CACHE_BYTES-1)) / sizeof(brlock_read_lock_t))
linux/brlock.h:	 * This causes a link-time bug message if an
linux/brlock.h:		(*ctr)--;
linux/brlock.h:	(*ctr)--;
linux/brlock.h:/* write path not inlined - it's rare and larger */
linux/major.h:#define	MUX_MAJOR	11	/* PA-RISC only */
linux/major.h:#define I2O_MAJOR		80	/* 80->87 */
linux/major.h:#define OSST_MAJOR	206	/* OnStream-SCx0 SCSI tape */
linux/hdsmart.h: * Copyright (C) 1999-2000	Michael Cornwell <cornwell@acm.org>
linux/hdsmart.h: * Copyright (C) 2000		Andre Hedrick <andre@linux-ide.org>
linux/hdsmart.h:/* smart_attribute is the vendor specific in SFF-8035 spec */
linux/netfilter_bridge.h:/* bridge-specific defines for netfilter. 
linux/if_pppox.h: * Linux PPP over X - Generic PPP transport layer sockets
linux/if_pppox.h:/* For user-space programs to pick up these definitions
linux/if_pppox.h:extern void pppox_unbind_sock(struct sock *sk);/* delete ppp-channel binding */
linux/ppp-comp.h: * ppp-comp.h - Definitions for doing PPP packet compression.
linux/ppp-comp.h: * $Id: ack,v 1.1.1.1 2006-10-13 02:42:37 steven Exp $
linux/ppp-comp.h: *     ppp-comp.h is shipped with a PPP distribution as well as with the kernel;
linux/ppp-comp.h: *     can do the right thing when deciding whether to install a new ppp-comp.h
linux/ppp-comp.h:#define DO_BSD_COMPRESS	1	/* by default, include BSD-Compress */
linux/ppp-comp.h: * useful functionality, namely sending a CCP reset-request as a result
linux/ppp-comp.h:#define DECOMP_ERROR		-1	/* error detected before decomp. */
linux/ppp-comp.h:#define DECOMP_FATALERROR	-2	/* error detected after decomp. */
linux/ppp-comp.h: * Definitions for BSD-Compress.
linux/ppp-comp.h:#define CI_BSD_COMPRESS		21	/* config. option for BSD-Compress */
linux/ppp-comp.h:/* Macros for handling the 3rd byte of the BSD-Compress config option. */
linux/ppp-comp.h:#define DEFLATE_MAKE_OPT(w)	((((w) - DEFLATE_MIN_SIZE) << 4) \
linux/ppp-comp.h:#define CI_PREDICTOR_1		1	/* config option for Predictor-1 */
linux/ppp-comp.h:#define CI_PREDICTOR_2		2	/* config option for Predictor-2 */
linux/pagemap.h: * Page-mapping primitive inline functions
linux/pagemap.h:#define PAGE_CACHE_ALIGN(addr)	(((addr)+PAGE_CACHE_SIZE-1)&PAGE_CACHE_MASK)
linux/pagemap.h:	return alloc_pages(x->gfp_mask, 0);
linux/pagemap.h: * We use a power-of-two hash table to avoid a modulus,
linux/pagemap.h:#define i (((unsigned long) mapping)/(sizeof(struct inode) & ~ (sizeof(struct inode) - 1)))
linux/pagemap.h:	return s(i+index) & (PAGE_HASH_SIZE-1);
linux/pagemap.h:	return find_or_create_page(mapping, index, mapping->gfp_mask);
linux/ncp_fs.h:/* Guess, what 0x564c is :-) */
linux/ncp_fs.h:#define NCP_SBP(sb)		(&((sb)->u.ncpfs_sb))
linux/ncp_fs.h:#define NCP_SERVER(inode)	NCP_SBP((inode)->i_sb)
linux/ncp_fs.h:#define NCP_FINFO(inode)	(&((inode)->u.ncpfs_i))
linux/ncp_fs.h:	ncp_current_malloced -= 1;
linux/ncp_fs.h:	return ncp_request2(server, function, server->packet, server->packet_size);
linux/ncp_fs.h:#define ncp_namespace(i)	(NCP_SERVER(i)->name_space[NCP_FINFO(i)->volNumber])
linux/ncp_no.h:#define aPURGE			(ntohl(1L<<(16-8)))
linux/ncp_no.h:#define aRENAMEINHIBIT		(ntohl(1L<<(17-8)))
linux/ncp_no.h:#define aDELETEINHIBIT		(ntohl(1L<<(18-8)))
linux/ncp_no.h:#define aDONTCOMPRESS		(nothl(1L<<(27-24)))
linux/completion.h: * Atomic wait-for-completion handler data structures.
linux/completion.h:	x->done = 0;
linux/completion.h:	init_waitqueue_head(&x->wait);
linux/mmzone.h: * Free memory management - zoned buddy allocator.
linux/mmzone.h: * ZONE_NORMAL	16-896 MB	direct mapped by the kernel
linux/mmzone.h:	 * wait_table		-- the array holding the hash table
linux/mmzone.h:	 * wait_table_size	-- the size of the hash table array
linux/mmzone.h:	 * wait_table_shift	-- wait_table_size
linux/mmzone.h:	 * per-page waitqueues, we use a waitqueue hash table.
linux/mmzone.h: * modify it apart from boot-up, and only a few indices are used,
linux/mmzone.h: * (mostly NUMA machines?) to denote a higher-level memory zone than the
linux/mmzone.h:#define zone_idx(zone)                 ((zone) - (zone)->zone_pgdat->node_zones)
linux/mmzone.h: * for_each_pgdat - helper macro to iterate over all nodes
linux/mmzone.h: * @pgdat - pg_data_t * variable
linux/mmzone.h: * 	pgdat = pgdat->node_next;
linux/mmzone.h:	for (pgdat = pgdat_list; pgdat; pgdat = pgdat->node_next)
linux/mmzone.h: * next_zone - helper magic for for_each_zone()
linux/mmzone.h:	pg_data_t *pgdat = zone->zone_pgdat;
linux/mmzone.h:	if (zone - pgdat->node_zones < MAX_NR_ZONES - 1)
linux/mmzone.h:	else if (pgdat->node_next) {
linux/mmzone.h:		pgdat = pgdat->node_next;
linux/mmzone.h:		zone = pgdat->node_zones;
linux/mmzone.h: * for_each_zone - helper macro to iterate over all memory zones
linux/mmzone.h: * @zone - zone_t * variable
linux/mmzone.h: * for(pgdat = pgdat_list; pgdat; pgdat = pgdat->node_next)
linux/mmzone.h: * 		zone_t * z = pgdat->node_zones + i;
linux/mmzone.h:	for(zone = pgdat_list->node_zones; zone; zone = next_zone(zone))
linux/mmzone.h:/* page->zone is currently 8 bits ... */
linux/mmzone.h:		sizeof(mem_map_t) - ((x) % sizeof(mem_map_t))))
linux/module.h:	char name[60];		/* should have been 64-sizeof(long); oh well */
linux/module.h:	} uc;				/* Needs to keep its size - so says rth */
linux/module.h:#define MOD_CAN_QUERY(mod) (((mod)->flags & (MOD_RUNNING | MOD_INITIALIZING)) && !((mod)->flags & MOD_DELETED))
linux/module.h:	((unsigned long)(&((struct module *)0L)->member + 1)		\
linux/module.h:	 <= (mod)->size_of_struct)
linux/module.h: * Ditto for archdata.  Assumes mod->archdata_start and mod->archdata_end
linux/module.h:	(((unsigned long)(&((type *)0L)->member) +			\
linux/module.h:	  sizeof(((type *)0L)->member)) <=				\
linux/module.h:	 ((mod)->archdata_end - (mod)->archdata_start))
linux/module.h:#define mod_bound(p, n, m) ((unsigned long)(p) >= ((unsigned long)(m) + ((m)->size_of_struct)) && \
linux/module.h:	         (unsigned long)((p)+(n)) <= (unsigned long)(m) + (m)->size)
linux/module.h:#define GET_USE_COUNT(module)	(atomic_read(&(module)->uc.usecount))
linux/module.h:	(atomic_inc(&(mod)->uc.usecount), (mod)->flags |= MOD_VISITED|MOD_USED_ONCE)
linux/module.h:	(atomic_dec(&(mod)->uc.usecount), (mod)->flags |= MOD_VISITED)
linux/module.h:	(mod_member_present((mod), can_unload) && (mod)->can_unload	\
linux/module.h:	 ? (mod)->can_unload() : atomic_read(&(mod)->uc.usecount))
linux/module.h:   	[min[-max]]{b,h,i,l,s}
linux/module.h: * is a C-like identifier passed as the first arg to this macro.
linux/module.h: * pci - struct pci_device_id - List of PCI ids supported by this module
linux/module.h: * isapnp - struct isapnp_device_id - List of ISA PnP ids supported by this module
linux/module.h: * usb - struct usb_device_id - List of USB ids supported by this module
linux/module.h:   insmod -[xX] flags.  Otherwise, only the variables listed are exported.
linux/module.h:#define SET_MODULE_OWNER(some_struct) do { (some_struct)->owner = THIS_MODULE; } while (0)
linux/smbno.h:#define SMBsendstrt   0xD5   /* send start of multi-block message */
linux/smbno.h:#define SMBsendend    0xD6   /* send end of multi-block message */
linux/smbno.h:#define SMBsendtxt    0xD7   /* send text of multi-block message */
linux/smbno.h:#define SMBtrans         0x25   /* transaction - name, bytes in/out */
linux/smbno.h:/* Information Levels -  Shared? */
linux/smbno.h:/* Information Levels -  TRANSACT2_FINDFIRST */
linux/smbno.h:/* Information Levels -  TRANSACT2_QPATHINFO */
linux/smbno.h:/* Information Levels - TRANSACT2_SETFILEINFO */
linux/locks.h: * Buffer cache locking - note that interrupts may only unlock, not
linux/locks.h:	if (test_bit(BH_Lock, &bh->b_state))
linux/locks.h:	while (test_and_set_bit(BH_Lock, &bh->b_state))
linux/locks.h: * super-block locking. Again, interrupts may only unlock
linux/locks.h: * a super-block (although even this isn't done right now.
linux/locks.h:	down(&sb->s_lock);
linux/locks.h:	up(&sb->s_lock);
linux/fdreg.h:#define STATUS_DMA	0x20		/* 0- DMA mode */
linux/fdreg.h:#define STATUS_DIR	0x40		/* 0- cpu->fdc */
linux/fdreg.h:#define ST1_ND		0x04		/* No Data - unreadable */
linux/fdreg.h:#define ST3_DS		0x08		/* drive is double-sided */
linux/fdreg.h: * http://www-techdoc.intel.com/docs/periph/fd_contr/datasheets/ */
linux/fdreg.h:#define FDC_765ED	0x30	/* Non-Intel 1MB-compatible FDC, can't detect */
linux/fdreg.h:#define FDC_82077	0x52	/* 82077AA-1 */
linux/fdreg.h:#define FDC_82078_1	0x61	/* 82078-1 (2Mbps fdc) */
linux/fdreg.h:#define FDC_S82078B	0x62	/* S82078B (first seen on Adaptec AVA-2825 VLB
linux/rwsem.h: * Derived from asm-i386/semaphore.h
linux/rwsem.h:#include <linux/rwsem-spinlock.h> /* use a generic implementation */
linux/rwsem.h:#include <asm/rwsem.h> /* use an arch-specific implementation */
linux/rwsem.h: * trylock for reading -- returns 1 if successful, 0 if contention
linux/rwsem.h: * trylock for writing -- returns 1 if successful, 0 if contention
linux/quotaio_v1.h: * (as it appears on disk) - the file is an array of these structures
linux/quotaio_v2.h: * (as it appears on disk) - the file is a radix tree whose leaves point
linux/quotaio_v2.h: * Here are header structures as written on disk and their in-memory copies
linux/quotaio_v2.h: *  there will be space for exactly 18 quota-entries in a block
linux/quotaio_v2.h:#define V2_DQSTRINBLK	((V2_DQBLKSIZE - sizeof(struct v2_disk_dqdbheader)) / sizeof(struct v2_disk_dqblk))	/* Number of entries in one blocks */
linux/autoconf.h: * Self-contained MTD device drivers
linux/autoconf.h: * Multi-device support (RAID and LVM)
linux/autoconf.h: * Wireless LAN (non-hamradio)
linux/isdn_ppp.h:#define DECOMP_ERR_NOMEM	(-10)
linux/isdn_ppp.h: * Reset-Requests in a variety of ways. The decompressor is already returning
linux/isdn_ppp.h: * Furthermore, the only case where this data is used is when the decom-
linux/isdn_ppp.h: * We use this same struct for the reset entry of the compressor to commu-
linux/isdn_ppp.h: * this is an 'old friend' from ppp-comp.h under a new name 
linux/isdn_ppp.h:  struct sk_buff * frags;	/* fragments sl list -- use skb->next */
linux/threads.h: * /proc/sys/kernel/threads-max.
linux/devpts_fs.h:/* -*- linux-c -*- --------------------------------------------------------- *
linux/devpts_fs.h: *  Copyright 1998 H. Peter Anvin -- All Rights Reserved
linux/devpts_fs.h: * ------------------------------------------------------------------------- */
linux/devpts_fs.h: * Prototypes for the pty driver <-> devpts filesystem interface.  Most
linux/elfcore.h: * Definitions to generate Intel SVR4-like core files.
linux/elfcore.h:	int pr_fpvalid;		/* True if math co-processor being used.  */
linux/spinlock.h: * These are the generic versions of the spinlocks and read-write
linux/spinlock.h:#define spin_lock_init(x)	do { (x)->lock = 0; } while (0)
linux/spinlock.h:#define spin_lock(x)		do { (x)->lock = 1; } while (0)
linux/spinlock.h:#define spin_unlock(x)		do { (x)->lock = 0; } while (0)
linux/spinlock.h:#define spin_lock_init(x)	do { (x)->lock = 0; } while (0)
linux/spinlock.h:#define spin_lock(x)		do {unsigned long __spinflags; save_flags(__spinflags); cli(); if ((x)->lock&&(x)->babble) {printk("%s:%d: spin_lock(%s:%p) already locked\n", __BASE_FILE__,__LINE__, (x)->module, (x));(x)->babble--;} (x)->lock = 1; restore_flags(__spinflags);} while (0)
linux/spinlock.h:#define spin_unlock_wait(x)	do {unsigned long __spinflags; save_flags(__spinflags); cli(); if ((x)->lock&&(x)->babble) {printk("%s:%d: spin_unlock_wait(%s:%p) deadlock\n", __BASE_FILE__,__LINE__, (x)->module, (x));(x)->babble--;} restore_flags(__spinflags);} while (0)
linux/spinlock.h:#define spin_unlock(x)		do {unsigned long __spinflags; save_flags(__spinflags); cli(); if (!(x)->lock&&(x)->babble) {printk("%s:%d: spin_unlock(%s:%p) not locked\n", __BASE_FILE__,__LINE__, (x)->module, (x));(x)->babble--;} (x)->lock = 0; restore_flags(__spinflags);} while (0)
linux/spinlock.h: * Read-write spinlocks, allowing multiple readers
linux/spinlock.h: * can "mix" irq-safe locks - any writer needs to get a
linux/spinlock.h: * irq-safe write-lock, but readers can get non-irqsafe
linux/spinlock.h: * read-locks.
linux/soundcard.h: * Copyright by Hannu Savolainen 1993-1997
linux/soundcard.h:#define WAVE_UNSIGNED	0x02	/* bit 1 = Signed - Unsigned data. */
linux/soundcard.h:#define WAVE_LOOPING	0x04	/* bit 2 = looping enabled-1. */
linux/soundcard.h:#define WAVE_ENVELOPES	0x40	/* bit 6 = Enable envelopes - 1 */
linux/soundcard.h:		int panning;	/* -128=left, 127=right */
linux/soundcard.h:/*		undefined		0x14 - 0x1f */
linux/soundcard.h:/*		undefined		0x46 - 0x4f */
linux/soundcard.h:/*		undefined		0x54 - 0x5a */
linux/soundcard.h:/*		undefined		0x66 - 0x78 */
linux/soundcard.h:/*		reserved		0x79 - 0x7f */
linux/soundcard.h:		short		device;		/*	Synth# (0-4)	*/
linux/soundcard.h:		int	device;		/* 0-N. INITIALIZE BEFORE CALLING */
linux/soundcard.h:#define MIDI_CAP_MPU401		1		/* MPU-401 intelligent mode */
linux/soundcard.h:		int		device;		/* 0-N. INITIALIZE BEFORE CALLING */
linux/soundcard.h:/* because they *do* exist and we want to use them --Monty */
linux/soundcard.h:/* Some on/off settings (SOUND_SPECIAL_MIN - SOUND_SPECIAL_MAX) */
linux/soundcard.h:		OSS_patch_caching(dev, -1, instr, seqfd, _seqbuf, _seqbuflen)
linux/soundcard.h:		OSS_drum_caching(dev, -1, drum, seqfd, _seqbuf, _seqbuflen)
linux/soundcard.h: *	SEQ_DEFINEBUF (2048);	-- Defines a buffer for 2048 bytes
linux/soundcard.h: *	int seqfd;		-- The file descriptor for /dev/sequencer.
linux/soundcard.h: *	    if (write (seqfd, _seqbuf, _seqbufptr) == -1)
linux/soundcard.h: *		exit (-1);
linux/soundcard.h: * and the last byte (buf[len-1] of the last fragment must be 0xf7. No byte
linux/soundcard.h:		 if (write(seqfd, (char*)(patchx), len)==-1) \
linux/sonet.h:/* sonet.h - SONET/SHD physical layer control */
linux/sonet.h:/* Written 1995-2000 by Werner Almesberger, EPFL LRC/ICA */
linux/sonet.h:#define SONET_FRAME_SONET 0		/* SONET STS-3 framing */
linux/sonet.h:#define SONET_FRAME_SDH   1		/* SDH STM-1 framing */
linux/filter.h:	return fp->len*sizeof(struct sock_filter) + sizeof(*fp);
linux/filter.h:/* ret - BPF_K and BPF_X also apply */
linux/filter.h:#define SKF_AD_OFF    (-0x1000)
linux/filter.h:#define SKF_NET_OFF   (-0x100000)
linux/filter.h:#define SKF_LL_OFF    (-0x200000)
linux/selection.h:#define video_num_columns	(vc_cons[currcons].d->vc_cols)
linux/selection.h:#define video_num_lines		(vc_cons[currcons].d->vc_rows)
linux/selection.h:#define video_size_row		(vc_cons[currcons].d->vc_size_row)
linux/selection.h:#define can_do_color		(vc_cons[currcons].d->vc_can_do_color)
linux/atm_suni.h:/* atm_suni.h - Driver-specific declarations of the SUNI driver (for use by
linux/atm_suni.h:		driver-specific utilities) */
linux/rocket.h:#define ROCKET_USR_MASK 0x0071	/* Legal flags that non-privileged
linux/rocket.h: * Rocketport ioctls -- "RP"
linux/i2c-elektor.h:/* ------------------------------------------------------------------------- */
linux/i2c-elektor.h:/* i2c-elektor.c i2c-hw access for PCF8584 style isa bus adaptes             */
linux/i2c-elektor.h:/* ------------------------------------------------------------------------- */
linux/i2c-elektor.h:/*   Copyright (C) 1995-97 Simon G. Vogl
linux/i2c-elektor.h:                   1998-99 Hans Berglund
linux/i2c-elektor.h:/* ------------------------------------------------------------------------- */
linux/i2c-elektor.h:/* $Id: ack,v 1.1.1.1 2006-10-13 02:42:37 steven Exp $ */
linux/i2c-elektor.h: * This struct contains the hw-dependent functions of PCF8584 adapters to
linux/i2c-elektor.h: * manipulate the registers, and to init any hw-specific features.
linux/i2c-elektor.h: * due to missing arguments in some functions, called from the algo-pcf module.
linux/i2c-elektor.h: * Sometimes it's need to be rewriten -
linux/cyclades.h: *fold in changes for Cyclom-Z -- including structures for
linux/cyclades.h: *to support use of this file in non-kernel applications
linux/cyclades.h:/*************** CYCLOM-Z ADDITIONS ***************/
linux/cyclades.h: *	CUSTOM_REG - Cyclom-Z/PCI Custom Registers Set. The driver
linux/cyclades.h:	uclong	ram_wait_state;		/* RAM wait-state Register */
linux/cyclades.h:	uclong	uart_wait_state;	/* UART wait-state Register */
linux/cyclades.h:	uclong	timer_wait_state;	/* timer wait-state Register */
linux/cyclades.h: *	RUNTIME_9060 - PLX PCI9060ES local configuration and shared runtime
linux/cyclades.h:	uclong	loc_addr_range;	/* 00h - Local Address Range */
linux/cyclades.h:	uclong	loc_addr_base;	/* 04h - Local Address Base */
linux/cyclades.h:	uclong	loc_arbitr;	/* 08h - Local Arbitration */
linux/cyclades.h:	uclong	endian_descr;	/* 0Ch - Big/Little Endian Descriptor */
linux/cyclades.h:	uclong	loc_rom_range;	/* 10h - Local ROM Range */
linux/cyclades.h:	uclong	loc_rom_base;	/* 14h - Local ROM Base */
linux/cyclades.h:	uclong	loc_bus_descr;	/* 18h - Local Bus descriptor */
linux/cyclades.h:	uclong	loc_range_mst;	/* 1Ch - Local Range for Master to PCI */
linux/cyclades.h:	uclong	loc_base_mst;	/* 20h - Local Base for Master PCI */
linux/cyclades.h:	uclong	loc_range_io;	/* 24h - Local Range for Master IO */
linux/cyclades.h:	uclong	pci_base_mst;	/* 28h - PCI Base for Master PCI */
linux/cyclades.h:	uclong	pci_conf_io;	/* 2Ch - PCI configuration for Master IO */
linux/cyclades.h:	uclong	mail_box_0;	/* 40h - Mail Box 0 */
linux/cyclades.h:	uclong	mail_box_1;	/* 44h - Mail Box 1 */
linux/cyclades.h:	uclong	mail_box_2;	/* 48h - Mail Box 2 */
linux/cyclades.h:	uclong	mail_box_3;	/* 4Ch - Mail Box 3 */
linux/cyclades.h:	uclong	pci_doorbell;	/* 60h - PCI to Local Doorbell */
linux/cyclades.h:	uclong	loc_doorbell;	/* 64h - Local to PCI Doorbell */
linux/cyclades.h:	uclong	intr_ctrl_stat;	/* 68h - Interrupt Control/Status */
linux/cyclades.h:	uclong	init_ctrl;	/* 6Ch - EEPROM control, Init Control, etc */
linux/cyclades.h:/* Values for the Local Base Address re-map register */
linux/cyclades.h: *	Cyclom-Z ZFIRM Firmware.
linux/cyclades.h:/* comm_parity - parity */
linux/cyclades.h:/* comm_data_l - data length and stop bits */
linux/cyclades.h:/* rs_control/rs_status RS-232 signals */
linux/cyclades.h:/* commands Host <-> Board */
linux/cyclades.h:#define	C_CM_IOCTL	0x02		/* re-read CH_CTRL */
linux/cyclades.h:#define	C_CM_IOCTLW	0x03		/* re-read CH_CTRL, intr when done */
linux/cyclades.h:#define	C_CM_IOCTLM	0x04		/* RS-232 outputs change */
linux/cyclades.h: *	CH_CTRL - This per port structure contains all parameters
linux/cyclades.h: *	configuration registers of a "super-serial-controller".
linux/cyclades.h:	uclong	comm_baud;	/* baud rate  - numerically specified */
linux/cyclades.h:	uclong	rs_control;	/* RS-232 outputs */
linux/cyclades.h:	uclong	rs_status;	/* RS-232 inputs */
linux/cyclades.h: *	BUF_CTRL - This per channel structure contains
linux/cyclades.h: *	BOARD_CTRL - This per board structure contains all global 
linux/cyclades.h:	/* static info provided by the on-board CPU */
linux/cyclades.h: *	ZFW_CTRL - This is the data structure that includes all other
linux/cyclades.h:    int num_chips;	/* 0 if card absent, -1 if Z/PCI, else Y */
linux/cyclades.h:    int bus_index;	/* address shift - 0 for ISA, 1 for PCI */
linux/cyclades.h:    int	intr_enabled;	/* FW Interrupt flag - 0 disabled, 1 enabled */
linux/cyclades.h: * Events are used to schedule things to happen at timer-interrupt
linux/cyclades.h:                                                               on SCHR4-SCHR3 */
linux/cyclades.h:                                                               on SCHR2-SCHR1 */
linux/zorro.h: *  linux/zorro.h -- Amiga AutoConfig (Zorro) Bus Definitions
linux/zorro.h: *  Copyright (C) 1995--2000 Geert Uytterhoeven
linux/zorro.h:     *  Each Zorro board has a 32-bit ID of the form
linux/zorro.h:     *      mmmmmmmmmmmmmmmm	16-bit Manufacturer ID (assigned by CBM (sigh))
linux/zorro.h:     *      pppppppp		8-bit Product ID (assigned by manufacturer)
linux/zorro.h:     *      eeeeeeee		8-bit Extended Product ID (currently only used
linux/zorro.h:    /* -First 16 bytes of the expansion ROM */
linux/zorro.h:    __u16 er_Manufacturer;	/* Unique ID, ASSIGNED BY COMMODORE-AMIGA! */
linux/zorro.h:    request_mem_region((z)->resource.start, \
linux/zorro.h:		       (z)->resource.end-(z)->resource.start+1, (name))
linux/zorro.h:    check_mem_region((z)->resource.start, \
linux/zorro.h:		     (z)->resource.end-(z)->resource.start+1)
linux/zorro.h:    release_mem_region((z)->resource.start, \
linux/zorro.h:		       (z)->resource.end-(z)->resource.start+1)
linux/zorro.h:     *  (128 chunks, physical 0x00200000-0x009fffff).
linux/blkcdb.h: * 2.5 Command Descriptor Block (CDB) Block Pre-Handler.
linux/blkcdb.h: * Copyright (C) 2001 Andre Hedrick <andre@linux-ide.org>
linux/blkcdb.h: * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-
linux/blkcdb.h:        return &hwif->drives[DEVICE_NR(dev) & 1].queue;
linux/blkcdb.h:        return &dpnt->device->request_queue;
linux/blkcdb.h:switch (SCpnt->request.cmd)
linux/blkcdb.h:SCpnt->cmnd[0] = WRITE_6/READ_6;
linux/blkcdb.h:SCpnt->cmnd[1] = (SCpnt->device->scsi_level <= SCSI_2) ?
linux/blkcdb.h:			((SCpnt->lun << 5) & 0xe0) : 0;
linux/blkcdb.h:SCpnt->cmnd[2] = (unsigned char) (block >> 24) & 0xff;
linux/blkcdb.h:SCpnt->cmnd[3] = (unsigned char) (block >> 16) & 0xff;
linux/blkcdb.h:SCpnt->cmnd[4] = (unsigned char) (block >> 8) & 0xff;
linux/blkcdb.h:SCpnt->cmnd[5] = (unsigned char) block & 0xff;
linux/blkcdb.h:SCpnt->cmnd[6] = 0;
linux/blkcdb.h:SCpnt->cmnd[7] = (unsigned char) (this_count >> 8) & 0xff;
linux/blkcdb.h:SCpnt->cmnd[8] = (unsigned char) this_count & 0xff;
linux/blkcdb.h:SCpnt->cmnd[9] = 0;
linux/blkdev.h:#define RQ_INACTIVE		(-1)
linux/blkdev.h:#define blk_queue_plugged(q)	(q)->plugged
linux/blkdev.h:#define blk_fs_request(rq)	((rq)->cmd == READ || (rq)->cmd == WRITE)
linux/blkdev.h:#define blk_queue_empty(q)	list_empty(&(q)->queue_head)
linux/blkdev.h:	if (rq->cmd == READ)
linux/blkdev.h:	else if (rq->cmd == WRITE)
linux/blkdev.h:		return -1; /* ahem */
linux/blkdev.h:	struct page *page = bh->b_page;
linux/blkdev.h:	if (page - mem_map <= q->bounce_pfn)
linux/blkdev.h:	if ((page - page_zone(page)->zone_mem_map) + (page_zone(page)->zone_start_paddr >> PAGE_SHIFT) <= q->bounce_pfn)
linux/blkdev.h:#define bh_phys(bh)		(page_to_phys((bh)->b_page) + bh_offset((bh)))
linux/blkdev.h:#define BH_CONTIG(b1, b2)	(bh_phys((b1)) + (b1)->b_size == bh_phys((b2)))
linux/blkdev.h:#define BH_PHYS_4G(b1, b2)	((bh_phys((b1)) | 0xffffffff) == ((bh_phys((b2)) + (b2)->b_size - 1) | 0xffffffff))
linux/blkdev.h:#define MAX_QUEUE_SECTORS (4 << (20 - 9)) /* 4 mbytes when full sized */
linux/blkdev.h:#define PageAlignSize(size) (((size) + PAGE_SIZE -1) & PAGE_MASK)
linux/blkdev.h:#define blkdev_entry_next_request(entry) blkdev_entry_to_request((entry)->next)
linux/blkdev.h:#define blkdev_entry_prev_request(entry) blkdev_entry_to_request((entry)->prev)
linux/blkdev.h:#define blkdev_next_request(req) blkdev_entry_to_request((req)->queue.next)
linux/blkdev.h:#define blkdev_prev_request(req) blkdev_entry_to_request((req)->queue.prev)
linux/blkdev.h:	if (q->can_throttle)
linux/blkdev.h:		return atomic_read(&q->nr_sectors) > q->max_queue_sectors;
linux/blkdev.h:	return q->rq.count == 0;
linux/blkdev.h:	if (q->can_throttle)
linux/blkdev.h:		return atomic_read(&q->nr_sectors) > q->max_queue_sectors + q->batch_sectors;
linux/blkdev.h:	return q->rq.count == 0;
linux/blkdev.h:	return atomic_read(&q->nr_sectors) > q->max_queue_sectors - q->batch_sectors;
linux/blkdev.h:	request_queue_t *q = rq->q;
linux/blkdev.h:	if (q && q->can_throttle) {
linux/blkdev.h:		atomic_add(count, &q->nr_sectors);
linux/blkdev.h:		if (atomic_read(&q->nr_sectors) < 0) {
linux/blkdev.h:			printk("nr_sectors is %d\n", atomic_read(&q->nr_sectors));
linux/blkdev.h:	request_queue_t *q = rq->q;
linux/blkdev.h:	if (q && q->can_throttle) {
linux/blkdev.h:		atomic_sub(count, &q->nr_sectors);
linux/blkdev.h:		if (q->rq.count >= q->batch_requests && !blk_oversized_queue_batch(q)) {
linux/blkdev.h:			if (waitqueue_active(&q->wait_for_requests))
linux/blkdev.h:				wake_up(&q->wait_for_requests);
linux/blkdev.h:		if (atomic_read(&q->nr_sectors) < 0) {
linux/blkdev.h:			printk("nr_sectors is %d\n", atomic_read(&q->nr_sectors));
linux/console.h: * 10-Mar-94: Arno Griffioen: Conversion for vt100 emulator port from PC LINUX
linux/console.h: * this is what the terminal answers to a ESC-Z or csi0c query.
linux/quotacompat.h:#define Q_V2_GETINFO  0x0900	/* get info about quotas - graces, flags... */
linux/skbuff.h: *		Florian La Roche, <rzsfl@rz.uni-sb.de>
linux/skbuff.h:#define SKB_DATA_ALIGN(X)	(((X) + (SMP_CACHE_BYTES-1)) & ~(SMP_CACHE_BYTES-1))
linux/skbuff.h:#define SKB_MAX_ORDER(X,ORDER)	(((PAGE_SIZE<<(ORDER)) - (X) - sizeof(struct skb_shared_info))&~(SMP_CACHE_BYTES-1))
linux/skbuff.h: *		skb->csum is undefined.
linux/skbuff.h: *		skb->csum is undefined.
linux/skbuff.h: *	    the packet as seen by netif_rx in skb->csum.
linux/skbuff.h: *	    is able to produce some skb->csum, it MUST use HW,
linux/skbuff.h: *	from skb->h.raw to the end and to record the checksum
linux/skbuff.h: *	at skb->h.raw+skb->csum.
linux/skbuff.h: *	Device must show its capabilities in dev->features, set
linux/skbuff.h: *	NETIF_F_HW_CSUM	- it is clever device, it is able to checksum
linux/skbuff.h: *	NETIF_F_NO_CSUM - loopback or reliable single hop media.
linux/skbuff.h: *	NETIF_F_IP_CSUM - device is dumb. It is able to csum only
linux/skbuff.h: *	Any questions? No questions, good. 		--ANK
linux/skbuff.h:#define NET_CALLER(arg) (*(((void**)&arg)-1))
linux/skbuff.h: * the end of the header data, ie. at skb->end.
linux/skbuff.h:						   replacing skb->dev with the virtual device.  */
linux/skbuff.h:	atomic_t	users;			/* User count - see datagram.c,tcp.c 		*/
linux/skbuff.h:#define skb_shinfo(SKB)		((struct skb_shared_info *)((SKB)->end))
linux/skbuff.h: *	skb_queue_empty - check if a queue is empty
linux/skbuff.h:	return (list->next == (struct sk_buff *) list);
linux/skbuff.h: *	skb_get - reference buffer
linux/skbuff.h:	atomic_inc(&skb->users);
linux/skbuff.h: *	kfree_skb - free an sk_buff
linux/skbuff.h:	if (likely(atomic_read(&skb->users) == 1))
linux/skbuff.h:	else if (likely(!atomic_dec_and_test(&skb->users)))
linux/skbuff.h: *	skb_cloned - is the buffer a clone
linux/skbuff.h:	return skb->cloned && atomic_read(&skb_shinfo(skb)->dataref) != 1;
linux/skbuff.h: *	skb_shared - is the buffer shared
linux/skbuff.h:	return (atomic_read(&skb->users) != 1);
linux/skbuff.h: *	skb_share_check - check if buffer is shared and if so clone it
linux/skbuff.h: *	skb_unshare - make a copy of a shared buffer
linux/skbuff.h:	struct sk_buff *list = ((struct sk_buff *)list_)->next;
linux/skbuff.h:	struct sk_buff *list = ((struct sk_buff *)list_)->prev;
linux/skbuff.h: *	skb_queue_len	- get queue length
linux/skbuff.h:	return(list_->qlen);
linux/skbuff.h:	spin_lock_init(&list->lock);
linux/skbuff.h:	list->prev = (struct sk_buff *)list;
linux/skbuff.h:	list->next = (struct sk_buff *)list;
linux/skbuff.h:	list->qlen = 0;
linux/skbuff.h: *	The "__skb_xxxx()" functions are the non-atomic ones that
linux/skbuff.h: *	__skb_queue_head - queue a buffer at the list head
linux/skbuff.h:	newsk->list = list;
linux/skbuff.h:	list->qlen++;
linux/skbuff.h:	next = prev->next;
linux/skbuff.h:	newsk->next = next;
linux/skbuff.h:	newsk->prev = prev;
linux/skbuff.h:	next->prev = newsk;
linux/skbuff.h:	prev->next = newsk;
linux/skbuff.h: *	skb_queue_head - queue a buffer at the list head
linux/skbuff.h:	spin_lock_irqsave(&list->lock, flags);
linux/skbuff.h:	spin_unlock_irqrestore(&list->lock, flags);
linux/skbuff.h: *	__skb_queue_tail - queue a buffer at the list tail
linux/skbuff.h:	newsk->list = list;
linux/skbuff.h:	list->qlen++;
linux/skbuff.h:	prev = next->prev;
linux/skbuff.h:	newsk->next = next;
linux/skbuff.h:	newsk->prev = prev;
linux/skbuff.h:	next->prev = newsk;
linux/skbuff.h:	prev->next = newsk;
linux/skbuff.h: *	skb_queue_tail - queue a buffer at the list tail
linux/skbuff.h:	spin_lock_irqsave(&list->lock, flags);
linux/skbuff.h:	spin_unlock_irqrestore(&list->lock, flags);
linux/skbuff.h: *	__skb_dequeue - remove from the head of the queue
linux/skbuff.h:	next = prev->next;
linux/skbuff.h:		next = next->next;
linux/skbuff.h:		list->qlen--;
linux/skbuff.h:		next->prev = prev;
linux/skbuff.h:		prev->next = next;
linux/skbuff.h:		result->next = NULL;
linux/skbuff.h:		result->prev = NULL;
linux/skbuff.h:		result->list = NULL;
linux/skbuff.h: *	skb_dequeue - remove from the head of the queue
linux/skbuff.h:	spin_lock_irqsave(&list->lock, flags);
linux/skbuff.h:	spin_unlock_irqrestore(&list->lock, flags);
linux/skbuff.h:	newsk->next = next;
linux/skbuff.h:	newsk->prev = prev;
linux/skbuff.h:	next->prev = newsk;
linux/skbuff.h:	prev->next = newsk;
linux/skbuff.h:	newsk->list = list;
linux/skbuff.h:	list->qlen++;
linux/skbuff.h: *	skb_insert	-	insert a buffer
linux/skbuff.h:	spin_lock_irqsave(&old->list->lock, flags);
linux/skbuff.h:	__skb_insert(newsk, old->prev, old, old->list);
linux/skbuff.h:	spin_unlock_irqrestore(&old->list->lock, flags);
linux/skbuff.h:	__skb_insert(newsk, old, old->next, old->list);
linux/skbuff.h: *	skb_append	-	append a buffer
linux/skbuff.h:	spin_lock_irqsave(&old->list->lock, flags);
linux/skbuff.h:	spin_unlock_irqrestore(&old->list->lock, flags);
linux/skbuff.h:	list->qlen--;
linux/skbuff.h:	next = skb->next;
linux/skbuff.h:	prev = skb->prev;
linux/skbuff.h:	skb->next = NULL;
linux/skbuff.h:	skb->prev = NULL;
linux/skbuff.h:	skb->list = NULL;
linux/skbuff.h:	next->prev = prev;
linux/skbuff.h:	prev->next = next;
linux/skbuff.h: *	skb_unlink	-	remove a buffer from a list
linux/skbuff.h:	struct sk_buff_head *list = skb->list;
linux/skbuff.h:		spin_lock_irqsave(&list->lock, flags);
linux/skbuff.h:		if(skb->list == list)
linux/skbuff.h:			__skb_unlink(skb, skb->list);
linux/skbuff.h:		spin_unlock_irqrestore(&list->lock, flags);
linux/skbuff.h: *	__skb_dequeue_tail - remove from the tail of the queue
linux/skbuff.h: *	skb_dequeue - remove from the head of the queue
linux/skbuff.h:	spin_lock_irqsave(&list->lock, flags);
linux/skbuff.h:	spin_unlock_irqrestore(&list->lock, flags);
linux/skbuff.h:	return skb->data_len;
linux/skbuff.h:	return skb->len - skb->data_len;
linux/skbuff.h:#define SKB_PAGE_ASSERT(skb) do { if (skb_shinfo(skb)->nr_frags) out_of_line_bug(); } while (0)
linux/skbuff.h:#define SKB_FRAG_ASSERT(skb) do { if (skb_shinfo(skb)->frag_list) out_of_line_bug(); } while (0)
linux/skbuff.h:	unsigned char *tmp=skb->tail;
linux/skbuff.h:	skb->tail+=len;
linux/skbuff.h:	skb->len+=len;
linux/skbuff.h: *	skb_put - add data to a buffer
linux/skbuff.h:	unsigned char *tmp=skb->tail;
linux/skbuff.h:	skb->tail+=len;
linux/skbuff.h:	skb->len+=len;
linux/skbuff.h:	if(skb->tail>skb->end) {
linux/skbuff.h:	skb->data-=len;
linux/skbuff.h:	skb->len+=len;
linux/skbuff.h:	return skb->data;
linux/skbuff.h: *	skb_push - add data to the start of a buffer
linux/skbuff.h:	skb->data-=len;
linux/skbuff.h:	skb->len+=len;
linux/skbuff.h:	if(skb->data<skb->head) {
linux/skbuff.h:	return skb->data;
linux/skbuff.h:	skb->len-=len;
linux/skbuff.h:	if (skb->len < skb->data_len)
linux/skbuff.h:	return 	skb->data+=len;
linux/skbuff.h: *	skb_pull - remove data from the start of a buffer
linux/skbuff.h:	if (len > skb->len)
linux/skbuff.h:	    __pskb_pull_tail(skb, len-skb_headlen(skb)) == NULL)
linux/skbuff.h:	skb->len -= len;
linux/skbuff.h:	return 	skb->data += len;
linux/skbuff.h:	if (len > skb->len)
linux/skbuff.h:	if (len > skb->len)
linux/skbuff.h:	return (__pskb_pull_tail(skb, len-skb_headlen(skb)) != NULL);
linux/skbuff.h: *	skb_headroom - bytes at buffer head
linux/skbuff.h:	return skb->data-skb->head;
linux/skbuff.h: *	skb_tailroom - bytes at buffer end
linux/skbuff.h:	return skb_is_nonlinear(skb) ? 0 : skb->end-skb->tail;
linux/skbuff.h: *	skb_reserve - adjust headroom
linux/skbuff.h:	skb->data+=len;
linux/skbuff.h:	skb->tail+=len;
linux/skbuff.h:	if (!skb->data_len) {
linux/skbuff.h:		skb->len = len;
linux/skbuff.h:		skb->tail = skb->data+len;
linux/skbuff.h: *	skb_trim - remove end from a buffer
linux/skbuff.h:	if (skb->len > len) {
linux/skbuff.h:	if (!skb->data_len) {
linux/skbuff.h:		skb->len = len;
linux/skbuff.h:		skb->tail = skb->data+len;
linux/skbuff.h:	if (len < skb->len)
linux/skbuff.h: *	skb_orphan - orphan a buffer
linux/skbuff.h:	if (skb->destructor)
linux/skbuff.h:		skb->destructor(skb);
linux/skbuff.h:	skb->destructor = NULL;
linux/skbuff.h:	skb->sk = NULL;
linux/skbuff.h: *	skb_purge - empty a list
linux/skbuff.h: *	__skb_purge - empty a list
linux/skbuff.h: *	__dev_alloc_skb - allocate an skbuff for sending
linux/skbuff.h: *	dev_alloc_skb - allocate an skbuff for sending
linux/skbuff.h: *	skb_cow - copy header of skb when it is required
linux/skbuff.h: *	The result is skb with writable area skb->head...skb->tail
linux/skbuff.h:	int delta = (headroom > 16 ? headroom : 16) - skb_headroom(skb);
linux/skbuff.h: *	skb_padto	- pad an skbuff up to a minimal size
linux/skbuff.h: *	for the original, or NULL for out of memory - in which case
linux/skbuff.h:	unsigned int size = skb->len;
linux/skbuff.h:	return skb_pad(skb, len-size);
linux/skbuff.h: *	skb_linearize - convert paged skb to linear one
linux/skbuff.h: *	If there is no free memory -ENOMEM is returned, otherwise zero
linux/skbuff.h:	return kmap_atomic(frag->page, KM_SKB_DATA_SOFTIRQ);
linux/skbuff.h:		for (skb = (queue)->next;			\
linux/skbuff.h:		     skb=skb->next)
linux/skbuff.h:	if (nfct && atomic_dec_and_test(&nfct->master->use))
linux/skbuff.h:		nfct->master->destroy(nfct->master);
linux/skbuff.h:		atomic_inc(&nfct->master->use);
linux/skbuff.h:	nf_conntrack_put(skb->nfct);
linux/skbuff.h:	skb->nfct = NULL;
linux/skbuff.h:	skb->nf_debug = 0;
linux/sysv_fs.h:   - sizeof(short) = 2, sizeof(int) = 4, sizeof(long) = 4,
linux/sysv_fs.h:   - alignof(short) = 2, alignof(long) = 4.
linux/sysv_fs.h:   On Coherent FS, they are always stored in PDP-11 manner: the least
linux/sysv_fs.h:/* Xenix FS, Coherent FS: block 0 is the boot block, block 1 the super-block.
linux/sysv_fs.h:   SystemV FS: block 0 contains both the boot sector and the super-block. */
linux/sysv_fs.h:/* The first inode zone is sb->sv_firstinodezone (1 or 2). */
linux/sysv_fs.h:/* 0 is non-existent */
linux/sysv_fs.h:/* Xenix super-block data on disk */
linux/sysv_fs.h:	char		s_fmod;		/* super-block modified flag */
linux/sysv_fs.h:	char		s_ronly;	/* flag whether fs is mounted read-only */
linux/sysv_fs.h:/* SystemV4 super-block data on disk */
linux/sysv_fs.h:	char	s_fmod;		/* super-block modified flag */
linux/sysv_fs.h:	char	s_ronly;	/* flag whether fs is mounted read-only */
linux/sysv_fs.h:	s32	s_state;	/* file system state: 0x7c269d38-s_time means clean */
linux/sysv_fs.h:/* SystemV2 super-block data on disk */
linux/sysv_fs.h:	char	s_fmod;			/* super-block modified flag */
linux/sysv_fs.h:	char	s_ronly;		/* flag whether fs is mounted read-only */
linux/sysv_fs.h:/* V7 super-block data on disk */
linux/sysv_fs.h:	char    s_fmod;         /* super-block modified flag */
linux/sysv_fs.h:	char    s_ronly;        /* flag whether fs is mounted read-only */
linux/sysv_fs.h:/* Coherent super-block data on disk */
linux/sysv_fs.h:	char		s_fmod;		/* super-block modified flag */
linux/sysv_fs.h:	char		s_ronly;	/* flag whether fs is mounted read-only */
linux/sysv_fs.h:   sb->sv_inodes_per_block = block_size / sizeof(struct sysv_inode) */
linux/sysv_fs.h:   sb->sv_ind_per_block = block_size / sizeof(u32) */
linux/sysv_fs.h:	mark_buffer_dirty(sb->sv_bh1);
linux/sysv_fs.h:	if (sb->sv_bh1 != sb->sv_bh2)
linux/sysv_fs.h:		mark_buffer_dirty(sb->sv_bh2);
linux/sysv_fs.h:	sb->s_dirt = 1;
linux/sysv_fs.h:	if (sb->sv_bytesex == BYTESEX_PDP)
linux/sysv_fs.h:	else if (sb->sv_bytesex == BYTESEX_LE)
linux/sysv_fs.h:	if (sb->sv_bytesex == BYTESEX_PDP)
linux/sysv_fs.h:	else if (sb->sv_bytesex == BYTESEX_LE)
linux/sysv_fs.h:	if (sb->sv_bytesex == BYTESEX_PDP)
linux/sysv_fs.h:	else if (sb->sv_bytesex == BYTESEX_LE)
linux/sysv_fs.h:	if (sb->sv_bytesex != BYTESEX_BE)
linux/sysv_fs.h:	if (sb->sv_bytesex != BYTESEX_BE)
linux/sysv_fs.h:	if (sb->sv_bytesex != BYTESEX_BE)
linux/pc_keyb.h:#undef KBD_IS_FOCUS_9000		/* We have the brain-damaged FOCUS-9000 keyboard */
linux/pc_keyb.h:					   a lock etc - ick */
linux/in_systm.h: * Authors:	Original taken from Berkeley BSD UNIX 4.3-RENO.
linux/in_systm.h: * The n_ types are network-order variants of their natural
linux/in_systm.h: * equivalents.  The Linux kernel NET-2 code does not use
linux/in_systm.h: * there for compatibility with BSD user-level programs.
linux/acct.h: *  BSD Process Accounting for Linux - Definitions
linux/acct.h: *  BSD-style process accounting. The kernel accounting code and all
linux/acct.h: *  user-level programs that try to do something useful with the
linux/acct.h: *  Copyright (C) 1995 - 1997 Marco van Wieringen - ELM Consultancy B.V.
linux/acct.h: *  comp_t is a 16-bit "floating" point number with a 3-bit base 8
linux/acct.h: *  exponent and a 13-bit fraction. See linux/kernel/acct.c for the
linux/acct.h: *	No binary format break with 2.0 - but when we hit 32bit uid we'll
linux/acct.h:#define ASU		0x02	/* ... used super-user privileges */
linux/smb_mount.h: *  Copyright (C) 1995, 1996 by Paal-Kr. Engstad and Volker Lendecke
linux/smb_mount.h:/* "vers" in big-endian */
linux/acpi.h: * acpi.h - ACPI Interface
linux/acpi.h: * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
linux/acpi.h:/* the following four functions are architecture-dependent */
linux/efs_fs.h:static const char cprt[] = "EFS: "EFS_VERSION" - (c) 1999 Al Smith <Al.Smith@aeschi.ch.eu.org>";
linux/efs_fs.h:#error This code is only for linux-2.2 and later.
linux/efs_fs.h:#define INODE_INFO(i) (struct efs_inode_info *)	&((i)->u.generic_ip)
linux/efs_fs.h:#define SUPER_INFO(s) (struct efs_sb_info *)	&((s)->u.generic_sbp)
linux/efs_fs.h:#define INODE_INFO(i)				&((i)->u.efs_i)
linux/efs_fs.h:#define SUPER_INFO(s)				&((s)->u.efs_sb)
linux/com20020.h: * Linux ARCnet driver - COM20020 chipset support - function declarations
linux/com20020.h: * Written 1994-1999 by Avery Pennarun.
linux/com20020.h:#define _ADDR_HI  (ioaddr+2)	/* control registers for IO-mapped memory */
linux/com20020.h:#define _MEMDATA  (ioaddr+4)	/* data port for IO-mapped memory */
linux/com20020.h:#define P1MODE          0x80    /* enable P1-MODE for Backplane */
linux/com20020.h:		lp->config = (lp->config & ~0x03) | (x); \
linux/com20020.h:#define ARCRESET { outb(lp->config | 0x80, _CONFIG); \
linux/com20020.h:		    outb(lp->config , _CONFIG);       \
linux/com20020.h:#define SETCONF		outb(lp->config, _CONFIG)
linux/efs_vh.h:/* partition type sysv is used for EFS format CD-ROM partitions */
linux/netfilter_ipv4/ip_conntrack_core.h:/* Returns conntrack if it dealt with ICMP, and filled in skb->nfct */
linux/netfilter_ipv4/ip_conntrack_core.h:	if (skb->nfct
linux/netfilter_ipv4/ip_conntrack_core.h:	    && !is_confirmed((struct ip_conntrack *)skb->nfct->master))
linux/netfilter_ipv4/ip_conntrack_core.h:		return __ip_conntrack_confirm(skb->nfct);
linux/netfilter_ipv4/ip_tables.h: * 25-Jul-1998 Major changes to allow for ip chain table
linux/netfilter_ipv4/ip_tables.h: * 3-Jan-2000 Named tables to allow packet selection for different uses.
linux/netfilter_ipv4/ip_tables.h:#define IPT_RETURN (-NF_MAX_VERDICT - 1)
linux/netfilter_ipv4/ip_tables.h:	u_int8_t option;			/* TCP Option iff non-zero*/
linux/netfilter_ipv4/ip_tables.h:	return (void *)e + e->target_offset;
linux/netfilter_ipv4/ip_tables.h:	     __i < (e)->target_offset;		\
linux/netfilter_ipv4/ip_tables.h:	     __i += __match->u.match_size) {	\
linux/netfilter_ipv4/ip_tables.h:	for (__i = 0; __i < (size); __i += __entry->next_offset) { \
linux/netfilter_ipv4/ip_tables.h:#define IPT_ALIGN(s) (((s) + (__alignof__(struct ipt_entry)-1)) & ~(__alignof__(struct ipt_entry)-1))
linux/netfilter_ipv4/ip_nat.h:/* Worst case: local-out manip + 1 post-routing, and reverse dirn. */
linux/netfilter_ipv4/ip_nat.h:/* Protects NAT hash tables, and NAT-private part of conntracks. */
linux/netfilter_ipv4/ip_nat.h:/* Hashes for by-source and IP/protocol. */
linux/netfilter_ipv4/ipt_ECN.h:	u_int8_t ip_ect;	/* ECT codepoint of IPv4 header, pre-shifted */
linux/netfilter_ipv4/ip_nat_protocol.h:	/* Alter the per-proto part of the tuple (depending on
linux/netfilter_ipv4/ip_nat_protocol.h:	   possible; return false if not.  Per-protocol part of tuple
linux/netfilter_ipv4/ip_conntrack_protocol.h:	/* Invert the per-proto part of the tuple: ie. turn xmit into reply.
linux/netfilter_ipv4/ip_conntrack_protocol.h:	/* Print out the per-protocol part of the tuple. */
linux/netfilter_ipv4/ip_conntrack_protocol.h:	/* Returns verdict for packet, or -1 for invalid. */
linux/netfilter_ipv4/ip_conntrack_protocol.h:/* Existing built-in protocols */
linux/netfilter_ipv4/listhelp.h:	list_add((new), (head)->prev);
linux/netfilter_ipv4/listhelp.h:	list_add((struct list_head *)(new), __i->prev);		\
linux/netfilter_ipv4/listhelp.h:/* If the field after the list_head is a nul-terminated string, you
linux/netfilter_ipv4/compat_firewall.h:#define FW_REJECT	(-1)
linux/netfilter_ipv4/ipchains_core.h: * 15-Feb-1997: Major changes to allow graphs for firewall rules.
linux/netfilter_ipv4/ipchains_core.h: * 2-Nov-1997: Changed types to __u16, etc.
linux/netfilter_ipv4/ipchains_core.h:#define IP_FW_F_TCPSYN	0x0002	/* For tcp packets-check SYN only */
linux/netfilter_ipv4/ip_nat_core.h:/* Built-in protocols. */
linux/netfilter_ipv4/ip_conntrack_tuple.h:  "non-manipulatable" lines, for the benefit of the NAT code.
linux/netfilter_ipv4/ip_conntrack_tuple.h:/* The protocol-specific manipulable parts of the tuple: always in
linux/netfilter_ipv4/ip_conntrack_tuple.h:		(tuple)->src.u.all = 0;				\
linux/netfilter_ipv4/ip_conntrack_tuple.h:		(tuple)->dst.u.all = 0;				\
linux/netfilter_ipv4/ip_conntrack_tuple.h:DEBUGP("tuple %p: %u %u.%u.%u.%u:%hu -> %u.%u.%u.%u:%hu\n",	\
linux/netfilter_ipv4/ip_conntrack_tuple.h:       (tp), (tp)->dst.protonum,				\
linux/netfilter_ipv4/ip_conntrack_tuple.h:       NIPQUAD((tp)->src.ip), ntohs((tp)->src.u.all),		\
linux/netfilter_ipv4/ip_conntrack_tuple.h:       NIPQUAD((tp)->dst.ip), ntohs((tp)->dst.u.all))
linux/netfilter_ipv4/ip_conntrack_tuple.h:#define DIRECTION(h) ((enum ip_conntrack_dir)(&(h)->ctrack->tuplehash[1] == (h)))
linux/netfilter_ipv4/ip_conntrack_tuple.h:	/* this == &ctrack->tuplehash[DIRECTION(this)]. */
linux/netfilter_ipv4/ip_conntrack_tuple.h:	return t1->src.ip == t2->src.ip
linux/netfilter_ipv4/ip_conntrack_tuple.h:		&& t1->src.u.all == t2->src.u.all;
linux/netfilter_ipv4/ip_conntrack_tuple.h:	return t1->dst.ip == t2->dst.ip
linux/netfilter_ipv4/ip_conntrack_tuple.h:		&& t1->dst.u.all == t2->dst.u.all
linux/netfilter_ipv4/ip_conntrack_tuple.h:		&& t1->dst.protonum == t2->dst.protonum;
linux/netfilter_ipv4/ip_conntrack_tuple.h:	return !(((t->src.ip ^ tuple->src.ip) & mask->src.ip)
linux/netfilter_ipv4/ip_conntrack_tuple.h:		 || ((t->dst.ip ^ tuple->dst.ip) & mask->dst.ip)
linux/netfilter_ipv4/ip_conntrack_tuple.h:		 || ((t->src.u.all ^ tuple->src.u.all) & mask->src.u.all)
linux/netfilter_ipv4/ip_conntrack_tuple.h:		 || ((t->dst.u.all ^ tuple->dst.u.all) & mask->dst.u.all)
linux/netfilter_ipv4/ip_conntrack_tuple.h:		 || ((t->dst.protonum ^ tuple->dst.protonum)
linux/netfilter_ipv4/ip_conntrack_tuple.h:		     & mask->dst.protonum));
linux/netfilter_ipv4/lockhelp.h:struct spinlock_debug l = { SPIN_LOCK_UNLOCKED, ATOMIC_INIT(-1) }
linux/netfilter_ipv4/lockhelp.h:do { if (atomic_read(&(l)->locked_by) != smp_processor_id())		\
linux/netfilter_ipv4/lockhelp.h:do { if (atomic_read(&(l)->locked_by) == smp_processor_id())		\
linux/netfilter_ipv4/lockhelp.h:do { if (!((l)->read_locked_map & (1UL << smp_processor_id()))		    \
linux/netfilter_ipv4/lockhelp.h:	 && !((l)->write_locked_map & (1UL << smp_processor_id())))	    \
linux/netfilter_ipv4/lockhelp.h:do { if (!((l)->write_locked_map & (1UL << smp_processor_id())))	     \
linux/netfilter_ipv4/lockhelp.h:do { if ((l)->read_locked_map & (1UL << smp_processor_id()))		  \
linux/netfilter_ipv4/lockhelp.h: else if ((l)->write_locked_map & (1UL << smp_processor_id()))		  \
linux/netfilter_ipv4/lockhelp.h:	spin_lock_bh(&(lk)->l);					\
linux/netfilter_ipv4/lockhelp.h:	atomic_set(&(lk)->locked_by, smp_processor_id());	\
linux/netfilter_ipv4/lockhelp.h:	atomic_set(&(lk)->locked_by, -1);	\
linux/netfilter_ipv4/lockhelp.h:	spin_unlock_bh(&(lk)->l);		\
linux/netfilter_ipv4/lockhelp.h:	read_lock_bh(&(lk)->l);					\
linux/netfilter_ipv4/lockhelp.h:	set_bit(smp_processor_id(), &(lk)->read_locked_map);	\
linux/netfilter_ipv4/lockhelp.h:	write_lock_bh(&(lk)->l);					  \
linux/netfilter_ipv4/lockhelp.h:	set_bit(smp_processor_id(), &(lk)->write_locked_map);		  \
linux/netfilter_ipv4/lockhelp.h:	if (!((lk)->read_locked_map & (1UL << smp_processor_id())))	\
linux/netfilter_ipv4/lockhelp.h:	clear_bit(smp_processor_id(), &(lk)->read_locked_map);		\
linux/netfilter_ipv4/lockhelp.h:	read_unlock_bh(&(lk)->l);					\
linux/netfilter_ipv4/lockhelp.h:	clear_bit(smp_processor_id(), &(lk)->write_locked_map);	\
linux/netfilter_ipv4/lockhelp.h:	write_unlock_bh(&(lk)->l);				\
linux/netfilter_ipv4/ipfwadm_core.h: *	Merged and included the FreeBSD-Current changes at Ugen's request
linux/netfilter_ipv4/ipfwadm_core.h: *	appear it's not practical - Read: It works, it's not clean but please
linux/netfilter_ipv4/ipfwadm_core.h:#define IP_FW_F_TCPSYN	0x0080	/* For tcp packets-check SYN only     */
linux/netfilter_ipv4/ipfwadm_core.h:#define IP_FW_F_TCPACK	0x0400	/* For tcp-packets match if ACK is set*/
linux/netfilter_ipv4/ip_conntrack_helper.h:	/* Function to call when data passes; return verdict, or -1 to
linux/netfilter_ipv4/ipt_ULOG.h: * (C) 2000-2002 by Harald Welte <laforge@gnumonks.org>
linux/netfilter_ipv4/ipt_ULOG.h: * bytes. So the multipart netlink-message has to be < 131000 bytes.
linux/netfilter_ipv4/ipt_ULOG.h: * Assuming a standard ethernet-mtu of 1500, we could define this up
linux/netfilter_ipv4/ip_conntrack.h:	IP_CT_NUMBER = IP_CT_IS_REPLY * 2 - 1
linux/netfilter_ipv4/ip_conntrack.h:	/* Conntrack should never be early-expired. */
linux/netfilter_ipv4/ip_conntrack.h:#define master_ct(conntr) (conntr->master ? conntr->master->expectant : NULL)
linux/netfilter_ipv4/ip_conntrack.h:	return test_bit(IPS_CONFIRMED_BIT, &ct->status);
linux/netfilter_ipv6/ip6_tables.h: * 25-Jul-1998 Major changes to allow for ip chain table
linux/netfilter_ipv6/ip6_tables.h: * 3-Jan-2000 Named tables to allow packet selection for different uses.
linux/netfilter_ipv6/ip6_tables.h:/* FIXME: If alignment in kernel different from userspace? --RR */
linux/netfilter_ipv6/ip6_tables.h:#define IP6T_RETURN (-NF_MAX_VERDICT - 1)
linux/netfilter_ipv6/ip6_tables.h:	u_int8_t option;			/* TCP Option iff non-zero*/
linux/netfilter_ipv6/ip6_tables.h:	return (void *)e + e->target_offset;
linux/netfilter_ipv6/ip6_tables.h:	     __i < (e)->target_offset;		\
linux/netfilter_ipv6/ip6_tables.h:	     __i += __m->u.match_size) {	\
linux/netfilter_ipv6/ip6_tables.h:	for (__i = 0; __i < (size); __i += __e->next_offset) {	\
linux/netfilter_ipv6/ip6_tables.h:#define IP6T_ALIGN(s) (((s) + (__alignof__(struct ip6t_entry)-1)) & ~(__alignof__(struct ip6t_entry)-1))
linux/netfilter_ipv6/ip6t_ipv6header.h:/* ipv6header match - matches IPv6 packets based
linux/netfilter_ipv6/ip6t_ipv6header.h: * Rewritten by: Andras Kis-Szabo <kisza@sch.bme.hu> */
linux/smb_fs_sb.h: *  Copyright (C) 1995 by Paal-Kr. Engstad and Volker Lendecke
linux/smb_fs_sb.h:#define server_from_inode(inode) (&(inode)->i_sb->u.smbfs_sb)
linux/smb_fs_sb.h:#define server_from_dentry(dentry) (&(dentry)->d_sb->u.smbfs_sb)
linux/smb_fs_sb.h:#define SB_of(server) ((struct super_block *) ((char *)(server) - \
linux/smb_fs_sb.h:	(unsigned long)(&((struct super_block *)0)->u.smbfs_sb)))
linux/smb_fs_sb.h:	/* utf8 can make strings longer so we can't do in-place conversion.
linux/smb_fs_sb.h:	down(&(server->sem));
linux/smb_fs_sb.h:	up(&(server->sem));
linux/hp_sdc.h: * HP i8042 System Device Controller -- header
linux/hp_sdc.h: * HP-HIL Technical Reference Manual.  Hewlett Packard Product No. 45918A
linux/hp_sdc.h: * 	for Part Number 1820-4784 Revision B.  Dwg No. A-1820-4784-2
linux/hp_sdc.h:#define HP_SDC_STATUS_PUP	0x70	/* Sucessful power-up self test */
linux/hp_sdc.h:#define HP_SDC_STR		0x7f    /* i8042 self-test result */
linux/hp_sdc.h:#define HP_SDC_CFG_ROLLOVER	0x08	/* WTF is "N-key rollover"? */
linux/hp_sdc.h:#define HP_SDC_CFG_KBD_OLD	0x03	/* keyboard code for non-HIL */
linux/hp_sdc.h:	case 0x1: str = "1820-3712"; break;		\
linux/hp_sdc.h:	case 0x2: str = "1820-4379"; break;		\
linux/hp_sdc.h:	case 0x3: str = "1820-4784"; break;		\
linux/hp_sdc.h:#define HP_SDC_XTD_BBRTC	0x20	/* OKI MSM-58321 BBRTC present */
linux/hp_sdc.h:#define HP_SDC_CMD_DO_RTCW	0xc2	/* i8042 RAM 0x70 --> RTC */
linux/hp_sdc.h:#define HP_SDC_CMD_DO_RTCR	0xc3	/* RTC[0x70 0:3] --> irq/status/data */
linux/hp_sdc.h:#define HP_SDC_CMD_DO_BEEP	0xc4	/* i8042 RAM 0x70-74  --> beeper,VT3 */
linux/hp_sdc.h:#define HP_SDC_CMD_DO_HIL	0xc5	/* i8042 RAM 0x70-73 --> 
linux/hp_sdc.h:#define HP_SDC_HIL_RC_DONE	0x80	/* i8042 auto-configured loop */
linux/hp_sdc.h:#define HP_SDC_HIL_RC		0x84	/* i8042 is auto-configuring loop */
linux/hp_sdc.h:	uint8_t		r7[4];          /* current i8042[0x70 - 0x74] values */
linux/ncp_mount.h:	/* we neever pass -1, so it is safe */
linux/ncp_mount.h:	/* we never pass -1, so it is safe */
linux/ite_gpio.h: *          Hai-Pao Fan <haipao@mvista.com>
linux/timer.h: * mod_timer(a,b) is equivalent to del_timer(a); a->expires = b; add_timer(a).
linux/timer.h: * is less efficient than a->expires = b; add_timer(a).
linux/timer.h:	timer->list.next = timer->list.prev = NULL;
linux/timer.h:	return timer->list.next != NULL;
linux/timer.h:#define time_after(a,b)		((long)(b) - (long)(a) < 0)
linux/timer.h:#define time_after_eq(a,b)	((long)(a) - (long)(b) >= 0)
linux/timex.h: *	Added defines for hybrid phase/frequency-lock loop.
linux/timex.h: *	defines for PPS phase-lock loop.
linux/timex.h: * 1995-08-13    Torsten Duwe
linux/timex.h: *      kernel PLL updated to 1994-12-13 specs (rfc-1589)
linux/timex.h: * 1997-08-30    Ulrich Windl
linux/timex.h: * variable which serves as an extension to the low-order bits of the
linux/timex.h: * The following defines are used only if a pulse-per-second (PPS)
linux/timex.h: * asynch driver. They establish the design parameters of the frequency-
linux/timex.h: * syscall interface - used (mainly by NTP daemon)
linux/timex.h:#define ADJ_OFFSET_SINGLESHOT	0x8001	/* old-fashioned adjtime */
linux/timex.h:#define STA_FLL		0x0008	/* select frequency-lock mode (rw) */
linux/timex.h:    STA_PPSERROR | STA_CLOCKERR) /* read-only bits */
linux/timex.h: * phase-lock loop variables
linux/timex.h:/* interface variables pps->timer interrupt */
linux/timex.h:/* interface variables pps->adjtimex */
linux/capi.h: * Copyright 1997 by Carsten Paeth (calle@calle.in-berlin.de)
linux/capi.h:	__u16 nbchannel;	/* number of B-Channels */
linux/msdos_fs_sb.h: * MS-DOS file system in-core superblock data
linux/msdos_fs_sb.h:		 atari:1,         /* Use Atari GEMDOS variation of MS-DOS fs */
linux/msdos_fs_sb.h:	int free_clusters;           /* -1 if undefined */
linux/ncp_fs_sb.h:#define NCP_CLR_FLAG(server, flag)	((server)->flags &= ~(flag))
linux/ncp_fs_sb.h:#define NCP_SET_FLAG(server, flag)	((server)->flags |= (flag))
linux/ncp_fs_sb.h:#define NCP_IS_FLAG(server, flag)	((server)->flags & (flag))
linux/ncp_fs_sb.h:	return ((server->conn_status & 0x11) == 0);
linux/ncp_fs_sb.h:	server->conn_status |= 0x01;
linux/tty_driver.h: * This structure defines the interface between the low-level tty
linux/tty_driver.h: *	device-specific ioctl's.  If the ioctl number passed in cmd
linux/tty_driver.h: * 	well-designed tty driver should be prepared to accept the case
linux/tty_driver.h: * 	off BREAK status on the RS-232 port.  If state is -1,
linux/tty_driver.h: * 	If this routine is implemented, the high-level tty driver will
linux/tty_driver.h: * 	This routine is used to send a high-priority XON/XOFF
linux/tty_driver.h: * TTY_DRIVER_RESET_TERMIOS --- requests the tty layer to reset the
linux/tty_driver.h: * TTY_DRIVER_REAL_RAW --- if set, indicates that the driver will
linux/tty_driver.h: * TTY_DRIVER_NO_DEVFS --- if set, do not create devfs entries. This
linux/etherdevice.h:	memcpy (dest->data, src, len);
linux/etherdevice.h: * is_valid_ether_addr - Determine if the given Ethernet address is valid
linux/etherdevice.h: * @addr: Pointer to a six-byte array containing the Ethernet address
linux/if_pppvar.h: * if_pppvar.h - private structures and declarations for PPP.
linux/scx200.h:   Copyright (c) 2001,2002 Christer Weinigel <wingel@nano-system.com>
linux/scx200.h:#define SCx200_WDT_WDTO 0x00	/* Time-Out Register */
linux/scx200.h:        compile-command: "make -C ../.. bzImage modules"
linux/scx200.h:        c-basic-offset: 8
linux/wireless.h: * Authors :	Jean Tourrilhes - HPL - <jt@hpl.hp.com>
linux/wireless.h: * Copyright (c) 1997-2002 Jean Tourrilhes, All Rights Reserved.
linux/wireless.h: * Initial APIs (1996 -> onward) :
linux/wireless.h: * -----------------------------
linux/wireless.h: * New driver API (2002 -> onward) :
linux/wireless.h: * -------------------------------
linux/wireless.h: * Wireless Events (2002 -> onward) :
linux/wireless.h: * --------------------------------
linux/wireless.h: * --------------
linux/wireless.h: * --------
linux/wireless.h: *	- Encryption renamed to Encode to avoid US regulation problems
linux/wireless.h: *	- Frequency changed from float to struct to avoid problems on old 386
linux/wireless.h: * --------
linux/wireless.h: *	- Add sensitivity
linux/wireless.h: * --------
linux/wireless.h: *	- Missing encoding definitions in range
linux/wireless.h: *	- Access points stuff
linux/wireless.h: * --------
linux/wireless.h: *	- 802.11 support (ESSID ioctls)
linux/wireless.h: * --------
linux/wireless.h: *	- define IW_ESSID_MAX_SIZE and IW_MAX_AP
linux/wireless.h: * --------
linux/wireless.h: *	- Changed my e-mail address
linux/wireless.h: *	- More 802.11 support (nickname, rate, rts, frag)
linux/wireless.h: *	- List index in frequencies
linux/wireless.h: * --------
linux/wireless.h: *	- Support for 'mode of operation' (ad-hoc, managed...)
linux/wireless.h: *	- Support for unicast and multicast power saving
linux/wireless.h: *	- Change encoding to support larger tokens (>64 bits)
linux/wireless.h: *	- Updated iw_params (disable, flags) and use it for NWID
linux/wireless.h: *	- Extracted iw_point from iwreq for clarity
linux/wireless.h: * ---------
linux/wireless.h: *	- Add PM capability to range structure
linux/wireless.h: *	- Add PM modifier : MAX/MIN/RELATIVE
linux/wireless.h: *	- Add encoding option : IW_ENCODE_NOKEY
linux/wireless.h: *	- Add TxPower ioctls (work like TxRate)
linux/wireless.h: * ----------
linux/wireless.h: *	- Add WE version in range (help backward/forward compatibility)
linux/wireless.h: *	- Add retry ioctls (work like PM)
linux/wireless.h: * ----------
linux/wireless.h: *	- Add SIOCSIWSTATS to get /proc/net/wireless programatically
linux/wireless.h: *	- Add DEV PRIVATE IOCTL to avoid collisions in SIOCDEVPRIVATE space
linux/wireless.h: *	- Add new statistics (frag, retry, beacon)
linux/wireless.h: *	- Add average quality (for user space calibration)
linux/wireless.h: * ----------
linux/wireless.h: *	- Document creation of new driver API.
linux/wireless.h: *	- Extract union iwreq_data from struct iwreq (for new driver API).
linux/wireless.h: *	- Rename SIOCSIWNAME as SIOCSIWCOMMIT
linux/wireless.h: * ----------
linux/wireless.h: *	- Wireless Events support : define struct iw_event
linux/wireless.h: *	- Define additional specific event numbers
linux/wireless.h: *	- Add "addr" and "param" fields in union iwreq_data
linux/wireless.h: *	- AP scanning stuff (SIOCSIWSCAN and friends)
linux/wireless.h: * ----------
linux/wireless.h: *	- Add IW_PRIV_TYPE_ADDR for struct sockaddr private arg
linux/wireless.h: *	- Make struct iw_freq signed (both m & e), add explicit padding
linux/wireless.h: *	- Add IWEVCUSTOM for driver specific event/scanning token
linux/wireless.h: *	- Add IW_MAX_GET_SPY for driver returning a lot of addresses
linux/wireless.h: *	- Add IW_TXPOW_RANGE for range of Tx Powers
linux/wireless.h: *	- Add IWEVREGISTERED & IWEVEXPIRED events for Access Points
linux/wireless.h: *	- Add IW_MODE_MONITOR for passive monitor
linux/wireless.h: * ----------
linux/wireless.h: *	- Increase the number of bitrates in iw_range to 32 (for 802.11g)
linux/wireless.h: *	- Increase the number of frequencies in iw_range to 32 (for 802.11b+a)
linux/wireless.h: *	- Reshuffle struct iw_range for increases, add filler
linux/wireless.h: *	- Increase IW_MAX_AP to 64 for driver returning a lot of addresses
linux/wireless.h: *	- Remove IW_MAX_GET_SPY because conflict with enhanced spy support
linux/wireless.h: *	- Add SIOCSIWTHRSPY/SIOCGIWTHRSPY and "struct iw_thrspy"
linux/wireless.h: *	- Add IW_ENCODE_TEMP and iw_range->encoding_login_index
linux/wireless.h:/* -------------------------- IOCTL LIST -------------------------- */
linux/wireless.h: * Common values : "IEEE 802.11-DS", "IEEE 802.11-FH", "IEEE 802.11b"...
linux/wireless.h:#define SIOCSIWNWID	0x8B02		/* set network id (pre-802.11) */
linux/wireless.h:/* Spy support (statistics per MAC address - used for Mobile IP support) */
linux/wireless.h:/* -------------------- DEV PRIVATE IOCTL LIST -------------------- */
linux/wireless.h: * 'mii-tool'.
linux/wireless.h: * We now have 32 commands, so a bit more space ;-).
linux/wireless.h:/* ------------------------- IOCTL STUFF ------------------------- */
linux/wireless.h:/* ----------------------- WIRELESS EVENTS ----------------------- */
linux/wireless.h:/* ------------------------- PRIVATE INFO ------------------------- */
linux/wireless.h: * Privates ioctl are SIOCIWFIRSTPRIV -> SIOCIWLASTPRIV
linux/wireless.h:/* ----------------------- OTHER CONSTANTS ----------------------- */
linux/wireless.h:#define IW_ENCODE_RESTRICTED	0x4000	/* Refuse non-encoded packets */
linux/wireless.h:#define IW_ENCODE_OPEN		0x2000	/* Accept non-encoded packets */
linux/wireless.h:#define IW_SCAN_ALL_RATE	0x0040	/* Scan all Bit-Rates */
linux/wireless.h:#define IW_SCAN_THIS_RATE	0x0080	/* Scan only this Bit-Rate */
linux/wireless.h:/* Max number of char in custom event - use multiple of them if needed */
linux/wireless.h:/* --------------------------- SUBTYPES --------------------------- */
linux/wireless.h:	__u8		pad;		/* Unused - just for alignement */
linux/wireless.h:/* ------------------------ WIRELESS STATS ------------------------ */
linux/wireless.h:					 * - device dependent for now */
linux/wireless.h:/* ------------------------ IOCTL REQUEST ------------------------ */
linux/wireless.h:	/* Config - generic */
linux/wireless.h:	struct iw_param	nwid;		/* network id (or domain - the cell) */
linux/wireless.h:					 * 0-1000 = channel
linux/wireless.h:/* -------------------------- IOCTL DATA -------------------------- */
linux/wireless.h:	/* Old Frequency (backward compat - moved lower ) */
linux/wireless.h:	__u16		num_channels;	/* Number of channels [0; num - 1] */
linux/wireless.h:/* ----------------------- WIRELESS EVENTS ----------------------- */
linux/wireless.h:#define IW_EV_LCP_LEN	(sizeof(struct iw_event) - sizeof(union iwreq_data))
linux/wanpipe.h:*		User-level API definitions.
linux/wanpipe.h:* Copyright:	(c) 1995-2000 Sangoma Technologies Inc.
linux/wanpipe.h: #define stop_net_queue(a) 	(set_bit(0, &##a->tbusy)) 
linux/wanpipe.h: #define start_net_queue(a) 	(clear_bit(0,&##a->tbusy))
linux/wanpipe.h: #define is_queue_stopped(a)	(##a->tbusy)
linux/wanpipe.h: #define wake_net_dev(a)	{clear_bit(0,&##a->tbusy);mark_bh(NET_BH);}
linux/wanpipe.h: #define is_dev_running(a)	(test_bit(0,&##a->start))
linux/wanpipe.h: #define stop_net_queue(a) 	(set_bit(0, &##a->tbusy)) 
linux/wanpipe.h: #define start_net_queue(a) 	(clear_bit(0,&##a->tbusy))
linux/wanpipe.h: #define is_queue_stopped(a)	(##a->tbusy)
linux/wanpipe.h: #define wake_net_dev(a)	{clear_bit(0,&##a->tbusy);mark_bh(NET_BH);}
linux/wanpipe.h: #define is_dev_running(a)	(test_bit(0,(void*)&##a->start))
linux/wanpipe.h:	void* ptr;		/* -> buffer */
linux/wanpipe.h:	void* cmd;		/* -> command structure */
linux/wanpipe.h:	void* data;		/* -> data buffer */
linux/wanpipe.h:	char in_isr;			/* interrupt-in-service flag */
linux/wanpipe.h:	void* mbox;			/* -> mailbox */
linux/wanpipe.h:	void* rxmb;			/* -> receive mailbox */
linux/wanpipe.h:	void* flags;			/* -> adapter status flags */
linux/wanpipe.h:			void* rxmb_base;	/* -> first Rx buffer */
linux/wanpipe.h:			void* rxmb_last;	/* -> last Rx buffer */
linux/wanpipe.h:		struct			/****** PPP-specific data ***********/
linux/wanpipe.h:			void* txbuf;		/* -> current Tx buffer */
linux/wanpipe.h:			void* txbuf_base;	/* -> first Tx buffer */
linux/wanpipe.h:			void* txbuf_last;	/* -> last Tx buffer */
linux/wanpipe.h:			void* rxbuf_base;	/* -> first Rx buffer */
linux/wanpipe.h:			void* rxbuf_last;	/* -> last Rx buffer */
linux/wanpipe.h:		struct			/* Cisco HDLC-specific data */
linux/wanpipe.h:			void* txbuf;		/* -> current Tx buffer */
linux/wanpipe.h:			void* txbuf_base;	/* -> first Tx buffer */
linux/wanpipe.h:			void* txbuf_last;	/* -> last Tx buffer */
linux/wanpipe.h:			void* rxbuf_base;	/* -> first Rx buffer */
linux/wanpipe.h:			void* rxbuf_last;	/* -> last Rx buffer */
linux/wanpipe.h:			void* txbuf;		/* -> current Tx buffer */
linux/wanpipe.h:			void* txbuf_base;	/* -> first Tx buffer */
linux/wanpipe.h:			void* txbuf_last;	/* -> last Tx buffer */
linux/wanpipe.h:			void* rxbuf_base;	/* -> first Rx buffer */
linux/wanpipe.h:			void* rxbuf_last;	/* -> last Rx buffer */
linux/wanpipe.h:			void* tracebuf;		/* -> current Trace buffer */
linux/wanpipe.h:			void* tracebuf_base;	/* -> current Trace buffer */
linux/wanpipe.h:			void* tracebuf_last;	/* -> current Trace buffer */
linux/hiddev.h: *  Copyright (c) 1999-2000 Vojtech Pavlik
linux/hiddev.h: * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
linux/hiddev.h: * e-mail - mail your message to <vojtech@suse.cz>, or by paper mail:
linux/hiddev.h: * IOCTLs (0x00 - 0x7f)
linux/hiddev.h: * In-kernel definitions.
linux/hiddev.h:static inline int hiddev_connect(struct hid_device *hid) { return -1; }
linux/jffs2_fs_i.h:	/* We need an internal semaphore similar to inode->i_sem.
linux/jffs2_fs_i.h:	   data - or if this is a directory inode */
linux/jffs2_fs_i.h:	/* Some stuff we just have to keep in-core at all times, for each inode. */
linux/jffs2_fs_i.h:	   use the doubly-linked lists because we don't want to increase
linux/jffs2_fs_i.h:#define JFFS2_INODE_INFO(i) ((struct jffs2_inode_info *) &(i)->u)
linux/jffs2_fs_i.h:#define JFFS2_INODE_INFO(i) (&i->u.jffs2_i)
linux/coda.h:          Copyright (c) 1987-1999 Carnegie Mellon University
linux/coda.h:          Copyright (c) 1987-1999 Carnegie Mellon University
linux/coda.h:#define DIRSIZ(dp)      ((sizeof (struct venus_dirent) - (CODA_MAXNAMLEN+1)) + \
linux/coda.h:                         (((dp)->d_namlen+1 + 3) &~ 3))
linux/coda.h:	if (fid->Vnode == 0xfffffffe || fid->Vnode == 0xffffffff)
linux/coda.h:		return ((fid->Volume << 20) | (fid->Unique & 0xfffff));
linux/coda.h:		return (fid->Unique + (fid->Vnode<<10) + (fid->Volume<<20));
linux/coda.h:	((fid) ? ((fid)->Unique + ((fid)->Vnode<<10) + ((fid)->Volume<<20)) : 0)
linux/coda.h: * Kernel <--> Venus communications.
linux/coda.h: *        Venus <-> Coda  RPC arguments
linux/coda.h:/* CODA_SIGNAL is out-of-band, doesn't need data. */
linux/coda.h:/* CODA_INVALIDATE is a venus->kernel call */
linux/coda.h:/* CODA_FLUSH is a venus->kernel call */
linux/coda.h:/* CODA_PURGEUSER is a venus->kernel call */
linux/coda.h:/* CODA_ZAPFILE is a venus->kernel call */
linux/coda.h:/* CODA_ZAPDIR is a venus->kernel call */	
linux/coda.h:/* CODA_ZAPVNODE is a venus->kernel call */	
linux/coda.h:/* CODA_PURGEFID is a venus->kernel call */	
linux/coda.h:/* CODA_REPLACE is a venus->kernel call */	
linux/coda.h:struct coda_replace_out { /* coda_replace is a venus->kernel call */
linux/coda.h:    struct file *fh; /* not passed from userspace but used in-kernel only */
linux/coda.h:    /* CODA_INVALIDATE is a venus->kernel call */
linux/coda.h:    /* CODA_FLUSH is a venus->kernel call */
linux/coda.h:#define	CTL_VOL			-1
linux/coda.h:#define	CTL_VNO			-1
linux/coda.h:#define	CTL_UNI			-1
linux/coda.h:#define CTL_INO                 -1
linux/coda.h:#define	IS_CTL_FID(fidp)	((fidp)->Volume == CTL_VOL &&\
linux/coda.h:				 (fidp)->Vnode == CTL_VNO &&\
linux/coda.h:				 (fidp)->Unique == CTL_UNI)
linux/cobalt-nvram.h: * $Id: ack,v 1.1.1.1 2006-10-13 02:42:37 steven Exp $
linux/cobalt-nvram.h: * cobalt-nvram.h : defines for the various fields in the cobalt NVRAM
linux/cobalt-nvram.h:/* flag bytes - 16 flags for now, leave room for more */
linux/cobalt-nvram.h:/* flags in flag bytes - up to 16 */
linux/cobalt-nvram.h:/* leave byte 0x12 blank - Linux looks for drive info here */
linux/cobalt-nvram.h:/* checksum of bytes 0xe-0x7f */
linux/cobalt-nvram.h:/* checksum for serial num - 1 byte */
linux/coff.h:/* Load a short int from the following tables with little-endian formats */
linux/coff.h:/* Load a long int from the following tables with little-endian formats */
linux/coff.h:/* Load a short int from the following tables with big-endian formats */
linux/coff.h:/* Load a long int from the following tables with big-endian formats */
linux/coff.h:   a big-endian header with little-endian data. In that case, generate a
linux/coff.h:#define COFF_SECT_BSS   2      /* Section for un-initialized globals       */
linux/coff.h:#define COFF_STYP_NOLOAD  0x02 /* no-load segment                          */
linux/netlink.h:#define NLMSG_ALIGN(len) ( ((len)+NLMSG_ALIGNTO-1) & ~(NLMSG_ALIGNTO-1) )
linux/netlink.h:#define NLMSG_NEXT(nlh,len)	 ((len) -= NLMSG_ALIGN((nlh)->nlmsg_len), \
linux/netlink.h:				  (struct nlmsghdr*)(((char*)(nlh)) + NLMSG_ALIGN((nlh)->nlmsg_len)))
linux/netlink.h:			   (nlh)->nlmsg_len >= sizeof(struct nlmsghdr) && \
linux/netlink.h:			   (nlh)->nlmsg_len <= (len))
linux/netlink.h:#define NLMSG_PAYLOAD(nlh,len) ((nlh)->nlmsg_len - NLMSG_SPACE((len)))
linux/netlink.h:#define NETLINK_CB(skb)		(*(struct netlink_skb_parms*)&((skb)->cb))
linux/netlink.h:	nlh->nlmsg_type = type;
linux/netlink.h:	nlh->nlmsg_len = size;
linux/netlink.h:	nlh->nlmsg_flags = 0;
linux/netlink.h:	nlh->nlmsg_pid = pid;
linux/netlink.h:	nlh->nlmsg_seq = seq;
linux/atm_zatm.h:/* atm_zatm.h - Driver-specific declarations of the ZATM driver (for use by
linux/atm_zatm.h:		driver-specific utilities) */
linux/atm_zatm.h:/* Written 1995-1999 by Werner Almesberger, EPFL LRC/ICA */
linux/atm_zatm.h: * Note: non-kernel programs including this file must also include
linux/atm_zatm.h:	struct timeval real;		/* real (wall-clock) time */
linux/qnx4_fs.h: *  Last modified                : 2000-01-31
linux/qnx4_fs.h: *  History                      : 23-03-1998 created
linux/phonedev.h:#define PHONE_UNIT_ANY	-1
linux/brlvger.h: *      Copyright 2001-2002 Stephane Dalton <sdalton@videotron.ca>
linux/brlvger.h: *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
linux/uinput.h: * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
linux/uinput.h: *		- first public version
linux/uinput.h:#define NBITS(x) ((((x)-1)/(sizeof(long)*8))+1)
linux/wm97xx.h:#define WM97XX_SLT(i)		((i - 5) & 0x7)	/* touchpanel slot selection (5-11) */
linux/wm97xx.h:#define WM9712_45W			0x1000		/* set for 5-wire touchscreen */
linux/hfs_fs_sb.h: * Copyright (C) 1995-1997  Paul H. Hargrove
linux/hfs_fs_sb.h: * HFS-specific information in the in-core superblock.
linux/hfs_fs_sb.h: * The HFS-specific part of a Linux (struct super_block)
linux/concap.h:   linux-x25 mailing list contributed by Alan Cox, Thomasz Motylewski
linux/sdla_fr.h:* Copyright:	(c) 1995-2000 Sangoma Technologies Inc.
linux/sdla_fr.h:/*----------------------------------------------------------------------------
linux/sdla_fr.h: * ------
linux/sdla_fr.h: * 1. All structures defined in this file are byte-alined.  
linux/sdla_fr.h: *	--------	--------
linux/sdla_fr.h:/*----------------------------------------------------------------------------
linux/sdla_fr.h:/*----------------------------------------------------------------------------
linux/sdla_fr.h:/*----------------------------------------------------------------------------
linux/sdla_fr.h:/*----------------------------------------------------------------------------
linux/sdla_fr.h:/*----------------------------------------------------------------------------
linux/sdla_fr.h:/*----------------------------------------------------------------------------
linux/sdla_fr.h:/*----------------------------------------------------------------------------
linux/sdla_fr.h:	unsigned short port	PACKED;	/* 06h: RS-232/V.35 */
linux/sdla_fr.h:/* bit settings for the 'status' byte  - note that bits 1, 2 and 3 are used */
linux/sdla_fr.h:/*----------------------------------------------------------------------------
linux/sdla_fr.h:/*----------------------------------------------------------------------------
linux/sdla_fr.h:/*----------------------------------------------------------------------------
linux/sdla_fr.h:/*----------------------------------------------------------------------------
linux/sdla_fr.h:/*----------------------------------------------------------------------------
linux/sdla_fr.h:/*----------------------------------------------------------------------------
linux/sdla_fr.h:/*----------------------------------------------------------------------------
linux/sdla_fr.h:/*----------------------------------------------------------------------------
linux/sdla_fr.h:/*----------------------------------------------------------------------------
linux/sdla_fr.h: * Frame Relay ARP Header -- Used for Dynamic route creation with InvARP 
linux/sdla_fr.h:/*----------------------------------------------------------------------------
linux/sdla_fr.h: * Frame Relay RFC 1490 SNAP Header -- Used to check for ARP packets
linux/dtlk.h:             			   bit goes zero 2-3 usec after
linux/dtlk.h:             			   writing, and goes 1 again 180-190
linux/dtlk.h:  unsigned short serial_number;	/* 0-7Fh:0-7Fh */
linux/dtlk.h:  unsigned char punc_level;	/* nB; 0-7 */
linux/dtlk.h:  unsigned char formant_freq;	/* nF; 0-9 */
linux/dtlk.h:  unsigned char pitch;		/* nP; 0-99 */
linux/dtlk.h:  unsigned char speed;		/* nS; 0-9 */
linux/dtlk.h:  unsigned char volume;		/* nV; 0-9 */
linux/dtlk.h:  unsigned char tone;		/* nX; 0-2 */
linux/dtlk.h:  unsigned char expression;	/* nE; 0-9 */
linux/dtlk.h:  unsigned char articulation;	/* nA; 0-9 */
linux/dtlk.h:  unsigned char reverb;		/* nR; 0-9 */
linux/sdladrv.h:* Copyright:	(c) 1995-2000 Sangoma Technologies Inc.
linux/sdladrv.h:#define	SDLA_WINDOWSIZE	0x2000	/* default dual-port memory window size */
linux/sdladrv.h:/*----------------------------------------------------------------------------
linux/sdladrv.h:	void * dpmbase;			/* dual-port memory base */
linux/sdladrv.h:	unsigned dpmsize;		/* dual-port memory size */
linux/coda_linux.h:#define D_MALLOC    16  /* print malloc, de-alloc information */
linux/coda_linux.h:#define ITOC(inode) (&((inode)->u.coda_i))
linux/coda_linux.h:	return &(ITOC(inode)->c_fid);
linux/coda_linux.h:	return coda_f2s(&(ITOC(inode)->c_fid));
linux/coda_linux.h:	ITOC(inode)->c_flags |= flag;
linux/zutil.h:/* zutil.h -- internal interface and configuration of the compression library
linux/zutil.h: * Copyright (C) 1995-1998 Jean-loup Gailly.
linux/zutil.h:/* compile with -Dlocal if your debugger can't find static symbols */
linux/zutil.h:/* NMAX is the largest n such that 255n(n+1)/2 + (n+1)(BASE-1) <= 2^32-1 */
linux/zutil.h:     Update a running Adler-32 checksum with the bytes buf[0..len-1] and
linux/zutil.h:   An Adler-32 checksum is almost as reliable as a CRC32 but can be computed
linux/zutil.h:        len -= k;
linux/zutil.h:            k -= 16;
linux/zutil.h:        } while (--k);
linux/usbdevice_fs.h: *	usbdevice_fs.h  --  USB device file system.
linux/usbdevice_fs.h:/* --------------------------------------------------------------------- */
linux/usbdevice_fs.h:	unsigned int signr;  /* signal to be sent on error, -1 if none should be sent */
linux/usbdevice_fs.h:/* --------------------------------------------------------------------- */
linux/usbdevice_fs.h:/* --------------------------------------------------------------------- */
linux/isapnp.h:#define ISAPNP_VENDOR(a,b,c)	(((((a)-'A'+1)&0x3f)<<2)|\
linux/isapnp.h:				((((b)-'A'+1)&0x18)>>3)|((((b)-'A'+1)&7)<<13)|\
linux/isapnp.h:				((((c)-'A'+1)&0x1f)<<8))
linux/isapnp.h:	struct isapnp_mem32 *next;	/* next 32-bit memory resource */
linux/isapnp.h:	struct isapnp_mem32 *mem32;	/* first 32-bit memory */
linux/isapnp.h:	void (*remove) (struct pci_dev *dev);	/* Device removed (NULL if not a hot-plug capable driver) */
linux/isapnp.h:	for(card = pci_bus_b(isapnp_cards.next); card != pci_bus_b(&isapnp_cards); card = pci_bus_b(card->node.next))
linux/isapnp.h:	for(dev = pci_dev_g(isapnp_devices.next); dev != pci_dev_g(&isapnp_devices); dev = pci_dev_g(dev->global_list.next))
linux/isapnp.h:static inline int isapnp_cfg_begin(int csn, int device) { return -ENODEV; }
linux/isapnp.h:static inline int isapnp_cfg_end(void) { return -ENODEV; }
linux/isapnp.h:						  const struct isapnp_card_id *id)) { return -ENODEV; }
linux/isapnp.h:						 const struct isapnp_device_id *id)) { return -ENODEV; }
linux/isapnp.h:static inline int isapnp_activate_dev(struct pci_dev *dev, const char *name) { return -ENODEV; }
linux/file.h:	struct files_struct *files = current->files;
linux/file.h:	read_lock(&files->file_lock);
linux/file.h:	res = FD_ISSET(fd, files->close_on_exec);
linux/file.h:	read_unlock(&files->file_lock);
linux/file.h:	struct files_struct *files = current->files;
linux/file.h:	write_lock(&files->file_lock);
linux/file.h:		FD_SET(fd, files->close_on_exec);
linux/file.h:		FD_CLR(fd, files->close_on_exec);
linux/file.h:	write_unlock(&files->file_lock);
linux/file.h:	if (fd < files->max_fds)
linux/file.h:		file = files->fd[fd];
linux/file.h:	struct files_struct *files = current->files;
linux/file.h:	if (fd < files->max_fds)
linux/file.h:		file = files->fd[fd];
linux/file.h:	FD_CLR(fd, files->open_fds);
linux/file.h:	if (fd < files->next_fd)
linux/file.h:		files->next_fd = fd;
linux/file.h:	struct files_struct *files = current->files;
linux/file.h:	write_lock(&files->file_lock);
linux/file.h:	write_unlock(&files->file_lock);
linux/sdlapci.h:* Copyright:	(c) 1999-2000 Sangoma Technologies Inc.
linux/sdlapci.h:#define PCI_MEM_BASE0_DWORD	0x14		/* memory base - apperture 0 */
linux/sdlapci.h:#define PCI_MEM_BASE1_DWORD     0x18		/* memory base - apperture 1 */
linux/matroxfb.h:  MATROXFB_CTRL_TYPE_INTEGER=0,	/* An integer-valued control */
linux/matroxfb.h:  MATROXFB_CTRL_TYPE_BOOLEAN,	/* A boolean-valued control */
linux/matroxfb.h:  __u32 id;			/* A driver-defined ID */
linux/generic_serial.h: *  Version 0.1 -- December, 1998.
linux/genhd.h:	EZD_PARTITION =	0x55,	/* EZ-DRIVE */
linux/genhd.h:	unsigned char boot_ind;		/* 0x80 - active */
linux/genhd.h:	__u32	d_trkseek;		/* track-to-track seek, usec */
linux/genhd.h:	__u32	d_drivedata[NDDATA];	/* drive-type specific information */
linux/genhd.h: * FIXME: this should use genhd->minor_shift, but that is slow to look up.
linux/highmem.h:	return kmap(bh->b_page) + bh_offset(bh);
linux/highmem.h:	kunmap(bh->b_page);
linux/highmem.h:	if (!PageHighMem(bh->b_page))
linux/highmem.h:		return bh->b_data;
linux/highmem.h:	addr = (unsigned long) kmap_atomic(bh->b_page, KM_BH_IRQ);
linux/highmem.h:#define bh_kmap(bh)			((bh)->b_data)
linux/highmem.h:#define bh_kmap_irq(bh, flags)		((bh)->b_data)
linux/sdlasfm.h:* Copyright:	(c) 1995-1999 Sangoma Technologies Inc.
linux/sdlasfm.h:#define	SFM_SIGNATURE	"SFM - Sangoma SDLA Firmware Module"
linux/sdlasfm.h:	unsigned short	winoffs;	/* dual-port memory window offset */
linux/if_arcnet.h:#define ARC_P_POWERLAN_BEACON	8	/* Probably ATA-Netbios related */
linux/if_arcnet.h:#define ARC_P_LANSOFT		251	/* 0xFB - what is this? */
linux/if_arcnet.h: * The RFC1201-specific components of an arcnet packet header.
linux/if_arcnet.h:    uint8_t  proto;		/* protocol ID field - varies		*/
linux/if_arcnet.h: * The RFC1051-specific components.
linux/if_arcnet.h: * The ethernet-encap-specific components.  We have a real ethernet header
linux/if_arcnet.h: * the _end_ of the 512-byte buffer.  We hide this complexity inside the
linux/if_arcnet.h:    uint8_t  source,		/* source ARCnet - filled in automagically */
linux/if_arcnet.h:             dest,		/* destination ARCnet - 0 for broadcast    */
linux/if_arcnet.h:    /* arcnet encapsulation-specific bits */
linux/highuid.h: * kernel-private data.
linux/highuid.h: * -1 is different in 16 bits than it is in 32 bits
linux/highuid.h:#define low2highuid(uid) ((uid) == (old_uid_t)-1 ? (uid_t)-1 : (uid_t)(uid))
linux/highuid.h:#define low2highgid(gid) ((gid) == (old_gid_t)-1 ? (gid_t)-1 : (gid_t)(gid))
linux/highuid.h: * only supports 16-bit UIDs and the kernel has a high UID/GID to write
linux/highuid.h: * 16-bit UID back compatibility, we won't use old_uid_t and old_gid_t
linux/mount.h:		atomic_inc(&mnt->mnt_count);
linux/mount.h:		if (atomic_dec_and_test(&mnt->mnt_count))
linux/hdlc.h: * Copyright (C) 1999-2003 Krzysztof Halasa <khc@pm.waw.pl>
linux/hdlc.h:#define CLOCK_EXT	1	/* External TX and RX clock - DTE */
linux/hdlc.h:#define CLOCK_INT	2	/* Internal TX and RX clock - DCE */
linux/hdlc.h:#define PARITY_CRC16_PR0_CCITT	4 /* CRC16, initial 0x0000, ITU-T version */
linux/hdlc.h:#define PARITY_CRC16_PR1_CCITT	5 /* CRC16, initial 0xFFFF, ITU-T version */
linux/hdlc.h:#define LMI_CCITT		3 /* ITU-T Annex A */
linux/hdlc.h:	struct net_device netdev; /* master net device - must be first */
linux/hdlc.h:	/* hardware driver must handle this instead of dev->hard_start_xmit */
linux/hdlc.h:	return &hdlc->netdev;
linux/hdlc.h:	return (pvc_device*)dev->priv;
linux/hdlc.h:	return hdlc_to_dev(hdlc)->name;
linux/hdlc.h:	for (i=0; i < skb->len; i++) {
linux/hdlc.h:		printk(" %02X", skb->data[i]);
linux/hdlc.h:	if (hdlc->proto == -1)
linux/hdlc.h:		return -ENOSYS;		/* no protocol attached */
linux/hdlc.h:	if (hdlc->open)
linux/hdlc.h:		return hdlc->open(hdlc);
linux/hdlc.h:	if (hdlc->stop)
linux/hdlc.h:		hdlc->stop(hdlc);
linux/hdlc.h:	if (hdlc->proto_detach)
linux/hdlc.h:		hdlc->proto_detach(hdlc);
linux/hdlc.h:	hdlc->proto_detach = NULL;
linux/hdlc.h:	hdlc_device *hdlc = dev_to_hdlc(skb->dev);
linux/hdlc.h:	if (hdlc->type_trans)
linux/hdlc.h:		return hdlc->type_trans(skb, dev);
linux/ext2_fs_sb.h: * Laboratoire MASI - Institut Blaise Pascal
linux/ext2_fs_sb.h: * second extended-fs super-block data in memory
linux/adfs_fs.h:    __u8  unused52[60 - 52];
linux/adfs_fs.h: * the disk size is non-zero!!!
linux/adfs_fs.h:        	result = result + *--p;
linux/sysrq.h:/* -*- linux-c -*-
linux/sysrq.h:/* Generic SysRq interface -- you may call it from any device driver, supplying
linux/sysrq.h: * are available -- else NULL's).
linux/sysrq.h:                retval = -1;
linux/sysrq.h:	return -EINVAL;
linux/802_11.h:        {Class_2_from_NonAuth,	0xff," Class 2 frame received from non-Authenticated station"},\
linux/802_11.h:#define ieee_802_11_frame_subtype_PS_Poll 		0xA // PS-Poll
linux/802_11.h:#define ieee_802_11_frame_subtype_CFEnd 		0xE // CF-End
linux/802_11.h:#define ieee_802_11_frame_subtype_CFEnd_CFAck 		0xF // CF-End + CF-Ack
linux/802_11.h:#define ieee_802_11_frame_subtype_Data_CFAck 		0x1 // Data + CF-Ack
linux/802_11.h:#define ieee_802_11_frame_subtype_Data_CF_Poll 		0x2 // Data + CF-Poll
linux/802_11.h:#define ieee_802_11_frame_subtype_Data_CF_AckCF_Poll 	0x3 // Data + CF-Ack + CF-Poll
linux/802_11.h:#define ieee_802_11_frame_subtype_CF_Ack 		0x5 // CF-Ack (no data)
linux/802_11.h:#define ieee_802_11_frame_subtype_CF_Poll 		0x6 // CF-Poll (no data)
linux/802_11.h:#define ieee_802_11_frame_subtype_CF_AckCF_Poll 	0x7 // CF-Ack + CF-Poll (no data)
linux/802_11.h:	{ ieee_802_11_frame_subtype_PS_Poll 	,	0xF,"A  PS-Poll"},\
linux/802_11.h:	{ ieee_802_11_frame_subtype_CFEnd	,	0xF,"E  CF-End"},\
linux/802_11.h:	{ ieee_802_11_frame_subtype_CFEnd_CFAck ,	0xF,"F  CF-End + CF-Ack"},\
linux/802_11.h:	{ ieee_802_11_frame_subtype_Data_CFAck 	,	0xF,"1  Data + CF-Ack"},\
linux/802_11.h:	{ ieee_802_11_frame_subtype_Data_CFPoll ,	0xF,"2  Data + CF-Poll"},\
linux/802_11.h:	{ ieee_802_11_frame_subtype_Data_CFAck_CFPoll,	0xF,"3  Data + CF-Ack + CF-Poll"},\
linux/802_11.h:	{ ieee_802_11_frame_subtype_CFAck ,		0xF,"5  CF-Ack (no data)"},\
linux/802_11.h:	{ ieee_802_11_frame_subtype_CFPoll ,		0xF,"6  CF-Poll (no data)"},\
linux/802_11.h:	{ ieee_802_11_frame_subtype_CFAck_CFPoll,	0xF,"y7  CF-Ack + CF-Poll (no data)"},\
linux/802_11.h:	{ ieee_802_11_frame_subtype_PS-Poll 	,	0xF,3,ieee_802_11_frame_type_Control},\
linux/ghash.h: * include/linux/ghash.h -- generic hashing with fuzzy retrieval
linux/ghash.h: * (C) 1997 Thomas Schoebel-Theuer
linux/ghash.h:	int ix = HASHFN(elem->KEY);\
linux/ghash.h:	TYPE ** base = &tbl->hashtable[ix];\
linux/ghash.h:	tbl->nr_entries++;\
linux/ghash.h:	while(ptr && KEYCMP(ptr->KEY, elem->KEY)) {\
linux/ghash.h:		base = &ptr->PTRS.next_hash;\
linux/ghash.h:	elem->PTRS.next_hash = ptr;\
linux/ghash.h:	elem->PTRS.prev_hash = prev;\
linux/ghash.h:		ptr->PTRS.prev_hash = elem;\
linux/ghash.h:		ptr = tbl->sorted_list;\
linux/ghash.h:		prev = ptr->PTRS.prev_sorted;\
linux/ghash.h:		TYPE * next = ptr->PTRS.next_hash;\
linux/ghash.h:		if(next && KEYCMP(next->KEY, elem->KEY)) {\
linux/ghash.h:		} else if(KEYCMP(ptr->KEY, elem->KEY)) {\
linux/ghash.h:			ptr = ptr->PTRS.next_sorted;\
linux/ghash.h:	elem->PTRS.next_sorted = ptr;\
linux/ghash.h:	elem->PTRS.prev_sorted = prev;\
linux/ghash.h:		ptr->PTRS.prev_sorted = elem;\
linux/ghash.h:		prev->PTRS.next_sorted = elem;\
linux/ghash.h:		tbl->sorted_list = elem;\
linux/ghash.h:	TYPE * next = elem->PTRS.next_hash;\
linux/ghash.h:	TYPE * prev = elem->PTRS.prev_hash;\
linux/ghash.h:	tbl->nr_entries--;\
linux/ghash.h:		next->PTRS.prev_hash = prev;\
linux/ghash.h:		prev->PTRS.next_hash = next;\
linux/ghash.h:		int ix = HASHFN(elem->KEY);\
linux/ghash.h:		tbl->hashtable[ix] = next;\
linux/ghash.h:	next = elem->PTRS.next_sorted;\
linux/ghash.h:	prev = elem->PTRS.prev_sorted;\
linux/ghash.h:		next->PTRS.prev_sorted = prev;\
linux/ghash.h:		prev->PTRS.next_sorted = next;\
linux/ghash.h:		tbl->sorted_list = next;\
linux/ghash.h:	TYPE * ptr = tbl->hashtable[ix];\
linux/ghash.h:	while(ptr && KEYCMP(ptr->KEY, pos))\
linux/ghash.h:		ptr = ptr->PTRS.next_hash;\
linux/ghash.h:	if(ptr && !KEYEQ(ptr->KEY, pos))\
linux/ghash.h:	ptr = tbl->sorted_list;\
linux/ghash.h:	if(!ptr || KEYCMP(pos, ptr->KEY))\
linux/ghash.h:		next = tbl->hashtable[(ix+offset) & ((HASHSIZE)-1)];\
linux/ghash.h:		if(next && (KEYCMP(next->KEY, pos) || KEYEQ(next->KEY, pos))\
linux/ghash.h:		   && KEYCMP(ptr->KEY, next->KEY))\
linux/ghash.h:		next = ptr->PTRS.next_hash;\
linux/ghash.h:			if(KEYCMP(next->KEY, pos)) {\
linux/ghash.h:		next = ptr->PTRS.next_sorted;\
linux/ghash.h:		if(next && KEYCMP(next->KEY, pos)) {\
linux/ghash.h:	int ix = HASHFN(elem->KEY);\
linux/ghash.h:	TYPE ** base = &tbl->hashtable[ix];\
linux/ghash.h:	tbl->nr_entries++;\
linux/ghash.h:	while(ptr && KEYCMP(ptr->KEY, elem->KEY)) {\
linux/ghash.h:		base = &ptr->PTRS.next_hash;\
linux/ghash.h:	elem->PTRS.next_hash = ptr;\
linux/ghash.h:	elem->PTRS.prev_hash = prev;\
linux/ghash.h:		ptr->PTRS.prev_hash = elem;\
linux/ghash.h:	TYPE * next = elem->PTRS.next_hash;\
linux/ghash.h:	TYPE * prev = elem->PTRS.prev_hash;\
linux/ghash.h:	tbl->nr_entries--;\
linux/ghash.h:		next->PTRS.prev_hash = prev;\
linux/ghash.h:		prev->PTRS.next_hash = next;\
linux/ghash.h:		int ix = HASHFN(elem->KEY);\
linux/ghash.h:		tbl->hashtable[ix] = next;\
linux/ghash.h:	TYPE * ptr = tbl->hashtable[ix];\
linux/ghash.h:	while(ptr && KEYCMP(ptr->KEY, pos))\
linux/ghash.h:		ptr = ptr->PTRS.next_hash;\
linux/ghash.h:	if(ptr && !KEYEQ(ptr->KEY, pos))\
linux/hpfs_fs_i.h:	unsigned i_conv : 2;	/* (files) crlf->newline hackery */
linux/stringify.h: * macro itself.  For example, compile with -DFOO=bar, __stringify(FOO)
linux/coda_fs_i.h:#define CODA_FTOC(file) ((struct coda_file_info *)((file)->private_data))
linux/dnotify.h:	if ((inode)->i_dnotify_mask & (event))
linux/dnotify.h:	parent = dentry->d_parent;
linux/dnotify.h:	if (parent->d_inode->i_dnotify_mask & event) {
linux/dnotify.h:		__inode_dir_notify(parent->d_inode, event);
linux/isdnif.h: * Definition of the interface between the subsystem and its low-level drivers.
linux/isdnif.h: * Values for general protocol-selection
linux/isdnif.h:#define ISDN_PTYPE_1TR6      1   /* german 1TR6-protocol */
linux/isdnif.h:#define ISDN_PTYPE_EURO      2   /* EDSS1-protocol       */
linux/isdnif.h:#define ISDN_PTYPE_NI1       4   /* US NI-1 protocol     */
linux/isdnif.h: * Values for Layer-2-protocol-selection
linux/isdnif.h:#define ISDN_PROTO_L2_X75I   0   /* X75/LAPB with I-Frames            */
linux/isdnif.h:#define ISDN_PROTO_L2_X75UI  1   /* X75/LAPB with UI-Frames           */
linux/isdnif.h:#define ISDN_PROTO_L2_X75BUI 2   /* X75/LAPB with UI-Frames           */
linux/isdnif.h: * Values for Layer-3-protocol-selection
linux/isdnif.h:/* value is <= 0 no action in LL will be taken -> request ignored    */
linux/isdnif.h:/* callback is initiated with timeout set to -1 and a datalen set    */
linux/isdnif.h:                 /* -1  in stat callback when timed out */
linux/isdnif.h:#define ISDN_CMD_ACCEPTD  2       /* Accept an incoming call on D-Chan.    */
linux/isdnif.h:#define ISDN_CMD_ACCEPTB  3       /* Request B-Channel connect.            */
linux/isdnif.h:#define ISDN_CMD_SETSIL   8       /* Set Service-Indicator-List of channel */
linux/isdnif.h:#define ISDN_CMD_GETSIL   9       /* Get Service-Indicator-List of channel */
linux/isdnif.h:#define ISDN_CMD_SETL2   10       /* Set B-Chan. Layer2-Parameter          */
linux/isdnif.h:#define ISDN_CMD_GETL2   11       /* Get B-Chan. Layer2-Parameter          */
linux/isdnif.h:#define ISDN_CMD_SETL3   12       /* Set B-Chan. Layer3-Parameter          */
linux/isdnif.h:#define ISDN_CMD_GETL3   13       /* Get B-Chan. Layer3-Parameter          */
linux/isdnif.h:#define ISDN_CMD_UNLOCK  15       /* Release usage-lock                    */
linux/isdnif.h:#define ISDN_CMD_FAXCMD  23       /* FAX commands to HL-driver             */
linux/isdnif.h: * Status-Values delivered from lowlevel to linklevel via
linux/isdnif.h:#define ISDN_STAT_STAVAIL 256    /* Raw status-data available             */
linux/isdnif.h:#define ISDN_STAT_RUN     258    /* Signal protocol-code is running       */
linux/isdnif.h:#define ISDN_STAT_STOP    259    /* Signal halt of protocol-code          */
linux/isdnif.h:#define ISDN_STAT_DCONN   260    /* Signal D-Channel connect              */
linux/isdnif.h:#define ISDN_STAT_BCONN   261    /* Signal B-Channel connect              */
linux/isdnif.h:#define ISDN_STAT_DHUP    262    /* Signal D-Channel disconnect           */
linux/isdnif.h:#define ISDN_STAT_BHUP    263    /* Signal B-Channel disconnect           */
linux/isdnif.h:#define ISDN_STAT_CINF    264    /* Charge-Info                           */
linux/isdnif.h:#define ISDN_STAT_LOAD    265    /* Signal new lowlevel-driver is loaded  */
linux/isdnif.h:#define ISDN_STAT_UNLOAD  266    /* Signal unload of lowlevel-driver      */
linux/isdnif.h:#define ISDN_STAT_NODCH   268    /* Signal no D-Channel                   */
linux/isdnif.h:#define ISDN_STAT_CAUSE   270    /* Cause-Message                         */
linux/isdnif.h:#define ISDN_STAT_ICALLW  271    /* Incoming call without B-chan waiting  */
linux/isdnif.h:#define ISDN_STAT_L1ERR   275    /* Signal Layer-1 Error                  */
linux/isdnif.h:#define ISDN_STAT_FAXIND  276    /* FAX indications from HL-driver        */
linux/isdnif.h: * Values for feature-field of interface-struct.
linux/isdnif.h:    unsigned char phone[32];	/* Remote Phone-Number */
linux/isdnif.h:	int   driver;		/* Lowlevel-Driver-ID            */
linux/isdnif.h:		isdn_cmd_stat isdn_io; /* ISDN IO-parameter/result	*/
linux/isdnif.h: * The interface-struct itself (initialized at load-time of lowlevel-driver)
linux/isdnif.h:   * Maximum Size of transmit/receive-buffer this driver supports.
linux/isdnif.h:  /* Feature-Flags for this driver.
linux/isdnif.h:   * dev->hard_header_len = linklayer header + hl_hdrlen;
linux/isdnif.h:   * Receive-Callback using sk_buff's
linux/isdnif.h:   *             int                    Driver-ID
linux/isdnif.h:   *             int                    local channel-number (0 ...)
linux/isdnif.h:  /* Status-Callback
linux/isdnif.h:   *                   arg     = depending on status-type.
linux/isdnif.h:   *                   num     = depending on status-type.
linux/isdnif.h:   *             int                    local channel-number (0...)
linux/isdnif.h:  /* Send raw D-Channel-Commands
linux/isdnif.h:   *             int    Flag: 0 = Call form Kernel-Space (use memcpy,
linux/isdnif.h:   *                          1 = Data is in User-Space (use memcpy_fromfs,
linux/isdnif.h:   *             int    local channel-number (0 ...)
linux/isdnif.h:   *             int    Flag: 0 = Call form Kernel-Space (use memcpy,
linux/isdnif.h:   *                          1 = Data is in User-Space (use memcpy_fromfs,
linux/isdnif.h:   *             int    local channel-number (0 ...)
linux/isdnif.h: * Function which must be called by lowlevel-driver at loadtime with
linux/isdnif.h: * command      Address of Command-Handler.
linux/isdnif.h: * writebuf_skb Address of Skbuff-Send-Handler.
linux/isdnif.h: * writecmd        "    "  D-Channel  " which accepts raw D-Ch-Commands.
linux/isdnif.h: * readstat        "    "  D-Channel  " which delivers raw Status-Data.
linux/isdnif.h: * The linklevel-driver fills the following fields:
linux/isdnif.h: * channels      Driver-ID assigned to this driver. (Must be used on all
linux/isdnif.h: * statcallb        "    "     "    for status-changes.
linux/igmp.h:#define IGMP_TIMER_SCALE		10	/* denotes that the igmphdr->timer field */
linux/igmp.h:#define IGMPV3_MASK(value, nb) ((nb)>=32 ? (value) : ((1<<(nb))-1) & (value))
linux/ftape.h: * Copyright (C) 1994-1996 Bas Laarhoven,
linux/ftape.h: *           (C) 1996-1997 Claus-Justus Heine.
linux/ftape.h: * $Source: /home/cvsroot/RT288x_SDK/source/linux-2.4.x/include/ack,v $
linux/ftape.h: *      for the QIC-40/80/3010/3020 floppy-tape driver for Linux.
linux/ftape.h:#define FT_SEGMENT_SIZE		((FT_SECTORS_PER_SEGMENT - FT_ECC_SECTORS) * FT_SECTOR_SIZE)
linux/ftape.h:#define FT_FOREVER      -1
linux/ftape.h:#define ABS(a)          ((a) < 0 ? -(a) : (a))
linux/devfs_fs_kernel.h:#define IS_DEVFS_INODE(inode) (DEVFS_SUPER_MAGIC == (inode)->i_sb->s_magic)
linux/devfs_fs_kernel.h:      ((inode)->i_sb && \
linux/devfs_fs_kernel.h:       ((inode)->i_sb->s_magic==DEVFS_SUPER_MAGIC) && \
linux/devfs_fs_kernel.h:      ) ? m : MINOR((inode)->r_dev); })
linux/devfs_fs_kernel.h:					 is set to read-write for all        */
linux/devfs_fs_kernel.h:    return -ENOSYS;
linux/devfs_fs_kernel.h:    return -ENOSYS;
linux/devfs_fs_kernel.h:    return -1;
linux/devfs_fs_kernel.h:    return -1;
linux/init.h: * module_init() - driver initialization entry point
linux/init.h: * module_exit() - driver exit entry point
linux/init.h: * module_exit() will wrap the driver clean-up code
linux/ipmi.h: * With that said, this driver provides a multi-user interface to the
linux/ipmi.h: * Multi-user means that multiple applications may use the driver,
linux/ipmi.h: * This driver provides two main interfaces: one for in-kernel
linux/ipmi.h: * #ifdef KERNEL below is the in-kernel interface.  The userland
linux/ipmi.h: * - is this right, or should we use -1?
linux/ipmi.h: * is used for the receive in-kernel interface and in the receive
linux/ipmi.h: * The in-kernel interface.
linux/ipmi.h:	/* Place-holder for the data, don't make any assumptions about
linux/ipmi.h:	msg->done(msg);
linux/ipmi.h:	/* Called when the interface detects a watchdog pre-timeout.  If
linux/ipmi.h:   so some initialization code can come in and do the OEM-specific
linux/ipmi.h: * 0, the message will go into a high-priority queue and be sent
linux/ipmi.h: * first.  Otherwise, it goes into a normal-priority queue.
linux/ipmi.h: *   - EFAULT - an address supplied was invalid.
linux/ipmi.h: *   - EINVAL - The address supplied was not valid, or the command
linux/ipmi.h: *   - EMSGSIZE - The message to was too large.
linux/ipmi.h: *   - ENOMEM - Buffers could not be allocated for the command.
linux/ipmi.h: *  - EAGAIN - no messages in the queue.
linux/ipmi.h: *  - EFAULT - an address supplied was invalid.
linux/ipmi.h: *  - EINVAL - The address supplied was not valid.
linux/ipmi.h: *  - EMSGSIZE - The message to was too large to fit into the message buffer,
linux/ipmi.h: *   - EFAULT - an address supplied was invalid.
linux/ipmi.h: *   - EBUSY - The netfn/cmd supplied was already in use.
linux/ipmi.h: *   - ENOMEM - could not allocate memory for the entry.
linux/ipmi.h: *  - EFAULT - an address supplied was invalid.
linux/ipmi.h: *  - ENOENT - The netfn/cmd was not found registered for this user.
linux/ipmi.h: *  - EFAULT - an address supplied was invalid.
linux/ipmi.h: * so some initialization code can come in and do the OEM-specific
linux/jffs.h: * JFFS -- Journalling Flash File System, Linux implementation.
linux/jffs.h:/* This is a magic number that every on-flash raw inode begins with.  */
linux/jffs.h:					- 2 * sizeof(__u32) - sizeof(__u8))
linux/jffs.h:				      - sizeof(__u16))
linux/jffs.h:				       - sizeof(__u16) - sizeof(__u16) \
linux/jffs.h:				       - sizeof(__u32))
linux/jffs.h:	char *name;   /* The name of this file; NULL-terminated.  */
linux/ipv6.h:#define ipv6_optlen(p)  (((p)->hdrlen+1) << 3)
linux/ipv6.h:   as offsets from skb->nh.
linux/wavefront.h: * Copyright (C) by Paul Barton-Davis 1998
linux/wavefront.h:     of 22 bytes, corresponding to 16-bit alignment (as would have been
linux/wavefront.h:     the case on the original platform, MS-DOS). If this is not done,
linux/wavefront.h:     then WavePatch-format files cannot be read/written correctly.
linux/wavefront.h:   between a 16-bit view of the world and a 32-bit one. 
linux/wavefront.h:/* Pseudo-commands not part of the WaveFront command set.
linux/wavefront.h:/* OR-values for MIDI status bits */
linux/wavefront.h:#define WF_SAMPLE_IS_8BIT(smpl) ((smpl)->SampleResolution&2)
linux/wavefront.h:  never been copied (just mmap-ed into user space straight from the
linux/wavefront.h:  disk), it would be nice to allow handling of multi-channel sample
linux/wavefront.h:  data without forcing user-level extraction of the relevant bytes.
linux/wavefront.h:  ---      -------
linux/wavefront.h: (samp)->Unused1 = chn & 0x1; \
linux/wavefront.h: (samp)->Unused2 = chn & 0x2; \
linux/wavefront.h: (samp)->Unused3 = chn & 0x4 
linux/wavefront.h:  (((samp)->Unused3 << 2)|((samp)->Unused2<<1)|(samp)->Unused1)
linux/wavefront.h:       sum(sizeof(struct-fields)) and so thought that giving a C level
linux/wavefront.h:       standard 16->32 bit issues.
linux/wavefront.h:   might work for other wave-table based patch loading situations.
linux/wavefront.h:       only, and are unused by the current user-level library.
linux/wavefront.h:    wavefront_any *hdrptr;      /* user-space ptr to hdr bytes */
linux/wavefront.h:    wavefront_any hdr;          /* kernel-space copy of hdr bytes */         
linux/wavefront.h:   well as data-nybbling to/from the card.
linux/wavefront.h:    char status;                       /* return status to user-space */
linux/wavefront.h:/* FX-related material */
linux/wavefront.h:/* Allow direct user-space control over FX memory/coefficient data.
linux/irda.h: *     provided "AS-IS" and at no charge.
linux/irda.h:/* For user space backward compatibility - may be fixed in kernel 2.5.X
linux/irda.h: * Note : need 60+1 ('\0'), make it 64 for alignement - Jean II */
linux/irda.h:/* No reason to include <linux/if.h> just because of this one ;-) */
linux/isdn.h: * Copyright 1995,96    by Michael Hipp (Michael.Hipp@student.uni-tuebingen.de)
linux/isdn.h:/* New ioctl-codes */
linux/isdn.h:#define IIOCNETDWRSET  _IO('I',24) /* dwabc ioctl to reset abc-values to default on a net-interface */
linux/isdn.h:/* Packet encapsulations for net-interfaces */
linux/isdn.h:#define ISDN_NET_ENCAP_X25IFACE   7 /* Documentation/networking/x25-iface.txt*/
linux/isdn.h:/* Facility which currently uses an ISDN-channel */
linux/isdn.h:#define ISDN_MODEM_NUMREG    24        /* Number of Modem-Registers        */
linux/isdn.h:#define ISDN_LMSNLEN         255 /* Length of tty's Listen-MSN string */
linux/isdn.h:#define ISDN_CMSGLEN	     50	 /* Length of CONNECT-Message to add for Modem */
linux/isdn.h:  int  onhtime;      /* Hangup-Timeout                        */
linux/isdn.h:  int  charge;       /* Charge-Units                          */
linux/isdn.h:  int  l2_proto;     /* Layer-2 protocol                      */
linux/isdn.h:  int  l3_proto;     /* Layer-3 protocol                      */
linux/isdn.h:  int  dialmax;      /* Dial Retry-Counter                    */
linux/isdn.h:  int  chargehup;    /* Flag: Charge-Hangup                   */
linux/isdn.h:  int  ihup;         /* Flag: Hangup-Timeout on incoming line */
linux/isdn.h:  int  dialtimeout;  /* Dial-Timeout                          */
linux/isdn.h:#define ISDN_NET_DIALMODE(x) ((&(x))->flags & ISDN_NET_DIALMODE_MASK)
linux/isdn.h:/* The minor-devicenumbers for Channel 0 and 1 are used as arguments for
linux/isdn.h: * physical Channel-Mapping, so they MUST NOT be changed without changing
linux/isdn.h:#define ISDN_MINOR_BMAX     (ISDN_MAX_CHANNELS-1)
linux/isdn.h:#define ISDN_MINOR_CTRLMAX  (64 + (ISDN_MAX_CHANNELS-1))
linux/isdn.h:#define ISDN_MINOR_PPPMAX   (128 + (ISDN_MAX_CHANNELS-1))
linux/isdn.h:#define ISDN_DRVIOCTL_MASK       0x7f  /* Mask for Device-ioctl */
linux/isdn.h:/* Timer-delays and scheduling-flags */
linux/isdn.h:#define ISDN_TIMER_RES         4                         /* Main Timer-Resolution   */
linux/isdn.h:#define ISDN_TIMER_02SEC       (HZ/ISDN_TIMER_RES/5)     /* Slow-Timer1 .2 sec      */
linux/isdn.h:#define ISDN_TIMER_1SEC        (HZ/ISDN_TIMER_RES)       /* Slow-Timer2 1 sec       */
linux/isdn.h:#define ISDN_TIMER_KEEPINT    10 /* Cisco-Keepalive = ISDN_TIMER_1SEC * this factor */
linux/isdn.h:/* Timeout-Values for isdn_net_dial() */
linux/isdn.h:/*=================== Start of ip-over-ISDN stuff =========================*/
linux/isdn.h:/* Feature- and status-flags for a net-interface */
linux/isdn.h:#define ISDN_NET_CONNECTED  0x01       /* Bound to ISDN-Channel             */
linux/isdn.h:#define ISDN_NET_MAGIC      0x49344C02 /* for paranoia-checking             */
linux/isdn.h:/* Phone-list-element */
linux/isdn.h:   - Stuff which is hardware specific (here i4l-specific) goes in 
linux/isdn.h:     the netdev -> local structure (here: isdn_net_local)
linux/isdn.h:   - Stuff which is encapsulation protocol specific goes in the structure
linux/isdn.h:/* Local interface-data */
linux/isdn.h:  int                    isdn_device;  /* Index to isdn-device             */
linux/isdn.h:  int                    isdn_channel; /* Index to isdn-channel            */
linux/isdn.h:  int                    pre_device;   /* Preselected isdn-device          */
linux/isdn.h:  int                    pre_channel;  /* Preselected isdn-channel         */
linux/isdn.h:  int                    exclusive;    /* If non-zero idx to reserved chan.*/
linux/isdn.h:  int                    flags;        /* Connection-flags                 */
linux/isdn.h:  int                    dialretry;    /* Counter for Dialout-retries      */
linux/isdn.h:  int                    dialmax;      /* Max. Number of Dial-retries      */
linux/isdn.h:  int                    dtimer;       /* Timeout-counter for dialing      */
linux/isdn.h:				       /*   1 = RAW-IP                     */
linux/isdn.h:  u_char                 l2_proto;     /* Layer-2-protocol                 */
linux/isdn.h:				       /* See ISDN_PROTO_L2..-constants in */
linux/isdn.h:                                       /*   0 = X75/LAPB with I-Frames     */
linux/isdn.h:				       /*   1 = X75/LAPB with UI-Frames    */
linux/isdn.h:				       /*   2 = X75/LAPB with BUI-Frames   */
linux/isdn.h:  u_char                 l3_proto;     /* Layer-3-protocol                 */
linux/isdn.h:				       /* See ISDN_PROTO_L3..-constants in */
linux/isdn.h:  int                    huptimer;     /* Timeout-counter for auto-hangup  */
linux/isdn.h:  int                    hupflags;     /* Flags for charge-unit-hangup:    */
linux/isdn.h:				       /* bit1: Getting charge-interval    */
linux/isdn.h:                                       /* bit2: Do charge-unit-hangup      */
linux/isdn.h:  int                    chargeint;    /* Interval between charge-infos    */
linux/isdn.h:  int                    transcount;   /* byte-counter for cps-calculation */
linux/isdn.h:  int                    sqfull;       /* Flag: netdev-queue overloaded    */
linux/isdn.h:  ulong                  sqfull_stamp; /* Start-Time of overload           */
linux/isdn.h:  isdn_net_phone         *phone[2];    /* List of remote-phonenumbers      */
linux/isdn.h:  ulong					dialstarted;	/* jiffies of first dialing-attempt */
linux/isdn.h:  ulong					dialwait_timer;	/* jiffies of earliest next dialing-attempt */
linux/isdn.h:  void *next;                          /* Pointer to next isdn-interface   */
linux/isdn.h:   			         * with the per-bundle data */
linux/isdn.h:/*===================== End of ip-over-ISDN stuff ===========================*/
linux/isdn.h:/*======================= Start of ISDN-tty stuff ===========================*/
linux/isdn.h:#define ISDN_ASYNC_MAGIC          0x49344C01 /* for paranoia-checking        */
linux/isdn.h: * and put it always at skb->head. A few macros help accessing the
linux/isdn.h:#define ISDN_AUDIO_SKB_DLECOUNT(skb) (((isdn_audio_skb*)skb->head)->dle_count)
linux/isdn.h:#define ISDN_AUDIO_SKB_LOCK(skb) (((isdn_audio_skb*)skb->head)->lock)
linux/isdn.h:/* Private data of AT-command-interpreter */
linux/isdn.h:	u_char       profile[ISDN_MODEM_NUMREG]; /* Modem-Regs. Profile 0              */
linux/isdn.h:	u_char       mdmreg[ISDN_MODEM_NUMREG];  /* Modem-Registers                    */
linux/isdn.h:	char         connmsg[ISDN_CMSGLEN];	 /* CONNECT-Msg from HL-Driver	       */
linux/isdn.h:	u_char       vpar[10];                   /* Voice-parameters                   */
linux/isdn.h:	int          lastDLE;                    /* Flag for voice-coding: DLE seen    */
linux/isdn.h:	int          mdmcmdl;                    /* Length of Modem-Commandbuffer      */
linux/isdn.h:	char         mdmcmd[255];                /* Modem-Commandbuffer                */
linux/isdn.h:  int                   online;          /* 1 = B-Channel is up, drop data */
linux/isdn.h:					 /* 2 = B-Channel is up, deliver d.*/
linux/isdn.h:  int                   isdn_driver;	 /* Index to isdn-driver           */
linux/isdn.h:  int                   isdn_channel;    /* Index to isdn-channel          */
linux/isdn.h:  int                   drv_index;       /* Index to dev->usage            */
linux/isdn.h:	                                 /* Last phone-number              */
linux/isdn.h:  unsigned char         last_l2;         /* Last layer-2 protocol          */
linux/isdn.h:  int                   send_outstanding;/* # of outstanding send-requests */
linux/isdn.h:  int                   vonline;         /* Voice-channel status           */
linux/isdn.h:					 /* Bit 2 = playback, DLE-ETX seen */
linux/isdn.h:  int			faxonline;	 /* Fax-channel status             */
linux/isdn.h:  atemu                 emu;             /* AT-emulator data               */
linux/isdn.h:/* Description of one ISDN-tty */
linux/isdn.h:  struct tty_driver  tty_modem;			   /* tty-device             */
linux/isdn.h:  struct tty_driver  cua_modem;			   /* cua-device             */
linux/isdn.h:/*======================= End of ISDN-tty stuff ============================*/
linux/isdn.h:	int nbytes;                    /* 1 Matrixbyte -> nbytes in stream     */
linux/isdn.h:/* Description of hardware-level-driver */
linux/isdn.h:	ulong               online;           /* Channel-Online flags             */
linux/isdn.h:	wait_queue_head_t   st_waitq;         /* Wait-Queue for status-read's     */
linux/isdn.h:	int                 stavail;          /* Chars avail on Status-device     */
linux/isdn.h:	int                *rcverr;           /* Error-counters for B-Ch.-receive */
linux/isdn.h:	int                *rcvcount;         /* Byte-counters for B-Ch.-receive  */
linux/isdn.h:	struct sk_buff_head *rpqueue;         /* Pointers to start of Rcv-Queue   */
linux/isdn.h:	wait_queue_head_t  *rcv_waitq;       /* Wait-Queues for B-Channel-Reads  */
linux/isdn.h:	wait_queue_head_t  *snd_waitq;       /* Wait-Queue for B-Channel-Send's  */
linux/isdn.h:	char               msn2eaz[10][ISDN_MSNLEN];  /* Mapping-Table MSN->EAZ   */
linux/isdn.h:/* Main driver-data */
linux/isdn.h:	int               net_verbose;               /* Verbose-Flag               */
linux/isdn.h:	int               modempoll;		       /* Flag: tty-read active      */
linux/isdn.h:	int               tflags;                    /* Timer-Flags:               */
linux/isdn.h:	infostruct        *infochain;                /* List of open info-devs.    */
linux/isdn.h:	wait_queue_head_t info_waitq;               /* Wait-Queue for isdninfo    */
linux/isdn.h:	struct timer_list timer;		       /* Misc.-function Timer       */
linux/isdn.h:	int               chanmap[ISDN_MAX_CHANNELS];/* Map minor->device-channel  */
linux/isdn.h:	int               drvmap[ISDN_MAX_CHANNELS]; /* Map minor->driver-index    */
linux/isdn.h:	isdn_net_dev      *netdev;		       /* Linked list of net-if's    */
linux/isdn.h:	char              drvid[ISDN_MAX_DRIVERS][20];/* Driver-ID                 */
linux/isdn.h:	modem             mdm;		       /* tty-driver-data            */
linux/isdn.h:	isdn_net_dev      *rx_netdev[ISDN_MAX_CHANNELS]; /* rx netdev-pointers     */
linux/isdn.h:	isdn_net_dev      *st_netdev[ISDN_MAX_CHANNELS]; /* stat netdev-pointers   */
linux/isdn.h:	int               v110emu[ISDN_MAX_CHANNELS];/* V.110 emulator-mode 0=none */
linux/isdn.h:	atomic_t          v110use[ISDN_MAX_CHANNELS];/* Usage-Semaphore for stream */
linux/netfilter_decnet.h:/* DECnet-specific defines for netfilter. 
linux/netfilter_decnet.h: * (C)1998 Rusty Russell -- This code is GPL.
linux/netfilter_decnet.h:	NF_DN_PRI_CONNTRACK = -200,
linux/netfilter_decnet.h:	NF_DN_PRI_MANGLE = -150,
linux/netfilter_decnet.h:	NF_DN_PRI_NAT_DST = -100,
linux/kernelcapi.h: * (c) Copyright 1997 by Carsten Paeth (calle@calle.in-berlin.de)
linux/if_arp.h: * Authors:	Original taken from Berkeley UNIX 4.3, (c) UCB 1986-1988
linux/if_arp.h:#define	ARPHRD_IEEE1394	24		/* IEEE 1394 IPv4 - RFC 2734	*/
linux/if_arp.h:#define ARPHRD_EUI64	27		/* EUI-64                       */
linux/if_arp.h:#define ARPHRD_SIT	776		/* sit0 device - IPv6-in-IPv4	*/
linux/if_arp.h:#define ARPHRD_IRDA 	783		/* Linux-IrDA			*/
linux/if_arp.h:	/* 787->799 reserved for fibrechannel media types */
linux/i2c-dev.h:    i2c-dev.h - i2c-bus driver, char device interface
linux/i2c-dev.h:    Copyright (C) 1995-97 Simon G. Vogl
linux/i2c-dev.h:    Copyright (C) 1998-99 Frodo Looijaard <frodol@dds.nl>
linux/i2c-dev.h:/* $Id: ack,v 1.1.1.1 2006-10-13 02:42:37 steven Exp $ */
linux/i2c-dev.h:/* Note: 10-bit addresses are NOT supported! */
linux/i2c-dev.h:		return -1;
linux/i2c-dev.h:		return -1;
linux/i2c-dev.h:		return -1;
linux/i2c-dev.h:		return -1;
linux/i2c-dev.h:		return -1;
linux/i2c-dev.h:			values[i-1] = data.block[i];
linux/i2c-dev.h:		data.block[i] = values[i-1];
linux/i2c-dev.h:		data.block[i] = values[i-1];
linux/intermezzo_fs.h:/* -*- mode: c; c-basic-offset: 8; indent-tabs-mode: nil; -*-
linux/intermezzo_fs.h: *   This file is part of InterMezzo, http://www.inter-mezzo.org.
linux/intermezzo_fs.h:#  define D_MALLOC     16  /* print malloc, de-alloc information */
linux/intermezzo_fs.h:                               __FUNCTION__, __LINE__, current->pid     \
linux/intermezzo_fs.h:               __LINE__, current->pid , ## a);                          \
linux/intermezzo_fs.h:                printk("Process %d entered %s\n", current->pid, __FUNCTION__)
linux/intermezzo_fs.h:                printk("Process %d leaving %s at %d\n", current->pid,   \
linux/intermezzo_fs.h:#  define presto_kmem_dec(ptr, size) presto_kmemory -= (size)
linux/intermezzo_fs.h:#  define presto_vmem_dec(ptr, size) presto_vmemory -= (size)
linux/intermezzo_fs.h:        save->fs = get_fs();
linux/intermezzo_fs.h:        save->pwd = dget(current->fs->pwd);
linux/intermezzo_fs.h:        save->pwdmnt = mntget(current->fs->pwdmnt);
linux/intermezzo_fs.h:        save->fsgid = current->fsgid;
linux/intermezzo_fs.h:        save->fsuid = current->fsuid;
linux/intermezzo_fs.h:        save->root = current->fs->root;
linux/intermezzo_fs.h:        save->rootmnt = current->fs->rootmnt;
linux/intermezzo_fs.h:        save->ngroups = current->ngroups;
linux/intermezzo_fs.h:        for (i = 0; i< current->ngroups; i++) 
linux/intermezzo_fs.h:                save->groups[i] = current->groups[i];
linux/intermezzo_fs.h:        set_fs(new->fs);
linux/intermezzo_fs.h:        set_fs_pwd(current->fs, new->pwdmnt, new->pwd);
linux/intermezzo_fs.h:        if (new->root)
linux/intermezzo_fs.h:                set_fs_root(current->fs, new->rootmnt, new->root);
linux/intermezzo_fs.h:        current->fsuid = new->fsuid;
linux/intermezzo_fs.h:        current->fsgid = new->fsgid;
linux/intermezzo_fs.h:        if (new->ngroups > 0) {
linux/intermezzo_fs.h:                current->ngroups = new->ngroups;
linux/intermezzo_fs.h:                for (i = 0; i< new->ngroups; i++) 
linux/intermezzo_fs.h:                        current->groups[i] = new->groups[i];
linux/intermezzo_fs.h:        set_fs(saved->fs);
linux/intermezzo_fs.h:        set_fs_pwd(current->fs, saved->pwdmnt, saved->pwd);
linux/intermezzo_fs.h:        if (saved->root)
linux/intermezzo_fs.h:                set_fs_root(current->fs, saved->rootmnt, saved->root);
linux/intermezzo_fs.h:        current->fsuid = saved->fsuid;
linux/intermezzo_fs.h:        current->fsgid = saved->fsgid;
linux/intermezzo_fs.h:        current->ngroups = saved->ngroups;
linux/intermezzo_fs.h:        for (i = 0; i< saved->ngroups; i++) 
linux/intermezzo_fs.h:                current->groups[i] = saved->groups[i];
linux/intermezzo_fs.h:        mntput(saved->pwdmnt);
linux/intermezzo_fs.h:        dput(saved->pwd);
linux/intermezzo_fs.h:        return (struct presto_dentry_data *)(dentry->d_fsdata);
linux/intermezzo_fs.h: * passed around during the KML-writing process. */
linux/intermezzo_fs.h: * corresponding character strings will be truncated anyway. During journalling- * we journal length for both name and value. See journal_set_ext_attr.
linux/intermezzo_fs.h:        return (strlen(name) == dentry->d_name.len &&
linux/intermezzo_fs.h:                memcmp(name, dentry->d_name.name, dentry->d_name.len) == 0);
linux/intermezzo_fs.h:        if (data->ioc_len > (1<<30)) {
linux/intermezzo_fs.h:        if (data->ioc_inllen1 > (1<<30)) {
linux/intermezzo_fs.h:        if (data->ioc_inllen2 > (1<<30)) {
linux/intermezzo_fs.h:        if (data->ioc_inlbuf1 && !data->ioc_inllen1) {
linux/intermezzo_fs.h:        if (data->ioc_inlbuf2 && !data->ioc_inllen2) {
linux/intermezzo_fs.h:        if (data->ioc_pbuf1 && !data->ioc_plen1) {
linux/intermezzo_fs.h:        if (data->ioc_pbuf2 && !data->ioc_plen2) {
linux/intermezzo_fs.h:        if (izo_ioctl_packlen(data) != data->ioc_len ) {
linux/intermezzo_fs.h:        if (data->ioc_inllen1 &&
linux/intermezzo_fs.h:            data->ioc_bulk[data->ioc_inllen1 - 1] != '\0') {
linux/intermezzo_fs.h:        if (data->ioc_inllen2 &&
linux/intermezzo_fs.h:            data->ioc_bulk[size_round(data->ioc_inllen1) + data->ioc_inllen2
linux/intermezzo_fs.h:                           - 1] != '\0') {
linux/intermezzo_fs.h:        if (hdr->ioc_version != IZO_IOCTL_VERSION) {
linux/intermezzo_fs.h:                return -EINVAL;
linux/intermezzo_fs.h:        if (hdr->ioc_len + buf >= end) {
linux/intermezzo_fs.h:                return -EINVAL;
linux/intermezzo_fs.h:        if (hdr->ioc_len < sizeof(struct izo_ioctl_data)) {
linux/intermezzo_fs.h:                return -EINVAL;
linux/intermezzo_fs.h:        err = copy_from_user(buf, (void *)arg, hdr->ioc_len);
linux/intermezzo_fs.h:                return -EINVAL;
linux/intermezzo_fs.h:        if (data->ioc_inllen1) {
linux/intermezzo_fs.h:                data->ioc_inlbuf1 = &data->ioc_bulk[0];
linux/intermezzo_fs.h:        if (data->ioc_inllen2) {
linux/intermezzo_fs.h:                data->ioc_inlbuf2 = &data->ioc_bulk[0] +
linux/intermezzo_fs.h:                        size_round(data->ioc_inllen1);
linux/intermezzo_fs.h:# define MYPATHLEN(buffer, path) ((buffer) + PAGE_SIZE - (path))
linux/intermezzo_fs.h:        data->ioc_len = sizeof(*data);
linux/intermezzo_fs.h:        data->ioc_version = IZO_IOCTL_VERSION;
linux/intermezzo_fs.h:        data->ioc_len = izo_ioctl_packlen(data);
linux/intermezzo_fs.h:        data->ioc_version = IZO_IOCTL_VERSION;
linux/intermezzo_fs.h:                *pbuf = malloc(data->ioc_len);
linux/intermezzo_fs.h:        ptr = overlay->ioc_bulk;
linux/intermezzo_fs.h:        if (data->ioc_inlbuf1)
linux/intermezzo_fs.h:                LOGL(data->ioc_inlbuf1, data->ioc_inllen1, ptr);
linux/intermezzo_fs.h:        if (data->ioc_inlbuf2)
linux/intermezzo_fs.h:                LOGL(data->ioc_inlbuf2, data->ioc_inllen2, ptr);
linux/intermezzo_fs.h:                return strerror(-err);
linux/if_eql.h: * Equalizer Load-balancer for serial network interfaces.
linux/if_eql.h: * (c) Copyright 1995 Simon "Guru Aleph-Null" Janes
linux/if_eql.h: *    Phone: 1-703-847-0040 ext 103
linux/ntfs_fs.h: * Attribute flags (16-bit).
linux/kdev_t.h:the corresponding things are objects of type dev_t - usually an
linux/kdev_t.h:is user-visible. So, it remains a dev_t for the moment, with some ugly
linux/kdev_t.h:minor, size, blocksize, sectorsize, name, read-only flag,
linux/kdev_t.h:- passing it along
linux/kdev_t.h:- comparing it for equality with another such object
linux/kdev_t.h:- storing it in ROOT_DEV, inode->i_dev, inode->i_rdev, sb->s_dev,
linux/kdev_t.h:  bh->b_dev, req->rq_dev, de->dc_dev, tty->device
linux/kdev_t.h:- using its bit pattern as argument in a hash function
linux/kdev_t.h:- finding its major and minor
linux/kdev_t.h:- complaining about it
linux/kdev_t.h:aeb - 950811
linux/kdev_t.h:#define MINORMASK	((1U << MINORBITS) - 1)
linux/video_encoder.h:#define	VIDEO_ENCODER_CCIR	16	/* CCIR-601 pixel rate (720 pixels per line) instead of square pixel rate */
linux/ipv6_route.h:#define RTF_DEFAULT	0x00010000	/* default - learned via ND	*/
linux/ipv6_route.h:#define RTF_ADDRCONF	0x00040000	/* addrconf route - RA		*/
linux/ipv6_route.h:#define RTF_PREFIX_RT	0x00080000	/* A prefix only route - RA	*/
linux/i2c-old.h: * A chip driver can provide a ioctl-like callback for the
linux/i2c-old.h: * write to them, for others they are read-only.
linux/i2c-old.h: * i2c_detach = i2c_attach ** -1
linux/i2c-old.h: * ioctl-line manner.
linux/i2c-old.h: * [-AC-] having a spinlock_irqsave is only needed if we have drivers wishing
linux/i2c-old.h:#  define LOCK_I2C_BUS(bus)    spin_lock_irqsave(&(bus->bus_lock),flags);
linux/i2c-old.h:#  define UNLOCK_I2C_BUS(bus)  spin_unlock_irqrestore(&(bus->bus_lock),flags);
linux/i2c-old.h:#  define LOCK_I2C_BUS(bus)    spin_lock(&(bus->bus_lock));
linux/i2c-old.h:#  define UNLOCK_I2C_BUS(bus)  spin_unlock(&(bus->bus_lock));
linux/i2c-old.h: *	This holds per-device data for a i2c device
linux/i2c-old.h:/* ------------------------------------------------------------------- */
linux/i2c-old.h:/* send a command to a chip using the ioctl-like callback interface */
linux/kmod.h:static inline int request_module(const char * name) { return -ENOSYS; }
linux/if_ppp.h: * if_ppp.h - Point-to-Point Protocol definitions.
linux/if_ppp.h:#define SC_NO_TCP_CCID	0x00000008	/* disable VJ connection-id comp. */
linux/if_ppp.h:#define SC_DC_ERROR	0x00400000	/* non-fatal decomp error detected */
linux/b1pcmcia.h: * Copyright 1999 by Carsten Paeth (calle@calle.in-berlin.de)
linux/if_tun.h: *  Copyright (C) 1999-2000 Maxim Krasnyansky <max_mk@yahoo.com>
linux/if_tun.h:#define DBG  if(tun->debug)printk
linux/list.h: * using the generic single-entry routines.
linux/list.h:	(ptr)->next = (ptr); (ptr)->prev = (ptr); \
linux/list.h:	next->prev = new;
linux/list.h:	new->next = next;
linux/list.h:	new->prev = prev;
linux/list.h:	prev->next = new;
linux/list.h: * list_add - add a new entry
linux/list.h:	__list_add(new, head, head->next);
linux/list.h: * list_add_tail - add a new entry
linux/list.h:	__list_add(new, head->prev, head);
linux/list.h:	next->prev = prev;
linux/list.h:	prev->next = next;
linux/list.h: * list_del - deletes entry from list.
linux/list.h:	__list_del(entry->prev, entry->next);
linux/list.h:	entry->next = (void *) 0;
linux/list.h:	entry->prev = (void *) 0;
linux/list.h: * list_del_init - deletes entry from list and reinitialize it.
linux/list.h:	__list_del(entry->prev, entry->next);
linux/list.h: * list_move - delete from one list and add as another's head
linux/list.h:        __list_del(list->prev, list->next);
linux/list.h: * list_move_tail - delete from one list and add as another's tail
linux/list.h:        __list_del(list->prev, list->next);
linux/list.h: * list_empty - tests whether a list is empty
linux/list.h:	return head->next == head;
linux/list.h:	struct list_head *first = list->next;
linux/list.h:	struct list_head *last = list->prev;
linux/list.h:	struct list_head *at = head->next;
linux/list.h:	first->prev = head;
linux/list.h:	head->next = first;
linux/list.h:	last->next = at;
linux/list.h:	at->prev = last;
linux/list.h: * list_splice - join two lists
linux/list.h: * list_splice_init - join two lists and reinitialise the emptied list.
linux/list.h: * list_entry - get the struct for this entry
linux/list.h:	((type *)((char *)(ptr)-(unsigned long)(&((type *)0)->member)))
linux/list.h: * list_for_each	-	iterate over a list
linux/list.h:	for (pos = (head)->next, prefetch(pos->next); pos != (head); \
linux/list.h:        	pos = pos->next, prefetch(pos->next))
linux/list.h: * list_for_each_prev	-	iterate over a list backwards
linux/list.h:	for (pos = (head)->prev, prefetch(pos->prev); pos != (head); \
linux/list.h:        	pos = pos->prev, prefetch(pos->prev))
linux/list.h: * list_for_each_safe	-	iterate over a list safe against removal of list entry
linux/list.h:	for (pos = (head)->next, n = pos->next; pos != (head); \
linux/list.h:		pos = n, n = pos->next)
linux/list.h: * list_for_each_entry	-	iterate over list of given type
linux/list.h:	for (pos = list_entry((head)->next, typeof(*pos), member),	\
linux/list.h:		     prefetch(pos->member.next);			\
linux/list.h:	     &pos->member != (head); 					\
linux/list.h:	     pos = list_entry(pos->member.next, typeof(*pos), member),	\
linux/list.h:		     prefetch(pos->member.next))
linux/list.h: * list_for_each_entry_safe - iterate over list of given type safe against removal of list entry
linux/list.h:	for (pos = list_entry((head)->next, typeof(*pos), member),	\
linux/list.h:		n = list_entry(pos->member.next, typeof(*pos), member);	\
linux/list.h:	     &pos->member != (head); 					\
linux/list.h:	     pos = n, n = list_entry(n->member.next, typeof(*n), member))
linux/list.h: * list_for_each_entry_continue -       iterate over list of given type
linux/list.h:	for (pos = list_entry(pos->member.next, typeof(*pos), member),	\
linux/list.h:		     prefetch(pos->member.next);			\
linux/list.h:	     &pos->member != (head);					\
linux/list.h:	     pos = list_entry(pos->member.next, typeof(*pos), member),	\
linux/list.h:		     prefetch(pos->member.next))
linux/vt_buffer.h: *	include/linux/vt_buffer.h -- Access to VT screen buffer
linux/vt_buffer.h: *	In most cases the console works with simple in-memory buffer,
linux/vt_buffer.h:	while (count--)
linux/vt_buffer.h:	while (count--)
linux/vt_buffer.h:		while (count--)
linux/vt_buffer.h:			scr_writew(scr_readw(--s), --d);
linux/stallion.h: *	stallion.h  -- stallion multiport serial driver.
linux/stallion.h: *	Copyright (C) 1996-1998  Stallion Technologies
linux/stallion.h: *	Copyright (C) 1994-1996  Greg Ungerer.
linux/stallion.h: *	protection - since "write" code only needs to change the head, and
linux/console_struct.h: * Fields marked with [#] must be set by the low-level driver.
linux/console_struct.h: * Fields marked with [!] can be changed by the low-level driver
linux/console_struct.h:	unsigned short	*vc_screenbuf;		/* In-memory character/attribute buffer */
linux/console_struct.h:	unsigned int	vc_intensity	: 2;	/* 0=half-bright, 1=normal, 2=bold */
linux/console_struct.h:	unsigned char	vc_utf		: 1;	/* Unicode UTF-8 encoding */
linux/console_struct.h:	   to have everything in one place - the disadvantage
linux/console_struct.h:#define CON_IS_VISIBLE(conp) (*conp->vc_display_fg == conp)
linux/loop.h:	if (!lo->transfer)
linux/loop.h:	return lo->transfer(lo, cmd, rbuf, lbuf, size, rblock);
linux/loop.h: * IOCTL commands --- we will commandeer 0x4C ('L')
linux/isicom.h:	struct isi_board * card = port->card;
linux/isicom.h:	unsigned short base = card->base;
linux/isicom.h:	unsigned char channel = port->channel;
linux/isicom.h:	while(((inw(base+0x0e) & 0x01) == 0) && (wait-- > 0));
linux/isicom.h:	outw(0x8000 | (channel << card->shift_count) | 0x02 , base);
linux/isicom.h:	port->status |= ISI_DTR;
linux/isicom.h:	struct isi_board * card = port->card;
linux/isicom.h:	unsigned short base = card->base;
linux/isicom.h:	unsigned char channel = port->channel;
linux/isicom.h:	while(((inw(base+0x0e) & 0x01) == 0) && (wait-- > 0));
linux/isicom.h:	outw(0x8000 | (channel << card->shift_count) | 0x02 , base);
linux/isicom.h:	port->status &= ~ISI_DTR;
linux/isicom.h:	struct isi_board * card = port->card;
linux/isicom.h:	unsigned short base = card->base;
linux/isicom.h:	unsigned char channel = port->channel;
linux/isicom.h:	while(((inw(base+0x0e) & 0x01) == 0) && (wait-- > 0));
linux/isicom.h:	outw(0x8000 | (channel << card->shift_count) | 0x02 , base);
linux/isicom.h:	port->status |= ISI_RTS;
linux/isicom.h:	struct isi_board * card = port->card;
linux/isicom.h:	unsigned short base = card->base;
linux/isicom.h:	unsigned char channel = port->channel;
linux/isicom.h:	while(((inw(base+0x0e) & 0x01) == 0) && (wait-- > 0));
linux/isicom.h:	outw(0x8000 | (channel << card->shift_count) | 0x02 , base);
linux/isicom.h:	port->status &= ~ISI_RTS;
linux/isicom.h:	struct isi_board * card = port->card;
linux/isicom.h:	unsigned short base = card->base;
linux/isicom.h:	unsigned char channel = port->channel;
linux/isicom.h:	while(((inw(base+0x0e) & 0x01) == 0) && (wait-- > 0));
linux/isicom.h:	outw(0x8000 | (channel << card->shift_count) | 0x02 , base);
linux/isicom.h:	port->status |= (ISI_DTR | ISI_RTS);
linux/isicom.h:	struct isi_board * card = port->card;
linux/isicom.h:	unsigned short base = card->base;
linux/isicom.h:	unsigned char channel = port->channel;
linux/isicom.h:	while(((inw(base+0x0e) & 0x01) == 0) && (wait-- > 0));
linux/isicom.h:	outw(0x8000 | (channel << card->shift_count) | 0x02 , base);
linux/isicom.h:	port->status &= ~(ISI_RTS | ISI_DTR);
linux/isicom.h:	struct isi_board * card = port->card;
linux/isicom.h:	unsigned short base = card->base;
linux/isicom.h:	unsigned char channel = port->channel;
linux/isicom.h:	while(((inw(base+0x0e) & 0x01) == 0) && (wait-- > 0));
linux/isicom.h:	outw(0x8000 | (channel << card->shift_count) | 0x02 , base);
linux/meye.h: * Copyright (C) 2001-2003 Stelian Pop <stelian@popies.net>
linux/meye.h: * Copyright (C) 2001-2002 Alcve <www.alcove.com>
linux/meye.h: * bttv-driver.c and zoran.c, see original files for credits.
linux/msdos_fs_i.h: * MS-DOS file system inode data in memory
linux/msdos_fs_i.h:	loff_t i_pos;	/* on-disk position of directory entry or 0 */
linux/minix_fs_sb.h: * minix super-block data in memory
linux/hfs_fs_i.h: * The HFS-specific part of a Linux (struct inode)
linux/trdevice.h: *		Definitions for the Token-ring handlers.
linux/posix_types.h: * <sys/time.h> (and thus <linux/time.h>) - but this is a more logical
linux/nfs2.h:#define NFS2_FIFO_DEV	(-1)
linux/nfs2.h:/* NFSv2 file types - beware, these are not the same in NFSv3 */
linux/nfs3.h:#define NFS3_FIFO_DEV		(-1)
linux/mtio.h: * by C.-J. Heine.
linux/mtio.h:/* structure for MTIOCTOP - mag tape op command */
linux/mtio.h:#define MTWEOF	5	/* write an end-of-file record (mark) */
linux/mtio.h:#define MTERASE 13	/* erase tape -- be careful! */
linux/mtio.h:#define MTSETDRVBUFFER 24 /* set the drive buffering according to SCSI-2 */
linux/mtio.h:/* structure for MTIOCGET - mag tape get status command */
linux/mtio.h:#define MT_ISQIC02		0x02	/* Generic QIC-02 tape streamer */
linux/mtio.h:#define MT_ISWT5150		0x03	/* Wangtek 5150EQ, QIC-150, QIC-02 */
linux/mtio.h:#define MT_ISARCHIVE_5945L2	0x04	/* Archive 5945L-2, QIC-24, QIC-02? */
linux/mtio.h:#define MT_ISCMSJ500		0x05	/* CMS Jumbo 500 (QIC-02?) */
linux/mtio.h:#define MT_ISTDC3610		0x06	/* Tandberg 6310, QIC-24 */
linux/mtio.h:#define MT_ISARCHIVE_VP60I	0x07	/* Archive VP60i, QIC-02 */
linux/mtio.h:#define MT_ISARCHIVESC499	0x0A	/* Archive SC-499 QIC-36 controller */
linux/mtio.h:#define MT_ISQIC02_ALL_FEATURES	0x0F	/* Generic QIC-02 with all features */
linux/mtio.h:#define MT_ISWT5099EEN24	0x11	/* Wangtek 5099-een24, 60MB, QIC-24 */
linux/mtio.h:#define MT_ISTEAC_MT2ST		0x12	/* Teac MT-2ST 155mb drive, Teac DC-1 card (Wangtek type) */
linux/mtio.h:#define MT_ISEVEREX_FT40A	0x32	/* Everex FT40A (QIC-40) */
linux/mtio.h:#define MT_ISONSTREAM_SC        0x61   /* OnStream SCSI tape drives (SC-x0)
linux/mtio.h:#define MT_ISSCSI1		0x71	/* Generic ANSI SCSI-1 tape unit */
linux/mtio.h:#define MT_ISSCSI2		0x72	/* Generic ANSI SCSI-2 tape unit */
linux/mtio.h:/* QIC-40/80/3010/3020 ftape supported drives.
linux/mtio.h: * 20bit vendor ID + 0x800000 (see ftape-vendors.h)
linux/mtio.h:	{MT_ISQIC02,		"Generic QIC-02 tape streamer"}, \
linux/mtio.h:	{MT_ISWT5150,		"Wangtek 5150, QIC-150"}, \
linux/mtio.h:	{MT_ISARCHIVE_5945L2,	"Archive 5945L-2"}, \
linux/mtio.h:	{MT_ISTDC3610,		"Tandberg TDC 3610, QIC-24"}, \
linux/mtio.h:	{MT_ISARCHIVE_VP60I,	"Archive VP60i, QIC-02"}, \
linux/mtio.h:	{MT_ISARCHIVESC499,	"Archive SC-499 QIC-36 controller"}, \
linux/mtio.h:	{MT_ISQIC02_ALL_FEATURES, "Generic QIC-02 tape, all features"}, \
linux/mtio.h:	{MT_ISWT5099EEN24,	"Wangtek 5099-een24, 60MB"}, \
linux/mtio.h:	{MT_ISTEAC_MT2ST,	"Teac MT-2ST 155mb data cassette drive"}, \
linux/mtio.h:	{MT_ISEVEREX_FT40A,	"Everex FT40A, QIC-40"}, \
linux/mtio.h:	{MT_ISONSTREAM_SC,      "OnStream SC-, DI-, DP-, or USB tape drive"}, \
linux/mtio.h:	{MT_ISSCSI1,		"Generic SCSI-1 tape"}, \
linux/mtio.h:	{MT_ISSCSI2,		"Generic SCSI-2 tape"}, \
linux/mtio.h:/* structure for MTIOCPOS - mag tape get position command */
linux/mtio.h: * as an interim solution for QIC-02 until DDI is fully implemented.
linux/mtio.h:	unsigned int mt_volno;   /* vol-number */
linux/mtio.h:	unsigned char  ft_qicstd;   /* QIC-40/QIC-80/QIC-3010/QIC-3020 */
linux/mtio.h:/* The next two are used by the QIC-02 driver for runtime reconfiguration.
linux/mtio.h:#define MTIOCFTCMD	_IOWR('m', 11, struct mtftcmd) /* send QIC-117 cmd */
linux/mtio.h: * mt_gstat -- HP-UX compatible.
linux/mtio.h:/* SCSI-tape specific definitions */
linux/mtio.h:/* The mode parameters to be controlled. Parameter chosen with bits 20-28 */
linux/journal-head.h: * include/linux/journal-head.h
linux/journal-head.h: *	Created - pulled out of fs.h
linux/journal-head.h:	/* Reference count - see description in journal.c */
linux/journal-head.h:	/* Doubly-linked list of buffers on a transaction's data,
linux/journal-head.h:	 * Doubly-linked list of buffers still remaining to be flushed
linux/byteorder/pdp_endian.h: * Could have been named NUXI-endian, but we use the same name as in glibc.
linux/byteorder/pdp_endian.h: * little-endian is 1234; big-endian is 4321; nuxi/pdp-endian is 3412
linux/byteorder/pdp_endian.h: * I thought vaxen were NUXI-endian, but was told they were correct-endian
linux/byteorder/pdp_endian.h: * (little-endian), though indeed there existed NUXI-endian machines
linux/byteorder/pdp_endian.h: * (DEC PDP-11 and old VAXen in compatibility mode).
linux/byteorder/pdp_endian.h: * This makes this file a bit useless, but as a proof-of-concept.
linux/byteorder/pdp_endian.h: * I don't dare imagine! Hence, no 64-bit byteorder support yet.
linux/byteorder/pdp_endian.h: * Hopefully, there 64-bit pdp-endian support shouldn't ever be required.
linux/byteorder/swabb.h: * Support for obNUXIous pdp-endian and other bizarre architectures.
linux/byteorder/swabb.h: * swahw32	swap 16-bit half-words in a 32-bit word
linux/byteorder/swabb.h: * swahb32	swap 8-bit halves of each 16-bit half-word in a 32-bit word
linux/byteorder/swabb.h: * No 64-bit support yet. I don't know NUXI conventions for long longs.
linux/byteorder/swabb.h: * I guarantee it will be a mess when it's there, though :->
linux/byteorder/swabb.h: * It will be even worse if there are conflicting 64-bit conventions.
linux/byteorder/swabb.h: * Hopefully, no one ever used 64-bit objects on NUXI machines.
linux/byteorder/swabb.h: * provide defaults when no architecture-specific optimization is detected
linux/byteorder/generic.h: * Generic Byte-reordering support
linux/byteorder/generic.h: * Francois-Rene Rideau <fare@tunes.org> 19970707
linux/byteorder/generic.h: *    gathered all the good ideas from all asm-foo/byteorder.h into one file,
linux/byteorder/generic.h: *    I hope it is compliant with non-GCC compilers.
linux/byteorder/generic.h: * Francois-Rene Rideau <fare@tunes.org> 19971012
linux/byteorder/generic.h: * Francois-Rene Rideau <fare@tunes.org> 19971205
linux/byteorder/generic.h: * Conversion of XX-bit integers (16- 32- or 64-)
linux/byteorder/generic.h: * 64-bit stuff only defined for proper architectures
linux/byteorder/generic.h: * See asm-foo/byteorder.h for examples of how to provide
linux/byteorder/generic.h: * architecture-optimized versions
linux/byteorder/generic.h: * issues - like we want to give the prototype even though we
linux/byteorder/generic.h: * long is often 64-bit these days.. Thus the casts.
linux/byteorder/generic.h: * correctly - if the argument passed into a inline function
linux/byteorder/swab.h: * Byte-swapping, independently from CPU endianness
linux/byteorder/swab.h: * Francois-Rene Rideau <fare@tunes.org> 19971205
linux/byteorder/swab.h: *    to clean up support for bizarre-endian architectures.
linux/byteorder/swab.h: * See asm-i386/byteorder.h and suches for examples of how to provide
linux/byteorder/swab.h: * architecture-dependent optimized versions
linux/byteorder/swab.h: * provide defaults when no architecture-specific optimization is detected
linux/byteorder/swab.h:        __u32 l = x & ((1ULL<<32)-1);
linux/ppp_defs.h: * ppp_defs.h - PPP definitions.
linux/ppp_defs.h:#define	PPP_ALLSTATIONS	0xff	/* All-Stations broadcast address */
linux/ppp_defs.h: * Extended asyncmap - allows any character to be escaped.
linux/udf_fs.h: *  OSTA-UDF(tm) = Optical Storage Technology Association
linux/udf_fs.h: *	E-mail regarding any portion of the Linux UDF file system should be
linux/udf_fs.h: *  (C) 1999-2000 Ben Fennema
linux/udf_fs.h: *  (C) 1999-2000 Stelias Computing Inc
linux/udf_fs.h:		printk (KERN_DEBUG "UDF-fs DEBUG %s:%d:%s: ", \
linux/udf_fs.h:		printk (KERN_INFO "UDF-fs INFO " f, ##a);
linux/agpgart.h:	long access_flags;	/* long req'd for set_bit --RR */
linux/video_decoder.h:#define	VIDEO_DECODER_CCIR	16	/* CCIR-601 pixel rate (720 pixels per line) instead of square pixel rate */
linux/efs_dir.h:#define EFS_DENTSIZE	(sizeof(struct efs_dentry) - 3 + 1)
linux/efs_dir.h:#define EFS_MAXNAMELEN  ((1 << (sizeof(char) * 8)) - 1)
linux/efs_dir.h:	unsigned char	space[EFS_DIRBSIZE - EFS_DIRBLK_HEADERSIZE];
linux/efs_dir.h:	((EFS_DIRBSIZE - EFS_DIRBLK_HEADERSIZE) / \
linux/efs_dir.h:#define EFS_SLOTAT(dir, slot) EFS_REALOFF((dir)->space[slot])
linux/hdreg.h: * This file contains some defines for the AT-hd-controller.
linux/hdreg.h:/* Hd controller regs. Ref: IBM AT Bios-listing */
linux/hdreg.h:#define HD_ERROR	0x1f1		/* see err-bits */
linux/hdreg.h:#define HD_STATUS	0x1f7		/* see status-bits */
linux/hdreg.h:#define HD_PRECOMP	HD_FEATURE	/* obsolete use of this port - predates IDE */
linux/hdreg.h:/* remainder is shared between hd.c, ide.c, ide-cd.c, and the hdparm utility */
linux/hdreg.h:#define BBD_ERR			0x80	/* pre-EIDE meaning:  block marked bad */
linux/hdreg.h:#define IDE_DRIVE_TASK_INVALID		-1
linux/hdreg.h: *	0x01->0x02 Reserved
linux/hdreg.h: *	0x04->0x07 Reserved
linux/hdreg.h: *	0x09->0x0F Reserved
linux/hdreg.h: *	0x10->0x1F Reserved
linux/hdreg.h:#define WIN_READ			0x20 /* 28-Bit */
linux/hdreg.h:#define WIN_READ_ONCE			0x21 /* 28-Bit without retries */
linux/hdreg.h:#define WIN_READ_LONG			0x22 /* 28-Bit */
linux/hdreg.h:#define WIN_READ_LONG_ONCE		0x23 /* 28-Bit without retries */
linux/hdreg.h:#define WIN_READ_EXT			0x24 /* 48-Bit */
linux/hdreg.h:#define WIN_READDMA_EXT			0x25 /* 48-Bit */
linux/hdreg.h:#define WIN_READDMA_QUEUED_EXT		0x26 /* 48-Bit */
linux/hdreg.h:#define WIN_READ_NATIVE_MAX_EXT		0x27 /* 48-Bit */
linux/hdreg.h:#define WIN_MULTREAD_EXT		0x29 /* 48-Bit */
linux/hdreg.h: *	0x2A->0x2F Reserved
linux/hdreg.h:#define WIN_WRITE			0x30 /* 28-Bit */
linux/hdreg.h:#define WIN_WRITE_ONCE			0x31 /* 28-Bit without retries */
linux/hdreg.h:#define WIN_WRITE_LONG			0x32 /* 28-Bit */
linux/hdreg.h:#define WIN_WRITE_LONG_ONCE		0x33 /* 28-Bit without retries */
linux/hdreg.h:#define WIN_WRITE_EXT			0x34 /* 48-Bit */
linux/hdreg.h:#define WIN_WRITEDMA_EXT		0x35 /* 48-Bit */
linux/hdreg.h:#define WIN_WRITEDMA_QUEUED_EXT		0x36 /* 48-Bit */
linux/hdreg.h:#define WIN_SET_MAX_EXT			0x37 /* 48-Bit */
linux/hdreg.h:#define WIN_MULTWRITE_EXT		0x39 /* 48-Bit */
linux/hdreg.h: *	0x3A->0x3B Reserved
linux/hdreg.h:#define WIN_WRITE_VERIFY		0x3C /* 28-Bit */
linux/hdreg.h: *	0x3D->0x3F Reserved
linux/hdreg.h:#define WIN_VERIFY			0x40 /* 28-Bit - Read Verify Sectors */
linux/hdreg.h:#define WIN_VERIFY_ONCE			0x41 /* 28-Bit - without retries */
linux/hdreg.h:#define WIN_VERIFY_EXT			0x42 /* 48-Bit */
linux/hdreg.h: *	0x43->0x4F Reserved
linux/hdreg.h: *	0x51->0x5F Reserved
linux/hdreg.h: *	0x61->0x5F Reserved
linux/hdreg.h:#define WIN_SEEK			0x70 /* 0x70-0x7F Reserved */
linux/hdreg.h:#define WIN_SMART			0xB0 /* self-monitoring and reporting */
linux/hdreg.h:#define WIN_READDMA_ONCE		0xC9 /* 28-Bit - without retries */
linux/hdreg.h:#define WIN_WRITEDMA_ONCE		0xCB /* 28-Bit - without retries */
linux/hdreg.h:#define WIN_ACKMEDIACHANGE		0xDB /* ATA-1, ATA-2 vendor */
linux/hdreg.h:#define WIN_WRITE_SAME			0xE9 /* read ata-2 to use */
linux/hdreg.h:#define WIN_FLUSH_CACHE_EXT		0xEA /* 48-Bit */
linux/hdreg.h:/* WIN_SMART sub-commands */
linux/hdreg.h:/* WIN_SETFEATURES sub-commands */
linux/hdreg.h:#define SETFEATURES_EN_8BIT	0x01	/* Enable 8-Bit Transfers */
linux/hdreg.h:#define SETFEATURES_EN_SAME_R	0x22	/* for a region ATA-1 */
linux/hdreg.h:#define SETFEATURES_DIS_RLA	0x55	/* Disable read look-ahead feature */
linux/hdreg.h:#define SETFEATURES_DIS_8BIT	0x81	/* Disable 8-Bit Transfers */
linux/hdreg.h:#define SETFEATURES_EN_RLA	0xAA	/* Enable read look-ahead feature */
linux/hdreg.h:#define SETFEATURES_EN_REST	0xAC	/* ATA-1 */
linux/hdreg.h:#define SETFEATURES_EN_SAME_M	0xDD	/* for a entire device ATA-1 */
linux/hdreg.h:/* WIN_SECURITY sub-commands */
linux/hdreg.h:#define HDIO_GET_QDMA		0x0305	/* get use-qdma flag */
linux/hdreg.h:#define HDIO_GET_KEEPSETTINGS	0x0308	/* get keep-settings-on-reset flag */
linux/hdreg.h:#define HDIO_GET_NOWERR		0x030a	/* get ignore-write-error flag */
linux/hdreg.h:#define HDIO_GET_DMA		0x030b	/* get use-dma flag */
linux/hdreg.h:/* hd/ide ctl's that pass (arg) non-ptr values are numbered 0x032n/0x033n */
linux/hdreg.h:#define HDIO_SET_NOWERR		0x0325	/* change ignore-write-error flag */
linux/hdreg.h:#define HDIO_SET_DMA		0x0326	/* change use-dma flag */
linux/hdreg.h:#define HDIO_SET_WCACHE		0x032b	/* change write cache enable-disable */
linux/hdreg.h:#define HDIO_SET_QDMA		0x032e	/* change use-qdma flag */
linux/hdreg.h:					 *  1:	eide_ok		words 64-70
linux/hdreg.h:					 *  0:	cur_ok		words 54-58
linux/hdreg.h:	unsigned short	dma_1word;	/* Obsolete, single-word dma info */
linux/hdreg.h:	unsigned short	dma_mword;	/* multiple-word dma info */
linux/hdreg.h:	unsigned short	words69_70[2];	/* reserved words 69-70
linux/hdreg.h:	unsigned short	words71_74[4];	/* reserved words 71-74
linux/hdreg.h:					 *  4:0	Maximum queue depth -1
linux/hdreg.h:	unsigned short  words76_79[4];	/* reserved words 76-79 */
linux/hdreg.h:					 *  6:	look-ahead
linux/hdreg.h:					 * 10:	48-bit Address Feature Set
linux/hdreg.h:					 *  6:	SetF sub-command Power-Up
linux/hdreg.h:					 *  5:	Power-Up in Standby Feature Set
linux/hdreg.h:					 * cmd set-feature supported extensions
linux/hdreg.h:					 *  1:	SMART selt-test supported
linux/hdreg.h:					 * command set-feature enabled
linux/hdreg.h:					 *  6:	look-ahead
linux/hdreg.h:					 * command set-feature enabled
linux/hdreg.h:					 * 10:	48-bit Address Feature Set
linux/hdreg.h:					 *  6:	SetF sub-command Power-Up
linux/hdreg.h:					 *  5:	Power-Up in Standby Feature Set
linux/hdreg.h:					 * command set-feature default
linux/hdreg.h:					 *  1:	SMART selt-test supported
linux/hdreg.h:	unsigned long long lba_capacity_2;/* 48-bit total number of sectors */
linux/hdreg.h:	unsigned short	words104_125[22];/* reserved words 104-125 */
linux/hdreg.h:					 *  1:	read-look-ahead
linux/hdreg.h:	unsigned short	words130_155[26];/* reserved vendor words 130-155 */
linux/hdreg.h:	unsigned short	words157_159[3];/* reserved vendor words 157-159 */
linux/hdreg.h:	unsigned short	words206_254[49];/* reserved words 206-254 */
linux/bfs_fs.h: *	include/linux/bfs_fs.h - BFS data structures on disk.
linux/bfs_fs.h:/* SVR4 vnode type values (bfs_inode->i_vtype) */
linux/bfs_fs.h:        (((ip)->i_eoffset + 1) - (ip)->i_sblock * BFS_BSIZE)
linux/bfs_fs.h:        ((ip)->i_sblock == 0 ? 0 : BFS_NZFILESIZE(ip))
linux/bfs_fs.h:        ((ip)->i_sblock == 0 ? 0 : ((ip)->i_eblock + 1) - (ip)->i_sblock)
linux/bfs_fs.h:        ((((offset) - BFS_BSIZE) / sizeof(struct bfs_inode)) + BFS_ROOT_INO)
linux/bfs_fs.h:	((__u32)(((ino) - BFS_ROOT_INO) * sizeof(struct bfs_inode)) + BFS_BSIZE)
linux/bfs_fs.h:	((bfs_sb->s_from != -1) && (bfs_sb->s_to != -1) && !(sb->s_flags & MS_RDONLY))
linux/dqblk_v1.h: *	File with in-memory structures of old quota format
linux/seq_file.h:	if (m->count < m->size) {
linux/seq_file.h:		m->buf[m->count++] = c;
linux/seq_file.h:	return -1;
linux/seq_file.h:	if (m->count + len < m->size) {
linux/seq_file.h:		memcpy(m->buf + m->count, s, len);
linux/seq_file.h:		m->count += len;
linux/seq_file.h:	m->count = m->size;
linux/seq_file.h:	return -1;
linux/poll.h:	pt->error = 0;
linux/poll.h:	pt->table = NULL;
linux/poll.h:#define FDS_LONGS(nr)	(((nr)+FDS_BITPERLONG-1)/FDS_BITPERLONG)
linux/poll.h: * Use "unsigned long" accesses to let user-mode fd_set's be long-aligned.
linux/poll.h:			error = -EFAULT;
linux/serial_reg.h:#define UART_LSR_THRE	0x20	/* Transmit-hold-register empty */
linux/serial_reg.h: * Note that for 16650, EFR-bit 4 must be selected as well.
linux/serial_reg.h:#define UART_NMR	0x0D	/* Nine-bit Mode Register */
linux/serial_reg.h: * These definitions are for the RSA-DV II/S card, from
linux/serial_reg.h: * Kiyokazu SUTO <suto@ks-and-ks.ne.jp>
linux/serial_reg.h:#define UART_RSA_BASE (-8)
linux/if_bonding.h: * Portions are (c) Copyright 1995 Simon "Guru Aleph-Null" Janes
linux/if_bonding.h: * 2003/03/18 - Amir Noam <amir.noam at intel dot com>
linux/if_bonding.h: *	- Added support for getting slave's speed and duplex via ethtool.
linux/if_bonding.h: * 2003/03/18 - Tsippy Mendelson <tsippy.mendelson at intel dot com> and
linux/if_bonding.h: *	- Enable support of modes that need to use the unique mac address of
linux/if_bonding.h: * 2003/03/18 - Tsippy Mendelson <tsippy.mendelson at intel dot com> and
linux/if_bonding.h: *	- Moved driver's private data types to bonding.h
linux/if_bonding.h: * 2003/03/18 - Amir Noam <amir.noam at intel dot com>,
linux/if_bonding.h: *	- Added support for IEEE 802.3ad Dynamic link aggregation mode.
linux/if_bonding.h: * 2003/05/01 - Amir Noam <amir.noam at intel dot com>
linux/if_bonding.h: *	- Added ABI version control to restore compatibility between
linux/if_bonding.h: * 2003/12/01 - Shmulik Hen <shmulik.hen at intel dot com>
linux/if_bonding.h: *	- Code cleanup and style changes
linux/if_bonding.h:/* userland - kernel ABI version (2003/05/08) */
linux/if_bonding.h: *  version-control: t
linux/if_bonding.h: *  kept-new-versions: 5
linux/if_bonding.h: *  c-indent-level: 8
linux/if_bonding.h: *  c-basic-offset: 8
linux/if_bonding.h: *  tab-width: 8
linux/netfilter_arp.h:/* ARP-specific defines for netfilter.
linux/netfilter_arp.h: * (C)2002 Rusty Russell IBM -- This code is GPL.
linux/iso_fs.h:#define ISODCL(from, to) (to - from + 1)
linux/iso_fs.h:#define ISOFS_BUFFER_SIZE(INODE) ((INODE)->i_sb->s_blocksize)
linux/iso_fs.h:#define ISOFS_BUFFER_BITS(INODE) ((INODE)->i_sb->s_blocksize_bits)
linux/iso_fs.h:#define ISOFS_ZONE_BITS(INODE)   ((INODE)->i_sb->u.isofs_sb.s_log_zone_size)
linux/netfilter_ddp.h:/* DDP-specific defines for netfilter.  Complete me sometime.
linux/netfilter_ddp.h: * (C)1998 Rusty Russell -- This code is GPL.
linux/sysctl.h: **  --sct
linux/sysctl.h:/* Top-level names: */
linux/sysctl.h:/* For internal pattern-matching use only: */
linux/sysctl.h:#define CTL_ANY		-1	/* Matches any name */
linux/sysctl.h:	KERN_CTLALTDEL=22,	/* int: allow ctl-alt-del to reboot */
linux/sysctl.h: 	KERN_SPARC_STOP_A=44,	/* int: Sparc Stop-A enable */
linux/sysctl.h: 	KERN_CORE_PATTERN=56,	/* string: pattern for core-files */
linux/sysctl.h:	KERN_SPARC_SCONS_PWROFF=64, /* int: serial console power-off halt */
linux/sysctl.h:	NET_PROTO_CONF_ALL=-2,
linux/sysctl.h:	NET_PROTO_CONF_DEFAULT=-3
linux/sysctl.h:/* /proc/sys/net/token-ring */
linux/sysctl.h:	NET_DECNET_CONF_LOOPBACK = -2,
linux/sysctl.h:	NET_DECNET_CONF_DDCMP = -3,
linux/sysctl.h:	NET_DECNET_CONF_PPP = -4,
linux/sysctl.h:	NET_DECNET_CONF_X25 = -5,
linux/sysctl.h:	NET_DECNET_CONF_GRE = -6,
linux/sysctl.h:	NET_DECNET_CONF_ETHER = -7
linux/sysctl.h:	DEV_PARPORT_DEFAULT=-3
linux/sysctl.h:	DEV_PARPORT_DEVICES_ACTIVE=-3,
linux/sysctl.h: * ctl_name terminates the table.  table->de will be set up by the
linux/sysctl.h: * proc-fs access.
linux/sysctl.h: * under /proc; non-leaf nodes will be represented by directories.  A
linux/sysctl.h: * 0:  OK - proceed with automatic read or write.
linux/sysctl.h: * >0: OK - read or write has been done by the strategy routine, so 
linux/sysctl.h: * mirrored under /proc/sys (non-terminals are handled by a built-in
linux/types.h:	(((bits)+BITS_PER_LONG-1)/BITS_PER_LONG)
linux/types.h:/* This is defined by include/asm-{arch}/posix_types.h */
linux/types.h: * when it is included by non-kernel code
linux/types.h: * Below are truly Linux-specific types that should never collide with
linux/sctp.h: * Copyright (c) 1999-2000 Cisco, Inc.
linux/sctp.h: * Copyright (c) 1999-2001 Motorola, Inc.
linux/sctp.h: * the Free Software Foundation, 59 Temple Place - Suite 330,
linux/sctp.h: * Boston, MA 02111-1307, USA.
linux/sctp.h: *    lksctp developers <lksctp-developerst@lists.sourceforge.net>
linux/sctp.h:	/* PR-SCTP Sec 3.2 */
linux/sctp.h: *  Chunk Types are encoded such that the highest-order two bits specify
linux/sctp.h: *     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
linux/sctp.h: *     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
linux/sctp.h:#define sctp_test_T_bit(c)    ((c)->chunk_hdr->flags & SCTP_CHUNK_FLAG_T)
linux/sctp.h: * Section 3.2.1 Optional/Variable-length Parmaeter Format.
linux/sctp.h:	/* PR-SCTP Sec 3.1 */
linux/sctp.h:	/* Add-IP Extension. Section 3.2 */
linux/sctp.h: *  The Parameter Types are encoded such that the highest-order two bits
linux/sctp.h:/* RFC 2960 3.3.10 - Operation Error
linux/sctp.h: *     ---------      ----------------
linux/sctp.h:	 * primarily for use in the ASCONF-ACK chunk.
linux/sctp.h:	 * ---------      ----------------
linux/sctp.h:	 * 0x0103          Association Aborted due to illegal ASCONF-ACK
linux/sctp.h:	 * 0x0104          Request refused - no authorization.
linux/sctp.h:/* PR-SCTP
linux/sctp.h: *      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
linux/sctp.h: *      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
linux/sctp.h: *      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
linux/sctp.h: *      |         Stream-1              |       Stream Sequence-1       |
linux/sctp.h: *      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
linux/sctp.h: *      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
linux/sctp.h: *      |         Stream-N              |       Stream Sequence-N       |
linux/sctp.h: *      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
linux/sctp.h: *      Stream-N: 16 bit u_int
linux/sctp.h: *       FWD-TSN.
linux/sctp.h: *      Stream Sequence-N: 16 bit u_int
linux/sctp.h: *       the FWD-TSN's can use the Stream-N and Stream Sequence-N fields
linux/sctp.h: *       re-ordering queues. This field MUST NOT report TSN's corresponding
linux/sctp.h: *	valid range of Serial Number is from 0 to 2^32-1.
linux/sctp.h: *	Serial Numbers wrap back to 0 after reaching 2^32 -1.
linux/sctp.h: * Section 3.1.2 Address Configuration Acknowledgement Chunk (ASCONF-ACK)
linux/sctp.h: *	The ASCONF Parameter Response is used in the ASCONF-ACK to
linux/sdla.h:#define SDLA_UNKNOWN			-1
linux/sdla.h:#define SDLA_MAX_MTU			4072	/* MAX_DATA - sizeof(fradhdr) */
linux/netfilter_ipx.h:/* IPX-specific defines for netfilter.  Complete me sometime.
linux/netfilter_ipx.h: * (C)1998 Rusty Russell -- This code is GPL.
linux/n_r3964.h: * -----------------------------------------------------------
linux/n_r3964.h: * http://www.pap-philips.de
linux/n_r3964.h: * -----------------------------------------------------------
linux/n_r3964.h: * Ioctl-commands
linux/n_r3964.h: * All open file-handles are 'clients' and are stored in a linked list:
linux/n_r3964.h:#define R3964_TX_FAIL -1  /* transmission error, block NOT sent */
linux/n_r3964.h:#define R3964_OVERFLOW -2 /* msg queue overflow */
linux/n_r3964.h: * we will reject all incoming STX-requests by sending NAK.
linux/netfilter_x25.h:/* X25-specific defines for netfilter.  Complete me sometime.
linux/netfilter_x25.h: * (C)1998 Rusty Russell -- This code is GPL.
linux/smb_fs.h: *  Copyright (C) 1995 by Paal-Kr. Engstad and Volker Lendecke
linux/smb_fs.h:/* macro names are short for word, double-word, long value (?) */
linux/smb_fs.h:        smb_current_vmalloced -= 1;
linux/smb_fs.h:	smb_current_kmalloced -= 1;
linux/smb_fs.h: * Flags for the in-memory inode
linux/smb_fs.h: * cause refresh on each inode for a dir listing ... one-by-one
linux/smb_fs.h:#define SMB_MAX_AGE(server) (((server)->mnt->ttl * HZ) / 1000)
linux/smb_fs.h:	dentry->d_time = jiffies - SMB_MAX_AGE(server);
linux/smb_fs.h:	sizeof(struct dentry *) - sizeof(struct smb_cache_head)) / \
linux/smb_fs.h:#define SMB_DIRCACHE_START      (SMB_DIRCACHE_SIZE - SMB_FIRSTCACHE_SIZE)
linux/smb_fs.h:	return (i->u.smbfs_i.open == server_from_inode(i)->generation);
linux/smb_fs.h:	/* --- --- --- end of "static" entries --- --- --- */
linux/rwsem-spinlock.h:/* rwsem-spinlock.h: fallback C implementation
linux/rwsem-spinlock.h: * - Derived partially from ideas by Andrea Arcangeli <andrea@suse.de>
linux/rwsem-spinlock.h: * - Derived also from comments by Linus
linux/rwsem-spinlock.h:#error please dont include linux/rwsem-spinlock.h directly, use linux/rwsem.h instead
linux/rwsem-spinlock.h: * the rw-semaphore definition
linux/rwsem-spinlock.h: * - if activity is 0 then there are no active readers or writers
linux/rwsem-spinlock.h: * - if activity is +ve then that is the number of active readers
linux/rwsem-spinlock.h: * - if activity is -1 then there is one active writer
linux/rwsem-spinlock.h: * - if wait_list is not empty, then there are processes waiting for the semaphore
linux/time.h: * at _least_ "jiffies" - so "jiffies+1" had better still
linux/time.h:#define MAX_JIFFY_OFFSET ((~0UL >> 1)-1)
linux/time.h:	unsigned long sec = value->tv_sec;
linux/time.h:	long nsec = value->tv_nsec;
linux/time.h:	nsec += 1000000000L / HZ - 1;
linux/time.h:	value->tv_nsec = (jiffies % HZ) * (1000000000L / HZ);
linux/time.h:	value->tv_sec = jiffies / HZ;
linux/time.h:/* Converts Gregorian date to seconds since 1970-01-01 00:00:00.
linux/time.h: * Assumes input in normal date format, i.e. 1980-12-31 23:59:59
linux/time.h: * -year/100+year/400 terms, and add 10.]
linux/time.h: * WARNING: this function will overflow on 2106-02-07 06:28:16 on
linux/time.h: * machines were long is 32-bit! (However, as time_t is signed, we
linux/time.h: * will already get problems at other places on 2038-01-19 03:14:08)
linux/time.h:	if (0 >= (int) (mon -= 2)) {	/* 1..12 -> 11,12,1..10 */
linux/time.h:		year -= 1;
linux/time.h:		(unsigned long) (year/4 - year/100 + year/400 + 367*mon/12 + day) +
linux/time.h:			year*365 - 719499
linux/affs_fs_sb.h: * super-block data in memory
linux/affs_fs_sb.h:#define AFFS_SB		(&sb->u.affs_sb)
linux/sunrpc/svcauth.h: * RPC server-side authentication stuff.
linux/sunrpc/svc.h:#define RPCSVC_MAXIOV		((RPCSVC_MAXPAYLOAD+PAGE_SIZE-1)/PAGE_SIZE + 1)
linux/sunrpc/svc.h:	/* iovec for zero-copy NFS READs */
linux/sunrpc/svc.h:#define svc_getlong(argp, val)	{ (val) = *(argp)->buf++; (argp)->len--; }
linux/sunrpc/svc.h:#define svc_putlong(resp, val)	{ *(resp)->buf++ = (val); (resp)->len++; }
linux/sunrpc/svc.h:				rq_userset : 1,	/* auth->setuser OK */
linux/sunrpc/svc.h:	__u32			rq_daddr;	/* dest addr of request - reply from here */
linux/sunrpc/svc.h:	struct svc_procedure *	vs_proc;	/* per-procedure info */
linux/sunrpc/xdr.h: * Copyright (C) 1995-1997 Olaf Kirch <okir@monad.swb.de>
linux/sunrpc/xdr.h: * satisfy the int_32-alignment requirements in RFC1832.
linux/sunrpc/xdr.h:	struct iovec	head[1],	/* RPC header + non-page data */
linux/sunrpc/xdr.h: * pre-xdr'ed macros.
linux/sunrpc/xdr.h:	return iov->iov_len = ((u8 *) p - (u8 *) iov->iov_base);
linux/sunrpc/sched.h:#define tk_auth			tk_client->cl_auth
linux/sunrpc/sched.h:#define tk_xprt			tk_client->cl_xprt
linux/sunrpc/sched.h:	    ((task=list_entry((head)->next, struct rpc_task, tk_list)),1))
linux/sunrpc/sched.h:#define RPC_IS_ASYNC(t)		((t)->tk_flags & RPC_TASK_ASYNC)
linux/sunrpc/sched.h:#define RPC_IS_SETUID(t)	((t)->tk_flags & RPC_TASK_SETUID)
linux/sunrpc/sched.h:#define RPC_IS_CHILD(t)		((t)->tk_flags & RPC_TASK_CHILD)
linux/sunrpc/sched.h:#define RPC_IS_SWAPPER(t)	((t)->tk_flags & RPC_TASK_SWAPPER)
linux/sunrpc/sched.h:#define RPC_DO_ROOTOVERRIDE(t)	((t)->tk_flags & RPC_TASK_ROOTCREDS)
linux/sunrpc/sched.h:#define RPC_ASSASSINATED(t)	((t)->tk_flags & RPC_TASK_KILLED)
linux/sunrpc/sched.h:#define RPC_IS_ACTIVATED(t)	((t)->tk_active)
linux/sunrpc/sched.h:#define RPC_DO_CALLBACK(t)	((t)->tk_callback != NULL)
linux/sunrpc/sched.h:#define RPC_IS_SLEEPING(t)	(test_bit(RPC_TASK_SLEEPING, &(t)->tk_runstate))
linux/sunrpc/sched.h:#define RPC_IS_RUNNING(t)	(test_bit(RPC_TASK_RUNNING, &(t)->tk_runstate))
linux/sunrpc/sched.h:#define rpc_set_running(t)	(set_bit(RPC_TASK_RUNNING, &(t)->tk_runstate))
linux/sunrpc/sched.h:#define rpc_clear_running(t)	(clear_bit(RPC_TASK_RUNNING, &(t)->tk_runstate))
linux/sunrpc/sched.h:#define rpc_set_sleeping(t)	(set_bit(RPC_TASK_SLEEPING, &(t)->tk_runstate))
linux/sunrpc/sched.h:		clear_bit(RPC_TASK_SLEEPING, &(t)->tk_runstate); \
linux/sunrpc/sched.h:	INIT_LIST_HEAD(&(ptr)->tasks); \
linux/sunrpc/sched.h:	INIT_LIST_HEAD(&(ptr)->tasks); (ptr)->name = qname; \
linux/sunrpc/sched.h:	return rpc_allocate(task->tk_flags, size);
linux/sunrpc/sched.h:	task->tk_status = status;
linux/sunrpc/sched.h:	task->tk_action = NULL;
linux/sunrpc/sched.h:	return q->name? q->name : "unknown";
linux/sunrpc/svcsock.h:#define	SK_QUED		5			/* on serv->sk_sockets */
linux/sunrpc/auth.h:	/* per-flavor data */
linux/sunrpc/auth.h:#define RPC_CREDCACHE_MASK	(RPC_CREDCACHE_NR - 1)
linux/sunrpc/auth.h:	/* per-flavor data */
linux/sunrpc/auth.h:	atomic_inc(&cred->cr_count);
linux/sunrpc/timer.h:	t = &rt->ntimeouts[timer-1];
linux/sunrpc/timer.h:			(*t)--;
linux/sunrpc/timer.h:	return rt->ntimeouts[timer-1];
linux/sunrpc/clnt.h: *  Declarations for the high-level RPC client interface
linux/sunrpc/clnt.h: * The high-level client handle
linux/sunrpc/clnt.h:#define cl_timeout		cl_xprt->timeout
linux/sunrpc/clnt.h:#define rpcproc_bufsiz(clnt, proc)	((clnt)->cl_procinfo[proc].p_bufsiz)
linux/sunrpc/clnt.h:#define rpcproc_encode(clnt, proc)	((clnt)->cl_procinfo[proc].p_encode)
linux/sunrpc/clnt.h:#define rpcproc_decode(clnt, proc)	((clnt)->cl_procinfo[proc].p_decode)
linux/sunrpc/clnt.h:#define rpcproc_name(clnt, proc)	((clnt)->cl_procinfo[proc].p_procname)
linux/sunrpc/clnt.h:#define rpcproc_count(clnt, proc)	((clnt)->cl_procinfo[proc].p_count)
linux/sunrpc/clnt.h:#define rpcproc_timer(clnt, proc)	((clnt)->cl_procinfo[proc].p_timer)
linux/sunrpc/clnt.h:#define RPC_CONGESTED(clnt)	(RPCXPRT_CONGESTED((clnt)->cl_xprt))
linux/sunrpc/clnt.h:#define RPC_PEERADDR(clnt)	(&(clnt)->cl_xprt->addr)
linux/sunrpc/clnt.h:	xprt_set_timeout(&clnt->cl_timeout, retr, incr);
linux/sunrpc/xprt.h: * The transport code maintains an estimate on the maximum number of out-
linux/sunrpc/xprt.h: *	-	a reply is received and
linux/sunrpc/xprt.h: *	-	a full number of requests are outstanding and
linux/sunrpc/xprt.h: *	-	the congestion window hasn't been updated recently.
linux/sunrpc/xprt.h:#define RPCXPRT_CONGESTED(xprt) ((xprt)->cong >= (xprt)->cwnd)
linux/sunrpc/xprt.h:	 * This is the user-visible part
linux/sunrpc/xprt.h:	int			rq_cong;	/* has incremented xprt->cong */
linux/sunrpc/xprt.h:#define xprt_connected(xp)		(test_bit(XPRT_CONNECT, &(xp)->sockstate))
linux/sunrpc/xprt.h:#define xprt_set_connected(xp)		(set_bit(XPRT_CONNECT, &(xp)->sockstate))
linux/sunrpc/xprt.h:#define xprt_test_and_set_connected(xp)	(test_and_set_bit(XPRT_CONNECT, &(xp)->sockstate))
linux/sunrpc/xprt.h:#define xprt_clear_connected(xp)	(clear_bit(XPRT_CONNECT, &(xp)->sockstate))
linux/swap.h: * swap area format, the second part of the union adds - in the
linux/swap.h: * old reserved area - some extra information. Note that the first
linux/swap.h:		char reserved[PAGE_SIZE - 10];
linux/swap.h:		char magic[10];			/* SWAP-SPACE or SWAPSPACE2 */
linux/swap.h:#define __swapoffset(x) ((unsigned long)&((union swap_header *)0)->x)
linux/swap.h:	((__swapoffset(magic.magic) - __swapoffset(info.badpages)) / sizeof(int))
linux/swap.h: * The in-memory structure used to track swap areas.
linux/swap.h:	int head;	/* head of priority-ordered swapfile list */
linux/swap.h:#define dec_nr_active_pages(page) delta_nr_active_pages(page, -1)
linux/swap.h:#define dec_nr_inactive_pages(page) delta_nr_inactive_pages(page, -1)
linux/swap.h:	list_add(&(page)->lru, &active_list);	\
linux/swap.h:	list_add(&(page)->lru, &inactive_list);	\
linux/swap.h:	list_del(&(page)->lru);			\
linux/swap.h:	list_del(&(page)->lru);			\
linux/swap.h:#define dec_nr_cache_pages(page) delta_nr_cache_pages(page, -1)
linux/swap.h:#define swap_device_lock(p)	spin_lock(&p->sdev_lock)
linux/swap.h:#define swap_device_unlock(p)	spin_unlock(&p->sdev_lock)
linux/namespace.h:	if (atomic_dec_and_test(&namespace->count)) {
linux/namespace.h:		down_write(&namespace->sem);
linux/namespace.h:		umount_tree(namespace->root);
linux/namespace.h:		up_write(&namespace->sem);
linux/namespace.h:	struct namespace *namespace = p->namespace;
linux/namespace.h:		p->namespace = NULL;
linux/namespace.h:	atomic_inc(&namespace->count);
linux/if_cablemodem.h:/* some useful defines for sb1000.c e cmconfig.c - fv */
linux/proc_fs.h: * create an in-memory tree (like the actual /proc filesystem
linux/proc_fs.h: * non-directory entries).
linux/proc_fs.h:#define PROC_INODE_PROPER(inode) ((inode)->i_ino & ~0xffff)
linux/proc_fs.h:		res->read_proc=read_proc;
linux/proc_fs.h:		res->data=data;
linux/proc_fs.h:	if (res) res->get_info=get_info;
linux/proc_fs.h:		res->proc_fops = fops;
linux/proc_fs.h:	return (struct proc_dir_entry *)inode->u.generic_ip;
linux/umem.h:READ-LINE (0xE) OR READ-MULTIPLE (0xC) PCI COMMAND CODES DURING DMA 
linux/umem.h:/* bits for card->flags */
linux/hcdp_serial.h: *  Copyright (C) 2002  Hewlett-Packard Co.
linux/reiserfs_fs_i.h: * Copyright 2000-2002 by Hans Reiser, licensing governed by reiserfs/README
linux/reiserfs_fs_i.h:/** bitmasks for i_flags field in reiserfs-specific part of inode */
linux/reiserfs_fs_i.h:	- 3.5 */
linux/reiserfs_fs_i.h:    struct list_head i_prealloc_list;	/* per-transaction list of inodes which
linux/reiserfs_fs_i.h:     * involved in a direct->indirect conversion for this file
linux/cramfs_fs_sb.h: * cramfs super-block data in memory
linux/wait.h:#define __WCLONE	0x80000000	/* Wait only on non-SIGCHLD children */
linux/wait.h:		if ((x)->__magic != (long)&((x)->__magic)) {			\
linux/wait.h:			(x)->__magic, (long)&((x)->__magic), (x)->__creator);	\
linux/wait.h:		if (!(list)->next || !(list)->prev)				\
linux/wait.h:		(tsk)->__waker = (long)__builtin_return_address(0);		\
linux/wait.h:	q->lock = WAITQUEUE_RW_LOCK_UNLOCKED;
linux/wait.h:	INIT_LIST_HEAD(&q->task_list);
linux/wait.h:	q->__magic = (long)&q->__magic;
linux/wait.h:	q->__creator = (long)current_text_addr();
linux/wait.h:	q->flags = 0;
linux/wait.h:	q->task = p;
linux/wait.h:	q->__magic = (long)&q->__magic;
linux/wait.h:	return !list_empty(&q->task_list);
linux/wait.h:	CHECK_MAGIC(new->__magic);
linux/wait.h:	if (!head->task_list.next || !head->task_list.prev)
linux/wait.h:	list_add(&new->task_list, &head->task_list);
linux/wait.h: * Used for wake-one threads:
linux/wait.h:	CHECK_MAGIC(new->__magic);
linux/wait.h:	if (!head->task_list.next || !head->task_list.prev)
linux/wait.h:	list_add_tail(&new->task_list, &head->task_list);
linux/wait.h:	CHECK_MAGIC(old->__magic);
linux/wait.h:	list_del(&old->task_list);
linux/capability.h: * ftp://linux.kernel.org/pub/linux/libs/security/linux-privs/kernel-2.2/
linux/capability.h:/* User-level do most of the mapping between kernel and user
linux/capability.h:/* XXX - Note, cap_t, is defined by POSIX to be an "opaque" pointer to
linux/capability.h: ** POSIX-draft defined capabilities. 
linux/capability.h: ** Linux-specific capabilities
linux/capability.h:/* Allow read/write of device-specific registers */
linux/capability.h:/* Insert and remove kernel modules - modify kernel without limit */
linux/capability.h:/* Allow reading non-standardized portions of pci configuration space */
linux/capability.h:/* Allow sending raw qic-117 commands */
linux/capability.h:/* Allow use of FIFO and round-robin (realtime) scheduling on own
linux/capability.h:/* Allow more than 64hz interrupts from the real-time clock */
linux/capability.h:/* Allow setting the real-time clock */
linux/hpfs_fs_sb.h:	unsigned sb_n_free;		/* free blocks for statfs, or -1 */
linux/hpfs_fs_sb.h:	unsigned sb_n_free_dnodes;	/* free dnodes for statfs, or -1 */
linux/hpfs_fs_sb.h:	unsigned sb_conv : 2;		/* crlf->newline hackery */
linux/hpfs_fs_sb.h:	unsigned sb_eas : 2;		/* eas: 0-ignore, 1-ro, 2-rw */
linux/hpfs_fs_sb.h:	unsigned sb_err : 2;		/* on errs: 0-cont, 1-ro, 2-panic */
linux/hpfs_fs_sb.h:	unsigned sb_chk : 2;		/* checks: 0-no, 1-normal, 2-strict */
linux/hpfs_fs_sb.h:	unsigned sb_chkdsk : 2;		/* chkdsk: 0-no, 1-on errs, 2-allways */
linux/hpfs_fs_sb.h:	unsigned sb_rd_fnode : 2;	/* read fnode 0-no 1-dirs 2-all */
linux/hpfs_fs_sb.h:	unsigned sb_rd_inode : 2;	/* lookup tells read_inode: 1-read fnode
linux/hpfs_fs_sb.h:					   2-don't read fnode, file
linux/hpfs_fs_sb.h:					   3-don't read fnode, direcotry */
linux/nubus.h:  Hacked to death by C. Scott Ananian and David Huggins-Daines.
linux/nubus.h: *  RBV built-in video (IIci): <3,1,1,24>
linux/nubus.h: *  Valkyrie built-in video (Q630): <3,1,1,46>
linux/nubus.h: *  Sonora built-in video (P460): <3,1,1,34>
linux/nubus.h: *  SONIC comm-slot/on-board and DuoDock Ethernet: <4,1,1,272>
linux/nubus.h: *  SONIC LC-PDS Ethernet (Dayna, but like Apple 16-bit, sort of): <4,1,1,271>
linux/nubus.h: *  Sonic Systems Ethernet A-Series Card: <4,1,268,256>
linux/nubus.h: *  Asante MacCon NuBus-A: <4,1,260,256> (alpha-1.0,1.1 revision)
linux/nubus.h: *  ftp://dev.apple.com/devworld/Tool_Chest/Devices_-_Hardware/NuBus_Slot_Manager/
linux/nubus.h: *  Alternately, TattleTech can be found at any Info-Mac mirror site.  
linux/nubus.h:	NUBUS_DRHW_APPLE_SONORA = 0x0022, /* Sonora built-in video */
linux/nubus.h:/* Category-specific resources. */
linux/nubus.h:        /* Only 9-E actually exist, though 0-8 are also theoretically
linux/nubus.h:/* These are somewhat more NuBus-specific.  They all return 0 for
linux/nubus.h:   success and -1 for failure, as you'd expect. */
linux/affs_fs.h:/* --- Prototypes -----------------------------------------------------------------------------	*/
linux/reiserfs_fs_sb.h:/* Copyright 1996-2002 Hans Reiser, see reiserfs/README for licensing
linux/reiserfs_fs_sb.h:#define REISERFS_VERSION_2 2 /* distributed bitmap, resizer, 64-bit, etc*/
linux/reiserfs_fs_sb.h:#define sb_block_count(sbp)         (le32_to_cpu((sbp)->s_v1.s_block_count))
linux/reiserfs_fs_sb.h:#define set_sb_block_count(sbp,v)   ((sbp)->s_v1.s_block_count = cpu_to_le32(v))
linux/reiserfs_fs_sb.h:#define sb_free_blocks(sbp)         (le32_to_cpu((sbp)->s_v1.s_free_blocks))
linux/reiserfs_fs_sb.h:#define set_sb_free_blocks(sbp,v)   ((sbp)->s_v1.s_free_blocks = cpu_to_le32(v))
linux/reiserfs_fs_sb.h:#define sb_root_block(sbp)          (le32_to_cpu((sbp)->s_v1.s_root_block))
linux/reiserfs_fs_sb.h:#define set_sb_root_block(sbp,v)    ((sbp)->s_v1.s_root_block = cpu_to_le32(v))
linux/reiserfs_fs_sb.h:              (le32_to_cpu((sbp)->s_v1.s_journal.jp_journal_1st_block))
linux/reiserfs_fs_sb.h:              ((sbp)->s_v1.s_journal.jp_journal_1st_block = cpu_to_le32(v))
linux/reiserfs_fs_sb.h:              (le32_to_cpu((sbp)->s_v1.s_journal.jp_journal_dev))
linux/reiserfs_fs_sb.h:              ((sbp)->s_v1.s_journal.jp_journal_dev = cpu_to_le32(v))
linux/reiserfs_fs_sb.h:              (le32_to_cpu((sbp)->s_v1.s_journal.jp_journal_size))
linux/reiserfs_fs_sb.h:              ((sbp)->s_v1.s_journal.jp_journal_size = cpu_to_le32(v))
linux/reiserfs_fs_sb.h:              (le32_to_cpu((sbp)->s_v1.s_journal.jp_journal_trans_max))
linux/reiserfs_fs_sb.h:              ((sbp)->s_v1.s_journal.jp_journal_trans_max = cpu_to_le32(v))
linux/reiserfs_fs_sb.h:              (le32_to_cpu((sbp)->s_v1.s_journal.jp_journal_magic))
linux/reiserfs_fs_sb.h:              ((sbp)->s_v1.s_journal.jp_journal_magic = cpu_to_le32(v))
linux/reiserfs_fs_sb.h:              (le32_to_cpu((sbp)->s_v1.s_journal.jp_journal_max_batch))
linux/reiserfs_fs_sb.h:              ((sbp)->s_v1.s_journal.jp_journal_max_batch = cpu_to_le32(v))
linux/reiserfs_fs_sb.h:              (le32_to_cpu((sbp)->s_v1.s_journal.jp_journal_max_commit_age))
linux/reiserfs_fs_sb.h:              ((sbp)->s_v1.s_journal.jp_journal_max_commit_age = cpu_to_le32(v))
linux/reiserfs_fs_sb.h:#define sb_blocksize(sbp)          (le16_to_cpu((sbp)->s_v1.s_blocksize))
linux/reiserfs_fs_sb.h:#define set_sb_blocksize(sbp,v)    ((sbp)->s_v1.s_blocksize = cpu_to_le16(v))
linux/reiserfs_fs_sb.h:#define sb_oid_maxsize(sbp)        (le16_to_cpu((sbp)->s_v1.s_oid_maxsize))
linux/reiserfs_fs_sb.h:#define set_sb_oid_maxsize(sbp,v)  ((sbp)->s_v1.s_oid_maxsize = cpu_to_le16(v))
linux/reiserfs_fs_sb.h:#define sb_oid_cursize(sbp)        (le16_to_cpu((sbp)->s_v1.s_oid_cursize))
linux/reiserfs_fs_sb.h:#define set_sb_oid_cursize(sbp,v)  ((sbp)->s_v1.s_oid_cursize = cpu_to_le16(v))
linux/reiserfs_fs_sb.h:#define sb_umount_state(sbp)       (le16_to_cpu((sbp)->s_v1.s_umount_state))
linux/reiserfs_fs_sb.h:#define set_sb_umount_state(sbp,v) ((sbp)->s_v1.s_umount_state = cpu_to_le16(v))
linux/reiserfs_fs_sb.h:#define sb_fs_state(sbp)           (le16_to_cpu((sbp)->s_v1.s_fs_state))
linux/reiserfs_fs_sb.h:#define set_sb_fs_state(sbp,v)     ((sbp)->s_v1.s_fs_state = cpu_to_le16(v)) 
linux/reiserfs_fs_sb.h:              (le32_to_cpu((sbp)->s_v1.s_hash_function_code))
linux/reiserfs_fs_sb.h:              ((sbp)->s_v1.s_hash_function_code = cpu_to_le32(v))
linux/reiserfs_fs_sb.h:#define sb_tree_height(sbp)        (le16_to_cpu((sbp)->s_v1.s_tree_height))
linux/reiserfs_fs_sb.h:#define set_sb_tree_height(sbp,v)  ((sbp)->s_v1.s_tree_height = cpu_to_le16(v))
linux/reiserfs_fs_sb.h:#define sb_bmap_nr(sbp)            (le16_to_cpu((sbp)->s_v1.s_bmap_nr))
linux/reiserfs_fs_sb.h:#define set_sb_bmap_nr(sbp,v)      ((sbp)->s_v1.s_bmap_nr = cpu_to_le16(v))
linux/reiserfs_fs_sb.h:#define sb_version(sbp)            (le16_to_cpu((sbp)->s_v1.s_version))
linux/reiserfs_fs_sb.h:#define set_sb_version(sbp,v)      ((sbp)->s_v1.s_version = cpu_to_le16(v))
linux/reiserfs_fs_sb.h:              (le16_to_cpu((sbp)->s_v1.s_reserved_for_journal))
linux/reiserfs_fs_sb.h:              ((sbp)->s_v1.s_reserved_for_journal = cpu_to_le16(v))
linux/reiserfs_fs_sb.h:/* LOGGING -- */
linux/reiserfs_fs_sb.h:** I don't know what n is yet, I'm guessing 8-16.
linux/reiserfs_fs_sb.h:				/* we have a node size define somewhere in reiserfs_fs.h. -Hans */
linux/reiserfs_fs_sb.h:				/* ifdef it. -Hans */
linux/reiserfs_fs_sb.h:/* reiserfs union of in-core super block data */
linux/reiserfs_fs_sb.h:                                   name are unclear for s_rs -Hans */
linux/reiserfs_fs_sb.h:				/* Comment? -Hans */
linux/reiserfs_fs_sb.h:                                   here (currently - NOTAIL, NOLOG,
linux/reiserfs_fs_sb.h:				/* Comment? -Hans */
linux/reiserfs_fs_sb.h:				/* To be obsoleted soon by per buffer seals.. -Hans */
linux/reiserfs_fs_sb.h:    // tree gets re-balanced
linux/reiserfs_fs_sb.h:				     on-disk FS format */
linux/reiserfs_fs_sb.h:/* Definitions of reiserfs on-disk properties: */
linux/reiserfs_fs_sb.h:#define REISERFS_NOLOG 4      /* -o nolog: turn journalling off */
linux/reiserfs_fs_sb.h:#define REISERFS_CONVERT 5    /* -o conv: causes conversion of old
linux/reiserfs_fs_sb.h:                                 format. If not specified - old
linux/reiserfs_fs_sb.h:/* -o hash={tea, rupasov, r5, detect} is meant for properly mounting 
linux/reiserfs_fs_sb.h:** with -o hash=rupasov, the mount will fail.
linux/reiserfs_fs_sb.h:#define reiserfs_r5_hash(s) ((s)->u.reiserfs_sb.s_mount_opt & (1 << FORCE_R5_HASH))
linux/reiserfs_fs_sb.h:#define reiserfs_rupasov_hash(s) ((s)->u.reiserfs_sb.s_mount_opt & (1 << FORCE_RUPASOV_HASH))
linux/reiserfs_fs_sb.h:#define reiserfs_tea_hash(s) ((s)->u.reiserfs_sb.s_mount_opt & (1 << FORCE_TEA_HASH))
linux/reiserfs_fs_sb.h:#define reiserfs_hash_detect(s) ((s)->u.reiserfs_sb.s_mount_opt & (1 << FORCE_HASH_DETECT))
linux/reiserfs_fs_sb.h:#define reiserfs_no_border(s) ((s)->u.reiserfs_sb.s_mount_opt & (1 << REISERFS_NO_BORDER))
linux/reiserfs_fs_sb.h:#define reiserfs_no_unhashed_relocation(s) ((s)->u.reiserfs_sb.s_mount_opt & (1 << REISERFS_NO_UNHASHED_RELOCATION))
linux/reiserfs_fs_sb.h:#define reiserfs_hashed_relocation(s) ((s)->u.reiserfs_sb.s_mount_opt & (1 << REISERFS_HASHED_RELOCATION))
linux/reiserfs_fs_sb.h:#define reiserfs_test4(s) ((s)->u.reiserfs_sb.s_mount_opt & (1 << REISERFS_TEST4))
linux/reiserfs_fs_sb.h:#define have_large_tails(s) ((s)->u.reiserfs_sb.s_mount_opt & (1 << REISERFS_LARGETAIL))
linux/reiserfs_fs_sb.h:#define have_small_tails(s) ((s)->u.reiserfs_sb.s_mount_opt & (1 << REISERFS_SMALLTAIL))
linux/reiserfs_fs_sb.h:#define replay_only(s) ((s)->u.reiserfs_sb.s_mount_opt & (1 << REPLAYONLY))
linux/reiserfs_fs_sb.h:#define reiserfs_dont_log(s) ((s)->u.reiserfs_sb.s_mount_opt & (1 << REISERFS_NOLOG))
linux/reiserfs_fs_sb.h:#define reiserfs_attrs(s) ((s)->u.reiserfs_sb.s_mount_opt & (1 << REISERFS_ATTRS))
linux/reiserfs_fs_sb.h:#define old_format_only(s) ((s)->u.reiserfs_sb.s_properties & (1 << REISERFS_3_5))
linux/reiserfs_fs_sb.h:#define convert_reiserfs(s) ((s)->u.reiserfs_sb.s_mount_opt & (1 << REISERFS_CONVERT))
linux/reiserfs_fs_sb.h:#define SB_BUFFER_WITH_SB(s) ((s)->u.reiserfs_sb.s_sbh)
linux/reiserfs_fs_sb.h:#define SB_JOURNAL(s) ((s)->u.reiserfs_sb.s_journal)
linux/reiserfs_fs_sb.h:#define SB_JOURNAL_1st_RESERVED_BLOCK(s) (SB_JOURNAL(s)->j_1st_reserved_block)
linux/reiserfs_fs_sb.h:#define SB_JOURNAL_LIST(s) (SB_JOURNAL(s)->j_journal_list)
linux/reiserfs_fs_sb.h:#define SB_JOURNAL_LIST_INDEX(s) (SB_JOURNAL(s)->j_journal_list_index) 
linux/reiserfs_fs_sb.h:#define SB_JOURNAL_LEN_FREE(s) (SB_JOURNAL(s)->j_journal_len_free) 
linux/reiserfs_fs_sb.h:#define SB_AP_BITMAP(s) ((s)->u.reiserfs_sb.s_ap_bitmap)
linux/reiserfs_fs_sb.h:#define SB_DISK_JOURNAL_HEAD(s) (SB_JOURNAL(s)->j_header_bh->)
linux/reiserfs_fs_sb.h:#define SB_JOURNAL_TRANS_MAX(s)      (SB_JOURNAL(s)->s_journal_trans_max)
linux/reiserfs_fs_sb.h:#define SB_JOURNAL_MAX_BATCH(s)      (SB_JOURNAL(s)->s_journal_max_batch)
linux/reiserfs_fs_sb.h:#define SB_JOURNAL_MAX_COMMIT_AGE(s) (SB_JOURNAL(s)->s_journal_max_commit_age)
linux/reiserfs_fs_sb.h:#define SB_JOURNAL_MAX_TRANS_AGE(s)  (SB_JOURNAL(s)->s_journal_max_trans_age)
linux/reiserfs_fs_sb.h:#define SB_JOURNAL_DEV(s)            (SB_JOURNAL(s)->j_dev)
linux/amifd.h:    int track;			/* current track (-1 == unknown) */
linux/amifd.h:    int disk;			/* disk in drive (-1 == unknown) */
linux/ticable.h:/* Hey EMACS -*- linux-c -*-
linux/ticable.h: * tipar/tiser/tiusb - low level driver for handling link cables
linux/ticable.h: * Copyright (C) 2000-2002, Romain Lievin <roms@lpg.ticalc.org>
linux/ticable.h:#define IO_DELAY  10      /* 10 micro-seconds  */
linux/stddef.h:#define offsetof(TYPE, MEMBER) ((size_t) &((TYPE *)0)->MEMBER)
linux/soundmodem.h: * (C) 1996-1998 by Thomas Sailer, HB9JNX/AE4WA
linux/soundmodem.h:/* -------------------------------------------------------------------- */
linux/soundmodem.h:/* -------------------------------------------------------------------- */
linux/soundmodem.h:/* -------------------------------------------------------------------- */
linux/soundmodem.h:/* --------------------------------------------------------------------- */
linux/ixjuser.h: *    (c) Copyright 1999-2001  Quicknet Technologies, Inc.
linux/ixjuser.h:* 1 uncompressed (480 byte) 16-bit linear frame.
linux/ixjuser.h:* 2 uncompressed (240 byte) 8-bit A-law/mu-law frames.
linux/ixjuser.h:* against over-scaling, if the multiplication factor times the input
linux/ixjuser.h:* tone table has 32 entries (0 - 31), but the driver only allows entries
linux/ixjuser.h:* 13 - 27 to be modified, entry 0 is reserved for silence and 1 - 12 are
linux/ixjuser.h:* the standard DTMF digits and 28 - 31 are the DTMF tones for A, B, C & D.
linux/ixjuser.h:*    Dial Tone   - 25
linux/ixjuser.h:*    Ring Back   - 26
linux/ixjuser.h:*    Busy Signal - 27
linux/ixjuser.h:* The gain values range from 0 to 15 indicating +6dB to -24dB in 2dB
linux/ixjuser.h:* structures.  If the freq0 variable is non-zero, the tone table contents
linux/ixjuser.h:* IXJCTL_DTMF_OOB determines if DTMF signaling is sent as Out-Of-Band
linux/ixjuser.h:* The master volume controls use attenuation with 32 levels from 0 to -62dB
linux/ixjuser.h:* The input volume controls use gain with 32 levels from +12dB to -50dB
linux/ixjuser.h:* The POTS volume control use attenuation with 8 levels from 0dB to -28dB
linux/ixjuser.h:#define AGX_6DB		0x04	/* Analog gain in transmit direction -6dB */
linux/ixjuser.h:#define AGX_2_5B	0x0C	/* Analog gain in transmit direction -2.5dB */
linux/ixjuser.h:* Passing a 1 to this ioctl enables the POTS<->PSTN connection while
linux/ixjuser.h:* Smart Cable of the Internet Phone Card.  Sending -1 as a value will cause
linux/ixjuser.h:* return value to be the current setting.  Valid values to set are 0x00 - 0x1F
linux/ixjuser.h:* 00000 = -34.5 dB
linux/serial.h:#define PORT_RSA	13	/* RSA-DV II/S card */
linux/serial.h:#define ASYNC_SPD_CUST	0x0030  /* Use user-specified divisor */
linux/serial.h:#define ASYNC_USR_MASK	0x3430	/* Legal flags that non-privileged
linux/serial.h:					     --- no longer used */
linux/serial.h: * Multiport serial configuration structure --- external structure
linux/serial.h: * Serial input interrupt line counters -- external structure
linux/serial.h:/* Export to allow PCMCIA to use this - Dave Hinds */
linux/bpqether.h: * For SIOCSBPQETHOPT - this is compatible with PI2/PacketTwin card drivers,
linux/bpqether.h: * to his Ethernet card he may find this useful. ;-)
linux/ext3_fs_i.h: * Laboratoire MASI - Institut Blaise Pascal
linux/ext3_fs_i.h:	 * into the on-disk inode when writing inodes out, instead of i_size.
linux/ext3_fs_i.h:	 * during recovery.  Hence we must fix the get_block-vs-truncate race
linux/pkt_sched.h:   with obsolete IPv6 values is not occasional :-). New IPv6 drafts
linux/pkt_sched.h:   ---------
linux/pkt_sched.h:	__u8	priomap[TC_PRIO_MAX+1];	/* Map: logical priority -> PRIO band */
linux/pkt_sched.h:	__u8		priomap[TC_PRIO_MAX+1];	/* Map: logical priority -> CSZ band */
linux/pkt_sched.h:	unsigned char   Plog;		/* log(P_max/(qth_max-qth_min))	*/
linux/pkt_sched.h:       unsigned char   Plog;           /* log(P_max/(qth_max-qth_min)) */
linux/pkt_sched.h:    	__u32 rate2quantum;	/* bps->quantum divisor */
linux/pkt_sched.h:	__u32	d;		/* x-projection of the first segment in us */
linux/pkt_sched.h:	__u64	rtwork;		/* work done by real-time criteria */
linux/pkt_sched.h:	TCA_ATM_PTR,		/* pointer to descriptor - later */
linux/pkt_sched.h:	__u32	gap;		/* re-ordering gap (0 for delay all) */
linux/toshiba.h:/* toshiba.h -- Linux driver for accessing the SMM on Toshiba laptops 
linux/toshiba.h: * Copyright (c) 1996-2000  Jonathan A. Buzzard (jonathan@buzzard.org.uk)
linux/rbtree.h:  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
linux/rbtree.h:-----------------------------------------------------------------------
linux/rbtree.h:	rb_node_t * n = inode->i_rb_page_cache.rb_node;
linux/rbtree.h:		if (offset < page->offset)
linux/rbtree.h:			n = n->rb_left;
linux/rbtree.h:		else if (offset > page->offset)
linux/rbtree.h:			n = n->rb_right;
linux/rbtree.h:	rb_node_t ** p = &inode->i_rb_page_cache.rb_node;
linux/rbtree.h:		if (offset < page->offset)
linux/rbtree.h:			p = &(*p)->rb_left;
linux/rbtree.h:		else if (offset > page->offset)
linux/rbtree.h:			p = &(*p)->rb_right;
linux/rbtree.h:	rb_insert_color(node, &inode->i_rb_page_cache);
linux/rbtree.h:-----------------------------------------------------------------------
linux/rbtree.h:	((type *)((char *)(ptr)-(unsigned long)(&((type *)0)->member)))
linux/rbtree.h:	node->rb_parent = parent;
linux/rbtree.h:	node->rb_color = RB_RED;
linux/rbtree.h:	node->rb_left = node->rb_right = NULL;
linux/nvram.h:#define NVRAM_OFFSET(x)   ((x)-NVRAM_FIRST_BYTE)
linux/nvram.h:/* __foo is foo without grabbing the rtc_lock - get it yourself */
linux/msdos_fs.h: * The MS-DOS filesystem constants/structures
linux/msdos_fs.h:#define ATTR_RO      1  /* read-only */
linux/msdos_fs.h:#define MSDOS_SB(s) (&((s)->u.msdos_sb))
linux/msdos_fs.h:#define MSDOS_I(i) (&((i)->u.msdos_i))
linux/msdos_fs.h:#define EOF_FAT(s) (MSDOS_SB(s)->fat_bits == 32 ? EOF_FAT32 : \
linux/msdos_fs.h:	MSDOS_SB(s)->fat_bits == 16 ? EOF_FAT16 : EOF_FAT12)
linux/msdos_fs.h:#define IS_FSINFO(x)		(CF_LE_L((x)->signature1) == FAT_FSINFO_SIG1	 \
linux/msdos_fs.h:				 && CF_LE_L((x)->signature2) == FAT_FSINFO_SIG2)
linux/msdos_fs.h: * Conversion from and to little-endian byte order. (no-op on i386/i486)
linux/msdos_fs.h: * Naming: Ca_b_c, where a: F = from, T = to, b: LE = little-endian,
linux/msdos_fs.h: * BE = big-endian, c: W = word (16 bits), L = longword (32 bits)
linux/msdos_fs.h:	__s8	system_id[8];	/* Name - can be used to special case
linux/msdos_fs.h:	__u32   free_clusters;	/* Free cluster count.  -1 if unknown */
linux/msdos_fs.h:	loff_t i_pos;		       /* on-disk position of directory entry */
linux/msdos_fs.h:/* Determine whether this FS has kB-aligned data. */
linux/msdos_fs.h:#define MSDOS_CAN_BMAP(mib) (!(((mib)->cluster_size & 1) || \
linux/msdos_fs.h:    ((mib)->data_start & 1)))
linux/msdos_fs.h:/* Convert the UNIX mode to MS-DOS attribute bits. */
linux/msdos_fs.h:	while (len--) {
linux/msdos_fs.h:	while (len--) {
linux/msdos_fs.h:	    (*de - (struct msdos_dir_entry *)(*bh)->b_data) < MSDOS_SB(dir->i_sb)->dir_per_block - 1) {
linux/msdos_fs.h:/* msdos/namei.c  - these are for Umsdos */
linux/msdos_fs.h:/* vfat/namei.c - these are for dmsdos */
linux/ibmtr.h:/* MMIO bits 0-4 select register */
linux/ibmtr.h:#define RRR_EVEN       0x00 /* Shared RAM relocation registers - even and odd */
linux/ibmtr.h:#define WRBR_EVEN       0x02    /* Write region base registers - even and odd */
linux/ibmtr.h:#define WWOR_EVEN       0x04    /* Write window open registers - even and odd */
linux/ibmtr.h:#define WWCR_EVEN       0x06   /* Write window close registers - even and odd */
linux/ibmtr.h:/* Interrupt status registers - PC system  - even and odd */
linux/ibmtr.h:#define TCR_INT    0x10    /* Bit 4 - Timer interrupt.  The TVR_EVEN timer has
linux/ibmtr.h:#define ERR_INT	   0x08    /* Bit 3 - Error interrupt.  The adapter has had an
linux/ibmtr.h:#define ACCESS_INT 0x04    /* Bit 2 - Access interrupt.  You have attempted to
linux/ibmtr.h:#define INT_ENABLE 0x40 /* Bit 6 - Interrupt enable.  If 0, no interrupts will
linux/ibmtr.h:/* Bit 0 - Primary or alternate adapter.  Set to zero if this adapter is the
linux/ibmtr.h:#define ADAP_CHK_INT 0x40 /* Bit 6 - Adapter check.  the adapter has
linux/ibmtr.h:#define SRB_RESP_INT 0x20 /* Bit 5 - SRB response.  The adapter has accepted
linux/ibmtr.h:#define ASB_FREE_INT 0x10 /* Bit 4 - ASB free.  The adapter has read the ASB
linux/ibmtr.h:#define ARB_CMD_INT  0x08 /* Bit 3 - ARB command.  The adapter has given you a
linux/ibmtr.h:#define SSB_RESP_INT 0x04 /* Bit 2 - SSB response.  The adapter has posted a
linux/ibmtr.h:/* Bit 1 - Bridge frame forward complete. */
linux/ibmtr.h:#define ISRA_EVEN 0x0A /*Interrupt status registers - adapter  - even and odd */
linux/ibmtr.h:/* Bit 7 - Internal parity error (on adapter's internal bus) */
linux/ibmtr.h:/* Bit 6 - Timer interrupt pending */
linux/ibmtr.h:/* Bit 5 - Access interrupt (attempt by adapter to access illegal address) */
linux/ibmtr.h:/* Bit 4 - Adapter microcode problem (microcode dead-man timer expired) */
linux/ibmtr.h:/* Bit 3 - Adapter processor check status */
linux/ibmtr.h:/* Bit 2 - Reserved */
linux/ibmtr.h:/* Bit 1 - Adapter hardware interrupt mask (prevents internal interrupts) */
linux/ibmtr.h:/* Bit 0 - Adapter software interrupt mask (prevents internal software ints) */
linux/ibmtr.h:#define CMD_IN_SRB  0x20 /* Bit 5  - Indicates that you have placed a new
linux/ibmtr.h:#define RESP_IN_ASB 0x10 /* Bit 4 - Indicates that you have placed a response
linux/ibmtr.h:/* Bit 3 - Indicates that you are ready to put an SRB in the shared RAM, but
linux/ibmtr.h:/* Bit 2 - Indicates that you are ready to put an ASB in the shared RAM, but
linux/ibmtr.h:#define TCR_EVEN        0x0C    /* Timer control registers - even and odd */
linux/ibmtr.h:#define TVR_EVEN        0x0E    /* Timer value registers - even and odd */
linux/ibmtr.h:#define SRPR_EVEN       0x18    /* Shared RAM paging registers - even and odd */
linux/ibmtr.h:/* MMIO bits 5-6 select operation */
linux/ibmtr.h:/* MMIO bits 7-8 select area of interest.. see below */
linux/ibmtr.h:#define SET_PAGE(x) (writeb((x), ti->mmio + ACA_OFFSET+ ACA_RW + SRPR_EVEN))
linux/ibmtr.h:	unsigned short adapter_int_enable; /* Adapter-specific int enable */
linux/logibusmouse.h: * Minor modifications for Linux 0.96c-pl1 by Nathan Laredo
linux/logibusmouse.h:/*--------- LOGITECH BUSMOUSE ITEMS -------------*/
linux/logibusmouse.h:/*--------- MICROSOFT BUSMOUSE ITEMS -------------*/
linux/qnx4_fs_i.h: *  Last modified                : 2000-01-06
linux/qnx4_fs_i.h: *  History                      : 23-03-1998 created
linux/if_ether.h:#define ETH_P_ATMFATE	0x8884		/* Frame-based ATM Transport
linux/if_ether.h:#define ETH_P_IRDA	0x0017		/* Linux-IrDA			*/
linux/amifdreg.h:/* bits 7-0 are data */
linux/qnxtypes.h: *  Last modified                : 2000-01-06
linux/qnxtypes.h: *  History                      : 22-03-1998 created
linux/auto_fs.h:/* -*- linux-c -*- ------------------------------------------------------- *
linux/auto_fs.h: *   Copyright 1997 Transmeta Corporation - All Rights Reserved
linux/auto_fs.h: * ----------------------------------------------------------------------- */
linux/auto_fs.h: * Architectures where both 32- and 64-bit binaries can be executed
linux/auto_fs.h: * on 64-bit kernels need this.  This keeps the structure format
linux/auto_fs.h: * -------------------------
linux/auto_fs.h: * If so, 32-bit user-space code should be backwards compatible.
linux/nfs_xdr.h:#define NFS_ATTR_WCC		0x0001		/* pre-op WCC data    */
linux/nfs_xdr.h:#define NFS_ATTR_FATTR		0x0002		/* post-op attributes */
linux/nfs_xdr.h: * Note that NFS_READ_MAXIOV must be <= (MAX_IOVEC-2) from sunrpc/xprt.h
linux/nfs_xdr.h: * Note that NFS_WRITE_MAXIOV must be <= (MAX_IOVEC-2) from sunrpc/xprt.h
linux/nfs_xdr.h: *	NFS_PROTO(inode)->getattr(fattr);
linux/nfs_xdr.h:#define NFS_CALL(op, inode, args)	NFS_PROTO(inode)->op args
linux/watchdog.h:#define	WDIOF_UNKNOWN		-1	/* Unknown flag error */
linux/watchdog.h:#define	WDIOS_UNKNOWN		-1	/* Unknown status error */
linux/zlib.h:/* zlib.h -- interface of the 'zlib' general purpose compression library
linux/zlib.h:  Copyright (C) 1995-1998 Jean-loup Gailly and Mark Adler
linux/zlib.h:  This software is provided 'as-is', without any express or implied
linux/zlib.h:  Jean-loup Gailly        Mark Adler
linux/zlib.h:     The 'zlib' compression library provides in-memory compression and
linux/zlib.h:   If zlib is used in a multi-threaded application, zalloc and zfree must be
linux/zlib.h:   On 16-bit systems, the functions zalloc and zfree must be able to allocate
linux/zlib.h:   compression ratio, compile the library with -DMAX_WBITS=14 (see zconf.h).
linux/zlib.h:#define Z_ERRNO        (-1)
linux/zlib.h:#define Z_STREAM_ERROR (-2)
linux/zlib.h:#define Z_DATA_ERROR   (-3)
linux/zlib.h:#define Z_MEM_ERROR    (-4)
linux/zlib.h:#define Z_BUF_ERROR    (-5)
linux/zlib.h:#define Z_VERSION_ERROR (-6)
linux/zlib.h:#define Z_DEFAULT_COMPRESSION  (-1)
linux/zlib.h:   Returns the number of bytes that needs to be allocated for a per-
linux/zlib.h:   returned in stream->workspace before calling zlib_deflateInit().
linux/zlib.h:  - Compress more input starting at next_in and update next_in and avail_in
linux/zlib.h:  - Provide more output starting at next_out and update next_out and avail_out
linux/zlib.h:  avail_out), until the flush is complete (deflate returns with non-zero
linux/zlib.h:    deflate() sets strm->adler to the adler32 checksum of all input read
linux/zlib.h:   Returns the number of bytes that needs to be allocated for a per-
linux/zlib.h:   returned in stream->workspace before calling zlib_inflateInit().
linux/zlib.h:  - Decompress more input starting at next_in and update next_in and avail_in
linux/zlib.h:  - Provide more output starting at next_out and update next_out and avail_out
linux/zlib.h:  below), inflate sets strm-adler to the adler32 checksum of the
linux/zlib.h:  it sets strm->adler to the adler32 checksum of all output produced
linux/zlib.h:     Upon return of this function, strm->adler is set to the Adler32 value
linux/zlib.h:   tried, for example when there are several ways of pre-processing the input
linux/zlib.h:   be compressed and flushed. In particular, strm->avail_out must be non-zero.
linux/zlib.h:   if strm->avail_out was zero.
linux/romfs_fs.h:#define ROMBMASK (ROMBSIZE-1)
linux/romfs_fs.h:#define ROMSB_WORD0 __mk4('-','r','o','m')
linux/romfs_fs.h:#define ROMSB_WORD1 __mk4('1','f','s','-')
linux/romfs_fs.h:/* On-disk "super block" */
linux/romfs_fs.h:#define ROMFH_PAD (ROMFH_SIZE-1)
linux/ethtool.h:				/* For PCI devices, use pci_dev->slot_name. */
linux/ethtool.h:/* wake-on-lan settings */
linux/ethtool.h:	u32	version; /* driver-specific, indicates different chips/revs */
linux/ethtool.h:	/* How many usecs to delay in-memory statistics
linux/ethtool.h:	 * block updates.  Some drivers do not have an in-memory
linux/ethtool.h:	/* If the link is being auto-negotiated (via ethtool_cmd.autoneg
linux/ethtool.h:	 * being true) the user may set 'autonet' here non-zero to have the
linux/ethtool.h:	 * pause parameters be auto-negotiated too.  In such a case, the
linux/ethtool.h:	 * If 'autoneg' is zero or the link is not being auto-negotiated,
linux/ethtool.h:	 * then {rx,tx}_pause force the driver to use/not-use pause
linux/ethtool.h:/* for dumping NIC-specific statistics */
linux/ethtool.h: * &ethtool_ops - Alter and report network device settings
linux/ethtool.h: * get_settings: Get device-specific settings
linux/ethtool.h: * set_settings: Set device-specific settings
linux/ethtool.h: * get_wol: Report whether Wake-on-Lan is enabled
linux/ethtool.h: * set_wol: Turn Wake-on-Lan on or off
linux/ethtool.h: * get_sg: Report whether scatter-gather is enabled
linux/ethtool.h: * set_sg: Turn scatter-gather on or off
linux/ethtool.h: * self_test: Run specified self-tests
linux/ethtool.h:#define ETHTOOL_GWOL		0x00000005 /* Get wake-on-lan options. */
linux/ethtool.h:#define ETHTOOL_SWOL		0x00000006 /* Set wake-on-lan options. */
linux/ethtool.h:#define ETHTOOL_GSG		0x00000018 /* Get scatter-gather enable
linux/ethtool.h:#define ETHTOOL_SSG		0x00000019 /* Set scatter-gather enable
linux/ethtool.h:#define ETHTOOL_TEST		0x0000001a /* execute NIC self-test. */
linux/ethtool.h:#define ETHTOOL_GSTATS		0x0000001d /* get NIC-specific statistics */
linux/ethtool.h:/* Wake-On-Lan options. */
linux/pipe_fs_i.h:#define PIPE_WAIT(inode)	(&(inode).i_pipe->wait)
linux/pipe_fs_i.h:#define PIPE_BASE(inode)	((inode).i_pipe->base)
linux/pipe_fs_i.h:#define PIPE_START(inode)	((inode).i_pipe->start)
linux/pipe_fs_i.h:#define PIPE_LEN(inode)		((inode).i_pipe->len)
linux/pipe_fs_i.h:#define PIPE_READERS(inode)	((inode).i_pipe->readers)
linux/pipe_fs_i.h:#define PIPE_WRITERS(inode)	((inode).i_pipe->writers)
linux/pipe_fs_i.h:#define PIPE_WAITING_READERS(inode)	((inode).i_pipe->waiting_readers)
linux/pipe_fs_i.h:#define PIPE_WAITING_WRITERS(inode)	((inode).i_pipe->waiting_writers)
linux/pipe_fs_i.h:#define PIPE_RCOUNTER(inode)	((inode).i_pipe->r_counter)
linux/pipe_fs_i.h:#define PIPE_WCOUNTER(inode)	((inode).i_pipe->w_counter)
linux/pipe_fs_i.h:#define PIPE_FREE(inode)	(PIPE_SIZE - PIPE_LEN(inode))
linux/pipe_fs_i.h:#define PIPE_END(inode)	((PIPE_START(inode) + PIPE_LEN(inode)) & (PIPE_SIZE-1))
linux/pipe_fs_i.h:#define PIPE_MAX_RCHUNK(inode)	(PIPE_SIZE - PIPE_START(inode))
linux/pipe_fs_i.h:#define PIPE_MAX_WCHUNK(inode)	(PIPE_SIZE - PIPE_END(inode))
linux/if_tr.h: *		Global definitions for the Token-Ring IEEE 802.5 interface.
linux/if_tr.h:/* IEEE 802.5 Token-Ring magic constants.  The frame sizes omit the preamble
linux/if_tr.h:/* This is an Token-Ring frame header. */
linux/if_tr.h:/* This is an Token-Ring LLC structure */
linux/if_tr.h:/* Token-Ring statistics collection data. */
linux/if_tr.h:	/* detailed Token-Ring errors. See IBM Token-Ring Network
linux/if_tr.h:#define TR_RCF_BROADCAST 0x8000         /* all-routes broadcast */
linux/if_tr.h:#define TR_RCF_LIMITED_BROADCAST 0xC000 /* single-route broadcast */
linux/videodev.h:	/* old, obsolete interface -- dropped in 2.5.x, don't use it */
linux/videodev.h:	/* obsolete -- fops->owner is used instead */
linux/videodev.h:	/* dev->driver_data will be used instead some day.
linux/videodev.h:	/* for videodev.c intenal usage -- please don't touch */
linux/videodev.h:   later can be used for video_device->release() */
linux/videodev.h:	return dev->priv;
linux/videodev.h:	dev->priv = data;
linux/videodev.h:#define VIDEO_CLIP_BITMAP	-1
linux/videodev.h:	unsigned	int frame;		/* Frame (0 - n) for double buffer */
linux/videodev.h:#define 	VIDEO_NO_UNIT	(-1)
linux/videodev.h:#define VIDIOCSWIN		_IOW('v',10, struct video_window)	/* Set the video overlay window - passes clip list for hardware smarts , chromakey etc */
linux/videodev.h:#define VIDIOCSFBUF		_IOW('v',12, struct video_buffer)	/* Set frame buffer - root only */
linux/videodev.h:#define VIDIOCKEY		_IOR('v',13, struct video_key)		/* Video key event - to dev 255 is to all - cuts capture on all DMA windows with this key (0xFFFFFFFF == all) */
linux/videodev.h:#define BASE_VIDIOCPRIVATE	192		/* 192-255 are private */
linux/videodev.h:#define VID_HARDWARE_PLANB	16	/* PowerMac motherboard video-in */
linux/videodev.h: * c-basic-offset: 8
linux/cyclomx.h:*		User-level API definitions.
linux/cyclomx.h:* Copyright:	(c) 1998-2000 Arnaldo Carvalho de Melo
linux/cyclomx.h:	char in_isr;			/* interrupt-in-service flag */
linux/cyclomx.h:	u32 mbox;			/* -> mailbox */
linux/affs_fs_i.h:#define AFFS_AC_MASK		(AFFS_AC_SIZE-1)
linux/affs_fs_i.h:#define AFFS_INODE	(&inode->u.affs_i)
linux/affs_fs_i.h:#define AFFS_DIR	(&dir->u.affs_i)
linux/ftape-header-segment.h: * Copyright (C) 1996-1997 Claus-Justus Heine.
linux/ftape-header-segment.h: * $Source: /home/cvsroot/RT288x_SDK/source/linux-2.4.x/include/ack,v $
linux/ftape-header-segment.h: *      floppy tape cartridge.  For use with the QIC-40/80/3010/3020
linux/ftape-header-segment.h: *      floppy-tape driver "ftape" for Linux.
linux/ftape-header-segment.h:#define FT_REV_LEVEL   5  /* only for QIC-80 since. Rev. L (== 0x0c)         */
linux/ftape-header-segment.h:#define FT_LABEL_SZ   (FT_LABEL_DATE - FT_LABEL)
linux/ftape-header-segment.h:			   * -  failed sector log until byte 2047
linux/ftape-header-segment.h:			   * -  bad sector map in the reamining part of segment
linux/ftape-header-segment.h:			   * -  bad sector map  starts hear
linux/ftape-header-segment.h:#define FT_YEAR(year) ((((year)-FT_YEAR_0)<<FT_YEAR_SHIFT)&FT_YEAR_MASK)
linux/ftape-header-segment.h:	fmt_normal = 2, /*  QIC-80 post Rev. B 205Ft or 307Ft tape    */
linux/ftape-header-segment.h:	fmt_1100ft = 3, /*  QIC-80 post Rev. B 1100Ft tape            */
linux/ftape-header-segment.h:	fmt_var    = 4, /*  QIC-80 post Rev. B variabel length format */
linux/ftape-header-segment.h:	fmt_425ft  = 5, /*  QIC-80 post Rev. B 425Ft tape             */
linux/ftape-header-segment.h:	fmt_big    = 6  /*  QIC-3010/3020 variable length tape with more 
linux/ftape-header-segment.h:#define FT_FSL_SIZE        (2 * FT_SECTOR_SIZE - FT_HEADER_END)
linux/ftape-header-segment.h:	(((((y) - FT_YEAR_0)<<9)&0xfe00) | (((m)<<5)&0x01e0) | ((d)&0x001f))
linux/videotext.h: * Copyright (c) 1994-97 Martin Buck  <martin-2.buck@student.uni-ulm.de>
linux/videotext.h:#define VTXIOCGETINFO  0x7101  /* get version of driver & capabilities of vtx-chipset */
linux/videotext.h:#define VTXIOCCLRPAGE  0x7102  /* clear page-buffer */
linux/videotext.h:#define VTXIOCGETSTAT  0x7105  /* get status of page-buffer */
linux/videotext.h:#define VTXIOCGETPAGE  0x7106  /* get contents of page-buffer */
linux/videotext.h:#define VTXIOCPUTPAGE  0x7108  /* display page on TV-screen */
linux/videotext.h:#define VTXIOCSETDISP  0x7109  /* set TV-mode */
linux/videotext.h:#define VTXIOCPUTSTAT  0x710a  /* set status of TV-output-buffer */
linux/videotext.h:#define VTXIOCCLRCACHE 0x710b  /* clear cache on VTX-interface (if avail.) */
linux/videotext.h:#define VTXIOCSETVIRT  0x710c  /* turn on virtual mode (this disables TV-display) */
linux/videotext.h:	int numpages;				/* number of page-buffers of vtx-chipset */
linux/videotext.h:	int cct_type;				/* type of vtx-chipset (SAA5243, SAA5246, SAA5248 or
linux/videotext.h:	unsigned hamming : 1;		/* hamming-error occurred */
linux/nfs_fs.h: *  OS-specific nfs filesystem definitions and declarations
linux/nfs_fs.h: * Note that at most server->rsize bytes of the cache memory are used.
linux/nfs_fs.h:	return &inode->u.nfs_i;
linux/nfs_fs.h:#define NFS_FH(inode)			(&(inode)->u.nfs_i.fh)
linux/nfs_fs.h:#define NFS_SERVER(inode)		(&(inode)->i_sb->u.nfs_sb.s_server)
linux/nfs_fs.h:#define NFS_CLIENT(inode)		(NFS_SERVER(inode)->client)
linux/nfs_fs.h:#define NFS_PROTO(inode)		(NFS_SERVER(inode)->rpc_ops)
linux/nfs_fs.h:#define NFS_REQUESTLIST(inode)		(NFS_SERVER(inode)->rw_requests)
linux/nfs_fs.h:#define NFS_COOKIEVERF(inode)		((inode)->u.nfs_i.cookieverf)
linux/nfs_fs.h:#define NFS_READTIME(inode)		((inode)->u.nfs_i.read_cache_jiffies)
linux/nfs_fs.h:#define NFS_MTIME_UPDATE(inode)		((inode)->u.nfs_i.cache_mtime_jiffies)
linux/nfs_fs.h:#define NFS_CACHE_CTIME(inode)		((inode)->u.nfs_i.read_cache_ctime)
linux/nfs_fs.h:#define NFS_CACHE_MTIME(inode)		((inode)->u.nfs_i.read_cache_mtime)
linux/nfs_fs.h:#define NFS_CACHE_ISIZE(inode)		((inode)->u.nfs_i.read_cache_isize)
linux/nfs_fs.h:#define NFS_NEXTSCAN(inode)		((inode)->u.nfs_i.nextscan)
linux/nfs_fs.h:	NFS_READTIME(inode) = jiffies - NFS_MAXATTRTIMEO(inode) - 1; \
linux/nfs_fs.h:#define NFS_ATTRTIMEO(inode)		((inode)->u.nfs_i.attrtimeo)
linux/nfs_fs.h:	(S_ISDIR(inode->i_mode)? NFS_SERVER(inode)->acdirmin \
linux/nfs_fs.h:			       : NFS_SERVER(inode)->acregmin)
linux/nfs_fs.h:	(S_ISDIR(inode->i_mode)? NFS_SERVER(inode)->acdirmax \
linux/nfs_fs.h:			       : NFS_SERVER(inode)->acregmax)
linux/nfs_fs.h:#define NFS_ATTRTIMEO_UPDATE(inode)	((inode)->u.nfs_i.attrtimeo_timestamp)
linux/nfs_fs.h:#define NFS_FLAGS(inode)		((inode)->u.nfs_i.flags)
linux/nfs_fs.h:#define NFS_FILEID(inode)		((inode)->u.nfs_i.fileid)
linux/nfs_fs.h:	return ((loff_t)page->index) << PAGE_CACHE_SHIFT;
linux/nfs_fs.h:	return page->index;
linux/nfs_fs.h:		cred = (struct rpc_cred *)file->private_data;
linux/nfs_fs.h:	if (cred && cred->cr_magic != RPCAUTH_CRED_MAGIC)
linux/nfs_fs.h:	return !list_empty(&inode->u.nfs_i.read);
linux/nfs_fs.h:	return !list_empty(&inode->u.nfs_i.writeback);
linux/nfs_fs.h: * Write back all requests on one page - we do this before reading it.
linux/nfs_fs.h:#define NFS_SetPageSync(page)		set_bit(PG_fs_1, &(page)->flags)
linux/nfs_fs.h:#define NFS_ClearPageSync(page)		clear_bit(PG_fs_1, &(page)->flags)
linux/nfs_fs.h:#define NFS_TestClearPageSync(page)	test_and_clear_bit(PG_fs_1, &(page)->flags)
linux/nfs_fs.h:		return NFS_STALE(inode) ? -ESTALE : 0;
linux/nfs_fs.h:	if ((fattr->valid & NFS_ATTR_FATTR) == 0)
linux/nfs_fs.h:	if ((fattr->valid & NFS_ATTR_FATTR) && !(fattr->valid & NFS_ATTR_WCC)) {
linux/nfs_fs.h:		fattr->pre_size  = NFS_CACHE_ISIZE(inode);
linux/nfs_fs.h:		fattr->pre_mtime = NFS_CACHE_MTIME(inode);
linux/nfs_fs.h:		fattr->pre_ctime = NFS_CACHE_CTIME(inode);
linux/nfs_fs.h:		fattr->valid |= NFS_ATTR_WCC;
linux/nfs_fs.h:	loff_t maxsz = (((loff_t) ULONG_MAX) << PAGE_CACHE_SHIFT) + PAGE_CACHE_SIZE - 1;
linux/nfs_fs.h:		ino ^= fileid >> (sizeof(u64)-sizeof(ino_t)) * 8;
linux/nfs_fs.h:	if (clnt->cl_intr) {						\
linux/nfs_fs.h:	if (task->tk_status != -EJUKEBOX)
linux/nfs_fs.h:	task->tk_status = 0;
linux/sc26198.h: *	sc26198.h  -- SC26198 UART hardware info.
linux/sc26198.h: *	Copyright (C) 1995-1998  Stallion Technologies
linux/inetdevice.h:#define IN_DEV_FORWARD(in_dev)		((in_dev)->cnf.forwarding)
linux/inetdevice.h:#define IN_DEV_MFORWARD(in_dev)		(ipv4_devconf.mc_forwarding && (in_dev)->cnf.mc_forwarding)
linux/inetdevice.h:#define IN_DEV_RPFILTER(in_dev)		(ipv4_devconf.rp_filter && (in_dev)->cnf.rp_filter)
linux/inetdevice.h:#define IN_DEV_SOURCE_ROUTE(in_dev)	(ipv4_devconf.accept_source_route && (in_dev)->cnf.accept_source_route)
linux/inetdevice.h:#define IN_DEV_BOOTP_RELAY(in_dev)	(ipv4_devconf.bootp_relay && (in_dev)->cnf.bootp_relay)
linux/inetdevice.h:#define IN_DEV_LOG_MARTIANS(in_dev)	(ipv4_devconf.log_martians || (in_dev)->cnf.log_martians)
linux/inetdevice.h:#define IN_DEV_PROXY_ARP(in_dev)	(ipv4_devconf.proxy_arp || (in_dev)->cnf.proxy_arp)
linux/inetdevice.h:#define IN_DEV_SHARED_MEDIA(in_dev)	(ipv4_devconf.shared_media || (in_dev)->cnf.shared_media)
linux/inetdevice.h:#define IN_DEV_TX_REDIRECTS(in_dev)	(ipv4_devconf.send_redirects || (in_dev)->cnf.send_redirects)
linux/inetdevice.h:#define IN_DEV_SEC_REDIRECTS(in_dev)	(ipv4_devconf.secure_redirects || (in_dev)->cnf.secure_redirects)
linux/inetdevice.h:#define IN_DEV_IDTAG(in_dev)		((in_dev)->cnf.tag)
linux/inetdevice.h:#define IN_DEV_MEDIUM_ID(in_dev)	((in_dev)->cnf.medium_id)
linux/inetdevice.h:	  (ipv4_devconf.accept_redirects && (in_dev)->cnf.accept_redirects)) \
linux/inetdevice.h:	  (ipv4_devconf.accept_redirects || (in_dev)->cnf.accept_redirects)))
linux/inetdevice.h:#define IN_DEV_ARPFILTER(in_dev)	(ipv4_devconf.arp_filter || (in_dev)->cnf.arp_filter)
linux/inetdevice.h:#define IN_DEV_ARP_ANNOUNCE(in_dev)	(max(ipv4_devconf.arp_announce, (in_dev)->cnf.arp_announce))
linux/inetdevice.h:#define IN_DEV_ARP_IGNORE(in_dev)	(max(ipv4_devconf.arp_ignore, (in_dev)->cnf.arp_ignore))
linux/inetdevice.h:	return !((addr^ifa->ifa_address)&ifa->ifa_mask);
linux/inetdevice.h:  for (ifa = (in_dev)->ifa_list; ifa && !(ifa->ifa_flags&IFA_F_SECONDARY); ifa = ifa->ifa_next)
linux/inetdevice.h:  for (ifa = (in_dev)->ifa_list; ifa; ifa = ifa->ifa_next)
linux/inetdevice.h:	in_dev = dev->ip_ptr;
linux/inetdevice.h:		atomic_inc(&in_dev->refcnt);
linux/inetdevice.h:	return (struct in_device*)dev->ip_ptr;
linux/inetdevice.h:	if (atomic_dec_and_test(&idev->refcnt))
linux/inetdevice.h:#define __in_dev_put(idev)  atomic_dec(&(idev)->refcnt)
linux/inetdevice.h:#define in_dev_hold(idev)   atomic_inc(&(idev)->refcnt)
linux/inetdevice.h:		return htonl(~((1<<(32-logmask))-1));
linux/inetdevice.h:	return 32 - ffz(~mask);
linux/fd1772.h:** WD1772 stuff - originally from the M68K Linux
linux/fd1772.h:#define FDC1772CMD_RESTORE  (0x00)   /*  -                   */
linux/fd1772.h:#define FDC1772CMD_STOT     (0x60)   /*  -                   */
linux/fd1772.h:#define FDC1772CMD_RDSEC    (0x80)   /*  -   TYP 2 Commands  */
linux/fd1772.h:#define FDC1772CMD_WRSEC    (0xa0)   /*  -          "        */
linux/fd1772.h:#define FDC1772CMD_RDADR    (0xc0)   /*  -                   */
linux/fd1772.h:#define FDC1772CMD_WRTRA    (0xf0)   /*  -                   */
linux/fd1772.h:#define FDC1772CMD_FORCI    (0xd0)   /*  -   TYP 4 Command   */
linux/fd1772.h:#define FDC1772CMDADD_H     (0x08)   /* wait for spin-up */
linux/fd1772.h:/* PSG Port A Bit Nr 0 .. Side Sel .. 0 -> Side 1  1 -> Side 2 */
linux/reiserfs_fs.h: * Copyright 1996-2002 Hans Reiser, see reiserfs/README for licensing and copyright details
linux/reiserfs_fs.h:#define _ROUND_UP(x,n) (((x)+(n)-1u) & ~((n)-1u))
linux/reiserfs_fs.h:		  in_interrupt() ? -1 : current -> pid, __LINE__ , __FUNCTION__ , ##args )
linux/reiserfs_fs.h: * Structure of super block on disk, a version of which in RAM is often accessed as s->u.reiserfs_sb.s_rs
linux/reiserfs_fs.h:				    * umounted, to 2 - when not */    
linux/reiserfs_fs.h:				    * with non-standard journal */
linux/reiserfs_fs.h:				    * making fs with non-standard journal */	
linux/reiserfs_fs.h:    __u32 s_flags;                  /* Right now used only by inode-attributes, if enabled */
linux/reiserfs_fs.h:// on-disk super block fields converted to cpu form
linux/reiserfs_fs.h:#define SB_DISK_SUPER_BLOCK(s) ((s)->u.reiserfs_sb.s_rs)
linux/reiserfs_fs.h:#define SB_V1_DISK_SUPER_BLOCK(s) (&(SB_DISK_SUPER_BLOCK(s)->s_v1))
linux/reiserfs_fs.h:        le32_to_cpu ((SB_V1_DISK_SUPER_BLOCK(s)->s_blocksize))
linux/reiserfs_fs.h:        le32_to_cpu ((SB_V1_DISK_SUPER_BLOCK(s)->s_block_count))
linux/reiserfs_fs.h:        le32_to_cpu ((SB_V1_DISK_SUPER_BLOCK(s)->s_free_blocks))
linux/reiserfs_fs.h:        (SB_V1_DISK_SUPER_BLOCK(s)->s_magic)
linux/reiserfs_fs.h:        le32_to_cpu ((SB_V1_DISK_SUPER_BLOCK(s)->s_root_block))
linux/reiserfs_fs.h:        le16_to_cpu ((SB_V1_DISK_SUPER_BLOCK(s)->s_tree_height))
linux/reiserfs_fs.h:        le16_to_cpu ((SB_V1_DISK_SUPER_BLOCK(s)->s_umount_state))
linux/reiserfs_fs.h:#define SB_VERSION(s) le16_to_cpu ((SB_V1_DISK_SUPER_BLOCK(s)->s_version))
linux/reiserfs_fs.h:#define SB_BMAP_NR(s) le16_to_cpu ((SB_V1_DISK_SUPER_BLOCK(s)->s_bmap_nr))
linux/reiserfs_fs.h:   do { SB_V1_DISK_SUPER_BLOCK(s)->s_block_count = cpu_to_le32(val); } while (0)
linux/reiserfs_fs.h:   do { SB_V1_DISK_SUPER_BLOCK(s)->s_free_blocks = cpu_to_le32(val); } while (0)
linux/reiserfs_fs.h:   do { SB_V1_DISK_SUPER_BLOCK(s)->s_root_block = cpu_to_le32(val); } while (0)
linux/reiserfs_fs.h:   do { SB_V1_DISK_SUPER_BLOCK(s)->s_tree_height = cpu_to_le16(val); } while (0)
linux/reiserfs_fs.h:   do { SB_V1_DISK_SUPER_BLOCK(s)->s_umount_state = cpu_to_le16(val); } while (0) 
linux/reiserfs_fs.h:   do { SB_V1_DISK_SUPER_BLOCK(s)->s_version = cpu_to_le16(val); } while (0)
linux/reiserfs_fs.h:   do { SB_V1_DISK_SUPER_BLOCK(s)->s_bmap_nr = cpu_to_le16 (val); } while (0)
linux/reiserfs_fs.h:#define SB_ONDISK_JP(s) (&SB_V1_DISK_SUPER_BLOCK(s)->s_journal)
linux/reiserfs_fs.h:         le32_to_cpu ((SB_ONDISK_JP(s)->jp_journal_size))
linux/reiserfs_fs.h:         le32_to_cpu ((SB_ONDISK_JP(s)->jp_journal_1st_block))
linux/reiserfs_fs.h:         le32_to_cpu ((SB_ONDISK_JP(s)->jp_journal_dev))
linux/reiserfs_fs.h:         le32_to_cpu ((SB_V1_DISK_SUPER_BLOCK(s)->s_reserved_for_journal))
linux/reiserfs_fs.h:   platform, or code will break.  -Hans */
linux/reiserfs_fs.h:/* the spot for the super in versions 3.5 - 3.5.10 (inclusive) */
linux/reiserfs_fs.h:#define REPEAT_SEARCH -1
linux/reiserfs_fs.h:#define IO_ERROR      -2
linux/reiserfs_fs.h:#define NO_DISK_SPACE -3
linux/reiserfs_fs.h:#define NO_BALANCING_NEEDED  (-4)
linux/reiserfs_fs.h:#define NO_MORE_UNUSED_CONTIGUOUS_BLOCKS (-5)
linux/reiserfs_fs.h:    (((inode)->u.reiserfs_i.i_flags & i_item_key_version_mask) ? KEY_FORMAT_3_6 : KEY_FORMAT_3_5)
linux/reiserfs_fs.h:                (inode)->u.reiserfs_i.i_flags |= i_item_key_version_mask;      \
linux/reiserfs_fs.h:                (inode)->u.reiserfs_i.i_flags &= ~i_item_key_version_mask; })
linux/reiserfs_fs.h:    (((inode)->u.reiserfs_i.i_flags & i_stat_data_version_mask) ? STAT_DATA_V2 : STAT_DATA_V1)
linux/reiserfs_fs.h:                (inode)->u.reiserfs_i.i_flags |= i_stat_data_version_mask;     \
linux/reiserfs_fs.h:                (inode)->u.reiserfs_i.i_flags &= ~i_stat_data_version_mask; })
linux/reiserfs_fs.h:   non-intuitive, but it helps to understand it if you consider that the
linux/reiserfs_fs.h:   non-linear disk access that is significant as a percentage of total
linux/reiserfs_fs.h:   -Hans */
linux/reiserfs_fs.h:    tmp->linear = le64_to_cpu(tmp->linear);
linux/reiserfs_fs.h:    tmp->offset_v2.k_type = type;
linux/reiserfs_fs.h:    tmp->linear = cpu_to_le64(tmp->linear);
linux/reiserfs_fs.h:    tmp->linear = le64_to_cpu(tmp->linear);
linux/reiserfs_fs.h:    tmp->offset_v2.k_offset = offset;
linux/reiserfs_fs.h:    tmp->linear = cpu_to_le64(tmp->linear);
linux/reiserfs_fs.h:# define offset_v2_k_type(v2)           ((v2)->k_type)
linux/reiserfs_fs.h:# define offset_v2_k_offset(v2)         ((v2)->k_offset)
linux/reiserfs_fs.h:#define SECOND_GREATER -1
linux/reiserfs_fs.h:#define DIRECTORY_NOT_FOUND -1
linux/reiserfs_fs.h:#define REGULAR_FILE_FOUND -2
linux/reiserfs_fs.h:#define DIRECTORY_FOUND -3
linux/reiserfs_fs.h:#define FILE_NOT_FOUND -1
linux/reiserfs_fs.h:#define ih_free_space(ih)            le16_to_cpu((ih)->u.ih_free_space_reserved)
linux/reiserfs_fs.h:#define ih_version(ih)               le16_to_cpu((ih)->ih_version)
linux/reiserfs_fs.h:#define ih_entry_count(ih)           le16_to_cpu((ih)->u.ih_entry_count)
linux/reiserfs_fs.h:#define ih_location(ih)              le16_to_cpu((ih)->ih_item_location)
linux/reiserfs_fs.h:#define ih_item_len(ih)              le16_to_cpu((ih)->ih_item_len)
linux/reiserfs_fs.h:#define put_ih_free_space(ih, val)   do { (ih)->u.ih_free_space_reserved = cpu_to_le16(val); } while(0)
linux/reiserfs_fs.h:#define put_ih_version(ih, val)      do { (ih)->ih_version = cpu_to_le16(val); } while (0)
linux/reiserfs_fs.h:#define put_ih_entry_count(ih, val)  do { (ih)->u.ih_entry_count = cpu_to_le16(val); } while (0)
linux/reiserfs_fs.h:#define put_ih_location(ih, val)     do { (ih)->ih_item_location = cpu_to_le16(val); } while (0)
linux/reiserfs_fs.h:#define put_ih_item_len(ih, val)     do { (ih)->ih_item_len = cpu_to_le16(val); } while (0)
linux/reiserfs_fs.h:	    reiserfs_warning(NULL, "vs-500: unknown uniqueness %d\n", uniqueness);
linux/reiserfs_fs.h:	    reiserfs_warning(NULL, "vs-501: unknown type %d\n", type);
linux/reiserfs_fs.h:        le32_to_cpu( key->u.k_offset_v1.k_offset ) :
linux/reiserfs_fs.h:	offset_v2_k_offset( &(key->u.k_offset_v2) );
linux/reiserfs_fs.h:    return le_key_k_offset (ih_version (ih), &(ih->ih_key));
linux/reiserfs_fs.h:        uniqueness2type( le32_to_cpu( key->u.k_offset_v1.k_uniqueness)) :
linux/reiserfs_fs.h:	offset_v2_k_type( &(key->u.k_offset_v2) );
linux/reiserfs_fs.h:    return le_key_k_type (ih_version (ih), &(ih->ih_key));
linux/reiserfs_fs.h:        (key->u.k_offset_v1.k_offset = cpu_to_le32 (offset)) : /* jdm check */
linux/reiserfs_fs.h:	(set_offset_v2_k_offset( &(key->u.k_offset_v2), offset ));
linux/reiserfs_fs.h:    set_le_key_k_offset (ih_version (ih), &(ih->ih_key), offset);
linux/reiserfs_fs.h:        (key->u.k_offset_v1.k_uniqueness = cpu_to_le32(type2uniqueness(type))):
linux/reiserfs_fs.h:	(set_offset_v2_k_type( &(key->u.k_offset_v2), type ));
linux/reiserfs_fs.h:    set_le_key_k_type (ih_version (ih), &(ih->ih_key), type);
linux/reiserfs_fs.h:#define is_direntry_le_ih(ih) is_direntry_le_key (ih_version (ih), &((ih)->ih_key))
linux/reiserfs_fs.h:#define is_direct_le_ih(ih) is_direct_le_key (ih_version (ih), &((ih)->ih_key))
linux/reiserfs_fs.h:#define is_indirect_le_ih(ih) is_indirect_le_key (ih_version(ih), &((ih)->ih_key))
linux/reiserfs_fs.h:#define is_statdata_le_ih(ih) is_statdata_le_key (ih_version (ih), &((ih)->ih_key))
linux/reiserfs_fs.h:    return (key->version == KEY_FORMAT_3_5) ?
linux/reiserfs_fs.h:        key->on_disk_key.u.k_offset_v1.k_offset :
linux/reiserfs_fs.h:	key->on_disk_key.u.k_offset_v2.k_offset;
linux/reiserfs_fs.h:    return (key->version == KEY_FORMAT_3_5) ?
linux/reiserfs_fs.h:        uniqueness2type (key->on_disk_key.u.k_offset_v1.k_uniqueness) :
linux/reiserfs_fs.h:	key->on_disk_key.u.k_offset_v2.k_type;
linux/reiserfs_fs.h:    (key->version == KEY_FORMAT_3_5) ?
linux/reiserfs_fs.h:        (key->on_disk_key.u.k_offset_v1.k_offset = offset) :
linux/reiserfs_fs.h:	(key->on_disk_key.u.k_offset_v2.k_offset = offset);
linux/reiserfs_fs.h:    (key->version == KEY_FORMAT_3_5) ?
linux/reiserfs_fs.h:        (key->on_disk_key.u.k_offset_v1.k_uniqueness = type2uniqueness (type)):
linux/reiserfs_fs.h:	(key->on_disk_key.u.k_offset_v2.k_type = type);
linux/reiserfs_fs.h:    if (key->version == KEY_FORMAT_3_5)
linux/reiserfs_fs.h:	key->on_disk_key.u.k_offset_v1.k_offset --;
linux/reiserfs_fs.h:	key->on_disk_key.u.k_offset_v2.k_offset --;
linux/reiserfs_fs.h:#define is_direntry_cpu_ih(ih) (is_direntry_cpu_key (&((ih)->ih_key)))
linux/reiserfs_fs.h:#define is_direct_cpu_ih(ih) (is_direct_cpu_key (&((ih)->ih_key)))
linux/reiserfs_fs.h:#define is_indirect_cpu_ih(ih) (is_indirect_cpu_key (&((ih)->ih_key)))
linux/reiserfs_fs.h:#define is_statdata_cpu_ih(ih) (is_statdata_cpu_key (&((ih)->ih_key)))
linux/reiserfs_fs.h:#define MAX_ITEM_LEN(block_size) (block_size - BLKH_SIZE - IH_SIZE)
linux/reiserfs_fs.h: * |Block |  Object-Item  |      F r e e      |  Objects- |
linux/reiserfs_fs.h:#define blkh_level(p_blkh)            (le16_to_cpu((p_blkh)->blk_level))
linux/reiserfs_fs.h:#define blkh_nr_item(p_blkh)          (le16_to_cpu((p_blkh)->blk_nr_item))
linux/reiserfs_fs.h:#define blkh_free_space(p_blkh)       (le16_to_cpu((p_blkh)->blk_free_space))
linux/reiserfs_fs.h:#define blkh_reserved(p_blkh)         (le16_to_cpu((p_blkh)->blk_reserved))
linux/reiserfs_fs.h:#define set_blkh_level(p_blkh,val)    ((p_blkh)->blk_level = cpu_to_le16(val))
linux/reiserfs_fs.h:#define set_blkh_nr_item(p_blkh,val)  ((p_blkh)->blk_nr_item = cpu_to_le16(val))
linux/reiserfs_fs.h:#define set_blkh_free_space(p_blkh,val) ((p_blkh)->blk_free_space = cpu_to_le16(val))
linux/reiserfs_fs.h:#define set_blkh_reserved(p_blkh,val) ((p_blkh)->blk_reserved = cpu_to_le16(val))
linux/reiserfs_fs.h:#define blkh_right_delim_key(p_blkh)  ((p_blkh)->blk_right_delim_key)
linux/reiserfs_fs.h:#define set_blkh_right_delim_key(p_blkh,val)  ((p_blkh)->blk_right_delim_key = val)
linux/reiserfs_fs.h:#define B_BLK_HEAD(p_s_bh)            ((struct block_head *)((p_s_bh)->b_data))
linux/reiserfs_fs.h:/* Get right delimiting key. -- little endian */
linux/reiserfs_fs.h:				   policy.  Someday.  -Hans */
linux/reiserfs_fs.h:#define sd_v1_mode(sdp)         (le16_to_cpu((sdp)->sd_mode))
linux/reiserfs_fs.h:#define set_sd_v1_mode(sdp,v)   ((sdp)->sd_mode = cpu_to_le16(v))
linux/reiserfs_fs.h:#define sd_v1_nlink(sdp)        (le16_to_cpu((sdp)->sd_nlink))
linux/reiserfs_fs.h:#define set_sd_v1_nlink(sdp,v)  ((sdp)->sd_nlink = cpu_to_le16(v))
linux/reiserfs_fs.h:#define sd_v1_uid(sdp)          (le16_to_cpu((sdp)->sd_uid))
linux/reiserfs_fs.h:#define set_sd_v1_uid(sdp,v)    ((sdp)->sd_uid = cpu_to_le16(v))
linux/reiserfs_fs.h:#define sd_v1_gid(sdp)          (le16_to_cpu((sdp)->sd_gid))
linux/reiserfs_fs.h:#define set_sd_v1_gid(sdp,v)    ((sdp)->sd_gid = cpu_to_le16(v))
linux/reiserfs_fs.h:#define sd_v1_size(sdp)         (le32_to_cpu((sdp)->sd_size))
linux/reiserfs_fs.h:#define set_sd_v1_size(sdp,v)   ((sdp)->sd_size = cpu_to_le32(v))
linux/reiserfs_fs.h:#define sd_v1_atime(sdp)        (le32_to_cpu((sdp)->sd_atime))
linux/reiserfs_fs.h:#define set_sd_v1_atime(sdp,v)  ((sdp)->sd_atime = cpu_to_le32(v))
linux/reiserfs_fs.h:#define sd_v1_mtime(sdp)        (le32_to_cpu((sdp)->sd_mtime))
linux/reiserfs_fs.h:#define set_sd_v1_mtime(sdp,v)  ((sdp)->sd_mtime = cpu_to_le32(v))
linux/reiserfs_fs.h:#define sd_v1_ctime(sdp)        (le32_to_cpu((sdp)->sd_ctime))
linux/reiserfs_fs.h:#define set_sd_v1_ctime(sdp,v)  ((sdp)->sd_ctime = cpu_to_le32(v))
linux/reiserfs_fs.h:#define sd_v1_rdev(sdp)         (le32_to_cpu((sdp)->u.sd_rdev))
linux/reiserfs_fs.h:#define set_sd_v1_rdev(sdp,v)   ((sdp)->u.sd_rdev = cpu_to_le32(v))
linux/reiserfs_fs.h:#define sd_v1_blocks(sdp)       (le32_to_cpu((sdp)->u.sd_blocks))
linux/reiserfs_fs.h:#define set_sd_v1_blocks(sdp,v) ((sdp)->u.sd_blocks = cpu_to_le32(v))
linux/reiserfs_fs.h:                                (le32_to_cpu((sdp)->sd_first_direct_byte))
linux/reiserfs_fs.h:                                ((sdp)->sd_first_direct_byte = cpu_to_le32(v))
linux/reiserfs_fs.h:/* persistent flag to disable tails on per-file basic.
linux/reiserfs_fs.h:#define sd_v2_mode(sdp)         (le16_to_cpu((sdp)->sd_mode))
linux/reiserfs_fs.h:#define set_sd_v2_mode(sdp,v)   ((sdp)->sd_mode = cpu_to_le16(v))
linux/reiserfs_fs.h:#define sd_v2_nlink(sdp)        (le32_to_cpu((sdp)->sd_nlink))
linux/reiserfs_fs.h:#define set_sd_v2_nlink(sdp,v)  ((sdp)->sd_nlink = cpu_to_le32(v))
linux/reiserfs_fs.h:#define sd_v2_size(sdp)         (le64_to_cpu((sdp)->sd_size))
linux/reiserfs_fs.h:#define set_sd_v2_size(sdp,v)   ((sdp)->sd_size = cpu_to_le64(v))
linux/reiserfs_fs.h:#define sd_v2_uid(sdp)          (le32_to_cpu((sdp)->sd_uid))
linux/reiserfs_fs.h:#define set_sd_v2_uid(sdp,v)    ((sdp)->sd_uid = cpu_to_le32(v))
linux/reiserfs_fs.h:#define sd_v2_gid(sdp)          (le32_to_cpu((sdp)->sd_gid))
linux/reiserfs_fs.h:#define set_sd_v2_gid(sdp,v)    ((sdp)->sd_gid = cpu_to_le32(v))
linux/reiserfs_fs.h:#define sd_v2_atime(sdp)        (le32_to_cpu((sdp)->sd_atime))
linux/reiserfs_fs.h:#define set_sd_v2_atime(sdp,v)  ((sdp)->sd_atime = cpu_to_le32(v))
linux/reiserfs_fs.h:#define sd_v2_mtime(sdp)        (le32_to_cpu((sdp)->sd_mtime))
linux/reiserfs_fs.h:#define set_sd_v2_mtime(sdp,v)  ((sdp)->sd_mtime = cpu_to_le32(v))
linux/reiserfs_fs.h:#define sd_v2_ctime(sdp)        (le32_to_cpu((sdp)->sd_ctime))
linux/reiserfs_fs.h:#define set_sd_v2_ctime(sdp,v)  ((sdp)->sd_ctime = cpu_to_le32(v))
linux/reiserfs_fs.h:#define sd_v2_blocks(sdp)       (le32_to_cpu((sdp)->sd_blocks))
linux/reiserfs_fs.h:#define set_sd_v2_blocks(sdp,v) ((sdp)->sd_blocks = cpu_to_le32(v))
linux/reiserfs_fs.h:#define sd_v2_rdev(sdp)         (le32_to_cpu((sdp)->u.sd_rdev))
linux/reiserfs_fs.h:#define set_sd_v2_rdev(sdp,v)   ((sdp)->u.sd_rdev = cpu_to_le32(v))
linux/reiserfs_fs.h:#define sd_v2_generation(sdp)   (le32_to_cpu((sdp)->u.sd_generation))
linux/reiserfs_fs.h:#define set_sd_v2_generation(sdp,v) ((sdp)->u.sd_generation = cpu_to_le32(v))
linux/reiserfs_fs.h:#define sd_v2_attrs(sdp)         (le16_to_cpu((sdp)->sd_attrs))
linux/reiserfs_fs.h:#define set_sd_v2_attrs(sdp,v)   ((sdp)->sd_attrs = cpu_to_le16(v))
linux/reiserfs_fs.h:   | directory     |N-1| N-2 | ....   |   1st |0th|
linux/reiserfs_fs.h:                    <----   directory entries         ------>
linux/reiserfs_fs.h:#define deh_offset(p_deh)         (le32_to_cpu((p_deh)->deh_offset))
linux/reiserfs_fs.h:#define deh_dir_id(p_deh)         (le32_to_cpu((p_deh)->deh_dir_id))
linux/reiserfs_fs.h:#define deh_objectid(p_deh)       (le32_to_cpu((p_deh)->deh_objectid))
linux/reiserfs_fs.h:#define deh_location(p_deh)       (le16_to_cpu((p_deh)->deh_location))
linux/reiserfs_fs.h:#define deh_state(p_deh)          (le16_to_cpu((p_deh)->deh_state))
linux/reiserfs_fs.h:#define put_deh_offset(p_deh,v)   ((p_deh)->deh_offset = cpu_to_le32((v)))
linux/reiserfs_fs.h:#define put_deh_dir_id(p_deh,v)   ((p_deh)->deh_dir_id = cpu_to_le32((v)))
linux/reiserfs_fs.h:#define put_deh_objectid(p_deh,v) ((p_deh)->deh_objectid = cpu_to_le32((v)))
linux/reiserfs_fs.h:#define put_deh_location(p_deh,v) ((p_deh)->deh_location = cpu_to_le16((v)))
linux/reiserfs_fs.h:#define put_deh_state(p_deh,v)    ((p_deh)->deh_state = cpu_to_le16((v)))
linux/reiserfs_fs.h:/* 64 bit systems (and the S/390) need to be aligned explicitly -jdm */
linux/reiserfs_fs.h:#   define aligned_address(addr)           ((void *)((long)(addr) & ~((1UL << ADDR_UNALIGNED_BITS) - 1)))
linux/reiserfs_fs.h:#   define unaligned_offset(addr)          (((int)((long)(addr) & ((1 << ADDR_UNALIGNED_BITS) - 1))) << 3)
linux/reiserfs_fs.h:#define mark_de_with_sd(deh)        set_bit_unaligned (DEH_Statdata, &((deh)->deh_state))
linux/reiserfs_fs.h:#define mark_de_without_sd(deh)     clear_bit_unaligned (DEH_Statdata, &((deh)->deh_state))
linux/reiserfs_fs.h:#define mark_de_visible(deh)	    set_bit_unaligned (DEH_Visible, &((deh)->deh_state))
linux/reiserfs_fs.h:#define mark_de_hidden(deh)	    clear_bit_unaligned (DEH_Visible, &((deh)->deh_state))
linux/reiserfs_fs.h:#define de_with_sd(deh)		    test_bit_unaligned (DEH_Statdata, &((deh)->deh_state))
linux/reiserfs_fs.h:#define de_visible(deh)	    	    test_bit_unaligned (DEH_Visible, &((deh)->deh_state))
linux/reiserfs_fs.h:#define de_hidden(deh)	    	    !test_bit_unaligned (DEH_Visible, &((deh)->deh_state))
linux/reiserfs_fs.h:#define B_I_PITEM(bh,ih) ( (bh)->b_data + ih_location(ih) )
linux/reiserfs_fs.h:   calculates length of i-th directory entry using directory entry
linux/reiserfs_fs.h:   locations from dir entry head. When it calculates length of 0-th
linux/reiserfs_fs.h:   location of the non-existent following entry in the calculation.
linux/reiserfs_fs.h:((i) ? (deh_location((deh)-1) - deh_location((deh))) : (ih_item_len((ih)) - deh_location((deh))))
linux/reiserfs_fs.h:	return deh_location(deh-1) - deh_location(deh);
linux/reiserfs_fs.h:    return ih_item_len(ih) - deh_location(deh);
linux/reiserfs_fs.h:#define B_I_E_NAME(bh,ih,entry_num) ((char *)(bh->b_data + ih_location(ih) + deh_location(B_I_DEH(bh,ih)+(entry_num))))
linux/reiserfs_fs.h:(I_DEH_N_ENTRY_LENGTH (ih, deh, entry_num) - (de_with_sd (deh) ? SD_SIZE : 0))
linux/reiserfs_fs.h:#define dc_block_number(dc_p)	(le32_to_cpu((dc_p)->dc_block_number))
linux/reiserfs_fs.h:#define dc_size(dc_p)		(le16_to_cpu((dc_p)->dc_size))
linux/reiserfs_fs.h:#define put_dc_block_number(dc_p, val)   do { (dc_p)->dc_block_number = cpu_to_le32(val); } while(0)
linux/reiserfs_fs.h:#define put_dc_size(dc_p, val)   do { (dc_p)->dc_size = cpu_to_le16(val); } while(0)
linux/reiserfs_fs.h:((p_s_bh)->b_data+BLKH_SIZE+B_NR_ITEMS(p_s_bh)*KEY_SIZE+DC_SIZE*(n_pos)))
linux/reiserfs_fs.h:#define MAX_CHILD_SIZE(bh) ((int)( (bh)->b_size - BLKH_SIZE ))
linux/reiserfs_fs.h:#define B_CHILD_SIZE(cur) (MAX_CHILD_SIZE(cur)-(B_FREE_SPACE(cur)))
linux/reiserfs_fs.h:#define MAX_NR_KEY(bh) ( (MAX_CHILD_SIZE(bh)-DC_SIZE)/(KEY_SIZE+DC_SIZE) )
linux/reiserfs_fs.h:#define ILLEGAL_PATH_ELEMENT_OFFSET 1 /* Must be equal to FIRST_PATH_ELEMENT_OFFSET - 1 */
linux/reiserfs_fs.h:excessive effort to avoid disturbing the precious VFS code.:-( The
linux/reiserfs_fs.h:#define pos_in_item(path) ((path)->pos_in_item)
linux/reiserfs_fs.h:#define PATH_OFFSET_PELEMENT(p_s_path,n_offset)  ((p_s_path)->path_elements +(n_offset))
linux/reiserfs_fs.h:#define PATH_OFFSET_PBUFFER(p_s_path,n_offset)   (PATH_OFFSET_PELEMENT(p_s_path,n_offset)->pe_buffer)
linux/reiserfs_fs.h:#define PATH_OFFSET_POSITION(p_s_path,n_offset) (PATH_OFFSET_PELEMENT(p_s_path,n_offset)->pe_position)
linux/reiserfs_fs.h:#define PATH_PLAST_BUFFER(p_s_path) (PATH_OFFSET_PBUFFER((p_s_path), (p_s_path)->path_length))
linux/reiserfs_fs.h:                                   dumping paths... -Hans */
linux/reiserfs_fs.h:#define PATH_LAST_POSITION(p_s_path) (PATH_OFFSET_POSITION((p_s_path), (p_s_path)->path_length))
linux/reiserfs_fs.h:#define PATH_H_PBUFFER(p_s_path, h) PATH_OFFSET_PBUFFER (p_s_path, p_s_path->path_length - (h))	/* tb->S[h] */
linux/reiserfs_fs.h:#define PATH_H_PPARENT(path, h) PATH_H_PBUFFER (path, (h) + 1)			/* tb->F[h] or tb->S[0]->b_parent */
linux/reiserfs_fs.h:#define PATH_H_POSITION(path, h) PATH_OFFSET_POSITION (path, path->path_length - (h))	
linux/reiserfs_fs.h:#define PATH_H_B_ITEM_ORDER(path, h) PATH_H_POSITION(path, h + 1)		/* tb->S[h]->b_item_order */
linux/reiserfs_fs.h:#define PATH_H_PATH_OFFSET(p_s_path, n_h) ((p_s_path)->path_length - (n_h))
linux/reiserfs_fs.h:// in in-core inode key is stored on le form
linux/reiserfs_fs.h:#define INODE_PKEY(inode) ((struct key *)((inode)->u.reiserfs_i.i_key))
linux/reiserfs_fs.h:// reiserfs version 2 has max offset 60 bits. Version 1 - 32 bit offset
linux/reiserfs_fs.h:#define REISERFS_LINK_MAX (MAX_US_INT - 1000)
linux/reiserfs_fs.h:#define fs_generation(s) ((s)->u.reiserfs_sb.s_generation_counter)
linux/reiserfs_fs.h:#define FILESYSTEM_CHANGED_TB(tb)  (get_generation((tb)->tb_sb) != (tb)->fs_gen)
linux/reiserfs_fs.h:  /* if -1 then nothing will be partially shifted */
linux/reiserfs_fs.h:  /* if -1 then nothing will be partially shifted                           */
linux/reiserfs_fs.h:				 another low-level subsystem */
linux/reiserfs_fs.h:+-------------------+------------+--------------+------------+
linux/reiserfs_fs.h:+-------------------+------------+--------------+------------+
linux/reiserfs_fs.h:+-------------------+------------+--------------+------------+
linux/reiserfs_fs.h:+-------------------+------------+--------------+------------+
linux/reiserfs_fs.h:+-------------------+------------+--------------+------------+
linux/reiserfs_fs.h:+-------------------+------------+--------------+------------+
linux/reiserfs_fs.h:#define op_bytes_number(ih,bsize)                    item_ops[le_ih_k_type (ih)]->bytes_number (ih, bsize)
linux/reiserfs_fs.h:#define op_is_left_mergeable(key,bsize)              item_ops[le_key_k_type (le_key_version (key), key)]->is_left_mergeable (key, bsize)
linux/reiserfs_fs.h:#define op_print_item(ih,item)                       item_ops[le_ih_k_type (ih)]->print_item (ih, item)
linux/reiserfs_fs.h:#define op_check_item(ih,item)                       item_ops[le_ih_k_type (ih)]->check_item (ih, item)
linux/reiserfs_fs.h:#define op_create_vi(vn,vi,is_affected,insert_size)  item_ops[le_ih_k_type ((vi)->vi_ih)]->create_vi (vn,vi,is_affected,insert_size)
linux/reiserfs_fs.h:#define op_check_left(vi,free,start_skip,end_skip) item_ops[(vi)->vi_index]->check_left (vi, free, start_skip, end_skip)
linux/reiserfs_fs.h:#define op_check_right(vi,free)                      item_ops[(vi)->vi_index]->check_right (vi, free)
linux/reiserfs_fs.h:#define op_part_size(vi,from,to)                     item_ops[(vi)->vi_index]->part_size (vi, from, to)
linux/reiserfs_fs.h:#define op_unit_num(vi)				     item_ops[(vi)->vi_index]->unit_num (vi)
linux/reiserfs_fs.h:#define op_print_vi(vi)                              item_ops[(vi)->vi_index]->print_vi (vi)
linux/reiserfs_fs.h:#define I_POS_UNFM_SIZE(ih,pos,size) (((pos) == I_UNFM_NUM(ih) - 1 ) ? (size) - ih_free_space(ih) : (size))
linux/reiserfs_fs.h:#define B_N_PITEM_HEAD(bh,item_num) ( (struct item_head * )((bh)->b_data + BLKH_SIZE) + (item_num) )
linux/reiserfs_fs.h:#define B_N_PDELIM_KEY(bh,item_num) ( (struct key * )((bh)->b_data + BLKH_SIZE) + (item_num) )
linux/reiserfs_fs.h:#define B_N_PKEY(bh,item_num) ( &(B_N_PITEM_HEAD(bh,item_num)->ih_key) )
linux/reiserfs_fs.h:#define B_N_PITEM(bh,item_num) ( (bh)->b_data + ih_location(B_N_PITEM_HEAD((bh),(item_num))))
linux/reiserfs_fs.h:( (struct stat_data *)((bh)->b_data + ih_location(B_N_PITEM_HEAD((bh),(nr))) ) )
linux/reiserfs_fs.h:/* get stat-data */
linux/reiserfs_fs.h:#define B_I_STAT_DATA(bh, ih) ( (struct stat_data * )((bh)->b_data + ih_location(ih)) )
linux/reiserfs_fs.h:#define MAX_DIRECT_ITEM_LEN(size) ((size) - BLKH_SIZE - 2*IH_SIZE - SD_SIZE - UNFM_P_SIZE)
linux/reiserfs_fs.h:#define JOURNAL_PER_BALANCE_CNT (3 * (MAX_HEIGHT-2) + 9)
linux/reiserfs_fs.h: * function won.  Do not mess with it... -DaveM
linux/reiserfs_fs.h: * sources and are not licensed by Namesys to its non-GPL license customers */
linux/reiserfs_fs.h:	((((dev)<<(JBH_HASH_SHIFT - 6)) ^ ((dev)<<(JBH_HASH_SHIFT - 9))) ^ \
linux/reiserfs_fs.h:	 (((block)<<(JBH_HASH_SHIFT - 6)) ^ ((block) >> 13) ^ ((block) << (JBH_HASH_SHIFT - 12))))
linux/reiserfs_fs.h:#define JOURNAL_BUFFER(j,n) ((j)->j_ap_blocks[((j)->j_start + (n)) % JOURNAL_BLOCK_COUNT])
linux/reiserfs_fs.h:  if (bh && test_bit(BH_JPrepared, &( (struct buffer_head *)bh)->b_state))
linux/reiserfs_fs.h:    return test_bit(BH_JDirty_wait, &( (struct buffer_head *)bh)->b_state) ;
linux/reiserfs_fs.h:    clear_bit(BH_JDirty_wait, &bh->b_state) ;
linux/reiserfs_fs.h:    clear_bit(BH_JNew, &bh->b_state) ;
linux/reiserfs_fs.h:// first key is in cpu form, second - le
linux/reiserfs_fs.h:// get key version from on disk key - kludge
linux/reiserfs_fs.h:    type = offset_v2_k_type( &(key->u.k_offset_v2));
linux/reiserfs_fs.h:#define block_size(inode) ((inode)->i_sb->s_blocksize)
linux/reiserfs_fs.h:#define file_size(inode) ((inode)->i_size)
linux/reiserfs_fs.h:#define tail_size(inode) (file_size (inode) & (block_size (inode) - 1))
linux/reiserfs_fs.h:#define tail_has_to_be_packed(inode) (have_large_tails ((inode)->i_sb)?\
linux/reiserfs_fs.h:!STORE_TAIL_IN_UNFM_S1(file_size (inode), tail_size(inode), block_size (inode)):have_small_tails ((inode)->i_sb)?!STORE_TAIL_IN_UNFM_S2(file_size (inode), tail_size(inode), block_size (inode)):0 )
linux/reiserfs_fs.h:#define __PINFO( sb ) ( sb ) -> u.reiserfs_sb.s_proc_info_data
linux/reiserfs_fs.h:        MAX( ( sb ) -> u.reiserfs_sb.s_proc_info_data.field, value )
linux/reiserfs_fs.h:	th:tb->transaction_handle,
linux/reiserfs_fs.h:	path: tb->tb_path,
linux/reiserfs_fs.h:	key: tb->key,
linux/if_strip.h: * if_strip.h --
linux/atalk.h:#define AARP_EXPIRY_TIME	(5*60*HZ)	/* Not specified - how long till we drop a resolved entry */
linux/atalk.h:	return dev->atalk_ptr;
linux/shmem_fs.h:/* inode in-kernel data */
linux/shmem_fs.h: * mm.h, but mm.h is including fs.h via sched .h :-/
linux/shmem_fs.h:#define SHMEM_I(inode)  (&inode->u.shmem_i)
linux/serial167.h: * Events are used to schedule things to happen at timer-interrupt
linux/libata.h:   Copyright 2003-2004 Red Hat, Inc.  All rights reserved.
linux/libata.h:   Copyright 2003-2004 Jeff Garzik
linux/libata.h:   http://www.opensource.org/licenses/osl-1.1.txt and is included herein
linux/libata.h:#include <linux/libata-compat.h>
linux/libata.h: * compile-time options
linux/libata.h:				 * low-level drivers */
linux/libata.h:	ATA_SHT_THIS_ID		= -1,
linux/libata.h:	struct Scsi_Host	*host;	/* our co-allocated scsi host */
linux/libata.h:	return ((dev->class == ATA_DEV_ATA) ||
linux/libata.h:		(dev->class == ATA_DEV_ATAPI));
linux/libata.h:	return ap->ops->check_status(ap);
linux/libata.h:		max--;
linux/libata.h:		unsigned long l = ap->ioaddr.status_addr;
linux/libata.h:	qc->tf.ctl |= ATA_NIEN;
linux/libata.h:		return &ap->qcmd[tag];
linux/libata.h:	tf->ctl = ap->ctl;
linux/libata.h:		tf->device = ATA_DEVICE_OBS;
linux/libata.h:		tf->device = ATA_DEVICE_OBS | ATA_DEV1;
linux/libata.h:	struct ata_ioports *ioaddr = &ap->ioaddr;
linux/libata.h:	ap->ctl &= ~ATA_NIEN;
linux/libata.h:	ap->last_ctl = ap->ctl;
linux/libata.h:	if (ap->flags & ATA_FLAG_MMIO)
linux/libata.h:		writeb(ap->ctl, (void __iomem *) ioaddr->ctl_addr);
linux/libata.h:		outb(ap->ctl, ioaddr->ctl_addr);
linux/libata.h:	ap->ops->irq_clear(ap);
linux/libata.h:	if (ap->flags & ATA_FLAG_MMIO) {
linux/libata.h:		void __iomem *mmio = (void __iomem *) ap->ioaddr.bmdma_addr;
linux/libata.h:		host_stat = inb(ap->ioaddr.bmdma_addr + ATA_DMA_STATUS);
linux/libata.h:		     ap->ioaddr.bmdma_addr + ATA_DMA_STATUS);
linux/libata.h:		post_stat = inb(ap->ioaddr.bmdma_addr + ATA_DMA_STATUS);
linux/libata.h:	return ap->ops->scr_read(ap, reg);
linux/libata.h:	ap->ops->scr_write(ap, reg, val);
linux/libata.h:	return ata_id_wcache_enabled(dev->id) ||
linux/libata.h:	       ata_id_has_flush(dev->id) ||
linux/libata.h:	       ata_id_has_flush_ext(dev->id);
linux/wrapper.h:#define mem_map_reserve(p)	set_bit(PG_reserved, &((p)->flags))
linux/wrapper.h:#define mem_map_unreserve(p)	clear_bit(PG_reserved, &((p)->flags))
linux/gameport.h: *  Copyright (c) 1999-2000 Vojtech Pavlik
linux/gameport.h: * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
linux/gameport.h: * e-mail - mail your message to <vojtech@ucw.cz>, or by paper mail:
linux/gameport.h:	if (gameport->trigger)
linux/gameport.h:		gameport->trigger(gameport);
linux/gameport.h:		outb(0xff, gameport->io);
linux/gameport.h:	if (gameport->read)
linux/gameport.h:		return gameport->read(gameport);
linux/gameport.h:		return inb(gameport->io);
linux/gameport.h:	if (gameport->cooked_read)
linux/gameport.h:		return gameport->cooked_read(gameport, axes, buttons);
linux/gameport.h:		return -1;
linux/gameport.h:	if (gameport->calibrate)
linux/gameport.h:		return gameport->calibrate(gameport, axes, max);
linux/gameport.h:		return -1;
linux/gameport.h:	return (time * gameport->speed) / 1000;
linux/gameport.h:	current->state = TASK_UNINTERRUPTIBLE;
linux/tty_ldisc.h: * 	low-level tty device for transmission, optionally performing
linux/tty_ldisc.h: * 	is not handled by the tty layer or the low-level tty driver.
linux/tty_ldisc.h: * 	layer, (2) tty low-level driver, (3) line discpline.  So a
linux/tty_ldisc.h: * 	low-level driver can "grab" an ioctl request before the line
linux/tty_ldisc.h: * 	This function is called by the low-level tty driver to send
linux/tty_ldisc.h: * 	This function is called by the low-level tty driver to
linux/tty_ldisc.h: * 	The low-level driver must not send more characters than was
linux/tty_ldisc.h: * 	This function is called by the low-level tty driver to signal
linux/tty_ldisc.h: * 	low-level driver for transmission.  If the line discpline does
linux/cciss_ioctl.h:    BYTE  offense_num; //byte # of offense 0-base
linux/efs_fs_i.h:	u_char		di_spare;	/* spare - used by AFS */
linux/amigaffs.h:#define GET_END_PTR(st,p,sz)		 ((st *)((char *)(p)+((sz)-sizeof(st))))
linux/amigaffs.h:#define AFFS_GET_HASHENTRY(data,hashkey) be32_to_cpu(((struct dir_front *)data)->hashtable[hashkey])
linux/amigaffs.h:#define AFFS_BLOCK(sb, bh, blk)		(AFFS_HEAD(bh)->table[(sb)->u.affs_sb.s_hashsize-1-(blk)])
linux/amigaffs.h:	set_blocksize(sb->s_dev, size);
linux/amigaffs.h:	sb->s_blocksize = size;
linux/amigaffs.h:	if (block >= AFFS_SB->s_reserved && block < AFFS_SB->s_partition_size)
linux/amigaffs.h:	if (block >= AFFS_SB->s_reserved && block < AFFS_SB->s_partition_size)
linux/amigaffs.h:	if (block >= AFFS_SB->s_reserved && block < AFFS_SB->s_partition_size) {
linux/amigaffs.h:		memset(bh->b_data, 0 , sb->s_blocksize);
linux/amigaffs.h:	if (block >= AFFS_SB->s_reserved && block < AFFS_SB->s_partition_size) {
linux/amigaffs.h:		pr_debug(KERN_DEBUG "affs_brelse: %ld\n", bh->b_blocknr);
linux/amigaffs.h:	u32 tmp = be32_to_cpu(((u32 *)bh->b_data)[5]);
linux/amigaffs.h:	((u32 *)bh->b_data)[5] = cpu_to_be32(tmp - val);
linux/amigaffs.h:	u32 tmp = be32_to_cpu(((u32 *)bh->b_data)[0]);
linux/amigaffs.h:	((u32 *)bh->b_data)[0] = cpu_to_be32(tmp - val);
linux/amigaffs.h:	down(&AFFS_INODE->i_link_lock);
linux/amigaffs.h:	up(&AFFS_INODE->i_link_lock);
linux/amigaffs.h:	down(&AFFS_INODE->i_hash_lock);
linux/amigaffs.h:	up(&AFFS_INODE->i_hash_lock);
linux/amigaffs.h:	down(&AFFS_INODE->i_ext_lock);
linux/amigaffs.h:	up(&AFFS_INODE->i_ext_lock);
linux/amigaffs.h:#define ST_LINKFILE	-4
linux/amigaffs.h:#define ST_FILE		-3
linux/amigaffs.h:#define AFFS_HEAD(bh)		((struct affs_head *)(bh)->b_data)
linux/amigaffs.h:#define AFFS_TAIL(sb, bh)	((struct affs_tail *)((bh)->b_data+(sb)->s_blocksize-sizeof(struct affs_tail)))
linux/amigaffs.h:#define AFFS_ROOT_HEAD(bh)	((struct affs_root_head *)(bh)->b_data)
linux/amigaffs.h:#define AFFS_ROOT_TAIL(sb, bh)	((struct affs_root_tail *)((bh)->b_data+(sb)->s_blocksize-sizeof(struct affs_root_tail)))
linux/amigaffs.h:#define AFFS_DATA_HEAD(bh)	((struct affs_data_head *)(bh)->b_data)
linux/amigaffs.h:#define AFFS_DATA(bh)		(((struct affs_data_head *)(bh)->b_data)->data)
linux/cache.h:#define L1_CACHE_ALIGN(x) (((x)+(L1_CACHE_BYTES-1))&~(L1_CACHE_BYTES-1))
linux/qic117.h: *      Copyright (C) 1993-1996 Bas Laarhoven,
linux/qic117.h: *                (C) 1997      Claus-Justus Heine.
linux/qic117.h: * $Source: /home/cvsroot/RT288x_SDK/source/linux-2.4.x/include/ack,v $
linux/qic117.h: *      This file contains QIC-117 spec. related definitions for the
linux/qic117.h: *      QIC-40/80/3010/3020 floppy-tape driver "ftape" for Linux.
linux/qic117.h: *      These data were taken from the Quarter-Inch Cartridge
linux/qic117.h: *       document QIC-117 Revision J, 28 Aug 96.
linux/qic117.h: *       Quarter-Inch Cartridge Drive Standards, Inc.
linux/qic117.h: *       Telephone (805) 963-3853
linux/qic117.h: *       Fax       (805) 962-1541
linux/qic117.h: *       QIC-40-MC,   Rev. M,  2 Sep 92.
linux/qic117.h: *       QIC-80-MC,   Rev. N, 20 Mar 96.
linux/qic117.h: *       QIC-80-MC,   Rev. K, 15 Dec 94.
linux/qic117.h: *       QIC-113,     Rev. G, 15 Jun 95.
linux/qic117.h: *       QIC-117,     Rev. J, 28 Aug 96.
linux/qic117.h: *       QIC-122,     Rev. B,  6 Mar 91.
linux/qic117.h: *       QIC-130,     Rev. C,  2 Sep 92.
linux/qic117.h: *       QIC-3010-MC, Rev. F, 14 Jun 95.
linux/qic117.h: *       QIC-3020-MC, Rev. G, 31 Aug 95.
linux/qic117.h: *       QIC-CRF3,    Rev. B, 15 Jun 95.
linux/qic117.h: *      QIC-117 common command set rev. J.
linux/qic117.h:/* commands 19-20: reserved */
linux/qic117.h:/* commands 39-45: reserved */
linux/qic117.h:#define QIC_CONFIG_RATE_4000    0       /* since QIC-117 Rev. J */
linux/qic117.h:#define QIC_CONFIG_80		0x80	/* QIC-80 detected. */
linux/qic117.h:	unsigned int fatal:1;	/* Non-zero if the error is fatal. */
linux/qic117.h:  /*11*/ { "Warning--Read Gain Setting Error", 1, },\
linux/qic117.h:  /*20*/ { "Self-Diagnostic Failed (cannot be cleared)", 1, },\
linux/qic117.h:  /*23*/ { "Motion Time-out Error", 1, },\
linux/qic117.h:  /*24*/ { "Data Segment Too Long -- Logical Forward or Pause", 1, },\
linux/qic117.h:  /*30*/ { "Command Received During Non-Interruptible Process", 1, },\
linux/awe_voice.h: * Copyright (C) 1996-2000 Takashi Iwai
linux/awe_voice.h:/*----------------------------------------------------------------
linux/awe_voice.h: *----------------------------------------------------------------*/
linux/awe_voice.h:/*----------------------------------------------------------------
linux/awe_voice.h: *----------------------------------------------------------------*/
linux/awe_voice.h:/*----------------------------------------------------------------
linux/awe_voice.h: *----------------------------------------------------------------*/
linux/awe_voice.h:	unsigned char filterQ;		/* initial filter Q [0-15] (0x0) */
linux/awe_voice.h:	unsigned char filterQ;		/* initial filter Q [0-15] (0x0) */
linux/awe_voice.h:/*----------------------------------------------------------------*/
linux/awe_voice.h:/*----------------------------------------------------------------
linux/awe_voice.h: *----------------------------------------------------------------*/
linux/awe_voice.h:#define AWE_SAMPLE_SINGLESHOT	8	/* single-shot w/o loop */
linux/awe_voice.h:/*----------------------------------------------------------------
linux/awe_voice.h: *----------------------------------------------------------------*/
linux/awe_voice.h:	int map_bank, map_instr, map_key;	/* key = -1 means all keys */
linux/awe_voice.h:/*----------------------------------------------------------------
linux/awe_voice.h: *----------------------------------------------------------------*/
linux/awe_voice.h:/*----------------------------------------------------------------*/
linux/awe_voice.h:/*----------------------------------------------------------------*/
linux/awe_voice.h:/*----------------------------------------------------------------*/
linux/awe_voice.h:/*----------------------------------------------------------------*/
linux/awe_voice.h:	unsigned short feedback;	/* feedback level (0xE600-0xE6FF) */
linux/awe_voice.h:	unsigned short delay_offset;	/* delay (0-0x0DA3) [1/44100 sec] */
linux/awe_voice.h:	unsigned short lfo_depth;	/* LFO depth (0xBC00-0xBCFF) */
linux/awe_voice.h:	unsigned int delay;	/* right delay (0-0xFFFFFFFF) [1/256/44100 sec] */
linux/awe_voice.h:	unsigned int lfo_freq;		/* LFO freq LFO freq (0-0xFFFFFFFF) */
linux/awe_voice.h:/*----------------------------------------------------------------*/
linux/awe_voice.h:/*----------------------------------------------------------------*/
linux/awe_voice.h:/*23*/	AWE_FX_CHORUS,		/* BYTE: chorus effects send (0-255) */
linux/awe_voice.h:/*24*/	AWE_FX_REVERB,		/* BYTE: reverb effects send (0-255) */
linux/blkpg.h: * For today, only the partition stuff - aeb, 990515
linux/netfilter.h:   <= 0x2000 is used for protocol-flags. */
linux/netfilter.h:	/* Non-inclusive ranges: use 0/0/NULL to never get called. */
linux/netfilter.h:/* Functions to register get/setsockopt ranges (non-inclusive).  You
linux/netfilter.h:   Returns -ERRNO if packet dropped.  Zero means queued, stolen or
linux/netfilter.h:   call in fast path: gcc doesn't inline (needs value tracking?). --RR */
linux/netfilter.h: * seconds to see why.		- Linus
linux/if_shaper.h: *	halving of speed or so. - ie about 20 for 9600 baud.
linux/comstats.h: *	comstats.h  -- Serial Port Stats.
linux/comstats.h: *	Copyright (C) 1996-1998  Stallion Technologies
linux/comstats.h: *	Copyright (C) 1994-1996  Greg Ungerer.
linux/kernel.h: * 'kernel.h' contains some often-used function prototypes etc
linux/kernel.h:#define INT_MIN		(-INT_MAX - 1)
linux/kernel.h:#define LONG_MIN	(-LONG_MAX - 1)
linux/kernel.h:#define	KERN_DEBUG	"<7>"	/* debug-level messages			*/
linux/kernel.h: * strict type-checking.. See the
linux/kernel.h:	char _f[20-2*sizeof(long)-sizeof(int)];	/* Padding: libc5 uses this.. */
linux/atm_nicstar.h: * Driver-specific declarations for use by NICSTAR driver specific utils.
linux/atm_nicstar.h:/* Note: non-kernel programs including this file must also include
linux/synclink.h: * Copyright (C) 1998-2000 by Microgate Corporation
linux/synclink.h:	unsigned short	crc_type;	/* None, CRC16-CCITT, or CRC32-CCITT */
linux/telephony.h: *		(c) Copyright 1999-2001 Quicknet Technologies, Inc.
linux/telephony.h: *  Quicknet Technologies, Inc. - makes low density analog telephony cards
linux/telephony.h:* bits 1-0	Frame Type	Data Rate		Significant Words
linux/dp83840.h: * linux/dp83840.h: definitions for DP83840 MII-compatible transceivers
linux/dp83840.h:#define CSCONFIG_LED4           0x0002  /* Pin for full-dplx LED4      */
linux/dp83840.h:#define CSCONFIG_LED1           0x0004  /* Pin for conn-status LED1    */
linux/dp83840.h:#define CSCONFIG_ENCODE         0x0800  /* 1=MLT-3, 0=binary           */
linux/joystick.h: *  Copyright (C) 1996-2000 Vojtech Pavlik
linux/joystick.h: * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
linux/joystick.h: * e-mail - mail your message to <vojtech@suse.cz>, or by paper mail:
linux/joystick.h:#define JSIOCSBTNMAP		_IOW('j', 0x33, __u16[KEY_MAX - BTN_MISC])	/* set button mapping */
linux/joystick.h:#define JSIOCGBTNMAP		_IOR('j', 0x34, __u16[KEY_MAX - BTN_MISC])	/* get button mapping */
linux/sockios.h: *		Definitions of the socket-level I/O control calls.
linux/sockios.h:/* Linux-specific socket ioctls */
linux/sockios.h:#define SIOCGIFINDEX	0x8933		/* name -> if_index mapping	*/
linux/sockios.h:#define SIOGIFINDEX	SIOCGIFINDEX	/* misprint compatibility :-)	*/
linux/sockios.h:		    /*  0x8950 - 0x8952  * obsolete calls, don't re-use */
linux/sockios.h: *	THESE IOCTLS ARE _DEPRECATED_ AND WILL DISAPPEAR IN 2.5.X -DaveM
linux/apm_bios.h: * Copyright 1994-2001 Stephen Rothwell (sfr@canb.auug.org.au)
linux/scx200_gpio.h:        compile-command: "make -C ../.. bzImage modules"
linux/scx200_gpio.h:        c-basic-offset: 8
linux/nfs_mount.h: *  structure passed from user-space to kernel-space during an nfs mount
linux/nfs_mount.h: * mount-to-kernel version compatibility.  Some of these aren't used yet
linux/serial_reg.h.orig:#define UART_LSR_THRE	0x20	/* Transmit-hold-register empty */
linux/serial_reg.h.orig: * Note that for 16650, EFR-bit 4 must be selected as well.
linux/serial_reg.h.orig:#define UART_NMR	0x0D	/* Nine-bit Mode Register */
linux/serial_reg.h.orig: * These definitions are for the RSA-DV II/S card, from
linux/serial_reg.h.orig: * Kiyokazu SUTO <suto@ks-and-ks.ne.jp>
linux/serial_reg.h.orig:#define UART_RSA_BASE (-8)
linux/keyboard.h:#define K_PPLUS		K(KT_PAD,10)	/* key-pad plus */
linux/keyboard.h:#define K_PMINUS	K(KT_PAD,11)	/* key-pad minus */
linux/keyboard.h:#define K_PSTAR		K(KT_PAD,12)	/* key-pad asterisk (star) */
linux/keyboard.h:#define K_PSLASH	K(KT_PAD,13)	/* key-pad slash */
linux/keyboard.h:#define K_PENTER	K(KT_PAD,14)	/* key-pad enter */
linux/keyboard.h:#define K_PCOMMA	K(KT_PAD,15)	/* key-pad comma: kludge... */
linux/keyboard.h:#define K_PDOT		K(KT_PAD,16)	/* key-pad dot (period): kludge... */
linux/keyboard.h:#define K_PPLUSMINUS	K(KT_PAD,17)	/* key-pad plus/minus */
linux/keyboard.h:#define K_PPARENL	K(KT_PAD,18)	/* key-pad left parenthesis */
linux/keyboard.h:#define K_PPARENR	K(KT_PAD,19)	/* key-pad right parenthesis */
linux/a.out.h:/* Code indicating demand-paged executable.  */
linux/a.out.h:/* This indicates a demand-paged executable with the header in the text. 
linux/a.out.h:#define _N_HDROFF(x) (1024 - sizeof (struct exec))
linux/a.out.h:#define _N_SEGMENT_ROUND(x) (((x) + SEGMENT_SIZE - 1) & ~(SEGMENT_SIZE - 1))
linux/a.out.h:   The text-relocation section of the file is a vector of these structures,
linux/a.out.h:   Likewise, the data-relocation section applies to the data section.  */
linux/a.out.h:  /* Nonzero means value is a pc-relative offset
linux/nfs_fs_sb.h: * nfs super-block data in memory
linux/mc6821.h: * Data came from MFC-31-Developer Kit (from Ralph Seidel,
linux/mc6821.h: * 6.11.95 copyright Joerg Dorchain (dorchain@mpi-sb.mpg.de)
linux/ppp_channel.h: * Packets are stored in sk_buffs and have the 2-byte PPP protocol
linux/ppp_channel.h:   The packet should have just the 2-byte PPP protocol header. */
linux/ppp_channel.h:/* Get the unit number associated with a channel, or -1 if none */
linux/ufs_fs_i.h: * Adrian Rodriguez (adrian@franklins-tower.rutgers.edu)
linux/iobuf.h: * Defines the structures used to track abstract kernel-space io buffers.
linux/iobuf.h: * pre-locked all of the pages for IO.
linux/udf_fs_i.h: *	E-mail regarding any portion of the Linux UDF file system should be
linux/udf_fs_i.h:/* exported IOCTLs, we have 'l', 0x40-0x7f */
linux/cdrom.h: * -- <linux/cdrom.h>
linux/cdrom.h: * General header file for linux CD-ROM drivers 
linux/cdrom.h: *               1998-2000    Jens Axboe, axboe@suse.de
linux/cdrom.h: * As of Linux 2.1.x, all Linux CD-ROM application programs will use this 
linux/cdrom.h: * a uniform interface between software accessing CD-ROMs and the various 
linux/cdrom.h: * 23 different kinds of strange CD-ROM drives, but at least there will 
linux/cdrom.h: * now be one, and only one, Linux CD-ROM interface.
linux/cdrom.h: * should use the O_NONBLOCK option when opening a CD-ROM device 
linux/cdrom.h: *       -    drive = open("/dev/cdrom", O_RDONLY);
linux/cdrom.h: * The CD-ROM IOCTL commands  -- these should be supported by 
linux/cdrom.h: * all the various cdrom drivers.  For the CD-ROM ioctls, we 
linux/cdrom.h:#define CDROMEJECT_SW		0x530f /* enable(1)/disable(0) auto-ejecting */
linux/cdrom.h:#define CDROMMULTISESSION	0x5310 /* Obtain the start-of-last-session 
linux/cdrom.h:#define CDROMRESET		0x5312 /* hard-reset the drive */
linux/cdrom.h: * This ioctl is only used by the scsi-cd driver.  
linux/cdrom.h: * These ioctls are (now) only in ide-cd.c for controlling 
linux/cdrom.h: *  -Erik
linux/cdrom.h: * These ioctls are implemented through the uniform CD-ROM driver
linux/cdrom.h: * They _will_ be adopted by all CD-ROM drivers, when all the CD-ROM
linux/cdrom.h: * drivers are eventually ported to the uniform CD-ROM driver interface.
linux/cdrom.h:#define CDROM_SELECT_SPEED	0x5322  /* Set the CD-ROM speed */
linux/cdrom.h:#define CDROM_SELECT_DISC	0x5323  /* Select disc (for juke-boxes) */
linux/cdrom.h:/* Note that scsi/scsi_ioctl.h also uses 0x5382 - 0x5386.
linux/cdrom.h:/* DVD-ROM Specific ioctls */
linux/cdrom.h:	int nframes;           /* number of 2352-byte-frames to read at once */
linux/cdrom.h:	union cdrom_addr addr; /* frame address: start-of-last-session 
linux/cdrom.h:  __u8 medium_catalog_number[14]; /* 13 ASCII digits, null-terminated */
linux/cdrom.h: * A CD-ROM physical sector size is 2048, 2052, 2056, 2324, 2332, 2336, 
linux/cdrom.h:*         Sector types of the standard CD-ROM data formats:
linux/cdrom.h: * -----------------------------------------------------------------------------
linux/cdrom.h: *   1     (Red Book)    CD-DA          2352    (CD_FRAMESIZE_RAW)
linux/cdrom.h: *       The layout of the standard CD-ROM data formats:
linux/cdrom.h: * -----------------------------------------------------------------------------
linux/cdrom.h: * - audio (red):                  | audio_sample_bytes |
linux/cdrom.h: * - data (yellow, mode1):         | sync - head - data - EDC - zero - ECC |
linux/cdrom.h: *                                 |  12  -   4  - 2048 -  4  -   8  - 276 |
linux/cdrom.h: * - data (yellow, mode2):         | sync - head - data |
linux/cdrom.h: *                                 |  12  -   4  - 2336 |
linux/cdrom.h: * - XA data (green, mode2 form1): | sync - head - sub - data - EDC - ECC |
linux/cdrom.h: *                                 |  12  -   4  -  8  - 2048 -  4  - 276 |
linux/cdrom.h: * - XA data (green, mode2 form2): | sync - head - sub - data - Spare |
linux/cdrom.h: *                                 |  12  -   4  -  8  - 2324 -  4    |
linux/cdrom.h:/* Some generally useful CD-ROM information -- mostly based on the above */
linux/cdrom.h:#define CD_CHUNK_SIZE        24 /* lowest-level "data bytes piece" */
linux/cdrom.h:#define CD_FRAMESIZE_RAW1 (CD_FRAMESIZE_RAW-CD_SYNC_SIZE) /*2340*/
linux/cdrom.h:#define CD_FRAMESIZE_RAW0 (CD_FRAMESIZE_RAW-CD_SYNC_SIZE-CD_HEAD_SIZE) /*2336*/
linux/cdrom.h:/* CD-ROM address types (cdrom_tocentry.cdte_format) */
linux/cdrom.h:#define	CDROM_MSF 0x02 /* "minute-second-frame": binary, not bcd here! */
linux/cdrom.h:/* audio states (from SCSI-2, but seen with other drives, too) */
linux/cdrom.h:/* capability flags used with the uniform CD-ROM driver */ 
linux/cdrom.h:#define CDC_SELECT_DISC		0x10    /* select disc from juke-box */
linux/cdrom.h:#define CDC_IOCTLS              0x400   /* driver has non-standard ioctls */
linux/cdrom.h:#define CDC_CD_R		0x2000	/* drive is a CD-R */
linux/cdrom.h:#define CDC_CD_RW		0x4000	/* drive is a CD-RW */
linux/cdrom.h:#define CDC_DVD_R		0x10000	/* drive can write DVD-R */
linux/cdrom.h:#define CDC_DVD_RAM		0x20000	/* drive can write DVD-RAM */
linux/cdrom.h:/* User-configurable behavior options for the uniform CD-ROM driver */
linux/cdrom.h:#define CDSL_NONE       	((int) (~0U>>1)-1)
linux/cdrom.h: * per drive - SCSI CD-ROM's use minors to differentiate between the
linux/cdrom.h: * Use the -o session=x option to mount on them.
linux/cdrom.h:#define CD_PART_MASK		(CD_PART_MAX - 1)
linux/cdrom.h:/* This seems to be a SCSI specific CD-ROM opcode 
linux/cdrom.h:/* Not in Mt. Fuji, but in ATAPI 2.6 -- depricated now in favor
linux/cdrom.h:typedef __u8 dvd_key[5];		/* 40-bit value, MSB is first elem. */
linux/cdrom.h:typedef __u8 dvd_challenge[10];	/* 80-bit value, MSB is first elem. */
linux/cdrom.h:	void *handle;		        /* driver-dependent data */
linux/cdrom.h:/* device-related storage */
linux/cdrom.h:/* per-device flags */
linux/cdrom.h:	/* dev-specific */
linux/cdrom.h:	sprintf (vname, "cdroms/cdrom%d", cdi->number);
linux/cdrom.h:	cdi->de = devfs_register (NULL, vname, DEVFS_FL_DEFAULT,
linux/cdrom.h:				    MAJOR (cdi->dev), MINOR (cdi->dev),
linux/input.h: *  Copyright (c) 1999-2000 Vojtech Pavlik
linux/input.h: * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
linux/input.h: * e-mail - mail your message to <vojtech@suse.cz>, or by paper mail:
linux/input.h: * IOCTLs (0x00 - 0x7f)
linux/input.h:#define EVIOCSAUTOCENTER	_IOW('E', 0x83, unsigned short)		/* Enable or disable auto-centering */
linux/input.h: * They are sub-structures of the actually sent structure (called ff_effect)
linux/input.h:	__u16 interval;		/* Time to wait before an effect can be re-triggered */
linux/input.h:	__u16 direction;	/* Direction. 0 deg -> 0x0000
linux/input.h:					     90 deg -> 0x4000 */
linux/input.h:#define FF_BTN(x)	((x) - BTN_MISC + FF_BTN_OFFSET)
linux/input.h: * In-kernel definitions.
linux/input.h:#define NBITS(x) ((((x)-1)/BITS_PER_LONG)+1)
linux/parport_pc.h:/* --- register definitions ------------------------------- */
linux/parport_pc.h:#define ECONTROL(p) ((p)->base_hi + 0x2)
linux/parport_pc.h:#define CONFIGB(p)  ((p)->base_hi + 0x1)
linux/parport_pc.h:#define CONFIGA(p)  ((p)->base_hi + 0x0)
linux/parport_pc.h:#define FIFO(p)     ((p)->base_hi + 0x0)
linux/parport_pc.h:#define EPPDATA(p)  ((p)->base    + 0x4)
linux/parport_pc.h:#define EPPADDR(p)  ((p)->base    + 0x3)
linux/parport_pc.h:#define CONTROL(p)  ((p)->base    + 0x2)
linux/parport_pc.h:#define STATUS(p)   ((p)->base    + 0x1)
linux/parport_pc.h:#define DATA(p)     ((p)->base    + 0x0)
linux/parport_pc.h:	/* here's hoping that reading these ports won't side-effect anything underneath */
linux/parport_pc.h:	const struct parport_pc_private *priv = (parport_pc_private *)p->physport->private_data;
linux/parport_pc.h:		dcr = i ? priv->ctr : inb (CONTROL (p));
linux/parport_pc.h:		if (!(dcr & 0x08)) printk (",N-SELECT-IN");
linux/parport_pc.h:		if (dcr & 0x04) printk (",N-INIT");
linux/parport_pc.h:		if (!(dcr & 0x02)) printk (",N-AUTOFD");
linux/parport_pc.h:		if (!(dcr & 0x01)) printk (",N-STROBE");
linux/parport_pc.h:	if (dsr & 0x40) printk (",N-ACK");
linux/parport_pc.h:	if (dsr & 0x08) printk (",N-FAULT");
linux/parport_pc.h:	struct parport_pc_private *priv = p->physport->private_data;
linux/parport_pc.h:	unsigned char ctr = priv->ctr;
linux/parport_pc.h:		"__parport_pc_frob_control(%02x,%02x): %02x -> %02x\n",
linux/parport_pc.h:		mask, val, ctr, ((ctr & ~mask) ^ val) & priv->ctr_writable);
linux/parport_pc.h:	ctr &= priv->ctr_writable; /* only write writable bits. */
linux/parport_pc.h:	priv->ctr = ctr;	/* Update soft copy */
linux/parport_pc.h:			p->name, p->cad->name);
linux/parport_pc.h:	const struct parport_pc_private *priv = p->physport->private_data;
linux/parport_pc.h:	return priv->ctr & rm; /* Use soft copy */
linux/parport_pc.h:			p->name, p->cad->name,
linux/romfs_fs_i.h:/* inode in-kernel data */
linux/romfs_fs_i.h:	unsigned long i_metasize;	/* size of non-data area */
linux/ufs_fs_sb.h: * Adrian Rodriguez (adrian@franklins-tower.rutgers.edu)
linux/ufs_fs_sb.h:	__u32	s_sblkno;	/* offset of super-blocks in filesys */
linux/ufs_fs_sb.h:	__u32	s_cblkno;	/* offset of cg-block in filesys */
linux/ufs_fs_sb.h:	__u32	s_iblkno;	/* offset of inode-blocks in filesys */
linux/ufs_fs_sb.h:#define UFS_CGNO_EMPTY ((unsigned)-1)
linux/ufs_fs_sb.h:	__s8	fs_fsmnt[UFS_MAXMNTLEN - 212];
linux/ufs_fs_sb.h:			__s32	fs_inodefmt;	/* format of on-disk inodes */
linux/mroute.h:#define ALL_VIFS	((vifi_t)(-1))
linux/mroute.h: *	Passed by mrouted for an MRT_ADD_VIF - again we use the
linux/mroute.h:	unsigned int mfcc_pkt_cnt;		/* pkt count for src-grp */
linux/mroute.h:#define MFC_HASH(a,b)	((((a)>>24)^((b)>>26))&(MFC_LINES-1))
linux/mroute.h:#define MFC_HASH(a,b)	(((a)^((b)>>2))&(MFC_LINES-1))
linux/mroute.h:/* PIMv2 register message header layout (ietf-draft-idmr-pimvsm-v2-00.ps */
linux/xattr.h:  Copyright (c) 2001-2002 Silicon Graphics, Inc.  All Rights Reserved.
linux/atm_eni.h:/* atm_eni.h - Driver-specific declarations of the ENI driver (for use by
linux/atm_eni.h:	       driver-specific utilities) */
linux/atm_eni.h:/* Written 1995-2000 by Werner Almesberger, EPFL LRC/ICA */
linux/circ_buf.h:#define CIRC_CNT(head,tail,size) (((head) - (tail)) & ((size)-1))
linux/circ_buf.h:/* Return space available, 0..size-1.  We always leave one free char
linux/circ_buf.h:	({int end = (size) - (tail); \
linux/circ_buf.h:	  int n = ((head) + end) & ((size)-1); \
linux/circ_buf.h:	({int end = (size) - 1 - (head); \
linux/circ_buf.h:	  int n = (end + (tail)) & ((size)-1); \
linux/dqblk_xfs.h: * Copyright (c) 1995-2001,2004 Silicon Graphics, Inc.  All Rights Reserved.
linux/dqblk_xfs.h: * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307
linux/dqblk_xfs.h: * Disk quota - quotactl(2) commands for the XFS Quota Manager (XQM).
linux/dqblk_xfs.h: * It is 64-bit aligned, and all the blk units are in BBs (Basic Blocks) of
linux/dqblk_xfs.h:	__s32		d_padding2;	/* padding2 - for future use */
linux/dqblk_xfs.h:	__s16		d_padding3;	/* padding3 - for future use */	
linux/dqblk_xfs.h:	__u64		qfs_nblks;	/* number of BBs 512-byte-blks */
linux/jffs2.h: * JFFS2 -- Journalling Flash File System, Version 2.
linux/jffs2.h: * The Original Code is JFFS2 - Journalling Flash File System, version 2
linux/jffs2.h:#define KSAMTIB_CIGAM_2SFFJ 0x5981 /* For detecting wrong-endian fs */
linux/jffs2.h:/* ROCOMPAT: Mount read-only */
linux/reboot.h: * CAD_ON      Ctrl-Alt-Del sequence causes RESTART command.
linux/reboot.h: * CAD_OFF     Ctrl-Alt-Del sequence sends SIGINT to init task.
linux/reboot.h: * Architecture-specific implementations of sys_reboot commands.
linux/ipsec.h:#define IPSEC_LEVEL_NONE	-1	/* send plaintext, accept any */
linux/ipsec.h:	return ((sk->authentication < IPSEC_LEVEL_REQUIRE) ||
linux/ipsec.h:		(skb->security & RCV_AUTH)) &&
linux/ipsec.h:		((sk->encryption < IPSEC_LEVEL_REQUIRE) ||
linux/ipsec.h:		(skb->security & RCV_CRYPT));
linux/udf_fs_sb.h: *	E-mail regarding any portion of the Linux UDF file system should be
linux/ftape-vendors.h: *      Copyright (C) 1993-1996 Bas Laarhoven,
linux/ftape-vendors.h: *                (C) 1996-1997 Claus-Justus Heine.
linux/ftape-vendors.h: * $Source: /home/cvsroot/RT288x_SDK/source/linux-2.4.x/include/ack,v $
linux/ftape-vendors.h: *      QIC-117 spec. vendor code and drive dependent configuration
linux/ftape-vendors.h:  { wake_up_insight,    "Motor-on" }, \
linux/ftape-vendors.h:#define UNKNOWN_VENDOR (-1)
linux/ftape-vendors.h:  { 0x00000,  82, wake_up_colorado,  "Colorado DJ-10 (old)" },		    \
linux/ftape-vendors.h:  { 0x00047,  90, wake_up_colorado,  "Colorado DJ-10/DJ-20" },		    \
linux/ftape-vendors.h:  { 0x011c4,  84, wake_up_colorado,  "Colorado DJ-10/DJ-20 (new)" },	    \
linux/ftape-vendors.h:  { 0x00380,  85, wake_up_colorado,  "Exabyte Eagle-96" },		    \
linux/ftape-vendors.h:  { 0x00381,  85, wake_up_colorado,  "Exabyte Eagle TR-3" },		    \
linux/ftape-vendors.h:  { 0x00382,  85, wake_up_colorado,  "Exabyte Eagle TR-3" },		    \
linux/ftape-vendors.h:  { 0x00021,  70, no_wake_up,        "AIWA CT-803" },			    \
linux/ftape-vendors.h:  { 0x004c0,  80, no_wake_up,        "AIWA TD-S1600" },			    \
linux/ntfs_fs_i.h: * is ok as Win2k also only uses 32-bits to store clusters.
linux/ntfs_fs_i.h:/* Definition of the NTFS in-memory inode structure. */
linux/ppdev.h: * User-space parallel port device driver (header file).
linux/ppdev.h: * Copyright (C) 1998-9 Tim Waugh <tim@cyberelk.demon.co.uk>
linux/ppdev.h:/* Data line direction: non-zero for input mode. */
linux/ppdev.h:/* only masks user-visible flags */
linux/atm_tcp.h:/* atm_tcp.h - Driver-specific declarations of the ATMTCP driver (for use by
linux/atm_tcp.h:	       driver-specific utilities) */
linux/atm_tcp.h:/* Written 1997-2000 by Werner Almesberger, EPFL LRC/ICA */
linux/atm_tcp.h: * -----------  ----	------- ----	----	---	---	------
linux/atm_tcp.h: * OPEN		K->D	Y	Y	Y	Y	Y	0
linux/atm_tcp.h: * OPEN		D->K	-	Y	Y	Y	Y	Y
linux/atm_tcp.h: * CLOSE	K->D	-	-	Y	-	Y	0
linux/atm_tcp.h: * CLOSE	D->K	-	-	-	-	Y	Y
linux/fs_struct.h: * Replace the fs->{rootmnt,root} with {mnt,dentry}. Put the old values.
linux/fs_struct.h:	write_lock(&fs->lock);
linux/fs_struct.h:	old_root = fs->root;
linux/fs_struct.h:	old_rootmnt = fs->rootmnt;
linux/fs_struct.h:	fs->rootmnt = mntget(mnt);
linux/fs_struct.h:	fs->root = dget(dentry);
linux/fs_struct.h:	write_unlock(&fs->lock);
linux/fs_struct.h: * Replace the fs->{pwdmnt,pwd} with {mnt,dentry}. Put the old values.
linux/fs_struct.h:	write_lock(&fs->lock);
linux/fs_struct.h:	old_pwd = fs->pwd;
linux/fs_struct.h:	old_pwdmnt = fs->pwdmnt;
linux/fs_struct.h:	fs->pwdmnt = mntget(mnt);
linux/fs_struct.h:	fs->pwd = dget(dentry);
linux/fs_struct.h:	write_unlock(&fs->lock);
linux/jhash.h: * any bugs present are surely my fault.  -DaveM
linux/jhash.h:  a -= b; a -= c; a ^= (c>>13); \
linux/jhash.h:  b -= c; b -= a; b ^= (a<<8); \
linux/jhash.h:  c -= a; c -= b; c ^= (b>>13); \
linux/jhash.h:  a -= b; a -= c; a ^= (c>>12);  \
linux/jhash.h:  b -= c; b -= a; b ^= (a<<16); \
linux/jhash.h:  c -= a; c -= b; c ^= (b>>5); \
linux/jhash.h:  a -= b; a -= c; a ^= (c>>3);  \
linux/jhash.h:  b -= c; b -= a; b ^= (a<<10); \
linux/jhash.h:  c -= a; c -= b; c ^= (b>>15); \
linux/jhash.h:		len -= 12;
linux/jhash.h:		k += 3; len -= 3;
linux/jhash.h:/* A special ultra-optimized versions that knows they are hashing exactly
linux/i2c-id.h:/* ------------------------------------------------------------------------- */
linux/i2c-id.h:/* i2c.h - definitions for the i2c-bus interface			     */
linux/i2c-id.h:/* ------------------------------------------------------------------------- */
linux/i2c-id.h:/*   Copyright (C) 1995-1999 Simon G. Vogl
linux/i2c-id.h:/* ------------------------------------------------------------------------- */
linux/i2c-id.h:/* $Id: ack,v 1.1.1.1 2006-10-13 02:42:37 steven Exp $ */
linux/i2c-id.h: * This file is part of the i2c-bus package and contains the identifier
linux/i2c-id.h: * ---- Driver types -----------------------------------------------------
linux/i2c-id.h: *  Range 1000-1999 range is defined in sensors/sensors.h 
linux/i2c-id.h: *  Range 0x100 - 0x1ff is for V4L2 Common Components 
linux/i2c-id.h: *  Range 0xf000 - 0xffff is reserved for local experimentation, and should
linux/i2c-id.h:#define I2C_DRIVERID_PCF8574A	15	/* i2c expander - 8 bit in/out	*/
linux/i2c-id.h:#define I2C_DRIVERID_VES1893	36     /* VLSI DVB-S decoder		*/
linux/i2c-id.h:#define I2C_DRIVERID_VES1820	37     /* VLSI DVB-C decoder		*/
linux/i2c-id.h:#define I2C_DRIVERID_TDA8444	39     /* octuple 6-bit DAC             */
linux/i2c-id.h:/* IDs --   Use DRIVERIDs 1000-1999 for sensors. 
linux/i2c-id.h:#define I2C_DRIVERID_CH700X 1027 /* single driver for CH7003-7009 digital pc to tv encoders */
linux/i2c-id.h: * ---- Adapter types ----------------------------------------------------
linux/i2c-id.h:#define I2C_ALGO_ISA 	0x050000	/* lm_sensors ISA pseudo-adapter */
linux/i2c-id.h:/* --- Bit algorithm adapters 						*/
linux/i2c-id.h:#define I2C_HW_B_IOC	0x11	/* IOC bit-wiggling			*/
linux/i2c-id.h:/* --- PCF 8584 based algorithms					*/
linux/i2c-id.h:/* --- ACPI Embedded controller algorithms                              */
linux/i2c-id.h:/* --- MPC8xx PowerPC adapters						*/
linux/i2c-id.h:/* --- Broadcom SiByte adapters						*/
linux/i2c-id.h:/* --- SGI adapters							*/
linux/i2c-id.h:/* --- Au1550 PSC adapters						*/
linux/i2c-id.h:/* --- SMBus only adapters						*/
linux/i2c-id.h:/* --- ISA pseudo-adapter						*/
linux/intermezzo_psdev.h:/* -*- mode: c; c-basic-offset: 8; indent-tabs-mode: nil; -*-
linux/intermezzo_psdev.h:#define ISLENTO(minor) (current->pid == izo_channels[minor].uc_pid \
linux/intermezzo_psdev.h:                || current->p_pptr->pid == izo_channels[minor].uc_pid \
linux/intermezzo_psdev.h:                || current->p_pptr->p_pptr->pid == izo_channels[minor].uc_pid)
linux/moduleparam.h:   it appears in sysfs: 0 means doens't appear, 0444 means read-only
linux/prctl.h:/* Get/set current->mm->dumpable */
linux/prctl.h:/* Get/set floating-point emulation control bits (if meaningful) */
linux/prctl.h:/* Get/set floating-point exception mode (if meaningful) */
linux/prctl.h:# define PR_FP_EXC_NONRECOV	1	/* async non-recoverable exc. mode */
linux/limits.h:#define CHILD_MAX        999    /* no limit :-) */
linux/limits.h:#define MAX_INPUT        255	/* size of the type-ahead buffer */
linux/rtnetlink.h:#define RTA_ALIGN(len) ( ((len)+RTA_ALIGNTO-1) & ~(RTA_ALIGNTO-1) )
linux/rtnetlink.h:			 (rta)->rta_len >= sizeof(struct rtattr) && \
linux/rtnetlink.h:			 (rta)->rta_len <= (len))
linux/rtnetlink.h:#define RTA_NEXT(rta,attrlen)	((attrlen) -= RTA_ALIGN((rta)->rta_len), \
linux/rtnetlink.h:				 (struct rtattr*)(((char*)(rta)) + RTA_ALIGN((rta)->rta_len)))
linux/rtnetlink.h:#define RTA_PAYLOAD(rta) ((int)((rta)->rta_len) - RTA_LENGTH(0))
linux/rtnetlink.h:#define RTN_MAX (__RTN_MAX - 1)
linux/rtnetlink.h:#define RT_TABLE_MAX (__RT_TABLE_MAX - 1)
linux/rtnetlink.h:#define RTA_MAX (__RTA_MAX - 1)
linux/rtnetlink.h:/* RTM_MULTIPATH --- array of struct rtnexthop.
linux/rtnetlink.h:#define RTNH_ALIGN(len) ( ((len)+RTNH_ALIGNTO-1) & ~(RTNH_ALIGNTO-1) )
linux/rtnetlink.h:#define RTNH_OK(rtnh,len) ((rtnh)->rtnh_len >= sizeof(struct rtnexthop) && \
linux/rtnetlink.h:			   ((int)(rtnh)->rtnh_len) <= (len))
linux/rtnetlink.h:#define RTNH_NEXT(rtnh)	((struct rtnexthop*)(((char*)(rtnh)) + RTNH_ALIGN((rtnh)->rtnh_len)))
linux/rtnetlink.h:/* RTM_METRICS --- array of struct rtattr with types of RTAX_* */
linux/rtnetlink.h:#define RTAX_MAX (__RTAX_MAX - 1)
linux/rtnetlink.h:#define IFA_MAX (__IFA_MAX - 1)
linux/rtnetlink.h:   but for point-to-point IFA_ADDRESS is DESTINATION address,
linux/rtnetlink.h:#define NDA_MAX (__NDA_MAX - 1)
linux/rtnetlink.h:	IFLA_WIRELESS,		/* Wireless Extension event - see wireless.h */
linux/rtnetlink.h:#define IFLA_MAX (__IFLA_MAX - 1)
linux/rtnetlink.h:   - Combination IFF_BROADCAST|IFF_POINTOPOINT is invalid
linux/rtnetlink.h:   - If neither of these three flags are set;
linux/rtnetlink.h:   - IFF_MULTICAST does not mean anything special:
linux/rtnetlink.h:   multicasts can be used on all not-NBMA links.
linux/rtnetlink.h:#define IFLA_INET6_MAX	(__IFLA_INET6_MAX - 1)
linux/rtnetlink.h:#define TCA_MAX (__TCA_MAX - 1)
linux/rtnetlink.h:	return len > rta->rta_len || memcmp(RTA_DATA(rta), str, len);
linux/rtnetlink.h:		             if (rtnl && rtnl->receive_queue.qlen) \
linux/rtnetlink.h:				     rtnl->data_ready(rtnl, 0); \
linux/errqueue.h:#define SKB_EXT_ERR(skb) ((struct sock_exterr_skb *) ((skb)->cb))
linux/ultrasound.h: *	ultrasound.h - Macros for programming the Gravis Ultrasound
linux/ultrasound.h: * Copyright (C) by Hannu Savolainen 1993-1997
linux/ultrasound.h: *		byte 0 		- SEQ_PRIVATE (0xfe)
linux/ultrasound.h: *		byte 1 		- Synthesizer device number (0-N)
linux/ultrasound.h: *		byte 2 		- Command (see below)
linux/ultrasound.h: *		byte 3 		- Voice number (0-31)
linux/ultrasound.h: *		bytes 4 and 5	- parameter P1 (unsigned short)
linux/ultrasound.h: *		bytes 6 and 7	- parameter P2 (unsigned short)
linux/ultrasound.h: *		_GUS_NUMVOICES	- Sets max. number of concurrent voices (P1=14-31, default 16)
linux/ultrasound.h: *		_GUS_VOICESAMPLE- ************ OBSOLETE *************
linux/ultrasound.h: *		_GUS_VOICEON	- Starts voice (P1=voice mode)
linux/ultrasound.h: *		_GUS_VOICEOFF	- Stops voice (no parameters)
linux/ultrasound.h: *		_GUS_VOICEFADE	- Stops the voice smoothly.
linux/ultrasound.h: *		_GUS_VOICEMODE	- Alters the voice mode, don't start or stop voice (P1=voice mode)
linux/ultrasound.h: *		_GUS_VOICEBALA	- Sets voice balence (P1, 0=left, 7=middle and 15=right, default 7)
linux/ultrasound.h: *		_GUS_VOICEFREQ	- Sets voice (sample) playback frequency (P1=Hz)
linux/ultrasound.h: *		_GUS_VOICEVOL	- Sets voice volume (P1=volume, 0xfff=max, 0xeff=half, 0x000=off)
linux/ultrasound.h: *		_GUS_VOICEVOL2	- Sets voice volume (P1=volume, 0xfff=max, 0xeff=half, 0x000=off)
linux/ultrasound.h: *		_GUS_RAMPRANGE	- Sets limits for volume ramping (P1=low volume, P2=high volume)
linux/ultrasound.h: *		_GUS_RAMPRATE	- Sets the speed for volume ramping (P1=scale, P2=rate)
linux/ultrasound.h: *		_GUS_RAMPMODE	- Sets the volume ramping mode (P1=ramping mode)
linux/ultrasound.h: *		_GUS_RAMPON	- Starts volume ramping (no parameters)
linux/ultrasound.h: *		_GUS_RAMPOFF	- Stops volume ramping (no parameters)
linux/ultrasound.h: *		_GUS_VOLUME_SCALE - Changes the volume calculation constants
linux/cramfs_fs.h: * Since inode.namelen is a unsigned 6-bit number, the maximum cramfs
linux/cramfs_fs.h:#define CRAMFS_MAXPATHLEN (((1 << CRAMFS_NAMELEN_WIDTH) - 1) << 2)
linux/cramfs_fs.h:	/* OFFSET: For symlinks and non-empty regular files, this
linux/cramfs_fs.h:	   see README).  For non-empty directories it is the offset
linux/cramfs_fs.h:	u32 magic;			/* 0x28cd3d45 - random number */
linux/cramfs_fs.h:	u8 name[16];			/* user-defined name */
linux/cramfs_fs.h: * 0x00000000 - 0x000000ff: features that work for all past kernels
linux/cramfs_fs.h: * 0x00000100 - 0xffffffff: features that don't work for past kernels
linux/bootmem.h: *  simple boot-time physical memory area allocator.
linux/bootmem.h: * node_bootmem_map is a map pointer - the bits represent all physical 
linux/baycom.h: * (C) 1997-1998 by Thomas Sailer, HB9JNX/AE4WA
linux/baycom.h:/* -------------------------------------------------------------------- */
linux/baycom.h:/* -------------------------------------------------------------------- */
linux/baycom.h:/* -------------------------------------------------------------------- */
linux/baycom.h:/* --------------------------------------------------------------------- */
linux/socket.h:	char		__data[_K_SS_MAXSIZE - sizeof(unsigned short)];
linux/socket.h:#include <asm/socket.h>			/* arch-dependent defines	*/
linux/socket.h: *	POSIX 1003.1g - ancillary data object information
linux/socket.h:        int		cmsg_type;	/* protocol-specific type */
linux/socket.h: *	Table 5-14 of POSIX 1003.1g
linux/socket.h:#define CMSG_ALIGN(len) ( ((len)+sizeof(long)-1) & ~(sizeof(long)-1) )
linux/socket.h:#define CMSG_FIRSTHDR(msg)	__CMSG_FIRSTHDR((msg)->msg_control, (msg)->msg_controllen)
linux/socket.h:#define CMSG_OK(mhdr, cmsg) ((cmsg)->cmsg_len >= sizeof(struct cmsghdr) && \
linux/socket.h:			     (cmsg)->cmsg_len <= (unsigned long) \
linux/socket.h:			     ((mhdr)->msg_controllen - \
linux/socket.h:			      ((char *)(cmsg) - (char *)(mhdr)->msg_control)))
linux/socket.h: *	HEADER. But caller still MUST check, that cmsg->cmsg_len is
linux/socket.h: *	inside range, given by msg->msg_controllen before using
linux/socket.h: *	ansillary object DATA.				--ANK (980731)
linux/socket.h:	__ptr = (struct cmsghdr*)(((unsigned char *) __cmsg) +  CMSG_ALIGN(__cmsg->cmsg_len));
linux/socket.h:	if ((unsigned long)((char*)(__ptr+1) - (char *) __ctl) > __size)
linux/socket.h:	return __cmsg_nxthdr(__msg->msg_control, __msg->msg_controllen, __cmsg);
linux/socket.h:/* "Socket"-level control message types: */
linux/socket.h:/* #define SOL_ICMP	1	No-no-no! Due to Linux :-) we cannot use SOL_ICMP=1 */
linux/atmclip.h:/* atmclip.h - Classical IP over ATM */
linux/atmclip.h:/* Written 1995-1998 by Werner Almesberger, EPFL LRC/ICA */
linux/i2c-algo-sibyte.h: * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
linux/atmapi.h:/* atmapi.h - ATM API user space/kernel compatibility */
linux/atmapi.h:   figure that we are on a sparc64 while compiling user-space programs. */
linux/atmarp.h:/* atmarp.h - ATM ARP protocol and kernel-demon interface definitions */
linux/atmarp.h:/* Written 1995-1999 by Werner Almesberger, EPFL LRC/ICA */
linux/atmarp.h:					   NAK after 30 sec - should go into
linux/atmdev.h:/* atmdev.h - ATM device driver declarations and various related items */
linux/atmdev.h:/* Written 1995-2000 by Werner Almesberger, EPFL LRC/ICA */
linux/atmdev.h:#define ATM_25_PCR	((25600000/8-8000)/54)
linux/atmdev.h:#define ATM_SD(s)	((s)->sk->protinfo.af_atm)
linux/atmdev.h:					/* enable or disable single-copy */
linux/atmdev.h: * above.  In the future we may support dynamic loading of these - for now,
linux/atmdev.h:#define ATM_BACKEND_PPP		1	/* PPPoATM - RFC2364 */
linux/atmdev.h:/* Point of loopback				CPU-->SAR-->PHY-->line--> ... */
linux/atmdev.h:#define __ATM_LM_AAL	1	/* loop back PDUs --'     |     |      |      */
linux/atmdev.h:#define __ATM_LM_ATM	2	/* loop back ATM cells ---'     |      |      */
linux/atmdev.h:/* RESERVED		4	loop back on PHY side  ---'		      */
linux/atmdev.h:#define __ATM_LM_PHY	8	/* loop back bits (digital) ----'      |      */
linux/atmdev.h:#define __ATM_LM_ANALOG 16	/* loop back the analog signal --------'      */
linux/atmdev.h:#define ATM_CI_MAX      -1              /* use maximum range of VPI/VCI */
linux/atmdev.h:	char	vpi_bits;		/* 1..8, ATM_CI_MAX (-1) for maximum */
linux/atmdev.h:	char	vci_bits;		/* 1..16, ATM_CI_MAX (-1) for maximum */
linux/atmdev.h:#define ATM_SC_RX	1024		/* enable RX single-copy */
linux/atmdev.h:#define ATM_SC_TX	2048		/* enable TX single-copy */
linux/atmdev.h: * ATM_VS_* are used to express VC state in a human-friendly way.
linux/atmdev.h:	ATM_VF_CLOSE,		/* asynchronous close - treat like VF_RELEASED*/
linux/atmdev.h:	void		*dev_data;	/* per-device data */
linux/atmdev.h:	void		*proto_data;	/* per-protocol data */
linux/atmdev.h:	/* SVC part --- may move later ------------------------------------- */
linux/atmdev.h:	/* Multipoint part ------------------------------------------------- */
linux/atmdev.h:	/* Other stuff ----------------------------------------------------- */
linux/atmdev.h:	void		*user_back;	/* user backlink - not touched by */
linux/atmdev.h:	void		*dev_data;	/* per-device data */
linux/atmdev.h:#define ATM_OF_INRATE	2	/* Attempt in-rate delivery */
linux/atmdev.h:#define ATM_SKB(skb) (((struct atm_skb_data *) (skb)->cb))
linux/atmdev.h:    int number,atm_dev_flags_t *flags); /* number == -1: pick first available */
linux/atmdev.h:	atomic_add(truesize, &vcc->sk->rmem_alloc);
linux/atmdev.h:	atomic_sub(truesize, &vcc->sk->rmem_alloc);
linux/atmdev.h:	return (size + atomic_read(&vcc->sk->wmem_alloc)) < vcc->sk->sndbuf;
linux/atmdev.h:	atomic_inc(&dev->refcnt);
linux/atmdev.h:	atomic_dec(&dev->refcnt);
linux/atmdev.h:	if ((atomic_read(&dev->refcnt) == 1) &&
linux/atmdev.h:	    test_bit(ATM_DF_CLOSE,&dev->flags))
math-emu/double.h:/* Software floating-point emulation.
math-emu/double.h:   59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
math-emu/double.h:#define _FP_FRACXBITS_D		(_FP_FRACTBITS_D - _FP_FRACBITS_D)
math-emu/double.h:#define _FP_WFRACXBITS_D	(_FP_FRACTBITS_D - _FP_WFRACBITS_D)
math-emu/double.h:	((_FP_W_TYPE)1 << (_FP_FRACBITS_D-2) % _FP_W_TYPE_SIZE)
math-emu/double.h:	((_FP_W_TYPE)1 << (_FP_FRACBITS_D-1) % _FP_W_TYPE_SIZE)
math-emu/double.h:    unsigned frac1 : _FP_FRACBITS_D - (_FP_IMPLBIT_D != 0) - _FP_W_TYPE_SIZE;
math-emu/double.h:    unsigned frac1 : _FP_FRACBITS_D - (_FP_IMPLBIT_D != 0) - _FP_W_TYPE_SIZE;
math-emu/double.h:    unsigned long frac : _FP_FRACBITS_D - (_FP_IMPLBIT_D != 0);
math-emu/double.h:    unsigned long frac : _FP_FRACBITS_D - (_FP_IMPLBIT_D != 0);
math-emu/single.h:/* Software floating-point emulation.
math-emu/single.h:   59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
math-emu/single.h:#define _FP_FRACXBITS_S		(_FP_W_TYPE_SIZE - _FP_FRACBITS_S)
math-emu/single.h:#define _FP_WFRACXBITS_S	(_FP_W_TYPE_SIZE - _FP_WFRACBITS_S)
math-emu/single.h:#define _FP_QNANBIT_S		((_FP_W_TYPE)1 << (_FP_FRACBITS_S-2))
math-emu/single.h:#define _FP_IMPLBIT_S		((_FP_W_TYPE)1 << (_FP_FRACBITS_S-1))
math-emu/single.h:    unsigned frac : _FP_FRACBITS_S - (_FP_IMPLBIT_S != 0);
math-emu/single.h:    unsigned frac : _FP_FRACBITS_S - (_FP_IMPLBIT_S != 0);
math-emu/soft-fp.h:/* Software floating-point emulation.
math-emu/soft-fp.h:   59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
math-emu/soft-fp.h:#include <asm/sfp-machine.h>
math-emu/soft-fp.h:/* Allow sfp-machine to have its own byte order definitions. */
math-emu/soft-fp.h: * sfp-machine may override this and e.g.
math-emu/soft-fp.h:#include <math-emu/op-1.h>
math-emu/soft-fp.h:#include <math-emu/op-2.h>
math-emu/soft-fp.h:#include <math-emu/op-4.h>
math-emu/soft-fp.h:#include <math-emu/op-8.h>
math-emu/soft-fp.h:#include <math-emu/op-common.h>
math-emu/op-1.h:/* Software floating-point emulation.
math-emu/op-1.h:   Basic one-word fraction declaration and manipulation.
math-emu/op-1.h:   59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
math-emu/op-1.h:/* Right shift with sticky-lsb.  */
math-emu/op-1.h:		     ? X & 1 : (X << (_FP_W_TYPE_SIZE - (N))) != 0)))
math-emu/op-1.h:#define _FP_FRAC_SUB_1(R,X,Y)	(R##_f = X##_f - Y##_f)
math-emu/op-1.h:#define _FP_FRAC_DEC_1(X,Y)	(X##_f -= Y##_f)
math-emu/op-1.h:    X##_f = _flo->bits.frac;					\
math-emu/op-1.h:    X##_e = _flo->bits.exp;					\
math-emu/op-1.h:    X##_s = _flo->bits.sign;					\
math-emu/op-1.h:    _flo->bits.frac = X##_f;					\
math-emu/op-1.h:    _flo->bits.exp  = X##_e;					\
math-emu/op-1.h:    _flo->bits.sign = X##_s;					\
math-emu/op-1.h:       at either 2B or 2B-1.  */					\
math-emu/op-1.h:    _FP_FRAC_SRS_1(R, wfracbits-1, 2*wfracbits);			\
math-emu/op-1.h:       at either 2B or 2B-1.  */					\
math-emu/op-1.h:    _FP_FRAC_SRS_2(_Z, wfracbits-1, 2*wfracbits);			\
math-emu/op-1.h:    _xl = X##_f & (((_FP_W_TYPE)1 << (_FP_W_TYPE_SIZE/2)) - 1);		\
math-emu/op-1.h:    _yl = Y##_f & (((_FP_W_TYPE)1 << (_FP_W_TYPE_SIZE/2)) - 1);		\
math-emu/op-1.h:    _FP_FRAC_SRS_2(_z, wfracbits - 1, 2*wfracbits);			\
math-emu/op-1.h:	       ? R##_e--, _FP_WFRACBITS_##fs		\
math-emu/op-1.h:	       : _FP_WFRACBITS_##fs - 1);		\
math-emu/op-1.h:    /* Normalize Y -- i.e. make the most significant bit set.  */	\
math-emu/op-1.h:	R##_e--;							\
math-emu/op-1.h:	_nl = X##_f << (_FP_W_TYPE_SIZE - 1);				\
math-emu/op-1.h:	R##_e--;					\
math-emu/op-1.h:	_nl = X##_f << (_FP_WFRACBITS_##fs - 1);	\
math-emu/op-1.h:            X##_f -= T##_f;				\
math-emu/op-1.h:	  _FP_FRAC_SRS_1(D, (_FP_WFRACBITS_##sfs-_FP_WFRACBITS_##dfs),	\
math-emu/op-1.h:	  _FP_FRAC_SRL_1(D, (_FP_WFRACBITS_##sfs-_FP_WFRACBITS_##dfs));	\
math-emu/op-1.h:      D##_f <<= _FP_WFRACBITS_##dfs - _FP_WFRACBITS_##sfs;		\
math-emu/op-2.h:/* Software floating-point emulation.
math-emu/op-2.h:   Basic two-word fraction declaration and manipulation.
math-emu/op-2.h:   59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
math-emu/op-2.h:	    X##_f1 = X##_f1 << (N) | X##_f0 >> (_FP_W_TYPE_SIZE - (N));	\
math-emu/op-2.h:	X##_f1 = X##_f0 << ((N) - _FP_W_TYPE_SIZE);			\
math-emu/op-2.h:	X##_f0 = X##_f0 >> (N) | X##_f1 << (_FP_W_TYPE_SIZE - (N));	\
math-emu/op-2.h:	X##_f0 = X##_f1 >> ((N) - _FP_W_TYPE_SIZE);			\
math-emu/op-2.h:/* Right shift with sticky-lsb.  */
math-emu/op-2.h:	X##_f0 = (X##_f1 << (_FP_W_TYPE_SIZE - (N)) | X##_f0 >> (N) |	\
math-emu/op-2.h:		   : (X##_f0 << (_FP_W_TYPE_SIZE - (N))) != 0));	\
math-emu/op-2.h:	X##_f0 = (X##_f1 >> ((N) - _FP_W_TYPE_SIZE) |			\
math-emu/op-2.h:		(((X##_f1 << (2*_FP_W_TYPE_SIZE - (N))) | X##_f0) != 0)); \
math-emu/op-2.h:  (rh = xh - yh - ((rl = xl - yl) > xl))
math-emu/op-2.h:    xh -= yh + ((xl -= yl) > _t);	\
math-emu/op-2.h:    X##_f0 = _flo->bits.frac0;				\
math-emu/op-2.h:    X##_f1 = _flo->bits.frac1;				\
math-emu/op-2.h:    X##_e  = _flo->bits.exp;				\
math-emu/op-2.h:    X##_s  = _flo->bits.sign;				\
math-emu/op-2.h:    _flo->bits.frac0 = X##_f0;				\
math-emu/op-2.h:    _flo->bits.frac1 = X##_f1;				\
math-emu/op-2.h:    _flo->bits.exp   = X##_e;				\
math-emu/op-2.h:    _flo->bits.sign  = X##_s;				\
math-emu/op-2.h:       at either 2B or 2B-1.  */					\
math-emu/op-2.h:    _FP_FRAC_SRS_4(_z, wfracbits-1, 2*wfracbits);			\
math-emu/op-2.h:    _b_f0 &= -_c2;							\
math-emu/op-2.h:    _b_f1 &= -_c1;							\
math-emu/op-2.h:       at either 2B or 2B-1.  */					\
math-emu/op-2.h:    _FP_FRAC_SRS_4(_z, wfracbits-1, 2*wfracbits);			\
math-emu/op-2.h:       at either 2B or 2B-1.  */					\
math-emu/op-2.h:    _FP_FRAC_SRS_4(_z, wfracbits-1, 2*wfracbits);			\
math-emu/op-2.h:   Caller guarantees that X and Y has (1LLL << (wfracbits - 1)) set.
math-emu/op-2.h:      /* 2^-24 */ 5.9604644775390625e-08,					\
math-emu/op-2.h:      /* 2^-48 */ 3.5527136788005009e-15,					\
math-emu/op-2.h:      /* 2^-72 */ 2.1175823681357508e-22,					\
math-emu/op-2.h:      /* 2^-96 */ 1.2621774483536189e-29,					\
math-emu/op-2.h:      /* 2^-20 */ 9.5367431640625e-07,						\
math-emu/op-2.h:      /* 2^-44 */ 5.6843418860808015e-14,					\
math-emu/op-2.h:      /* 2^-68 */ 3.3881317890172014e-21,					\
math-emu/op-2.h:      /* 2^-92 */ 2.0194839173657902e-28,					\
math-emu/op-2.h:      /* 2^-116 */ 1.2037062152420224e-35};					\
math-emu/op-2.h:    _s240.d -= ((_const[10]+_s240.d)-_const[10]);				\
math-emu/op-2.h:    _r240.d -= ((_const[9]+_r240.d)-_const[9]);					\
math-emu/op-2.h:    _q240.d -= ((_const[8]+_q240.d)-_const[8]);					\
math-emu/op-2.h:    _p240.d -= ((_const[7]+_p240.d)-_const[7]);					\
math-emu/op-2.h:    R##_f1 = (_t240 << (128 - (wfracbits - 1)))					\
math-emu/op-2.h:	     | ((_u240 & 0xffffff) >> ((wfracbits - 1) - 104));			\
math-emu/op-2.h:    R##_f0 = ((_u240 & 0xffffff) << (168 - (wfracbits - 1)))			\
math-emu/op-2.h:    	     | ((_v240 & 0xffffff) << (144 - (wfracbits - 1)))			\
math-emu/op-2.h:    	     | ((_w240 & 0xffffff) << (120 - (wfracbits - 1)))			\
math-emu/op-2.h:    	     | ((_x240 & 0xffffff) >> ((wfracbits - 1) - 96))			\
math-emu/op-2.h:	_n_f1 = X##_f1 << (_FP_W_TYPE_SIZE - 1) | X##_f0 >> 1;		\
math-emu/op-2.h:	_n_f0 = X##_f0 << (_FP_W_TYPE_SIZE - 1);			\
math-emu/op-2.h:	R##_e--;							\
math-emu/op-2.h:	R##_f1--;							\
math-emu/op-2.h:	    R##_f1--;							\
math-emu/op-2.h:	   (UWtype)-1 or (UWtype)-2.  But as we know what kind		\
math-emu/op-2.h:	   guard bit will be set anyway.  -jj */			\
math-emu/op-2.h:	R##_f0 = -1;							\
math-emu/op-2.h:	    R##_f0--;							\
math-emu/op-2.h:		R##_f0--;						\
math-emu/op-2.h:	_x[1] = (X##_f0 << (_FP_WFRACBITS_##fs-1 - _FP_W_TYPE_SIZE) |	\
math-emu/op-2.h:		 X##_f1 >> (_FP_W_TYPE_SIZE -				\
math-emu/op-2.h:			    (_FP_WFRACBITS_##fs-1 - _FP_W_TYPE_SIZE)));	\
math-emu/op-2.h:	_x[2] = X##_f1 << (_FP_WFRACBITS_##fs-1 - _FP_W_TYPE_SIZE);	\
math-emu/op-2.h:	_x[1] = (X##_f0 << (_FP_WFRACBITS_##fs - _FP_W_TYPE_SIZE) |	\
math-emu/op-2.h:		 X##_f1 >> (_FP_W_TYPE_SIZE -				\
math-emu/op-2.h:			    (_FP_WFRACBITS_##fs - _FP_W_TYPE_SIZE)));	\
math-emu/op-2.h:	_x[2] = X##_f1 << (_FP_WFRACBITS_##fs - _FP_W_TYPE_SIZE);	\
math-emu/op-2.h:	    X##_f1 -= T##_f1;				\
math-emu/op-2.h:    q = (_FP_W_TYPE)1 << (_FP_W_TYPE_SIZE - 1);		\
math-emu/op-2.h:      _FP_FRAC_SRS_2(S, (_FP_WFRACBITS_##sfs - _FP_WFRACBITS_##dfs),	\
math-emu/op-2.h:      _FP_FRAC_SRL_2(S, (_FP_WFRACBITS_##sfs - _FP_WFRACBITS_##dfs));	\
math-emu/op-2.h:    _FP_FRAC_SLL_2(D, (_FP_WFRACBITS_##dfs - _FP_WFRACBITS_##sfs));	\
math-emu/op-4.h:/* Software floating-point emulation.
math-emu/op-4.h:   Basic four-word fraction declaration and manipulation.
math-emu/op-4.h:   59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
math-emu/op-4.h:    _down = _FP_W_TYPE_SIZE - _up;					\
math-emu/op-4.h:      for (_i = 3; _i >= _skip; --_i)					\
math-emu/op-4.h:	X##_f[_i] = X##_f[_i-_skip];					\
math-emu/op-4.h:	for (_i = 3; _i > _skip; --_i)					\
math-emu/op-4.h:	  X##_f[_i] = X##_f[_i-_skip] << _up				\
math-emu/op-4.h:		      | X##_f[_i-_skip-1] >> _down;			\
math-emu/op-4.h:	X##_f[_i--] = X##_f[0] << _up; 					\
math-emu/op-4.h:    for (; _i >= 0; --_i)						\
math-emu/op-4.h:    _up = _FP_W_TYPE_SIZE - _down;					\
math-emu/op-4.h:      for (_i = 0; _i <= 3-_skip; ++_i)					\
math-emu/op-4.h:	for (_i = 0; _i < 3-_skip; ++_i)				\
math-emu/op-4.h:/* Right shift with sticky-lsb. 
math-emu/op-4.h: * What this actually means is that we do a standard right-shift,
math-emu/op-4.h:    _up = _FP_W_TYPE_SIZE - _down;					\
math-emu/op-4.h:      for (_i = 0; _i <= 3-_skip; ++_i)					\
math-emu/op-4.h:	for (_i = 0; _i < 3-_skip; ++_i)				\
math-emu/op-4.h:    X##_f[0] = _flo->bits.frac0;				\
math-emu/op-4.h:    X##_f[1] = _flo->bits.frac1;				\
math-emu/op-4.h:    X##_f[2] = _flo->bits.frac2;				\
math-emu/op-4.h:    X##_f[3] = _flo->bits.frac3;				\
math-emu/op-4.h:    X##_e  = _flo->bits.exp;					\
math-emu/op-4.h:    X##_s  = _flo->bits.sign;					\
math-emu/op-4.h:    _flo->bits.frac0 = X##_f[0];				\
math-emu/op-4.h:    _flo->bits.frac1 = X##_f[1];				\
math-emu/op-4.h:    _flo->bits.frac2 = X##_f[2];				\
math-emu/op-4.h:    _flo->bits.frac3 = X##_f[3];				\
math-emu/op-4.h:    _flo->bits.exp   = X##_e;					\
math-emu/op-4.h:    _flo->bits.sign  = X##_s;					\
math-emu/op-4.h:       at either 2B or 2B-1.  */					    \
math-emu/op-4.h:    _FP_FRAC_SRS_8(_z, wfracbits-1, 2*wfracbits);			    \
math-emu/op-4.h:       at either 2B or 2B-1.  */					    \
math-emu/op-4.h:    _FP_FRAC_SRS_8(_z, wfracbits-1, 2*wfracbits);	 		    \
math-emu/op-4.h:	_n_f[3] = X##_f[0] << (_FP_W_TYPE_SIZE - 1);			    \
math-emu/op-4.h:      R##_e--;								    \
math-emu/op-4.h:    for (_i = 3; ; _i--)						    \
math-emu/op-4.h:               (UWtype)-1 or (UWtype)-2.  */				    \
math-emu/op-4.h:            R##_f[_i] = -1;						    \
math-emu/op-4.h:                R##_f[_i] = -2;						    \
math-emu/op-4.h:                R##_f[_i]--;						    \
math-emu/op-4.h:		    R##_f[_i]--;					    \
math-emu/op-4.h:	    X##_f[3] -= T##_f[3];				\
math-emu/op-4.h:    q = (_FP_W_TYPE)1 << (_FP_W_TYPE_SIZE - 1);			\
math-emu/op-4.h:    q = (_FP_W_TYPE)1 << (_FP_W_TYPE_SIZE - 1);			\
math-emu/op-4.h:    q = (_FP_W_TYPE)1 << (_FP_W_TYPE_SIZE - 1);			\
math-emu/op-4.h:    r0 = x0 - y0;						\
math-emu/op-4.h:    r1 = x1 - y1;						\
math-emu/op-4.h:    r1 -= _c1;							\
math-emu/op-4.h:    r2 = x2 - y2 - _c2;						\
math-emu/op-4.h:    r0 = x0 - y0;						\
math-emu/op-4.h:    r1 = x1 - y1;						\
math-emu/op-4.h:    r1 -= _c1;							\
math-emu/op-4.h:    r2 = x2 - y2;						\
math-emu/op-4.h:    r2 -= _c2;							\
math-emu/op-4.h:    r3 = x3 - y3 - _c3;						\
math-emu/op-4.h: * the ones in op-2.h and op-1.h. 
math-emu/op-4.h:       _FP_FRAC_SRS_4(S, (_FP_WFRACBITS_##sfs - _FP_WFRACBITS_##dfs),	\
math-emu/op-4.h:       _FP_FRAC_SRL_4(S, (_FP_WFRACBITS_##sfs - _FP_WFRACBITS_##dfs));	\
math-emu/op-4.h:       _FP_FRAC_SRS_4(S, (_FP_WFRACBITS_##sfs - _FP_WFRACBITS_##dfs),	\
math-emu/op-4.h:       _FP_FRAC_SRL_4(S, (_FP_WFRACBITS_##sfs - _FP_WFRACBITS_##dfs));	\
math-emu/op-4.h:     _FP_FRAC_SLL_4(D, (_FP_WFRACBITS_##dfs - _FP_WFRACBITS_##sfs));	\
math-emu/op-4.h:     _FP_FRAC_SLL_4(D, (_FP_WFRACBITS_##dfs - _FP_WFRACBITS_##sfs));	\
math-emu/op-8.h:/* Software floating-point emulation.
math-emu/op-8.h:   Basic eight-word fraction declaration and manipulation.
math-emu/op-8.h:   59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
math-emu/op-8.h:/* We need just a few things from here for op-4, if we ever need some
math-emu/op-8.h:    _down = _FP_W_TYPE_SIZE - _up;					\
math-emu/op-8.h:      for (_i = 7; _i >= _skip; --_i)					\
math-emu/op-8.h:	X##_f[_i] = X##_f[_i-_skip];					\
math-emu/op-8.h:	for (_i = 7; _i > _skip; --_i)					\
math-emu/op-8.h:	  X##_f[_i] = X##_f[_i-_skip] << _up				\
math-emu/op-8.h:		      | X##_f[_i-_skip-1] >> _down;			\
math-emu/op-8.h:	X##_f[_i--] = X##_f[0] << _up; 					\
math-emu/op-8.h:    for (; _i >= 0; --_i)						\
math-emu/op-8.h:    _up = _FP_W_TYPE_SIZE - _down;					\
math-emu/op-8.h:      for (_i = 0; _i <= 7-_skip; ++_i)					\
math-emu/op-8.h:	for (_i = 0; _i < 7-_skip; ++_i)				\
math-emu/op-8.h:/* Right shift with sticky-lsb. 
math-emu/op-8.h: * What this actually means is that we do a standard right-shift,
math-emu/op-8.h:    _up = _FP_W_TYPE_SIZE - _down;					\
math-emu/op-8.h:      for (_i = 0; _i <= 7-_skip; ++_i)					\
math-emu/op-8.h:	for (_i = 0; _i < 7-_skip; ++_i)				\
math-emu/quad.h:/* Software floating-point emulation.
math-emu/quad.h:   59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
math-emu/quad.h:#define _FP_FRACXBITS_Q		(_FP_FRACTBITS_Q - _FP_FRACBITS_Q)
math-emu/quad.h:#define _FP_WFRACXBITS_Q	(_FP_FRACTBITS_Q - _FP_WFRACBITS_Q)
math-emu/quad.h:	((_FP_W_TYPE)1 << (_FP_FRACBITS_Q-2) % _FP_W_TYPE_SIZE)
math-emu/quad.h:	((_FP_W_TYPE)1 << (_FP_FRACBITS_Q-1) % _FP_W_TYPE_SIZE)
math-emu/quad.h:      unsigned long frac3 : _FP_FRACBITS_Q - (_FP_IMPLBIT_Q != 0)-(_FP_W_TYPE_SIZE * 3);
math-emu/quad.h:      unsigned long frac3 : _FP_FRACBITS_Q - (_FP_IMPLBIT_Q != 0)-(_FP_W_TYPE_SIZE * 3);
math-emu/quad.h:    unsigned long frac1 : _FP_FRACBITS_Q-(_FP_IMPLBIT_Q != 0)-_FP_W_TYPE_SIZE;
math-emu/quad.h:    unsigned long frac1 : _FP_FRACBITS_Q-(_FP_IMPLBIT_Q != 0)-_FP_W_TYPE_SIZE;
math-emu/op-common.h:/* Software floating-point emulation. Common operations.
math-emu/op-common.h:   59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
math-emu/op-common.h:    X##_e -= _FP_EXPBIAS_##fs;						\
math-emu/op-common.h:	_shift -= _FP_FRACXBITS_##fs;					\
math-emu/op-common.h:	X##_e -= _FP_EXPBIAS_##fs - 1 + _shift;				\
math-emu/op-common.h: * extracted -- but that is ok, we can regenerate them now.
math-emu/op-common.h:		X##_e = _FP_EXPMAX_##fs - 1;			\
math-emu/op-common.h:	X##_e = -X##_e + 1;					\
math-emu/op-common.h:      _FP_I_TYPE diff = X##_e - Y##_e;					     \
math-emu/op-common.h:	  diff = -diff;							     \
math-emu/op-common.h:	      diff -= _FP_WFRACXBITS_##fs;				     \
math-emu/op-common.h:		  R##_e -= diff;					     \
math-emu/op-common.h:	/* +INF + -INF => NAN */					     \
math-emu/op-common.h:    _FP_ADD_INTERNAL(fs, wc, R, X, Y, '-');				     \
math-emu/op-common.h: * Main negation routine.  FIXME -- when we care about setting exception
math-emu/op-common.h:      R##_e--;						\
math-emu/op-common.h:    R##_e = X##_e - Y##_e;				\
math-emu/op-common.h: * cooked.  The return is -1,0,1 for normal values, 2 otherwise.
math-emu/op-common.h:		ret = Y##_s ? 1 : -1;					\
math-emu/op-common.h:		ret = X##_s ? -1 : 1;					\
math-emu/op-common.h:	  ret = X##_s ? -1 : 1;						\
math-emu/op-common.h:	  ret = X##_s ? -1 : 1;						\
math-emu/op-common.h:	  ret = X##_s ? 1 : -1;						\
math-emu/op-common.h:	  ret = X##_s ? -1 : 1;						\
math-emu/op-common.h:	  ret = X##_s ? 1 : -1;						\
math-emu/op-common.h:	R##_c = FP_CLS_ZERO; /* sqrt(+-0) = +-0 */			\
math-emu/op-common.h: * 0:  the number is required to be 0..(2^rsize)-1, if not, NV is set plus
math-emu/op-common.h: *     the result is either 0 or (2^rsize)-1 depending on the sign in such case.
math-emu/op-common.h: * 1:  the number is required to be -(2^(rsize-1))..(2^(rsize-1))-1, if not, NV is
math-emu/op-common.h: *     set plus the result is either -(2^(rsize-1)) or (2^(rsize-1))-1 depending
math-emu/op-common.h: * 2:  the number is required to be -(2^(rsize-1))..(2^(rsize-1))-1, if not, NV is
math-emu/op-common.h: * -1: the number is required to be -(2^(rsize-1))..(2^rsize)-1, if not, NV is
math-emu/op-common.h: *     set plus the result is either -(2^(rsize-1)) or (2^(rsize-1))-1 depending
math-emu/op-common.h:	else if (X##_e >= rsize - (rsigned > 0 || X##_s)			\
math-emu/op-common.h:		    || X##_e >= rsize - 1 + _FP_WFRACBITS_##fs)			\
math-emu/op-common.h:		    _FP_FRAC_SLL_##wc(X, (X##_e - _FP_WFRACBITS_##fs + 1));	\
math-emu/op-common.h:		r <<= rsize - 1;						\
math-emu/op-common.h:		r -= 1 - X##_s;							\
math-emu/op-common.h:		r <<= X##_e - _FP_WFRACBITS_##fs;				\
math-emu/op-common.h:		  _FP_FRAC_SLL_##wc(X, (X##_e - _FP_WFRACBITS_##fs + 1));	\
math-emu/op-common.h:		else if (X##_e < _FP_WFRACBITS_##fs - 1)			\
math-emu/op-common.h:		    _FP_FRAC_SRS_##wc(X, (_FP_WFRACBITS_##fs - X##_e - 2),	\
math-emu/op-common.h:	      r = -r;								\
math-emu/op-common.h:	if (X##_e >= _FP_FRACBITS_##fs - 1)					\
math-emu/op-common.h:	    if (X##_e < rsize - 1 + _FP_WFRACBITS_##fs)				\
math-emu/op-common.h:		if (X##_e >= _FP_WFRACBITS_##fs - 1)				\
math-emu/op-common.h:		    r <<= X##_e - _FP_WFRACBITS_##fs + 1;			\
math-emu/op-common.h:		    _FP_FRAC_SRL_##wc(X, _FP_WORKBITS - X##_e			\
math-emu/op-common.h:				      + _FP_FRACBITS_##fs - 1);			\
math-emu/op-common.h:	    if (X##_e <= -_FP_WORKBITS - 1)					\
math-emu/op-common.h:	      _FP_FRAC_SRS_##wc(X, _FP_FRACBITS_##fs - 1 - X##_e,		\
math-emu/op-common.h:	  r = -r;								\
math-emu/op-common.h:	if (X##_e >= rsize - (rsigned > 0 || X##_s)				\
math-emu/op-common.h:		r <<= rsize - 1;						\
math-emu/op-common.h:		r -= 1 - X##_s;							\
math-emu/op-common.h:	  r = -r;							\
math-emu/op-common.h:		X##_e -= (_FP_W_TYPE_SIZE - rsize);			\
math-emu/op-common.h:	X##_e = rsize - X##_e - 1;					\
math-emu/op-common.h:	  __FP_FRAC_SRS_1(ur_, (X##_e - _FP_WFRACBITS_##fs + 1), rsize);\
math-emu/op-common.h:	if ((_FP_WFRACBITS_##fs - X##_e - 1) > 0)			\
math-emu/op-common.h:	  _FP_FRAC_SLL_##wc(X, (_FP_WFRACBITS_##fs - X##_e - 1));	\
math-emu/op-common.h:/* this is just to shut the compiler up about shifts > word length -- PMM 02/1998 */
math-emu/op-common.h:    r = _FP_W_TYPE_SIZE - 1;			\
math-emu/op-common.h:    if (_t > 0xffff) r -= 16;			\
math-emu/op-common.h:    if (_t > 0xff) r -= 8;			\
math-emu/op-common.h:    if (_t & 0xf0) r -= 4;			\
math-emu/op-common.h:    if (_t & 0xc) r -= 2;			\
math-emu/op-common.h:    if (_t & 0x2) r -= 1;			\
math-emu/op-common.h:    r = _FP_W_TYPE_SIZE - 1;			\
math-emu/op-common.h:    if (_t > 0xffffffff) r -= 32;		\
math-emu/op-common.h:    if (_t > 0xffff) r -= 16;			\
math-emu/op-common.h:    if (_t > 0xff) r -= 8;			\
math-emu/op-common.h:    if (_t & 0xf0) r -= 4;			\
math-emu/op-common.h:    if (_t & 0xc) r -= 2;			\
math-emu/op-common.h:    if (_t & 0x2) r -= 1;			\
math-emu/extended.h:/* Software floating-point emulation.
math-emu/extended.h:   59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
math-emu/extended.h:#define _FP_FRACXBITS_E		(_FP_FRACTBITS_E - _FP_FRACBITS_E)
math-emu/extended.h:#define _FP_WFRACXBITS_E	(_FP_FRACTBITS_E - _FP_WFRACBITS_E)
math-emu/extended.h:	((_FP_W_TYPE)1 << (_FP_FRACBITS_E-2) % _FP_W_TYPE_SIZE)
math-emu/extended.h:	((_FP_W_TYPE)1 << (_FP_FRACBITS_E-1) % _FP_W_TYPE_SIZE)
math-emu/extended.h:      unsigned long pad2 : (_FP_W_TYPE_SIZE - 1 - _FP_EXPBITS_E);
math-emu/extended.h:    X##_f[0] = _flo->bits.frac0;			\
math-emu/extended.h:    X##_f[1] = _flo->bits.frac1;			\
math-emu/extended.h:    X##_e  = _flo->bits.exp;				\
math-emu/extended.h:    X##_s  = _flo->bits.sign;				\
math-emu/extended.h:	_flo->bits.frac0 = X##_f[0];			\
math-emu/extended.h:	_flo->bits.frac1 = X##_f[1];			\
math-emu/extended.h:	_flo->bits.exp   = X##_e;			\
math-emu/extended.h:	_flo->bits.sign  = X##_s;			\
math-emu/extended.h:    q = (_FP_W_TYPE)1 << (_FP_W_TYPE_SIZE - 1);		\
math-emu/extended.h:	    X##_f[1] -= T##_f[1];			\
math-emu/extended.h:    q = (_FP_W_TYPE)1 << (_FP_W_TYPE_SIZE - 1);		\
math-emu/extended.h:    unsigned long pad : (_FP_W_TYPE_SIZE - 1 - _FP_EXPBITS_E);
math-emu/extended.h:    X##_f0 = _flo->bits.frac;					\
math-emu/extended.h:    X##_e = _flo->bits.exp;					\
math-emu/extended.h:    X##_s = _flo->bits.sign;					\
math-emu/extended.h:	_flo->bits.frac = X##_f0;				\
math-emu/extended.h:	_flo->bits.exp  = X##_e;				\
math-emu/extended.h:	_flo->bits.sign = X##_s;				\
math-emu/extended.h:    q = (_FP_W_TYPE)1 << (_FP_W_TYPE_SIZE - 1);		\
math-emu/extended.h:            X##_f0 -= T##_f0;				\
net/tcp_ecn.h:	if (tp->ecn_flags&TCP_ECN_OK)
net/tcp_ecn.h:		tp->ecn_flags |= TCP_ECN_QUEUE_CWR;
net/tcp_ecn.h:	TCP_SKB_CB(skb)->flags &= ~TCPCB_FLAG_CWR;
net/tcp_ecn.h:	if (!(tp->ecn_flags&TCP_ECN_OK))
net/tcp_ecn.h:		TCP_SKB_CB(skb)->flags &= ~TCPCB_FLAG_ECE;
net/tcp_ecn.h:	tp->ecn_flags = 0;
net/tcp_ecn.h:		TCP_SKB_CB(skb)->flags |= TCPCB_FLAG_ECE|TCPCB_FLAG_CWR;
net/tcp_ecn.h:		tp->ecn_flags = TCP_ECN_OK;
net/tcp_ecn.h:	if (req->ecn_ok)
net/tcp_ecn.h:		th->ece = 1;
net/tcp_ecn.h:	if (tp->ecn_flags & TCP_ECN_OK) {
net/tcp_ecn.h:		/* Not-retransmitted data segment: set ECT and inject CWR. */
net/tcp_ecn.h:		if (skb->len != tcp_header_len &&
net/tcp_ecn.h:		    !before(TCP_SKB_CB(skb)->seq, tp->snd_nxt)) {
net/tcp_ecn.h:			if (tp->ecn_flags&TCP_ECN_QUEUE_CWR) {
net/tcp_ecn.h:				tp->ecn_flags &= ~TCP_ECN_QUEUE_CWR;
net/tcp_ecn.h:				skb->h.th->cwr = 1;
net/tcp_ecn.h:		if (tp->ecn_flags & TCP_ECN_DEMAND_CWR)
net/tcp_ecn.h:			skb->h.th->ece = 1;
net/tcp_ecn.h:	if (skb->h.th->cwr)
net/tcp_ecn.h:		tp->ecn_flags &= ~TCP_ECN_DEMAND_CWR;
net/tcp_ecn.h:	tp->ecn_flags &= ~TCP_ECN_DEMAND_CWR;
net/tcp_ecn.h:	if (tp->ecn_flags&TCP_ECN_OK) {
net/tcp_ecn.h:		if (INET_ECN_is_ce(TCP_SKB_CB(skb)->flags))
net/tcp_ecn.h:			tp->ecn_flags |= TCP_ECN_DEMAND_CWR;
net/tcp_ecn.h:		else if (!INET_ECN_is_capable((TCP_SKB_CB(skb)->flags)))
net/tcp_ecn.h:	if ((tp->ecn_flags&TCP_ECN_OK) && (!th->ece || th->cwr))
net/tcp_ecn.h:		tp->ecn_flags &= ~TCP_ECN_OK;
net/tcp_ecn.h:	if ((tp->ecn_flags&TCP_ECN_OK) && (!th->ece || !th->cwr))
net/tcp_ecn.h:		tp->ecn_flags &= ~TCP_ECN_OK;
net/tcp_ecn.h:	if (th->ece && !th->syn && (tp->ecn_flags&TCP_ECN_OK))
net/tcp_ecn.h:	tp->ecn_flags = req->ecn_ok ? TCP_ECN_OK : 0;
net/tcp_ecn.h:	if (sysctl_tcp_ecn && th->ece && th->cwr)
net/tcp_ecn.h:		req->ecn_ok = 1;
net/dn.h:#define DN_SK(sk) (&sk->protinfo.dn)
net/dn.h:	 * nsp_srtt:   Round-Trip-Time (x8) in jiffies. This is a rolling
net/dn.h:	 * nsp_rttvar: Round-Trip-Time-Varience (x4) in jiffies. This is the
net/dn.h:#define DN_SKB_CB(skb) ((struct dn_skb_cb *)(skb)->cb)
net/dn.h:	return *(dn_address *)saddr->sdn_nodeaddr;
net/ip_fib.h:#define fib_mtu fib_metrics[RTAX_MTU-1]
net/ip_fib.h:#define fib_window fib_metrics[RTAX_WINDOW-1]
net/ip_fib.h:#define fib_rtt fib_metrics[RTAX_RTT-1]
net/ip_fib.h:#define fib_advmss fib_metrics[RTAX_ADVMSS-1]
net/ip_fib.h:#define FIB_RES_NH(res)		((res).fi->fib_nh[(res).nh_sel])
net/ip_fib.h:#define FIB_RES_NH(res)		((res).fi->fib_nh[0])
net/ip_fib.h:#define FIB_RES_PREFSRC(res)		((res).fi->fib_prefsrc ? : __fib_res_prefsrc(&res))
net/ip_fib.h:	if (local_table->tb_lookup(local_table, key, res) &&
net/ip_fib.h:	    main_table->tb_lookup(main_table, key, res))
net/ip_fib.h:		return -ENETUNREACH;
net/ip_fib.h:		main_table->tb_select_default(main_table, key, res);
net/ip_fib.h:	if (atomic_dec_and_test(&fi->fib_clntref))
net/ip_fib.h:	if (res->fi)
net/ip_fib.h:		fib_info_put(res->fi);
net/ip_fib.h:	if (res->r)
net/ip_fib.h:		fib_rule_put(res->r);
net/ip.h:#define IPCB(skb) ((struct inet_skb_parm*)((skb)->cb))
net/ip.h:				 /* -1 if not needed */ 
net/ip.h:	if (skb->len > skb->dst->pmtu)
net/ip.h: * check=0xFEFF. It was noticed by Arthur Skawina _year_ ago. --ANK(000625) */
net/ip.h:	u32 check = iph->check;
net/ip.h:	iph->check = check + (check>=0xFFFF);
net/ip.h:	return --iph->ttl;
net/ip.h:	return (sk->protinfo.af_inet.pmtudisc == IP_PMTUDISC_DO ||
net/ip.h:		(sk->protinfo.af_inet.pmtudisc == IP_PMTUDISC_WANT &&
net/ip.h:		 !(dst->mxlock&(1<<RTAX_MTU))));
net/ip.h:	if (iph->frag_off&__constant_htons(IP_DF)) {
net/ip.h:		iph->id = ((sk && sk->daddr) ? htons(sk->protinfo.af_inet.id++) : 0);
net/irda/irlmp_frame.h: *     provided "AS-IS" and at no charge.
net/irda/irlap_frame.h: *     Copyright (c) 1997-1999 Dag Brattli <dagb@cs.uit.no>,
net/irda/irlap_frame.h: *     MA 02111-1307 USA
net/irda/vlsi_ir.h: *	MA 02111-1307 USA
net/irda/vlsi_ir.h:/* non-standard PCI registers */
net/irda/vlsi_ir.h:/* ------------------------------------------ */
net/irda/vlsi_ir.h:/* Three possible clock sources: either on-chip 48MHz PLL or
net/irda/vlsi_ir.h: * On my HP OB-800 the BIOS sets external 40MHz clock as source
net/irda/vlsi_ir.h:/* ------------------------------------------ */
net/irda/vlsi_ir.h:	/* PCI busmastering is somewhat special for this guy - in short:
net/irda/vlsi_ir.h:	 * composed of [0:23] taken from various busaddr-pointers
net/irda/vlsi_ir.h:	 * targeted to/from one single 16MB (busaddr-) superpage!
net/irda/vlsi_ir.h:	 * are indeed bus-mappable to the same 16MB range (for x86 this
net/irda/vlsi_ir.h:	 * the correct 32bit dma-mask used by the chip. Afterwards the device's
net/irda/vlsi_ir.h:	 * dma-mask gets restricted to 24bit, which must be honoured somehow by
net/irda/vlsi_ir.h:	 * The chip has its PCI latency timer RO fixed at 0 - which is not a
net/irda/vlsi_ir.h:/* ------------------------------------------ */
net/irda/vlsi_ir.h:/* legacy UART emulation - not used by this driver - would require:
net/irda/vlsi_ir.h: * (see below for some register-value definitions)
net/irda/vlsi_ir.h: *	- IRMISC_UARTEN must be set to enable UART address decoding
net/irda/vlsi_ir.h: *	- IRMISC_UARTSEL configured
net/irda/vlsi_ir.h: *	- IRCFG_MASTER must be cleared
net/irda/vlsi_ir.h: *	- IRCFG_SIR must be set
net/irda/vlsi_ir.h: *	- IRENABLE_IREN must be asserted 0->1 (and hence IRENABLE_SIR_ON)
net/irda/vlsi_ir.h:						 * 0=3.3V / 1=5V. Probably set during power-on?
net/irda/vlsi_ir.h:						 * unclear - not touched by driver */
net/irda/vlsi_ir.h:	IRMISC_UARTTST		= 0x80,		/* UART test mode - "always write 0" */
net/irda/vlsi_ir.h:	/* 0x0a-0x0f: reserved / duplicated UART regs */
net/irda/vlsi_ir.h:	VLSI_PIO_RCVBCNT	= 0x1c		/* current receive-FIFO byte count (u16, ro) */
net/irda/vlsi_ir.h:	/* 0x1e-0x1f: reserved / duplicated UART regs */
net/irda/vlsi_ir.h:/* ------------------------------------------ */
net/irda/vlsi_ir.h:/* enable-bits:
net/irda/vlsi_ir.h: *		write-to-clear
net/irda/vlsi_ir.h: * note: RPKTINT and TPKTINT behave different in legacy UART mode (which we don't use :-)
net/irda/vlsi_ir.h:	IRINTR_RPKTINT	= 0x10,	/* rx-packet transfered from fifo to memory finished */
net/irda/vlsi_ir.h:	IRINTR_TPKTINT	= 0x04,	/* last bit of tx-packet+crc shifted to ir-pulser */
net/irda/vlsi_ir.h:/* ------------------------------------------ */
net/irda/vlsi_ir.h:/* VLSI_PIO_RINGPTR: Ring Pointer Read-Back Register (u16, ro) */
net/irda/vlsi_ir.h:/* _both_ ring pointers are indices relative to the _entire_ rx,tx-ring!
net/irda/vlsi_ir.h: * therefore, the tx-pointer has offset MAX_RING_DESCR
net/irda/vlsi_ir.h:#define RINGPTR_RX_MASK		(MAX_RING_DESCR-1)
net/irda/vlsi_ir.h:#define RINGPTR_TX_MASK		((MAX_RING_DESCR-1)<<8)
net/irda/vlsi_ir.h:/* ------------------------------------------ */
net/irda/vlsi_ir.h:/* Contains [23:10] part of the ring base (bus-) address
net/irda/vlsi_ir.h: * which must be 1k-alinged. [31:24] is taken from
net/irda/vlsi_ir.h: * The controller initiates non-burst PCI BM cycles to
net/irda/vlsi_ir.h:/* ------------------------------------------ */
net/irda/vlsi_ir.h:#define SIZE_TO_BITS(num)		((((num)-1)>>2)&0x0f)
net/irda/vlsi_ir.h:/* ------------------------------------------ */
net/irda/vlsi_ir.h:/* VLSI_PIO_PROMPT: Ring Prompting Register (u16, write-to-start) */
net/irda/vlsi_ir.h: * 	- active rings (currently owning an active descriptor)
net/irda/vlsi_ir.h: *	- idle rings fetch the next descr from the ring and start
net/irda/vlsi_ir.h:/* ------------------------------------------ */
net/irda/vlsi_ir.h: *	- not more than one SIR/MIR/FIR bit must be set at any time
net/irda/vlsi_ir.h: *	- SIR, MIR, FIR and CRC16 select the configuration which will
net/irda/vlsi_ir.h: *	  be applied on next 0->1 transition of IRENABLE_IREN (see below).
net/irda/vlsi_ir.h: *	- besides allowing the PCI interface to execute busmaster cycles
net/irda/vlsi_ir.h: *	  and therefore the ring SM to operate, the MSTR bit has side-effects:
net/irda/vlsi_ir.h: *	- clearing ENRX or setting ENTX while data is received may stall the
net/irda/vlsi_ir.h: *	- SIRFILT means the chip performs the required unwrapping of hardware
net/irda/vlsi_ir.h: *	  headers (XBOF's, BOF/EOF) and un-escaping in the _receive_ direction.
net/irda/vlsi_ir.h: *	  Only the resulting IrLAP payload is copied to the receive buffers -
net/irda/vlsi_ir.h:/* ------------------------------------------ */
net/irda/vlsi_ir.h: * which is used for unwrapping received frames in SIR decode-filter mode
net/irda/vlsi_ir.h:/* ------------------------------------------ */
net/irda/vlsi_ir.h: *	- IREN acts as gate for latching the configured IR mode information
net/irda/vlsi_ir.h: *	- ENTXST reflects IRCFG_ENTX
net/irda/vlsi_ir.h: *	- ENRXST = IRCFG_ENRX && (!IRCFG_ENTX || IRCFG_LOOP)
net/irda/vlsi_ir.h:/* ------------------------------------------ */
net/irda/vlsi_ir.h:/* read-back of the currently applied physical layer status.
net/irda/vlsi_ir.h:/* ------------------------------------------ */
net/irda/vlsi_ir.h:/* latched during IRENABLE_IREN=0 and applied at 0-1 transition
net/irda/vlsi_ir.h: * SIR-mode:	BAUD = (115.2kHz / baudrate) - 1
net/irda/vlsi_ir.h: *		PLSWID = (pulsetime * freq / (BAUD+1)) - 1
net/irda/vlsi_ir.h: *		Using the expression PLSWID = 12/(BAUD+1)-1 (multiplied by to for 48MHz)
net/irda/vlsi_ir.h: * MIR-mode:	BAUD = 0
net/irda/vlsi_ir.h: * FIR-mode:	BAUD = 0
net/irda/vlsi_ir.h:#define BAUD_BITS(br)		((115200/(br))-1)
net/irda/vlsi_ir.h:	return (tmp>0) ? (tmp-1) : 0;
net/irda/vlsi_ir.h: * baudrate	BAUD	min-PLSWID	nom-PLSWID	PREAMB
net/irda/vlsi_ir.h: *	MIR	   0	    -		    9(10)	   1
net/irda/vlsi_ir.h: *	FIR	   0        -               0		  15
net/irda/vlsi_ir.h: * note: x(y) means x-value for 40MHz / y-value for 48MHz primary input clock
net/irda/vlsi_ir.h:/* ------------------------------------------ */
net/irda/vlsi_ir.h:/* specifies the maximum legth (up to 4k - or (4k-1)? - bytes), which a
net/irda/vlsi_ir.h: * received frame may have - i.e. the size of the corresponding
net/irda/vlsi_ir.h: * byond IrDA-MTU = 2048 so we have sufficient space left when
net/irda/vlsi_ir.h: * so we use 2*IrDA-MTU for both directions and cover even the
net/irda/vlsi_ir.h: * well, this wastes some memory - anyway, later we will
net/irda/vlsi_ir.h:#define MAX_PACKET_LENGTH	(XFER_BUF_SIZE-1) /* register uses only [11:0] */
net/irda/vlsi_ir.h:/* ------------------------------------------ */
net/irda/vlsi_ir.h:/* recive packet counter gets incremented on every non-filtered
net/irda/vlsi_ir.h: * accessed by hardware - don't change!
net/irda/vlsi_ir.h:/* ------------------------------------------ */
net/irda/vlsi_ir.h: * static buffers for now - probably skb's later
net/irda/vlsi_ir.h:/* ------------------------------------------ */
net/irda/vlsi_ir.h:/* our private compound VLSI-PCI-IRDA device information */
net/irda/discovery.h: *     MA 02111-1307 USA
net/irda/qos.h: *     MA 02111-1307 USA
net/irda/irqueue.h: *     Copyright (C) 1998-1999, Aage Kvalnes <aage@cs.uit.no>
net/irda/irqueue.h: *     provided "AS-IS" and at no charge.
net/irda/irqueue.h:#define HASHBIN_GET_SIZE(hashbin) hashbin->hb_size
net/irda/toshoboe.h: * Description:   Driver for the Toshiba OBOE (or type-O)
net/irda/toshoboe.h: *     Copyright (c) 1999-2000 James McKenzie, All Rights Reserved.
net/irda/toshoboe.h: *     provided "AS-IS" and at no charge.
net/irda/toshoboe.h:#define OBOE_RCVT	(0x00+(self->base))
net/irda/toshoboe.h:#define OBOE_XMTT	(0x01+(self->base))
net/irda/toshoboe.h:#define OBOE_TFP2	(0x02+(self->base))
net/irda/toshoboe.h:#define OBOE_TFP0	(0x04+(self->base))
net/irda/toshoboe.h:#define OBOE_TFP1	(0x05+(self->base))
net/irda/toshoboe.h:#define OBOE_REG_3	(0x03+(self->base))
net/irda/toshoboe.h:#define OBOE_NTR	(0x07+(self->base))
net/irda/toshoboe.h:#define OBOE_REG_9	(0x09+(self->base))
net/irda/toshoboe.h:#define OBOE_ISR	(0x0c+(self->base))
net/irda/toshoboe.h:#define OBOE_REG_D	(0x0d+(self->base))
net/irda/toshoboe.h:#define OBOE_LOCK	((self->base)+0x0e)
net/irda/toshoboe.h:#define OBOE_PMDL	(0x10+(self->base))
net/irda/toshoboe.h:#define OBOE_SMDL	(0x18+(self->base))
net/irda/toshoboe.h:#define OBOE_UDIV	(0x19+(self->base))
net/irda/toshoboe.h:#define OBOE_REG_11	(0x11+(self->base))
net/irda/toshoboe.h:#define OBOE_RST	(0x15+(self->base))
net/irda/toshoboe.h:#define OBOE_REG_1A	(0x1a+(self->base))
net/irda/toshoboe.h:#define OBOE_REG_1B	(0x1b+(self->base))
net/irda/parameters.h: *     Copyright (c) 1999-2000 Dag Brattli, All Rights Reserved.
net/irda/parameters.h: *     MA 02111-1307 USA
net/irda/parameters.h: *     - simplify irda_pv_t to avoid endianness issues
net/irda/irlan_client.h: *     provided "AS-IS" and at no charge.
net/irda/irda-usb.h: * Filename:      irda-usb.h
net/irda/irda-usb.h: * Description:   IrDA-USB Driver
net/irda/irda-usb.h: * good enough to handle back-to-back (brickwalled) frames. I tried it,
net/irda/irda-usb.h: * UHCI : frame period = 1ms, but notification can take 2 or 3 ms :-(
net/irda/irda-usb.h:/* class specific interface request to get the IrDA-USB class descriptor
net/irda/irda-usb.h: * (6.2.5, USB-IrDA class spec 1.0) */
net/irda/irda_device.h: *     Copyright (c) 1999-2000 Dag Brattli, All Rights Reserved.
net/irda/irda_device.h: *     MA 02111-1307 USA
net/irda/irda_device.h:/* Some non-standard interface flags (should not conflict with any in if.h) */
net/irda/irda_device.h:                  (((struct irda_skb_cb *) skb->cb)->magic == LAP_MAGIC) ?  \
net/irda/irda_device.h:                          ((struct irda_skb_cb *)(skb->cb))->mtt : 10000    \
net/irda/irda_device.h:	if (((struct irda_skb_cb *)(skb->cb))->magic != LAP_MAGIC)
net/irda/irda_device.h:		mtt = ((struct irda_skb_cb *)(skb->cb))->mtt;
net/irda/irda_device.h: * Note : return -1 for user space frames
net/irda/irda_device.h:	(((struct irda_skb_cb*) skb->cb)->magic == LAP_MAGIC) ? 	\
net/irda/irda_device.h:                  ((struct irda_skb_cb *)(skb->cb))->next_speed : -1 	\
net/irda/irda_device.h:	if (((struct irda_skb_cb *)(skb->cb))->magic != LAP_MAGIC)
net/irda/irda_device.h:		speed = -1;
net/irda/irda_device.h:		speed = ((struct irda_skb_cb *)(skb->cb))->next_speed;
net/irda/irda_device.h:	(((struct irda_skb_cb*) skb->cb)->magic == LAP_MAGIC) ? 	\
net/irda/irda_device.h:                  ((struct irda_skb_cb *)(skb->cb))->xbofs : 10 	\
net/irda/irda_device.h: * Note : return -1 for user space frames
net/irda/irda_device.h:	(((struct irda_skb_cb*) skb->cb)->magic == LAP_MAGIC) ? 	\
net/irda/irda_device.h:                  ((struct irda_skb_cb *)(skb->cb))->next_xbofs : -1 	\
net/irda/ircomm_core.h: *     MA 02111-1307 USA
net/irda/ircomm_core.h: * A small call-table, so we don't have to check the service-type whenever
net/irda/ircomm_core.h:#define ircomm_is_connected(self) (self->state == IRCOMM_CONN)
net/irda/ircomm_param.h: *     MA 02111-1307 USA
net/irda/ircomm_param.h:#define IRCOMM_PORT_TYPE        0x01 /* Only used in LM-IAS */
net/irda/ircomm_param.h:#define IRCOMM_PORT_NAME        0x02 /* Only used in LM-IAS */
net/irda/ircomm_param.h:	/* Control params for 3- and 9-wire service type */
net/irda/ircomm_param.h:	/* Control params for 9-wire service type */
net/irda/irlan_provider.h: *     Copyright (c) 1998-1999 Dag Brattli <dagb@cs.uit.no>, All Rights Reserved.
net/irda/irlan_provider.h: *     provided "AS-IS" and at no charge.
net/irda/irlan_eth.h: *     Copyright (c) 1998-1999 Dag Brattli, All Rights Reserved.
net/irda/irlan_eth.h: *     provided "AS-IS" and at no charge.
net/irda/ircomm_lmp.h: *     MA 02111-1307 USA
net/irda/ircomm_ttp.h: *     MA 02111-1307 USA
net/irda/ircomm_tty.h: *     Copyright (c) 1999-2000 Dag Brattli, All Rights Reserved.
net/irda/ircomm_tty.h: *     MA 02111-1307 USA
net/irda/ircomm_tty.h: * the state of the underlying connection. - Jean II */
net/irda/ircomm_tty.h:#define IRCOMM_TTY_DATA_UNINITIALISED	(64 - IRCOMM_TTY_HDR_UNINITIALISED)
net/irda/timer.h: *     Copyright (c) 1997, 1998-1999 Dag Brattli <dagb@cs.uit.no>, 
net/irda/timer.h: *     Copyright (c) 2000-2001 Jean Tourrilhes <jt@hpl.hp.com>
net/irda/timer.h: *     provided "AS-IS" and at no charge.
net/irda/timer.h: *  Normally twice of p-timer. Note 3, IrLAP p. 60 suggests at least twice 
net/irda/timer.h: *  duration of the P-timer.
net/irda/timer.h:#define SMALLBUSY_TIMEOUT   (100*HZ/1000)    /* 100 msec - IrLAP 6.13.4 */
net/irda/timer.h: *  suggested to  75-85 msec by IrDA lite. This doesn't work with a lot of
net/irda/smc-ircc.h: * Filename:      smc-ircc.h
net/irda/smc-ircc.h: *     Copyright (c) 1999-2000, Dag Brattli <dagb@cs.uit.no>
net/irda/smc-ircc.h: *     Copyright (c) 1998-1999, Thomas Davis (tadavis@jps.net>
net/irda/smc-ircc.h: *     MA 02111-1307 USA
net/irda/smc-ircc.h:/* Register block 3 - Identification Registers! */
net/irda/smc-ircc.h:/* Register block 4 - IrDA */
net/irda/smc-ircc.h:#define IRCC_BOF_COUNT_HI          0x00 /* High nibble (bit 0-3) */
net/irda/smc-ircc.h:#define IRCC_BRICKWALL_CNT_HI      0x03 /* High nibble (bit 4-7) */
net/irda/smc-ircc.h:#define IRCC_TX_SIZE_HI            0x03 /* High nibble (bit 0-3) */
net/irda/smc-ircc.h:#define IRCC_RX_SIZE_HI            0x05 /* High nibble (bit 0-3) */
net/irda/w83977af_ir.h: *     Copyright (c) 1998-2000 Dag Brattli, All Rights Reserved.
net/irda/w83977af_ir.h: *     provided "AS-IS" and at no charge.
net/irda/irda.h: *     Copyright (c) 1998-2000 Dag Brattli, All Rights Reserved.
net/irda/irda.h: *     Copyright (c) 2000-2001 Jean Tourrilhes <jt@hpl.hp.com>
net/irda/irda.h: *     provided "AS-IS" and at no charge.
net/irda/irda.h: *  Magic numbers used by Linux-IrDA. Random numbers which must be unique to 
net/irda/irda.h: * Per-packet information we need to hide inside sk_buff 
net/irda/irda.h: *  please do not touch :-)
net/irda/irda.h:	LM_NON_RESP_CLIENT,   /* Non responsive LM-MUX client */
net/irda/irda.h:	LM_NO_AVAIL_CLIENT,   /* No available LM-MUX client */
net/irda/irport.h: *     Copyright (c) 1997, 1998-2000 Dag Brattli <dagb@cs.uit.no>
net/irda/irport.h: *     provided "AS-IS" and at no charge.
net/irda/irlan_filter.h: *     provided "AS-IS" and at no charge.
net/irda/nsc-ircc.h: * Filename:      nsc-ircc.h
net/irda/nsc-ircc.h: *     Copyright (c) 1998-2000 Dag Brattli <dagb@cs.uit.no>
net/irda/nsc-ircc.h: *     provided "AS-IS" and at no charge.
net/irda/irlan_event.h: *     provided "AS-IS" and at no charge.
net/irda/irlan_common.h: *     Copyright (c) 1998-1999 Dag Brattli <dagb@cs.uit.no>, 
net/irda/irlan_common.h: *     provided "AS-IS" and at no charge.
net/irda/iriap_event.h: *     Copyright (c) 1998-1999 Dag Brattli <dagb@cs.uit.no>, All Rights Reserved.
net/irda/iriap_event.h: *     provided "AS-IS" and at no charge.
net/irda/iriap_event.h:	/* S-Call */
net/irda/iriap_event.h:	/* R-Connect */
net/irda/wrapper.h: *     Copyright (c) 1998-2000 Dag Brattli <dagb@cs.uit.no>, 
net/irda/wrapper.h: *     provided "AS-IS" and at no charge.
net/irda/ircomm_tty_attach.h: *     MA 02111-1307 USA
net/irda/ircomm_tty_attach.h:/* Used for passing information through the state-machine */
net/irda/irias_object.h: *     Copyright (c) 1998-1999 Dag Brattli, All Rights Reserved.
net/irda/irias_object.h: *     provided "AS-IS" and at no charge.
net/irda/irias_object.h:/* LM-IAS Attribute types */
net/irda/irias_object.h: *  LM-IAS Object
net/irda/irias_object.h: *  Values used by LM-IAS attributes
net/irda/irias_object.h: *  Attributes used by LM-IAS objects
net/irda/irlmp_event.h: * Description:   IrDA-LMP event handling
net/irda/irlmp_event.h: *     Copyright (c) 2000-2001 Jean Tourrilhes <jt@hpl.hp.com>
net/irda/irlmp_event.h: *     provided "AS-IS" and at no charge.
net/irda/ali-ircc.h: * Filename:      ali-ircc.h
net/irda/irlap_event.h: *     Copyright (c) 1998-1999 Dag Brattli <dagb@cs.uit.no>, 
net/irda/irlap_event.h: *     Copyright (c) 2000-2001 Jean Tourrilhes <jt@hpl.hp.com>
net/irda/irlap_event.h: *     MA 02111-1307 USA
net/irda/iriap.h: *     Copyright (c) 1997-1999 Dag Brattli <dagb@cs.uit.no>, 
net/irda/iriap.h: *     provided "AS-IS" and at no charge.
net/irda/iriap.h:/* IrIAP Op-codes */
net/irda/iriap.h:	irda_start_timer(&self->watchdog_timer, timeout, self, 
net/irda/irlap.h: *     Copyright (c) 1998-1999 Dag Brattli <dagb@cs.uit.no>, 
net/irda/irlap.h: *     Copyright (c) 2000-2001 Jean Tourrilhes <jt@hpl.hp.com>
net/irda/irlap.h: *     provided "AS-IS" and at no charge.
net/irda/irlap.h: * - Jean II */
net/irda/irlap.h:#define NR_INVALID     -1
net/irda/irlap.h:#define NS_INVALID     -1
net/irda/irlap.h:	int N1; /* N1 * F-timer = Negitiated link disconnect warning threshold */
net/irda/irlap.h:	int N2; /* N2 * F-timer = Negitiated link disconnect time */
net/irda/irlap.h: 	int     window;        /* Nr of I-frames allowed to send */
net/irda/irlap.h:#define IRLAP_GET_TX_QUEUE_LEN(self) skb_queue_len(&self->txq)
net/irda/irlap.h: * - Jean II */
net/irda/irlap.h:	switch(self->state) {
net/irda/irlap.h:		ret = -1;
net/irda/irlmp.h: *     Copyright (c) 1998-1999 Dag Brattli <dagb@cs.uit.no>, 
net/irda/irlmp.h: *     Copyright (c) 2000-2001 Jean Tourrilhes <jt@hpl.hp.com>
net/irda/irlmp.h: *     provided "AS-IS" and at no charge.
net/irda/irlmp.h:/* LSAP-SEL's */
net/irda/irlmp.h:#define LSAP_MAX      0x6f /* 0x70-0x7f are reserved */
net/irda/irlmp.h: *  Used for caching the last slsap->dlsap->handle mapping
net/irda/irlmp.h:	CACHE_ENTRY cache;  /* Caching last slsap->dlsap->handle mapping */
net/irda/irlmp.h:static inline hashbin_t *irlmp_get_cachelog(void) { return irlmp->cachelog; }
net/irda/irlmp.h: * Used by IrTTP for low control, see comments in irlap.h - Jean II */
net/irda/irlmp.h:	if (self->lap == NULL)
net/irda/irlmp.h:	if (self->lap->irlap == NULL)
net/irda/irlmp.h:	return(IRLAP_GET_TX_QUEUE_LEN(self->lap->irlap) >= LAP_HIGH_THRESHOLD);
net/irda/irlmp.h: * - Jean II */
net/irda/irlmp.h:	self->dlsap_sel = LSAP_ANY;
net/irda/irlmp.h:	self->lap = NULL;
net/irda/irlmp.h:	self->lsap_state = LSAP_DISCONNECTED;
net/irda/irlmp.h:	del_timer(&self->watchdog_timer);
net/irda/irmod.h: *     Copyright (c) 1998-2000 Dag Brattli, All Rights Reserved.
net/irda/irmod.h: *     Copyright (c) 2000-2001 Jean Tourrilhes <jt@hpl.hp.com>
net/irda/irmod.h: *     provided "AS-IS" and at no charg.
net/irda/irmod.h:/* Nothing much here anymore - Maybe this header should be merged in
net/irda/irmod.h: * another header like net/irda/irda.h... - Jean II */
net/irda/irmod.h:/* Locking wrapper - Note the inverted logic on irda_lock().
net/irda/irmod.h: * position you want to set it. - Jean II */
net/irda/irttp.h: *     Copyright (c) 1998-1999 Dag Brattli <dagb@cs.uit.no>, 
net/irda/irttp.h: *     provided "AS-IS" and at no charge.
net/irda/irttp.h:/* Worst case scenario, two window of data - Jean II */
net/irda/irttp.h: * to have 7 to make a full window - Jean II */
net/irda/irttp.h: * keep a low number of Tx buffers in TTP - Jean II */
net/irda/irttp.h: * + 1 frames while he process the credits). - Jean II */
net/irda/irttp.h: * LAP window + 1 + MIN_CREDITS. - Jean II */
net/irda/irttp.h: * more than one or two packets. - Jean II */
net/irda/irttp.h:	return irlmp_get_saddr(self->lsap);
net/irda/irttp.h:	return irlmp_get_daddr(self->lsap);
net/irda/irttp.h:	return self->max_seg_size;
net/irda/irttp.h: * - Jean II */
net/irda/irttp.h:	irlmp_listen(self->lsap);
net/irda/irttp.h:	self->dtsap_sel = LSAP_ANY;
net/irda/irttp.h: * - Jean II */
net/irda/irttp.h:	    (self->lsap == NULL) ||
net/irda/irttp.h:	    (self->lsap->lap == NULL) ||
net/irda/irttp.h:	    (self->lsap->lap->irlap == NULL))
net/irda/irttp.h:		return -2;
net/irda/irttp.h:	return(irlap_is_primary(self->lsap->lap->irlap));
net/irda/irtty.h: *     Copyright (c) 1997, 1999-2000 Dag Brattli, All Rights Reserved.
net/irda/irtty.h: *     provided "AS-IS" and at no charge.
net/irda/ircomm_event.h: *     MA 02111-1307 USA
net/irda/ircomm_event.h: * Used for passing information through the state-machine
net/sctp/sm.h: * Copyright (c) 1999-2000 Cisco, Inc.
net/sctp/sm.h: * Copyright (c) 1999-2001 Motorola, Inc.
net/sctp/sm.h: * the Free Software Foundation, 59 Temple Place - Suite 330,
net/sctp/sm.h: * Boston, MA 02111-1307, USA.
net/sctp/sm.h: *    lksctp developers <lksctp-developers@lists.sourceforge.net>
net/sctp/sm.h:	SCTP_DISPOSITION_NOMEM,		 /* We ran out of memory--recover.  */
net/sctp/sm.h:/* Prototypes for chunk-building functions.  */
net/sctp/sm.h:	size = ntohs(chunk->chunk_hdr->length);
net/sctp/sm.h:	size -= sizeof(sctp_data_chunk_t);
net/sctp/sm.h:/* RFC 1982 - Serial Number Arithmetic
net/sctp/sm.h: *      (i1 < i2 and i2 - i1 < 2^(SERIAL_BITS - 1)) or
net/sctp/sm.h: *      (i1 > i2 and i1 - i2 > 2^(SERIAL_BITS - 1))
net/sctp/sm.h: *      (i1 < i2 and i2 - i1 > 2^(SERIAL_BITS - 1)) or
net/sctp/sm.h: *      (i1 > i2 and i1 - i2 < 2^(SERIAL_BITS - 1))
net/sctp/sm.h:	return (((s) - (t)) & TSN_SIGN_BIT);
net/sctp/sm.h:	return (((s) == (t)) || (((s) - (t)) & TSN_SIGN_BIT));
net/sctp/sm.h:	return (((s) - (t)) & SSN_SIGN_BIT);
net/sctp/sm.h:	return (((s) == (t)) || (((s) - (t)) & SSN_SIGN_BIT));
net/sctp/sm.h: * The valid range of Serial Number is from 0 to 4294967295 (2**32 - 1). Serial
net/sctp/sm.h:	return (((s) == (t)) || (((t) - (s)) & ADDIP_SERIAL_SIGN_BIT));
net/sctp/sm.h:        if (ntohl(chunk->sctp_hdr->vtag) == asoc->c.my_vtag)
net/sctp/sm.h:        /* RFC 2960 Section 8.5.1, sctpimpguide-06 Section 2.13.2
net/sctp/sm.h:        if ((ntohl(chunk->sctp_hdr->vtag) == asoc->c.my_vtag) ||
net/sctp/sm.h:	    (sctp_test_T_bit(chunk) && (ntohl(chunk->sctp_hdr->vtag)
net/sctp/sm.h:	    == asoc->c.peer_vtag))) {
net/sctp/constants.h: * Copyright (c) 1999-2000 Cisco, Inc.
net/sctp/constants.h: * Copyright (c) 1999-2001 Motorola, Inc.
net/sctp/constants.h: * the Free Software Foundation, 59 Temple Place - Suite 330,
net/sctp/constants.h: * Boston, MA 02111-1307, USA.
net/sctp/constants.h: *    lksctp developers <lksctp-developers@lists.sourceforge.net>
net/sctp/constants.h:#define sctp_chunk_is_control(a) (a->chunk_hdr->type != SCTP_CID_DATA)
net/sctp/constants.h:#define sctp_chunk_is_data(a) (a->chunk_hdr->type == SCTP_CID_DATA)
net/sctp/constants.h:#define SCTP_DATA_SNDSIZE(c) ((int)((unsigned long)(c->chunk_end)\
net/sctp/constants.h:		       		- (unsigned long)(c->chunk_hdr)\
net/sctp/constants.h:				- sizeof(sctp_data_chunk_t)))
net/sctp/constants.h:/* These are values for sk->state.
net/sctp/constants.h: * For a UDP-style SCTP socket, the states are defined as follows
net/sctp/constants.h: * - A socket in SCTP_SS_CLOSED state indicates that it is not willing to
net/sctp/constants.h: * - A socket in SCTP_SS_LISTENING state indicates that it is willing to
net/sctp/constants.h: * - A socket in SCTP_SS_ESTABLISHED state indicates that it is a peeled off
net/sctp/constants.h: * For a TCP-style SCTP socket, the states are defined as follows
net/sctp/constants.h: * - A socket in SCTP_SS_CLOSED state indicates that it is not willing to
net/sctp/constants.h: * - A socket in SCTP_SS_LISTENING state indicates that it is willing to
net/sctp/constants.h: * - A socket in SCTP_SS_ESTABLISHED state indicates that it has a single 
net/sctp/constants.h:enum { SCTP_MAX_CHUNK_LEN = ((1<<16) - sizeof(__u32)) };
net/sctp/constants.h:/* Encourage Cookie-Echo bundling by pre-fragmenting chunks a little
net/sctp/constants.h: * NEVER make this more than 32767 (2^15-1).  The Gap Ack Blocks in a
net/sctp/constants.h: * must be less than 65535 (2^16 - 1), or we will have overflow
net/sctp/constants.h:/* RTO.Initial              - 3  seconds
net/sctp/constants.h: * RTO.Min                  - 1  second
net/sctp/constants.h: * RTO.Max                  - 60 seconds
net/sctp/constants.h: * RTO.Alpha                - 1/8
net/sctp/constants.h: * RTO.Beta                 - 1/4
net/sctp/constants.h:                                         * to which we will raise the P-MTU.
net/sctp/constants.h:#define SCTP_SIGNATURE_SIZE 20	        /* size of a SLA-1 signature */
net/sctp/constants.h: * based on draft of SCTP IPv4 scoping <draft-stewart-tsvwg-sctp-ipv4-00.txt>.
net/sctp/constants.h:/* Based on IPv4 scoping <draft-stewart-tsvwg-sctp-ipv4-00.txt>,
net/sctp/constants.h: * Also, RFC 8.4, non-unicast addresses are not considered valid SCTP
net/sctp/constants.h:/* IPv4 Link-local addresses: 169.254.0.0/16.  */
net/sctp/constants.h: * 10.0.0.0 - 10.255.255.255 (10/8 prefix)
net/sctp/constants.h: * 172.16.0.0.0 - 172.31.255.255 (172.16/12 prefix)
net/sctp/constants.h: * 192.168.0.0 - 192.168.255.255 (192.168/16 prefix)
net/sctp/command.h: * Copyright (C) 1999-2001 Cisco, Motorola
net/sctp/command.h: * the Free Software Foundation, 59 Temple Place - Suite 330,
net/sctp/command.h: * Boston, MA 02111-1307, USA.
net/sctp/command.h:	SCTP_CMD_SETUP_T2,       /* Hi-level, setup T2-shutdown parms.  */
net/sctp/command.h:	SCTP_CMD_DEL_NON_PRIMARY, /* Removes non-primary peer transports. */
net/sctp/command.h:	SCTP_CMD_T3_RTX_TIMERS_STOP, /* Stops T3-rtx pending timers */
net/sctp/command.h:#define SCTP_CMD_MAX		(SCTP_CMD_LAST - 1)
net/sctp/structs.h: * Copyright (c) 1999-2000 Cisco, Inc.
net/sctp/structs.h: * Copyright (c) 1999-2001 Motorola, Inc.
net/sctp/structs.h: * the Free Software Foundation, 59 Temple Place - Suite 330,
net/sctp/structs.h: * Boston, MA 02111-1307, USA.
net/sctp/structs.h: *    lksctp developers <lksctp-developers@lists.sourceforge.net>
net/sctp/structs.h:	 * RTO.Initial		    - 3	 seconds
net/sctp/structs.h:	 * RTO.Min		    - 1	 second
net/sctp/structs.h:	 * RTO.Max		   -  60 seconds
net/sctp/structs.h:	 * RTO.Alpha		    - 1/8  (3 when converted to right shifts.)
net/sctp/structs.h:	 * RTO.Beta		    - 1/4  (2 when converted to right shifts.)
net/sctp/structs.h:	/* Max.Burst		    - 4 */
net/sctp/structs.h:	/* Valid.Cookie.Life	    - 60  seconds  */
net/sctp/structs.h:	/* Association.Max.Retrans  - 10 attempts
net/sctp/structs.h:	 * Path.Max.Retrans	    - 5	 attempts (per destination address)
net/sctp/structs.h:	 * Max.Init.Retransmits	    - 8	 attempts
net/sctp/structs.h:	/* HB.interval		    - 30 seconds  */
net/sctp/structs.h:	/* Flag to indicate if PR-SCTP is enabled. */
net/sctp/structs.h:/* This is our APPLICATION-SPECIFIC state cookie.
net/sctp/structs.h:	 * Include the source port of the INIT-ACK
net/sctp/structs.h:	 * the association TCB is re-constructed from the cookie.
net/sctp/structs.h: *    The Sender-specific Heartbeat Info field should normally include
net/sctp/structs.h: *  messages that are to be delivered to the upper-layer protocol in
net/sctp/structs.h:	return stream->ssn[id];
net/sctp/structs.h:	return stream->ssn[id]++;
net/sctp/structs.h:	stream->ssn[id] = ssn+1;
net/sctp/structs.h: * a chunk header and chunk-specific content.
net/sctp/structs.h:	/* This is our link to the per-transport transmitted list.  */
net/sctp/structs.h:/* sin_family -- AF_INET or AF_INET6
net/sctp/structs.h: * sin_port -- ordinary port number
net/sctp/structs.h: * sin_addr -- cast to either (struct in_addr) or (struct in6_addr)
net/sctp/structs.h:	/* This packet contains a COOKIE-ECHO chunk. */
net/sctp/structs.h:	return (packet->size == packet->overhead);
net/sctp/structs.h: *	source-destination pair but for each destination).  The parameters
net/sctp/structs.h:	/* RTO-Pending : A flag used to track if one of the DATA
net/sctp/structs.h:	 *	       :  i.e. ALLOW-HB, NO-HEARTBEAT, etc.
net/sctp/structs.h:	 * [Everywhere else in the text this is called T3-rtx. -ed]
net/sctp/structs.h:	/* Since we're using per-destination retransmission timers
net/sctp/structs.h:	 * (see above), we're also using per-destination "transmitted"
net/sctp/structs.h:	/* We build bundle-able packets for this transport here.  */
net/sctp/structs.h:	 * per-destination basis when a changeover happens.
net/sctp/structs.h:	/* How many unackd bytes do we have in-flight?	*/
net/sctp/structs.h:	q->cork = 1;
net/sctp/structs.h:	 *   refcnt   - Reference count access to this object.
net/sctp/structs.h:	 *   dead     - Do not attempt to use this object.
net/sctp/structs.h:	 *   malloced - Do we need to kfree this object?
net/sctp/structs.h: *   multi-homed host, an SCTP endpoint is represented to its peers as a
net/sctp/structs.h: * A TCP-style socket will have exactly one association on one of
net/sctp/structs.h: * these.  An UDP-style socket will have multiple associations hanging
net/sctp/structs.h:		 * RFC2960 6.4 Multi-homed SCTP Endpoints
net/sctp/structs.h:		 * Furthermore, when its peer is multi-homed, an
net/sctp/structs.h:		 * in tsn_map--we get it by calling sctp_tsnmap_get_ctsn().
net/sctp/structs.h:		__u8    prsctp_capable;  /* Can peer do PR-SCTP? */
net/sctp/structs.h:		 * C1) ... "Peer-Serial-Number'. This value MUST be initialized to the
net/sctp/structs.h:	 *	       : association is in, i.e. COOKIE-WAIT,
net/sctp/structs.h:	 *	       : COOKIE-ECHOED, ESTABLISHED, SHUTDOWN-PENDING,
net/sctp/structs.h:	 *	       : SHUTDOWN-SENT, SHUTDOWN-RECEIVED, SHUTDOWN-ACK-SENT.
net/sctp/structs.h:	/* PR-SCTP Advanced.Peer.Ack.Point */
net/sctp/structs.h:	 * as specified in the sk->sndbuf.
net/sctp/structs.h:	 * <draft-ietf-tsvwg-addip-sctp-02.txt>
net/sctp/structs.h:	 * ASCONF Chunk, it MUST wait until the ASCONF-ACK Chunk
net/sctp/structs.h:	 * so at any time two ASCONF may be in-transit on any given
net/sctp/structs.h:	 * [This is our one-and-only-one ASCONF in flight.  If we do
net/sctp/structs.h:	 * to save the last ASCONF-ACK for some predetermined period
net/sctp/structs.h:	 * of time and instead of re-processing the ASCONF (with the
net/sctp/structs.h:	 * same serial number) it may just re-transmit the
net/sctp/structs.h:	 * ASCONF-ACK. It may wish to use the arrival of a new serial
net/sctp/structs.h:	 * number to discard the previously saved ASCONF-ACK or any
net/sctp/structs.h:	 * other means it may choose to expire the saved ASCONF-ACK.
net/sctp/structs.h:	 * [This is our saved ASCONF-ACK.  We invalidate it when a new
net/sctp/structs.h:	 * ASCONF Chunk, it MUST wait until the ASCONF-ACK Chunk
net/sctp/structs.h:	 * so at any time two ASCONF may be in-transit on any given
net/sctp/structs.h:	 *  queue and its supporting logic down there.	--piggy]
net/sctp/structs.h:	 * 4294967295 (2^32 - 1).  Serial Numbers wrap back to 0
net/sctp/tsnmap.h: * Copyright (c) 1999-2000 Cisco, Inc.
net/sctp/tsnmap.h: * Copyright (c) 1999-2001 Motorola, Inc.
net/sctp/tsnmap.h: * the Free Software Foundation, 59 Temple Place - Suite 330,
net/sctp/tsnmap.h: * Boston, MA 02111-1307, USA.
net/sctp/tsnmap.h: *    lksctp developers <lksctp-developers@lists.sourceforge.net>
net/sctp/tsnmap.h:	 * ping-pong between.
net/sctp/tsnmap.h:	 * It points at one of the other ping-pong buffers.
net/sctp/tsnmap.h:	return map->cumulative_tsn_ack_point;
net/sctp/tsnmap.h:	return map->max_tsn_seen;
net/sctp/tsnmap.h:	return map->num_dup_tsns;
net/sctp/tsnmap.h:	map->num_dup_tsns = 0;
net/sctp/tsnmap.h:	return map->dup_tsns;
net/sctp/tsnmap.h:	return map->gabs;
net/sctp/tsnmap.h:	has_gap = (map->cumulative_tsn_ack_point != map->max_tsn_seen);
net/sctp/tsnmap.h:	if (map->num_dup_tsns < SCTP_MAX_DUP_TSNS)
net/sctp/tsnmap.h:		map->dup_tsns[map->num_dup_tsns++] = htonl(tsn);
net/sctp/ulpqueue.h: * Copyright (c) 1999-2000 Cisco, Inc.
net/sctp/ulpqueue.h: * Copyright (c) 1999-2001 Motorola, Inc.
net/sctp/ulpqueue.h: * the Free Software Foundation, 59 Temple Place - Suite 330,
net/sctp/ulpqueue.h: * Boston, MA 02111-1307, USA.
net/sctp/ulpqueue.h: *    lksctp developers <lksctp-developers@lists.sourceforge.net>
net/sctp/compat.h: * Copyright (c) 2003 Hewlett-Packard Company
net/sctp/compat.h: * the Free Software Foundation, 59 Temple Place - Suite 330,
net/sctp/compat.h: * Boston, MA 02111-1307, USA.  
net/sctp/compat.h: * container_of - cast a member of a structure out to the containing structure
net/sctp/compat.h:	const typeof( ((type *)0)->member ) *__mptr = (ptr);	\
net/sctp/compat.h:	(type *)( (char *)__mptr - offsetof(type,member) );})
net/sctp/compat.h:#define SNMP_DEC_STATS(mib, field) ((mib)[2*smp_processor_id()+!in_softirq()].field--)
net/sctp/compat.h:#define inet_sk(__sk) (&(((struct sock *)__sk)->protinfo.af_inet))
net/sctp/compat.h:#define inet6_sk(__sk) (&(((struct sock *)__sk)->net_pinfo.af_inet6))
net/sctp/compat.h:#define sock_owned_by_user(sk)  ((sk)->lock.users)
net/sctp/compat.h:#define dst_pmtu(x) ((x)->pmtu)
net/sctp/compat.h:		r -= 16;
net/sctp/compat.h:		r -= 8;
net/sctp/compat.h:		r -= 4;
net/sctp/compat.h:		r -= 2;
net/sctp/compat.h:		r -= 1;
net/sctp/ulpevent.h: * Copyright (c) 1999-2000 Cisco, Inc.
net/sctp/ulpevent.h: * Copyright (c) 1999-2001 Motorola, Inc.
net/sctp/ulpevent.h: * the Free Software Foundation, 59 Temple Place - Suite 330,
net/sctp/ulpevent.h: * Boston, MA 02111-1307, USA.
net/sctp/ulpevent.h: *    lksctp developers <lksctp-developers@lists.sourceforge.net>
net/sctp/ulpevent.h:	return (struct sctp_ulpevent *)skb->cb;
net/sctp/ulpevent.h:	return amask[sn_type - SCTP_SN_TYPE_BASE];
net/sctp/sctp.h: * Copyright (c) 1999-2000 Cisco, Inc.
net/sctp/sctp.h: * Copyright (c) 1999-2001 Motorola, Inc.
net/sctp/sctp.h: * Copyright (c) 2001-2003 Intel Corp.
net/sctp/sctp.h: * the Free Software Foundation, 59 Temple Place - Suite 330,
net/sctp/sctp.h: * Boston, MA 02111-1307, USA.
net/sctp/sctp.h: *    lksctp developers <lksctp-developers@lists.sourceforge.net>
net/sctp/sctp.h:	return -ENOSYS;
net/sctp/sctp.h:for (pos = (head)->next;\
net/sctp/sctp.h:     tmp = (pos)->next, pos != ((struct sk_buff *)(head));\
net/sctp/sctp.h:	sctp_spin_lock_irqsave(&head->lock, flags);
net/sctp/sctp.h:	sctp_spin_lock(&list->lock);
net/sctp/sctp.h:	list_splice((struct list_head *)list, (struct list_head *)head->prev);
net/sctp/sctp.h:	head->qlen += list->qlen;
net/sctp/sctp.h:	list->qlen = 0;
net/sctp/sctp.h:	sctp_spin_unlock(&list->lock);
net/sctp/sctp.h:	sctp_spin_unlock_irqrestore(&head->lock, flags);
net/sctp/sctp.h: *	sctp_list_dequeue - remove from the head of the queue
net/sctp/sctp.h:	if (list->next != list) {
net/sctp/sctp.h:		result = list->next;
net/sctp/sctp.h:		list->next = result->next;
net/sctp/sctp.h:		list->next->prev = list;
net/sctp/sctp.h:	return ((head->next != head) && (head->next == head->prev));
net/sctp/sctp.h:	for (; iovlen > 0; --iovlen) {
net/sctp/sctp.h:		retval += iov->iov_len;
net/sctp/sctp.h:/* Generate a random jitter in the range of -50% ~ +50% of input RTO. */
net/sctp/sctp.h:	/* Choose random number from 0 to rto, then move to -50% ~ +50%
net/sctp/sctp.h:	ret = sctp_rand % rto - (rto >> 1);
net/sctp/sctp.h:	frag -= sp->pf->af->net_header_len;
net/sctp/sctp.h:	frag -= sizeof(struct sctphdr) + sizeof(struct sctp_data_chunk);
net/sctp/sctp.h:	if (sp->user_frag)
net/sctp/sctp.h:		frag = min_t(int, frag, sp->user_frag);
net/sctp/sctp.h:_sctp_walk_params((pos), (chunk), WORD_ROUND(ntohs((chunk)->chunk_hdr.length)), member)
net/sctp/sctp.h:for (pos.v = chunk->member;\
net/sctp/sctp.h:     pos.v <= (void *)chunk + end - sizeof(sctp_paramhdr_t) &&\
net/sctp/sctp.h:     pos.v <= (void *)chunk + end - WORD_ROUND(ntohs(pos.p->length)) &&\
net/sctp/sctp.h:     ntohs(pos.p->length) >= sizeof(sctp_paramhdr_t);\
net/sctp/sctp.h:     pos.v += WORD_ROUND(ntohs(pos.p->length)))
net/sctp/sctp.h:_sctp_walk_errors((err), (chunk_hdr), ntohs((chunk_hdr)->length))
net/sctp/sctp.h:     (void *)err <= (void *)chunk_hdr + end - sizeof(sctp_errhdr_t) &&\
net/sctp/sctp.h:     (void *)err <= (void *)chunk_hdr + end - WORD_ROUND(ntohs(err->length)) &&\
net/sctp/sctp.h:     ntohs(err->length) >= sizeof(sctp_errhdr_t); \
net/sctp/sctp.h:     err = (sctp_errhdr_t *)((void *)err + WORD_ROUND(ntohs(err->length))))
net/sctp/sctp.h:_sctp_walk_fwdtsn((pos), (chunk), ntohs((chunk)->chunk_hdr->length) - sizeof(struct sctp_fwdtsn_chunk))
net/sctp/sctp.h:for (pos = chunk->subh.fwdtsn_hdr->skip;\
net/sctp/sctp.h:     (void *)pos <= (void *)chunk->subh.fwdtsn_hdr->skip + end - sizeof(struct sctp_fwdtsn_skip);\
net/sctp/sctp.h:                usecs -= 1000000; \
net/sctp/sctp.h:		    sizeof(((struct sk_buff *)0)->cb),
net/sctp/sctp.h:	return (lport & (sctp_port_hashsize - 1));
net/sctp/sctp.h:	return (lport & (sctp_ep_hashsize - 1));
net/sctp/sctp.h:	return (h & (sctp_assoc_hashsize - 1));
net/sctp/sctp.h:	return (h & (sctp_assoc_hashsize-1));
net/sctp/sctp.h:#define sctp_sk(__sk) (&(((struct sock *)__sk)->tp_pinfo.af_sctp))
net/sctp/sctp.h:	return sctp_sk(sk)->type == style;
net/sctp/sctp.h:	return asoc->state == state;
net/sctp/sctp.h:	return sk->state == state;
net/sctp/sctp.h:/* Map v4-mapped v6 address back to v4 address */
net/sctp/sctp.h:	addr->v4.sin_family = AF_INET;
net/sctp/sctp.h:	addr->v4.sin_port = addr->v6.sin6_port;
net/sctp/sctp.h:	addr->v4.sin_addr.s_addr = addr->v6.sin6_addr.s6_addr32[3];
net/sctp/sctp.h:/* Map v4 address to v4-mapped v6 address */
net/sctp/sctp.h:	addr->v6.sin6_family = AF_INET6;
net/sctp/sctp.h:	addr->v6.sin6_port = addr->v4.sin_port;
net/sctp/sctp.h:	addr->v6.sin6_addr.s6_addr32[3] = addr->v4.sin_addr.s_addr;
net/sctp/sctp.h:	addr->v6.sin6_addr.s6_addr32[0] = 0;
net/sctp/sctp.h:	addr->v6.sin6_addr.s6_addr32[1] = 0;
net/sctp/sctp.h:	addr->v6.sin6_addr.s6_addr32[2] = htonl(0x0000ffff);
net/sctp/sla1.h: * the Free Software Foundation, 59 Temple Place - Suite 330,
net/sctp/sla1.h: * Boston, MA 02111-1307, USA.  
net/sctp/sla1.h: *    lksctp developers <lksctp-developers@lists.sourceforge.net>
net/sctp/sla1.h:#define CSHIFT(A,B) ((B << A) | (B >> (32-A)))
net/sctp/user.h: * Copyright (c) 1999-2000 Cisco, Inc.
net/sctp/user.h: * Copyright (c) 1999-2001 Motorola, Inc.
net/sctp/user.h: * the Free Software Foundation, 59 Temple Place - Suite 330,
net/sctp/user.h: * Boston, MA 02111-1307, USA.
net/sctp/user.h: *    lksctp developers <lksctp-developers@lists.sourceforge.net>
net/sctp/user.h: * SCTP <draft-ietf-tsvwg-sctpsocket-07.txt>.
net/sctp/user.h: *   ------------  ------------   ----------------------
net/sctp/user.h: *   ------------  ------------   ----------------------
net/sctp/user.h: *   When a destination address on a multi-homed peer encounters a change
net/sctp/user.h: *   SCTP_DATA_UNSENT  - Indicates that the data was never put on
net/sctp/user.h: *   SCTP_DATA_SENT    - Indicates that the data was put on the wire.
net/sctp/user.h: * Indication parameter for all future INIT and INIT-ACK exchanges.
net/sctp/user.h: *   read-only. The following structure is used to access this
net/sctp/user.h: *   receipt.  This information is read-only.  The following structure is
net/sctp/user.h:/* These are bit fields for msghdr->msg_flags.  See section 5.1.  */
net/ip6_fib.h:	w->next = fib6_walker_list.next;
net/ip6_fib.h:	w->prev = &fib6_walker_list;
net/ip6_fib.h:	w->next->prev = w;
net/ip6_fib.h:	w->prev->next = w;
net/ip6_fib.h:	w->next->prev = w->prev;
net/ip6_fib.h:	w->prev->next = w->next;
net/ip6_fib.h:	w->prev = w->next = w;
net/iw_handler.h: * Authors :	Jean Tourrilhes - HPL - <jt@hpl.hp.com>
net/iw_handler.h: * Copyright (c) 2001-2002 Jean Tourrilhes, All Rights Reserved.
net/iw_handler.h: * Initial driver API (1996 -> onward) :
net/iw_handler.h: * -----------------------------------
net/iw_handler.h: * New driver API (2002 -> onward) :
net/iw_handler.h: * -------------------------------
net/iw_handler.h: *	o Driver doesn't have to worry about memory and user-space issues
net/iw_handler.h: * ---
net/iw_handler.h: * Good luck with migration to the new API ;-)
net/iw_handler.h:/* ---------------------- THE IMPLEMENTATION ---------------------- */
net/iw_handler.h: * --------------------
net/iw_handler.h: * ---------------------------------------------
net/iw_handler.h: * ----------------------------------------
net/iw_handler.h: * modify it according to info->cmd and rewrite it).
net/iw_handler.h: * -----------------------------------------
net/iw_handler.h: * ----------------------------------
net/iw_handler.h: * ---------------------------------
net/iw_handler.h: * ----------------------
net/iw_handler.h: * --------------------------------
net/iw_handler.h: * --------
net/iw_handler.h: *	- Move event definition in <linux/wireless.h>
net/iw_handler.h: *	- Add Wireless Event support :
net/iw_handler.h: * --------
net/iw_handler.h: *	- Reshuffle IW_HEADER_TYPE_XXX to map IW_PRIV_TYPE_XXX changes
net/iw_handler.h: * --------
net/iw_handler.h: *	- Add new spy support : struct iw_spy_data & prototypes
net/iw_handler.h: * cool features we might need one day ;-) */
net/iw_handler.h:/* ----------------------- WIRELESS HANDLER ----------------------- */
net/iw_handler.h: * (that's the perfect hash table ;-).
net/iw_handler.h:	__u16		flags;		/* More to come ;-) */
net/iw_handler.h:	 * We will call dev->wireless_handlers->standard[ioctl - SIOCSIWNAME]
net/iw_handler.h:	 * Will call dev->wireless_handlers->private[ioctl - SIOCIWFIRSTPRIV]
net/iw_handler.h:/* ---------------------- IOCTL DESCRIPTION ---------------------- */
net/iw_handler.h:/* --------------------- ENHANCED SPY SUPPORT --------------------- */
net/iw_handler.h:	/* --- Standard spy support --- */
net/iw_handler.h:	/* --- Enhanced spy support (event) */
net/iw_handler.h:/*------------------------------------------------------------------*/
net/iw_handler.h:		iwe->len = event_len;
net/iw_handler.h:/*------------------------------------------------------------------*/
net/iw_handler.h:	int	event_len = IW_EV_POINT_LEN + iwe->u.data.length;
net/iw_handler.h:		iwe->len = event_len;
net/iw_handler.h:		memcpy(stream + IW_EV_POINT_LEN, extra, iwe->u.data.length);
net/iw_handler.h:/*------------------------------------------------------------------*/
net/iw_handler.h:	event_len -= IW_EV_LCP_LEN;
net/iw_handler.h:		iwe->len = value - event;
net/pkt_cls.h:	u32 protocol = skb->protocol;
net/pkt_cls.h:	for ( ; tp; tp = tp->next) {
net/pkt_cls.h:		if ((tp->protocol == protocol ||
net/pkt_cls.h:		     tp->protocol == __constant_htons(ETH_P_ALL)) &&
net/pkt_cls.h:		    (err = tp->classify(skb, tp, res)) >= 0)
net/pkt_cls.h:	return -1;
net/pkt_cls.h:	tp->ops->destroy(tp);
net/inetpeer.h: *		INETPEER - A storage for permanent information about peers
net/inetpeer.h:	if (atomic_dec_and_test(&p->refcnt)) {
net/inetpeer.h:		p->unused_prevp = inet_peer_unused_tailp;
net/inetpeer.h:		p->unused_next = NULL;
net/inetpeer.h:		inet_peer_unused_tailp = &p->unused_next;
net/inetpeer.h:		p->dtime = jiffies;
net/inetpeer.h:	id = p->ip_id_count++;
net/dst.h: * 0 - no debugging messages
net/dst.h: * 1 - rare events and bugs (default)
net/dst.h: * 2 - trace mode.
net/dst.h:	atomic_inc(&dst->__refcnt);
net/dst.h:		atomic_inc(&dst->__refcnt);
net/dst.h:		atomic_dec(&dst->__refcnt);
net/dst.h:	if (dst->obsolete > 1)
net/dst.h:	if (!atomic_read(&dst->__refcnt)) {
net/dst.h:		neigh_confirm(dst->neighbour);
net/dst.h:	if (dst && dst->ops->negative_advice)
net/dst.h:		*dst_p = dst->ops->negative_advice(dst);
net/dst.h:	struct dst_entry * dst = skb->dst;
net/dst.h:	if (dst && dst->ops && dst->ops->link_failure)
net/dst.h:		dst->ops->link_failure(skb);
net/dst.h:	if (dst->expires == 0 || (long)(dst->expires - expires) > 0)
net/dst.h:		dst->expires = expires;
net/ipx.h: *		Part No. 107-000029-001
net/llc.h:#define ADD_TO_RTQ(skb) skb_queue_tail(&lp->rtq,skb)
net/llc.h:#define ADD_TO_ATQ(skb) skb_queue_tail(&lp->atq,skb)
net/raw.h: *		Definitions for the RAW-IP module.
net/dsfield.h:/* include/net/dsfield.h - Manipulation of the Differentiated Services field */
net/dsfield.h:/* Written 1998-2000 by Werner Almesberger, EPFL ICA */
net/dsfield.h:	return iph->tos;
net/dsfield.h:        __u32 check = ntohs(iph->check);
net/dsfield.h:	dsfield = (iph->tos & mask) | value;
net/dsfield.h:	check += iph->tos;
net/dsfield.h:	check -= dsfield;
net/dsfield.h:	iph->check = htons(check);
net/dsfield.h:	iph->tos = dsfield;
net/scm.h:#define SCM_MAX_FD	(OPEN_MAX-1)
net/scm.h:	if (scm && scm->fp)
net/scm.h:	scm->creds.uid = current->uid;
net/scm.h:	scm->creds.gid = current->gid;
net/scm.h:	scm->creds.pid = current->pid;
net/scm.h:	if (msg->msg_controllen <= 0)
net/scm.h:	if (!msg->msg_control)
net/scm.h:		if (sock->passcred || scm->fp)
net/scm.h:			msg->msg_flags |= MSG_CTRUNC;
net/scm.h:	if (sock->passcred)
net/scm.h:		put_cmsg(msg, SOL_SOCKET, SCM_CREDENTIALS, sizeof(scm->creds), &scm->creds);
net/scm.h:	if (!scm->fp)
net/x25.h:#define X25_SKB_CB(s) ((struct x25_skb_cb *) ((s)->cb))
net/tcp.h: *	2) If all sockets have sk->reuse set, and none of them are in
net/tcp.h: *	3) If all sockets are bound to a specific sk->rcv_saddr local
net/tcp.h: * check of: (newsk->reuse && (newsk->state != TCP_LISTEN))
net/tcp.h: * sk->reuse set, we don't even have to walk the owners list at all,
net/tcp.h: * ports are created in O(1) time?  I thought so. ;-)	-DaveM
net/tcp.h:	 *          TCP_ESTABLISHED <= sk->state < TCP_CLOSE
net/tcp.h:	 * never written again _or_ are predominantly read-access.
net/tcp.h:	return (lport & (tcp_bhash_size - 1));
net/tcp.h:	 * XXX networking file if I created a "struct sock_header". -DaveM
net/tcp.h:	if (atomic_dec_and_test(&tw->refcnt)) {
net/tcp.h:	(((*((__u64 *)&((__sk)->daddr)))== (__cookie))	&&		\
net/tcp.h:	 ((*((__u32 *)&((__sk)->dport)))== (__ports))   &&		\
net/tcp.h:	 (!((__sk)->bound_dev_if) || ((__sk)->bound_dev_if == (__dif))))
net/tcp.h:#else /* 32-bit arch */
net/tcp.h:	(((__sk)->daddr			== (__saddr))	&&		\
net/tcp.h:	 ((__sk)->rcv_saddr		== (__daddr))	&&		\
net/tcp.h:	 ((*((__u32 *)&((__sk)->dport)))== (__ports))   &&		\
net/tcp.h:	 (!((__sk)->bound_dev_if) || ((__sk)->bound_dev_if == (__dif))))
net/tcp.h:#endif /* 64-bit arch */
net/tcp.h:	(((*((__u32 *)&((__sk)->dport)))== (__ports))   			&& \
net/tcp.h:	 ((__sk)->family		== AF_INET6)				&& \
net/tcp.h:	 !ipv6_addr_cmp(&(__sk)->net_pinfo.af_inet6.daddr, (__saddr))		&& \
net/tcp.h:	 !ipv6_addr_cmp(&(__sk)->net_pinfo.af_inet6.rcv_saddr, (__daddr))	&& \
net/tcp.h:	 (!((__sk)->bound_dev_if) || ((__sk)->bound_dev_if == (__dif))))
net/tcp.h:	return num & (TCP_LHTABLE_SIZE - 1);
net/tcp.h:	return tcp_lhashfn(sk->num);
net/tcp.h:/* Minimal accepted MSS. It is (60+60+8) - (20+20). */
net/tcp.h:/* Maximal number of ACKs sent quickly to accelerate slow-start. */
net/tcp.h:				 * to ~3sec-8min depending on RTO.
net/tcp.h:				 * 15 is ~13-30min depending on RTO.
net/tcp.h:				 * socket. 7 is ~50sec-16min.
net/tcp.h:#define TCP_TIMEWAIT_LEN (60*HZ) /* how long to wait to destroy TIME-WAIT
net/tcp.h:				  * to combine FIN-WAIT-2 timeout with
net/tcp.h:				  * TIME-WAIT timer.
net/tcp.h:#define TCP_PAWS_MSL	60		/* Per-host timestamps are invalidated
net/tcp.h:#define TCP_PAWS_WINDOW	1		/* Replay window for per-host
net/tcp.h:# define TCP_TW_RECYCLE_TICK (5+2-TCP_TW_RECYCLE_SLOTS_LOG)
net/tcp.h:# define TCP_TW_RECYCLE_TICK (6+2-TCP_TW_RECYCLE_SLOTS_LOG)
net/tcp.h:# define TCP_TW_RECYCLE_TICK (7+2-TCP_TW_RECYCLE_SLOTS_LOG)
net/tcp.h:# define TCP_TW_RECYCLE_TICK (8+2-TCP_TW_RECYCLE_SLOTS_LOG)
net/tcp.h:# define TCP_TW_RECYCLE_TICK (9+2-TCP_TW_RECYCLE_SLOTS_LOG)
net/tcp.h:# define TCP_TW_RECYCLE_TICK (10+2-TCP_TW_RECYCLE_SLOTS_LOG)
net/tcp.h:# define TCP_TW_RECYCLE_TICK (11+2-TCP_TW_RECYCLE_SLOTS_LOG)
net/tcp.h:# define TCP_TW_RECYCLE_TICK (12+2-TCP_TW_RECYCLE_SLOTS_LOG)
net/tcp.h:					 * log(B/Smin)/log(B/(B-1))+1,
net/tcp.h:	/* The following two fields can be easily recomputed I think -AK */
net/tcp.h:	req->class->destructor(req);
net/tcp.h: *						--ANK (980802)
net/tcp.h:        return (__s32)(seq1-seq2) < 0;
net/tcp.h:	return (__s32)(seq2-seq1) < 0;
net/tcp.h:	return seq3 - seq2 >= seq1 - seq2;
net/tcp.h:	tp->ack.pending |= TCP_ACK_SCHED;
net/tcp.h:	return tp->ack.pending&TCP_ACK_SCHED;
net/tcp.h:	if (tp->ack.quick && --tp->ack.quick == 0) {
net/tcp.h:		tp->ack.ato = TCP_ATO_MIN;
net/tcp.h:	memset(&tp->ack, 0, sizeof(tp->ack));
net/tcp.h: 	tp->tstamp_ok = tp->sack_ok = tp->wscale_ok = tp->snd_wscale = 0;
net/tcp.h:/* Read 'sendfile()'-style from a TCP socket */
net/tcp.h:	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
net/tcp.h:		tp->pending = 0;
net/tcp.h:		if (timer_pending(&tp->retransmit_timer) &&
net/tcp.h:		    del_timer(&tp->retransmit_timer))
net/tcp.h:		tp->ack.blocked = 0;
net/tcp.h:		tp->ack.pending = 0;
net/tcp.h:		if (timer_pending(&tp->delack_timer) &&
net/tcp.h:		    del_timer(&tp->delack_timer))
net/tcp.h:	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
net/tcp.h:		tp->pending = what;
net/tcp.h:		tp->timeout = jiffies+when;
net/tcp.h:		if (!mod_timer(&tp->retransmit_timer, tp->timeout))
net/tcp.h:		tp->ack.pending |= TCP_ACK_TIMER;
net/tcp.h:		tp->ack.timeout = jiffies+when;
net/tcp.h:		if (!mod_timer(&tp->delack_timer, tp->ack.timeout))
net/tcp.h:	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
net/tcp.h:	int mss_now = tp->mss_cache; 
net/tcp.h:	if (dst && dst->pmtu != tp->pmtu_cookie)
net/tcp.h:		mss_now = tcp_sync_mss(sk, dst->pmtu);
net/tcp.h:	if (tp->eff_sacks)
net/tcp.h:		mss_now -= (TCPOLEN_SACK_BASE_ALIGNED +
net/tcp.h:			    (tp->eff_sacks * TCPOLEN_SACK_PERBLOCK));
net/tcp.h:	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
net/tcp.h:	unsigned int hint = min(tp->advmss, tp->mss_cache);
net/tcp.h:	hint = min(hint, tp->rcv_wnd/2);
net/tcp.h:	tp->ack.rcv_mss = hint;
net/tcp.h:	tp->pred_flags = htonl((tp->tcp_header_len << 26) |
net/tcp.h:	__tcp_fast_path_on(tp, tp->snd_wnd>>tp->snd_wscale);
net/tcp.h:	if (skb_queue_len(&tp->out_of_order_queue) == 0 &&
net/tcp.h:	    tp->rcv_wnd &&
net/tcp.h:	    atomic_read(&sk->rmem_alloc) < sk->rcvbuf &&
net/tcp.h:	    !tp->urg_data)
net/tcp.h:	s32 win = tp->rcv_wup + tp->rcv_wnd - tp->rcv_nxt;
net/tcp.h:/* TCP timestamps are only 32-bits, this causes a slight
net/tcp.h: * complication on 64-bit systems since we store a snapshot
net/tcp.h: * only use of the low 32-bits of jiffies and hide the ugly
net/tcp.h: * TCP per-packet control information to the transmission
net/tcp.h: * code.  We also store the host-order sequence numbers in
net/tcp.h: * here too.  This is 36 bytes on 32-bit architectures,
net/tcp.h: * 40 bytes on 64-bit machines, if this grows please adjust
net/tcp.h: * skbuff.h:skbuff->cb[xxx] size appropriately.
net/tcp.h:#define TCP_SKB_CB(__skb)	((struct tcp_skb_cb *)&((__skb)->cb[0]))
net/tcp.h:		for (skb = (sk)->write_queue.next;			\
net/tcp.h:		     (skb != (tp)->send_head) &&			\
net/tcp.h:		     (skb != (struct sk_buff *)&(sk)->write_queue);	\
net/tcp.h:		     skb=skb->next)
net/tcp.h:	return sk->wmem_queued/2;
net/tcp.h:	return sk->sndbuf - sk->wmem_queued;
net/tcp.h: * tp->packets_out to determine if the send queue is empty or not.
net/tcp.h:	return tp->packets_out - tp->left_out + tp->retrans_out;
net/tcp.h:#define tcp_is_vegas(__tp)	((__tp)->adv_cong == TCP_VEGAS)
net/tcp.h:#define tcp_is_westwood(__tp)	((__tp)->adv_cong == TCP_WESTWOOD)
net/tcp.h:#define tcp_is_bic(__tp)	((__tp)->adv_cong == TCP_BIC)
net/tcp.h:		    tp->snd_cwnd < tp->bictcp.last_max_cwnd)
net/tcp.h:			tp->bictcp.last_max_cwnd = (tp->snd_cwnd * 
net/tcp.h:			tp->bictcp.last_max_cwnd = tp->snd_cwnd;
net/tcp.h:		if (tp->snd_cwnd > sysctl_tcp_bic_low_window)
net/tcp.h:			return max((tp->snd_cwnd * sysctl_tcp_bic_beta)
net/tcp.h:	return max(tp->snd_cwnd >> 1U, 2U);
net/tcp.h:#define tcp_vegas_disable(__tp)	((__tp)->vegas.doing_vegas_now = 0)
net/tcp.h:	/* There are several situations when we must "re-start" Vegas:
net/tcp.h:	 * stale info -- both the saved cwnd and congestion feedback are
net/tcp.h:	tp->vegas.doing_vegas_now = 1;
net/tcp.h:	tp->vegas.beg_snd_nxt = tp->snd_nxt;
net/tcp.h:	tp->vegas.cntRTT = 0;
net/tcp.h:	tp->vegas.minRTT = 0x7fffffff;
net/tcp.h:#define tcp_vegas_enabled(__tp)	((__tp)->vegas.doing_vegas_now)
net/tcp.h:	tp->ca_state = ca_state;
net/tcp.h:/* If cwnd > ssthresh, we may raise ssthresh to be half-way to cwnd.
net/tcp.h:	if ((1<<tp->ca_state)&(TCPF_CA_CWR|TCPF_CA_Recovery))
net/tcp.h:		return tp->snd_ssthresh;
net/tcp.h:		return max(tp->snd_ssthresh,
net/tcp.h:			   ((tp->snd_cwnd >> 1) +
net/tcp.h:			    (tp->snd_cwnd >> 2)));
net/tcp.h:	if (tp->sack_ok && tp->sacked_out >= tp->packets_out - tp->lost_out)
net/tcp.h:		tp->sacked_out = tp->packets_out - tp->lost_out;
net/tcp.h:	tp->left_out = tp->sacked_out + tp->lost_out;
net/tcp.h:	if (tp->packets_out >= tp->snd_cwnd) {
net/tcp.h:		tp->snd_cwnd_used = 0;
net/tcp.h:		tp->snd_cwnd_stamp = tcp_time_stamp;
net/tcp.h:		if (tp->packets_out > tp->snd_cwnd_used)
net/tcp.h:			tp->snd_cwnd_used = tp->packets_out;
net/tcp.h:		if ((s32)(tcp_time_stamp - tp->snd_cwnd_stamp) >= tp->rto)
net/tcp.h:	tp->undo_marker = 0;
net/tcp.h:	tp->snd_ssthresh = tcp_recalc_ssthresh(tp);
net/tcp.h:	tp->snd_cwnd = min(tp->snd_cwnd,
net/tcp.h:	tp->snd_cwnd_cnt = 0;
net/tcp.h:	tp->high_seq = tp->snd_nxt;
net/tcp.h:	tp->snd_cwnd_stamp = tcp_time_stamp;
net/tcp.h:	tp->prior_ssthresh = 0;
net/tcp.h:	if (tp->ca_state < TCP_CA_CWR) {
net/tcp.h:	return after(tp->snd_sml,tp->snd_una) &&
net/tcp.h:		!after(tp->snd_sml, tp->snd_nxt);
net/tcp.h:	if (skb->len < mss)
net/tcp.h:		tp->snd_sml = TCP_SKB_CB(skb)->end_seq;
net/tcp.h:	return (skb->len < mss_now &&
net/tcp.h:		!(TCP_SKB_CB(skb)->flags & TCPCB_FLAG_FIN) &&
net/tcp.h:		  tp->packets_out &&
net/tcp.h:/* This checks if the data bearing packet SKB (usually tp->send_head)
net/tcp.h:	/*	RFC 1122 - section 4.2.3.4
net/tcp.h:	 *	for the final FIN -DaveM).
net/tcp.h:	 * final FIN frame.  -DaveM
net/tcp.h:	return ((nonagle==1 || tp->urg_mode
net/tcp.h:		((tcp_packets_in_flight(tp) < tp->snd_cwnd) ||
net/tcp.h:		 (TCP_SKB_CB(skb)->flags & TCPCB_FLAG_FIN)) &&
net/tcp.h:		!after(TCP_SKB_CB(skb)->end_seq, tp->snd_una + tp->snd_wnd));
net/tcp.h:	if (!tp->packets_out && !tp->pending)
net/tcp.h:		tcp_reset_xmit_timer(sk, TCP_TIME_PROBE0, tp->rto);
net/tcp.h:	return (skb->next == (struct sk_buff*)&sk->write_queue);
net/tcp.h:	struct sk_buff *skb = tp->send_head;
net/tcp.h:	__tcp_push_pending_frames(sk, tp, tcp_current_mss(sk), tp->nonagle);
net/tcp.h:	struct sk_buff *skb = tp->send_head;
net/tcp.h:			     tcp_skb_is_last(sk, skb) ? 1 : tp->nonagle));
net/tcp.h:	tp->snd_wl1 = seq;
net/tcp.h:	tp->snd_wl1 = seq;
net/tcp.h:	return (unsigned short)csum_fold(skb_checksum(skb, 0, skb->len, skb->csum));
net/tcp.h:	return skb->ip_summed != CHECKSUM_UNNECESSARY &&
net/tcp.h:	tp->ucopy.task = NULL;
net/tcp.h:	tp->ucopy.len = 0;
net/tcp.h:	tp->ucopy.memory = 0;
net/tcp.h:	skb_queue_head_init(&tp->ucopy.prequeue);
net/tcp.h:/* Packet is added to VJ-style prequeue for processing in process
net/tcp.h: * idea (VJ's mail "Re: query about TCP header on tcp-ip" of 07 Sep 93)
net/tcp.h: * see, why it failed. 8)8)				  --ANK
net/tcp.h:	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
net/tcp.h:	if (!sysctl_tcp_low_latency && tp->ucopy.task) {
net/tcp.h:		__skb_queue_tail(&tp->ucopy.prequeue, skb);
net/tcp.h:		tp->ucopy.memory += skb->truesize;
net/tcp.h:		if (tp->ucopy.memory > sk->rcvbuf) {
net/tcp.h:			if (sk->lock.users)
net/tcp.h:			while ((skb1 = __skb_dequeue(&tp->ucopy.prequeue)) != NULL) {
net/tcp.h:				sk->backlog_rcv(sk, skb1);
net/tcp.h:			tp->ucopy.memory = 0;
net/tcp.h:		} else if (skb_queue_len(&tp->ucopy.prequeue) == 1) {
net/tcp.h:			wake_up_interruptible(sk->sleep);
net/tcp.h:	int oldstate = sk->state;
net/tcp.h:		sk->prot->unhash(sk);
net/tcp.h:		if (sk->prev && !(sk->userlocks&SOCK_BINDPORT_LOCK))
net/tcp.h:			tcp_statistics[smp_processor_id()*2+!in_softirq()].TcpCurrEstab--;
net/tcp.h:	sk->state = state;
net/tcp.h:	SOCK_DEBUG(sk, "TCP sk=%p, State %s -> %s\n",sk, statename[oldstate],statename[state]);
net/tcp.h:	sk->shutdown = SHUTDOWN_MASK;
net/tcp.h:	if (!sk->dead)
net/tcp.h:		sk->state_change(sk);
net/tcp.h:	tp->dsack = 0;
net/tcp.h:	tp->eff_sacks = 0;
net/tcp.h:	tp->num_sacks = 0;
net/tcp.h:	if (tp->tstamp_ok) {
net/tcp.h:		*ptr++ = htonl(tp->ts_recent);
net/tcp.h:	if (tp->eff_sacks) {
net/tcp.h:		struct tcp_sack_block *sp = tp->dsack ? tp->duplicate_sack : tp->selective_acks;
net/tcp.h:					   (tp->eff_sacks * TCPOLEN_SACK_PERBLOCK)));
net/tcp.h:		for(this_sack = 0; this_sack < tp->eff_sacks; this_sack++) {
net/tcp.h:		if (tp->dsack) {
net/tcp.h:			tp->dsack = 0;
net/tcp.h:			tp->eff_sacks--;
net/tcp.h:	 * advertised.  But we subtract them from tp->mss_cache so
net/tcp.h:		    space - max((space>>sysctl_tcp_app_win), mss>>*rcv_wscale) < 65536/2)
net/tcp.h:			(*rcv_wscale)--;
net/tcp.h:		(space>>(-sysctl_tcp_adv_win_scale)) :
net/tcp.h:		space - (space>>sysctl_tcp_adv_win_scale);
net/tcp.h:	return tcp_win_from_space(sk->rcvbuf - atomic_read(&sk->rmem_alloc));
net/tcp.h:	return tcp_win_from_space(sk->rcvbuf); 
net/tcp.h:	sk->ack_backlog--;
net/tcp.h:	sk->ack_backlog++;
net/tcp.h:	return sk->ack_backlog > sk->max_ack_backlog;
net/tcp.h:	struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
net/tcp.h:	req->sk = child;
net/tcp.h:	if (!tp->accept_queue_tail) {
net/tcp.h:		tp->accept_queue = req;
net/tcp.h:		tp->accept_queue_tail->dl_next = req;
net/tcp.h:	tp->accept_queue_tail = req;
net/tcp.h:	req->dl_next = NULL;
net/tcp.h:	struct tcp_listen_opt *lopt = sk->tp_pinfo.af_tcp.listen_opt;
net/tcp.h:	if (--lopt->qlen == 0)
net/tcp.h:	if (req->retrans == 0)
net/tcp.h:		lopt->qlen_young--;
net/tcp.h:	struct tcp_listen_opt *lopt = sk->tp_pinfo.af_tcp.listen_opt;
net/tcp.h:	if (lopt->qlen++ == 0)
net/tcp.h:	lopt->qlen_young++;
net/tcp.h:	return sk->tp_pinfo.af_tcp.listen_opt->qlen;
net/tcp.h:	return sk->tp_pinfo.af_tcp.listen_opt->qlen_young;
net/tcp.h:	return tcp_synq_len(sk)>>sk->tp_pinfo.af_tcp.listen_opt->max_qlen_log;
net/tcp.h:	write_lock(&tp->syn_wait_lock);
net/tcp.h:	*prev = req->dl_next;
net/tcp.h:	write_unlock(&tp->syn_wait_lock);
net/tcp.h:	tcp_synq_unlink(&sk->tp_pinfo.af_tcp, req, prev);
net/tcp.h:	req->rcv_wnd = 0;		/* So that tcp_send_synack() knows! */
net/tcp.h:	req->rcv_isn = TCP_SKB_CB(skb)->seq;
net/tcp.h:	req->mss = tp->mss_clamp;
net/tcp.h:	req->ts_recent = tp->saw_tstamp ? tp->rcv_tsval : 0;
net/tcp.h:	req->tstamp_ok = tp->tstamp_ok;
net/tcp.h:	req->sack_ok = tp->sack_ok;
net/tcp.h:	req->snd_wscale = tp->snd_wscale;
net/tcp.h:	req->wscale_ok = tp->wscale_ok;
net/tcp.h:	req->acked = 0;
net/tcp.h:	req->ecn_ok = 0;
net/tcp.h:	req->rmt_port = skb->h.th->source;
net/tcp.h:	sk->tp_pinfo.af_tcp.queue_shrunk = 1;
net/tcp.h:	sk->wmem_queued -= skb->truesize;
net/tcp.h:	sk->forward_alloc += skb->truesize;
net/tcp.h:	sk->wmem_queued += skb->truesize;
net/tcp.h:	sk->forward_alloc -= skb->truesize;
net/tcp.h:	if (sk->forward_alloc >= TCP_MEM_QUANTUM)
net/tcp.h:	if (!(sk->userlocks&SOCK_SNDBUF_LOCK)) {
net/tcp.h:		sk->sndbuf = min(sk->sndbuf, sk->wmem_queued/2);
net/tcp.h:		sk->sndbuf = max(sk->sndbuf, SOCK_MIN_SNDBUF);
net/tcp.h:		skb->truesize += mem;
net/tcp.h:		if (sk->forward_alloc >= (int)skb->truesize ||
net/tcp.h:		    tcp_mem_schedule(sk, skb->truesize, 0)) {
net/tcp.h:	if (sk->forward_alloc >= (int)PAGE_SIZE ||
net/tcp.h:		struct page *page = alloc_pages(sk->allocation, 0);
net/tcp.h:	while ((skb = __skb_dequeue(&sk->write_queue)) != NULL)
net/tcp.h:	skb->sk = sk;
net/tcp.h:	skb->destructor = tcp_rfree;
net/tcp.h:	atomic_add(skb->truesize, &sk->rmem_alloc);
net/tcp.h:	sk->forward_alloc -= skb->truesize;
net/tcp.h:/* - We may sleep inside this lock.
net/tcp.h: * - If sleeping is not required (or called from BH),
net/tcp.h:	return tp->keepalive_intvl ? : sysctl_tcp_keepalive_intvl;
net/tcp.h:	return tp->keepalive_time ? : sysctl_tcp_keepalive_time;
net/tcp.h:	int fin_timeout = tp->linger2 ? : sysctl_tcp_fin_timeout;
net/tcp.h:	if (fin_timeout < (tp->rto<<2) - (tp->rto>>1))
net/tcp.h:		fin_timeout = (tp->rto<<2) - (tp->rto>>1);
net/tcp.h:	if ((s32)(tp->rcv_tsval - tp->ts_recent) >= 0)
net/tcp.h:	if (xtime.tv_sec >= tp->ts_recent_stamp + TCP_PAWS_24DAYS)
net/tcp.h:	   out-of-sync and half-open connections will not be reset.
net/tcp.h:	   via reboots. Linux-2.2 DOES NOT!
net/tcp.h:	if (rst && xtime.tv_sec >= tp->ts_recent_stamp + TCP_PAWS_MSL)
net/tcp.h:	const struct tcp_opt *tp = &sk->tp_pinfo.af_tcp;
net/tcp.h:	/* F-RTO must be activated in sysctl and there must be some
net/tcp.h:	return (sysctl_tcp_frto && tp->send_head &&
net/tcp.h:		!after(TCP_SKB_CB(tp->send_head)->end_seq,
net/tcp.h:		       tp->snd_una + tp->snd_wnd));
net/tcp.h:	TCP_ADD_STATS_USER(TcpMaxConn, -1);
net/tcp.h:		tp->westwood.rtt = rtt_seq;
net/tcp.h:	struct tcp_opt *tp = &(sk->tp_pinfo.af_tcp);
net/tcp.h:	tp->westwood.bw_ns_est = 0;
net/tcp.h:	tp->westwood.bw_est = 0;
net/tcp.h:	tp->westwood.accounted = 0;
net/tcp.h:	tp->westwood.cumul_ack = 0;
net/tcp.h:	tp->westwood.rtt_win_sx = tcp_time_stamp;
net/tcp.h:	tp->westwood.rtt = TCP_WESTWOOD_INIT_RTT;
net/tcp.h:	tp->westwood.rtt_min = TCP_WESTWOOD_INIT_RTT;
net/tcp.h:	tp->westwood.snd_una = tp->snd_una;
net/tcp.h:	if (tcp_is_westwood(&(sk->tp_pinfo.af_tcp)))
net/tcp.h:	if (tcp_is_westwood(&(sk->tp_pinfo.af_tcp)))
net/tcp.h:	return (__u32) ((tp->westwood.bw_est) * (tp->westwood.rtt_min) /
net/tcp.h:			(__u32) (tp->mss_cache));
net/tcp.h:		tp->snd_ssthresh = ssthresh;
net/tcp.h:		tp->snd_cwnd = cwnd;
net/tcp.h:			tp->snd_ssthresh = tp->snd_cwnd;
net/spx.h:	__u16	sequence;	/* Host order - our current pkt # */
net/spx.h:	__u16	alloc;		/* Host order - max seq we can rcv now */
net/spx.h:	__u16	rmt_ack;	/* Host order - last pkt ACKd by remote */
net/spx.h:	__u16	rmt_alloc;	/* Host order - max seq remote can handle now */
net/spx.h:/* Packet transmit types - Internal */
net/udp.h:	struct sock *sk = udp_hash[num & (UDP_HTABLE_SIZE - 1)];
net/udp.h:	for(; sk != NULL; sk = sk->next) {
net/udp.h:		if(sk->num == num)
net/dn_neigh.h: * this structure are critical - SJW
net/route.h:#define RT_CONN_FLAGS(sk)   (RT_TOS(sk->protinfo.af_inet.tos) | sk->localroute)
net/route.h:	struct inet_peer	*peer; /* long-living peer info */
net/route.h:		dst_release(&rt->u.dst);
net/route.h:	dst = (*rp)->rt_dst;
net/route.h:	src = (*rp)->rt_src;
net/route.h:	if (rt->peer)
net/route.h:		return rt->peer;
net/route.h:	return rt->peer;
net/if_inet6.h:	 *	+-------+-------+-------+-------+-------+-------+
net/if_inet6.h:	 *      +-------+-------+-------+-------+-------+-------+
net/if_inet6.h:	memcpy(buf + 2, &addr->s6_addr32[3], sizeof(__u32));
net/if_inet6.h:	if (((addr->s6_addr[0] == 0xFF) &&
net/if_inet6.h:	    ((addr->s6_addr[1] == 0x01) || (addr->s6_addr[1] == 0x02)) &&
net/if_inet6.h:	     (addr->s6_addr16[1] == 0) &&
net/if_inet6.h:	     (addr->s6_addr32[1] == 0) &&
net/if_inet6.h:	     (addr->s6_addr32[2] == 0) &&
net/if_inet6.h:	     (addr->s6_addr16[6] == 0) &&
net/if_inet6.h:	     (addr->s6_addr[15] == 1)) ||
net/if_inet6.h:	    ((addr->s6_addr[0] == 0xFF) &&
net/if_inet6.h:	     (addr->s6_addr[1] == 0x02) &&
net/if_inet6.h:	     (addr->s6_addr16[1] == 0) &&
net/if_inet6.h:	     (addr->s6_addr32[1] == 0) &&
net/if_inet6.h:	     (addr->s6_addr16[4] == 0) &&
net/if_inet6.h:	     (addr->s6_addr[10] == 0) &&
net/if_inet6.h:	     (addr->s6_addr[11] == 1) &&
net/if_inet6.h:	     (addr->s6_addr[12] == 0xff)))
net/if_inet6.h:	} else if ((addr->s6_addr[0] ==0xff) &&
net/if_inet6.h:		((addr->s6_addr[1] & 0xF0) == 0) &&
net/if_inet6.h:		(addr->s6_addr16[1] == 0) &&
net/if_inet6.h:		(addr->s6_addr32[1] == 0) &&
net/if_inet6.h:		(addr->s6_addr32[2] == 0) &&
net/if_inet6.h:		(addr->s6_addr16[6] == 0) &&
net/if_inet6.h:		(addr->s6_addr[15] == 2))
net/if_inet6.h:		i = addr->s6_addr[15] & 7 ; 
net/addrconf.h:	return (struct inet6_dev *)dev->ip6_ptr;
net/addrconf.h:	idev = dev->ip6_ptr;
net/addrconf.h:		atomic_inc(&idev->refcnt);
net/addrconf.h:	if (atomic_dec_and_test(&idev->refcnt))
net/addrconf.h:#define __in6_dev_put(idev)  atomic_dec(&(idev)->refcnt)
net/addrconf.h:#define in6_dev_hold(idev)   atomic_inc(&(idev)->refcnt)
net/addrconf.h:	if (atomic_dec_and_test(&ifp->refcnt))
net/addrconf.h:#define __in6_ifa_put(idev)  atomic_dec(&(idev)->refcnt)
net/addrconf.h:#define in6_ifa_hold(idev)   atomic_inc(&(idev)->refcnt)
net/addrconf.h:	word = addr->s6_addr[2] ^ addr->s6_addr32[3];
net/addrconf.h: *	compute link-local solicited-node multicast address
net/addrconf.h:		      __constant_htonl(0xFF000000) | addr->s6_addr32[3]);
net/addrconf.h:	return (addr->s6_addr32[0] & __constant_htonl(0xFF000000)) == __constant_htonl(0xFF000000);
net/addrconf.h:	return (addr->s6_addr32[0] == htonl(0xff020000) &&
net/addrconf.h:		addr->s6_addr32[1] == 0 &&
net/addrconf.h:		addr->s6_addr32[2] == 0 &&
net/addrconf.h:		addr->s6_addr32[3] == htonl(0x00000001));
net/addrconf.h:	return (addr->s6_addr32[0] == htonl(0xff020000) &&
net/addrconf.h:		addr->s6_addr32[1] == 0 &&
net/addrconf.h:		addr->s6_addr32[2] == 0 &&
net/addrconf.h:		addr->s6_addr32[3] == htonl(0x00000002));
net/ax25.h:/* Upper sub-layer (LAPB) definitions */
net/ax25.h:/* AX25 L2 C-bit */
net/ax25.h:	AX25_VALUES_CONMODE,	/* Allow connected modes - 0=No 1=no "PID text" 2=all PIDs */
net/ax25.h:#define	AX25_DEF_EWINDOW	32			/* Module-128 Window=32 */
net/syncppp.h:	    (&((struct ppp_device *)(*(unsigned long *)((dev)->priv)))->sppp)
net/syncppp.h:#define LCP_STATE_CLOSED        0       /* LCP state: closed (conf-req sent) */
net/syncppp.h:#define LCP_STATE_ACK_RCVD      1       /* LCP state: conf-ack received */
net/syncppp.h:#define LCP_STATE_ACK_SENT      2       /* LCP state: conf-ack sent */
net/syncppp.h:#define IPCP_STATE_CLOSED       0       /* IPCP state: closed (conf-req sent) */
net/syncppp.h:#define IPCP_STATE_ACK_RCVD     1       /* IPCP state: conf-ack received */
net/syncppp.h:#define IPCP_STATE_ACK_SENT     2       /* IPCP state: conf-ack sent */
net/syncppp.h:#define SPPP_LINK_DOWN		0	/* link down - no keepalive */
net/syncppp.h:#define SPPP_LINK_UP		1	/* link is up - keepalive ok */
net/ip6_route.h:	struct ipv6_pinfo *np = &sk->net_pinfo.af_inet6;
net/ip6_route.h:	write_lock(&sk->dst_lock);
net/ip6_route.h:	np->daddr_cache = daddr;
net/ip6_route.h:	np->dst_cookie = rt->rt6i_node ? rt->rt6i_node->fn_sernum : 0;
net/ip6_route.h:	write_unlock(&sk->dst_lock);
net/ipip.h:	int pkt_len = skb->len;						\
net/ipip.h:	skb->ip_summed = CHECKSUM_NONE;					\
net/ipip.h:	iph->tot_len = htons(skb->len);					\
net/ipip.h:	ip_select_ident(iph, &rt->u.dst, NULL);				\
net/ipip.h:	err = NF_HOOK(PF_INET, NF_IP_LOCAL_OUT, skb, NULL, rt->u.dst.dev, do_ip_send); \
net/ipip.h:		stats->tx_bytes += pkt_len;				\
net/ipip.h:		stats->tx_packets++;					\
net/ipip.h:		stats->tx_errors++;					\
net/ipip.h:		stats->tx_aborted_errors++;				\
net/ipv6.h:#define NEXTHDR_HOP		0	/* Hop-by-hop option header. */
net/ipv6.h: *	type	-	unicast | multicast | anycast
net/ipv6.h: *	scope	-	local	| site	    | global
net/ipv6.h: *	v4	-	compat
net/ipv6.h:	((a)->s6_addr[1] & 0x0f)	/* nonstandard */
net/ipv6.h:#define __IPV6_ADDR_SCOPE_INVALID	-1
net/ipv6.h:		atomic_dec(&fl->users);
net/ipv6.h:	addr->s6_addr32[0] = w1;
net/ipv6.h:	addr->s6_addr32[1] = w2;
net/ipv6.h:	addr->s6_addr32[2] = w3;
net/ipv6.h:	addr->s6_addr32[3] = w4;
net/ipv6.h:	return ((a->s6_addr32[0] | a->s6_addr32[1] | 
net/ipv6.h:		 a->s6_addr32[2] | a->s6_addr32[3] ) == 0); 
net/ipv6.h: *	upper-layer output functions
net/lapb.h:/* LAPB C-bit */
net/rose.h:#define	ROSE_DEFAULT_IDLE		(0 * 60 * HZ)	/* No Activity Timeout - none */
net/snmp.h: *	will rapidly get too small 8-). Seriously consider the IpInReceives count
net/snmp.h: * to emulate multiply in case it is not power-of-two. Currently n is always <=3 for
net/snmp.h: * cacheline machine it makes a *lot* of sense -AK
net/snmp.h: * RFC 1213:  MIB-II
net/snmp.h: * RFC 2011 (updates 1213):  SNMPv2-MIB-IP
net/snmp.h: * RFC 1213:  MIB-II ICMP Group
net/snmp.h: * RFC 2466:  ICMPv6-MIB
net/snmp.h: * RFC 1213:  MIB-II TCP group
net/snmp.h: * RFC 2012 (updates 1213):  SNMPv2-MIB-TCP
net/snmp.h: * RFC 1213:  MIB-II UDP group
net/snmp.h: * RFC 2013 (updates 1213):  SNMPv2-MIB-UDP
net/snmp.h:/* draft-ietf-sigtran-sctp-mib-07.txt */
net/snmp.h: * cycles). Wants new nonlocked_atomic_inc() primitives -AK
net/sock.h: *		Corey Minyard <wf-rch!minyard@relay.EU.net>
net/sock.h: *		Florian La Roche <flla@stud.uni-sb.de>
net/sock.h: * To handle special ncp connection-handling sockets for mars_nwe,
net/sock.h:#define __ipv6_only_sock(sk)	((sk)->net_pinfo.af_inet6.ipv6only)
net/sock.h:#define ipv6_only_sock(sk)	((sk)->family == PF_INET6 && \
net/sock.h:				 (sk)->net_pinfo.af_inet6.ipv6only)
net/sock.h:	__u8	ca_state;	/* State of fast-retransmit machine 	*/
net/sock.h:	__u8	dsack;		/* D-SACK is scheduled			*/
net/sock.h:	struct tcp_sack_block duplicate_sack[1]; /* D-SACK block */
net/sock.h:				 * also used in SYN-SENT to remember stamp of
net/sock.h:/* Define this to get the sk->debug debugging facility. */
net/sock.h:#define SOCK_DEBUG(sk, msg...) do { if((sk) && ((sk)->debug)) printk(KERN_DEBUG msg); } while (0)
net/sock.h:/* This is the per-socket lock.  The spinlock provides a synchronization
net/sock.h: * mini-semaphore synchronizes multiple users amongst themselves.
net/sock.h:do {	spin_lock_init(&((__sk)->lock.slock)); \
net/sock.h:	(__sk)->lock.users = 0; \
net/sock.h:	init_waitqueue_head(&((__sk)->lock.wq)); \
net/sock.h:	 * XXX Make this a flag word -DaveM
net/sock.h:	 * the per-socket spinlock held and requires low latency
net/sock.h:/* The per-socket spinlock must be held here. */
net/sock.h:do {	if((__sk)->backlog.tail == NULL) {		\
net/sock.h:		(__sk)->backlog.head =			\
net/sock.h:		     (__sk)->backlog.tail = (__skb);	\
net/sock.h:		((__sk)->backlog.tail)->next = (__skb);	\
net/sock.h:		(__sk)->backlog.tail = (__skb);		\
net/sock.h:	(__skb)->next = NULL;				\
net/sock.h: * socket layer -> transport layer interface
net/sock.h: * transport -> network interface is defined by struct inet_proto
net/sock.h:		u8  __pad[SMP_CACHE_BYTES - sizeof(int)];
net/sock.h:	prot->stats[smp_processor_id()].inuse++;
net/sock.h:	prot->stats[smp_processor_id()].inuse--;
net/sock.h:/* Sockets 0-1023 can't be bound to unless you are superuser */
net/sock.h:do {	spin_lock_bh(&((__sk)->lock.slock)); \
net/sock.h:	if ((__sk)->lock.users != 0) \
net/sock.h:	(__sk)->lock.users = 1; \
net/sock.h:	spin_unlock_bh(&((__sk)->lock.slock)); \
net/sock.h:do {	spin_lock_bh(&((__sk)->lock.slock)); \
net/sock.h:	if ((__sk)->backlog.tail != NULL) \
net/sock.h:	(__sk)->lock.users = 0; \
net/sock.h:        if (waitqueue_active(&((__sk)->lock.wq))) wake_up(&((__sk)->lock.wq)); \
net/sock.h:	spin_unlock_bh(&((__sk)->lock.slock)); \
net/sock.h:#define bh_lock_sock(__sk)	spin_lock(&((__sk)->lock.slock))
net/sock.h:#define bh_unlock_sock(__sk)	spin_unlock(&((__sk)->lock.slock))
net/sock.h: *	sk_filter - run a packet through a socket filter
net/sock.h: * Run the filter code and then cut skb->data to correct size returned by
net/sock.h: * sk_run_filter. If pkt_len is 0 we toss packet. If skb->len is smaller
net/sock.h: * than pkt_len we keep whole skb->data. This is the socket level
net/sock.h: * be accepted or -EPERM if the packet should be tossed.
net/sock.h:	if (sk->filter) {
net/sock.h:		filter = sk->filter;
net/sock.h:			int pkt_len = sk_run_filter(skb, filter->insns,
net/sock.h:						    filter->len);
net/sock.h:				err = -EPERM;
net/sock.h:	atomic_sub(size, &sk->omem_alloc);
net/sock.h:	if (atomic_dec_and_test(&fp->refcnt))
net/sock.h:	atomic_inc(&fp->refcnt);
net/sock.h:	atomic_add(sk_filter_len(fp), &sk->omem_alloc);
net/sock.h: *   it is called, socket has no references from outside -> sk_free
net/sock.h:	atomic_inc(&sk->refcnt);
net/sock.h:	atomic_dec(&sk->refcnt);
net/sock.h:	if (atomic_dec_and_test(&sk->refcnt))
net/sock.h:	write_lock_bh(&sk->callback_lock);
net/sock.h:	sk->dead = 1;
net/sock.h:	sk->socket = NULL;
net/sock.h:	sk->sleep = NULL;
net/sock.h:	write_unlock_bh(&sk->callback_lock);
net/sock.h:	write_lock_bh(&sk->callback_lock);
net/sock.h:	sk->sleep = &parent->wait;
net/sock.h:	parent->sk = sk;
net/sock.h:	sk->socket = parent;
net/sock.h:	write_unlock_bh(&sk->callback_lock);
net/sock.h:	read_lock(&sk->callback_lock);
net/sock.h:	uid = sk->socket ? sk->socket->inode->i_uid : 0;
net/sock.h:	read_unlock(&sk->callback_lock);
net/sock.h:	read_lock(&sk->callback_lock);
net/sock.h:	ino = sk->socket ? sk->socket->inode->i_ino : 0;
net/sock.h:	read_unlock(&sk->callback_lock);
net/sock.h:	return sk->dst_cache;
net/sock.h:	read_lock(&sk->dst_lock);
net/sock.h:	dst = sk->dst_cache;
net/sock.h:	read_unlock(&sk->dst_lock);
net/sock.h:	old_dst = sk->dst_cache;
net/sock.h:	sk->dst_cache = dst;
net/sock.h:	write_lock(&sk->dst_lock);
net/sock.h:	write_unlock(&sk->dst_lock);
net/sock.h:	old_dst = sk->dst_cache;
net/sock.h:	sk->dst_cache = NULL;
net/sock.h:	write_lock(&sk->dst_lock);
net/sock.h:	write_unlock(&sk->dst_lock);
net/sock.h:	struct dst_entry *dst = sk->dst_cache;
net/sock.h:	if (dst && dst->obsolete && dst->ops->check(dst, cookie) == NULL) {
net/sock.h:		sk->dst_cache = NULL;
net/sock.h:	if (dst && dst->obsolete && dst->ops->check(dst, cookie) == NULL) {
net/sock.h:	skb->sk = sk;
net/sock.h:	skb->destructor = sock_wfree;
net/sock.h:	atomic_add(skb->truesize, &sk->wmem_alloc);
net/sock.h:	skb->sk = sk;
net/sock.h:	skb->destructor = sock_rfree;
net/sock.h:	atomic_add(skb->truesize, &sk->rmem_alloc);
net/sock.h:	/* Cast skb->rcvbuf to unsigned... It's pointless, but reduces
net/sock.h:	   number of warnings when compiling with -W --ANK
net/sock.h:	if (atomic_read(&sk->rmem_alloc) + skb->truesize >= (unsigned)sk->rcvbuf) {
net/sock.h:		err = -ENOMEM;
net/sock.h:	skb->dev = NULL;
net/sock.h:	skb_len = skb->len;
net/sock.h:	skb_queue_tail(&sk->receive_queue, skb);
net/sock.h:	if (!sk->dead)
net/sock.h:		sk->data_ready(sk,skb_len);
net/sock.h:	/* Cast skb->rcvbuf to unsigned... It's pointless, but reduces
net/sock.h:	   number of warnings when compiling with -W --ANK
net/sock.h:	if (atomic_read(&sk->rmem_alloc) + skb->truesize >= (unsigned)sk->rcvbuf)
net/sock.h:		return -ENOMEM;
net/sock.h:	skb_queue_tail(&sk->error_queue,skb);
net/sock.h:	if (!sk->dead)
net/sock.h:		sk->data_ready(sk,skb->len);
net/sock.h:	int err=xchg(&sk->err,0);
net/sock.h:	return -err;
net/sock.h:	if (!(sk->shutdown & SEND_SHUTDOWN)) {
net/sock.h:		amt = sk->sndbuf - atomic_read(&sk->wmem_alloc);
net/sock.h:	if (sk->socket && sk->socket->fasync_list)
net/sock.h:		sock_wake_async(sk->socket, how, band);
net/sock.h:	return atomic_read(&sk->wmem_alloc) < (sk->sndbuf / 2);
net/sock.h:	return noblock ? 0 : sk->rcvtimeo;
net/sock.h:	return noblock ? 0 : sk->sndtimeo;
net/sock.h:	return (waitall ? len : min_t(int, sk->rcvlowat, len)) ? : 1;
net/sock.h:	return timeo == MAX_SCHEDULE_TIMEOUT ? -ERESTARTSYS : -EINTR;
net/sock.h:	if (sk->rcvtstamp)
net/sock.h:		put_cmsg(msg, SOL_SOCKET, SO_TIMESTAMP, sizeof(skb->stamp), &skb->stamp);
net/sock.h:		sk->stamp = skb->stamp;
net/sock.h:				tsk->state = TASK_INTERRUPTIBLE; \
net/sock.h:				add_wait_queue((sk)->sleep, &wait); \
net/sock.h:#define SOCK_SLEEP_POST(sk)	tsk->state = TASK_RUNNING; \
net/sock.h:				remove_wait_queue((sk)->sleep, &wait); \
net/checksum.h: *	<ralf@waldorf-gmbh.de>
net/checksum.h:	csum += saddr->s6_addr32[0];
net/checksum.h:	carry = (csum < saddr->s6_addr32[0]);
net/checksum.h:	csum += saddr->s6_addr32[1];
net/checksum.h:	carry = (csum < saddr->s6_addr32[1]);
net/checksum.h:	csum += saddr->s6_addr32[2];
net/checksum.h:	carry = (csum < saddr->s6_addr32[2]);
net/checksum.h:	csum += saddr->s6_addr32[3];
net/checksum.h:	carry = (csum < saddr->s6_addr32[3]);
net/checksum.h:	csum += daddr->s6_addr32[0];
net/checksum.h:	carry = (csum < daddr->s6_addr32[0]);
net/checksum.h:	csum += daddr->s6_addr32[1];
net/checksum.h:	carry = (csum < daddr->s6_addr32[1]);
net/checksum.h:	csum += daddr->s6_addr32[2];
net/checksum.h:	carry = (csum < daddr->s6_addr32[2]);
net/checksum.h:	csum += daddr->s6_addr32[3];
net/checksum.h:	carry = (csum < daddr->s6_addr32[3]);
net/checksum.h:		*err_ptr = -EFAULT;
net/checksum.h:		*err_ptr = -EFAULT;
net/checksum.h:	return -1; /* invalid checksum */
net/netrom.h:#define NR_DEFAULT_T1			(120 * HZ)	/* Outstanding frames - 120 seconds */
net/netrom.h:#define NR_DEFAULT_T2			(5   * HZ)	/* Response delay     - 5 seconds */
net/netrom.h:#define NR_DEFAULT_N2			3		/* Number of Retries - 3 */
net/netrom.h:#define	NR_DEFAULT_T4			(180 * HZ)	/* Busy Delay - 180 seconds */
net/netrom.h:#define	NR_DEFAULT_IDLE			(0 * 60 * HZ)	/* No Activity Timeout - none */
net/netrom.h:#define	NR_DEFAULT_WINDOW		4		/* Default Window Size - 4 */
net/netrom.h:#define	NR_DEFAULT_OBS			6		/* Default Obsolescence Count - 6 */
net/netrom.h:#define	NR_DEFAULT_QUAL			10		/* Default Neighbour Quality - 10 */
net/netrom.h:#define	NR_DEFAULT_TTL			16		/* Default Time To Live - 16 */
net/netrom.h:#define NR_MAX_WINDOW_SIZE		127			/* Maximum Window Allowable - 127 */
net/netrom.h:#define	NR_MAX_PACKET_SIZE		236			/* Maximum Packet Length - 236 */
net/slhc_vj.h: * $Header: /home/cvsroot/RT288x_SDK/source/linux-2.4.x/include/ack,v 1.1.1.1 2006-10-13 02:42:37 steven Exp $
net/slhc_vj.h: *	- Initial distribution.
net/slhc_vj.h: *	- 01-31-90	initial adaptation
net/slhc_vj.h: *	- Feb 1991	Bill_Simpson@um.cc.umich.edu
net/slhc_vj.h: * the receiver implicitly knows what changed -- see below).
net/slhc_vj.h: * range 1 - 255 and 3 octets (0, MSB, LSB) for numbers in the
net/slhc_vj.h: * range 256 - 65535 or 0.  (If the change in sequence number or
net/slhc_vj.h: * with the 8-bit protocol field replaced by an 8-bit connection id --
net/slhc_vj.h: * LSB of 4-bit field is TCP "PUSH" bit (a worthless anachronism) and
net/slhc_vj.h: * is logically part of the 4-bit "changes" field that follows.  Top
net/slhc_vj.h:/* reserved, special-case values of above */
net/slhc_vj.h:	byte_t tslot_limit;	/* highest transmit slot id (0-l)*/
net/slhc_vj.h:	byte_t rslot_limit;	/* highest receive slot id (0-l)*/
net/slhc_vj.h:	int32 sls_o_nontcp;	/* outbound non-TCP packets */
net/llc_frame.h:	unsigned f1 : 1;	/* I- U- or S- format id bits */
net/llc_frame.h:	unsigned u_pflag : 1;    /* P/F for U- pdus */
net/llc_frame.h:	unsigned char u_info[ ETH_DATA_LEN-1];
net/llc_frame.h:#define IS_UFRAME( fr ) ( ( (fr)->pdu_hdr.f1) & ( (fr)->pdu_hdr.f2) )
net/llc_frame.h:#define IS_IFRAME( fr ) ( !( (fr)->pdu_hdr.f1) )
net/llc_frame.h:#define IS_SFRAME( fr ) ( ( (fr)->pdu_hdr.f1) & !( (fr)->pdu_hdr.f2) )
net/llc_frame.h:#define IS_RSP( fr ) ( fr->pdu_hdr.ssap & 0x01 )
net/dn_dev.h:#define DN_DEV_S_RU  0 /* Run - working normally   */
net/dn_dev.h: * t2 - Rate limit timer, min time between routing and hello messages
net/dn_dev.h: * t3 - Hello timer, send hello messages when it expires
net/dn_dev.h: * up() - Called to initialize device, return value can veto use of
net/dn_dev.h: * down() - Called to turn device off when it goes down
net/dn_dev.h: * timer3() - Called when timer 3 goes off
net/dn_dev.h: * sysctl - Hook for sysctl things
net/dn_dev.h:/*------------------------- DRP - Routing messages ---------------------*/
net/dn_dev.h:	struct dn_dev *dn_db = dev->dn_ptr;
net/dn_dev.h:	for(ifa = dn_db->ifa_list; ifa; ifa = ifa->ifa_next)
net/dn_dev.h:		if ((addr ^ ifa->ifa_local) == 0)
net/dn_fib.h:#define DN_FIB_RES_NH(res)	((res).fi->fib_nh[(res).nh_sel])
net/dn_fib.h:#define DN_FIB_INFO(f) ((f)->fn_info)
net/dn_fib.h:	if (atomic_dec_and_test(&fi->fib_clntref))
net/dn_fib.h:	if (res->fi)
net/dn_fib.h:		dn_fib_info_put(res->fi);
net/dn_fib.h:	if (res->r)
net/dn_fib.h:		dn_fib_rule_put(res->r);
net/dn_fib.h:                return htons(~((1<<(16-n))-1));
net/af_unix.h:	if (s->next)
net/af_unix.h:		return s->next;
net/af_unix.h:	/* Look for next non-empty chain. */
net/af_unix.h:#define UNIXCB(skb) 	(*(struct unix_skb_parms*)&((skb)->cb))
net/af_unix.h:#define unix_state_rlock(s)	read_lock(&(s)->protinfo.af_unix.lock)
net/af_unix.h:#define unix_state_runlock(s)	read_unlock(&(s)->protinfo.af_unix.lock)
net/af_unix.h:#define unix_state_wlock(s)	write_lock(&(s)->protinfo.af_unix.lock)
net/af_unix.h:#define unix_state_wunlock(s)	write_unlock(&(s)->protinfo.af_unix.lock)
net/pkt_sched.h:	spin_lock_bh(&q->dev->queue_lock);
net/pkt_sched.h:	spin_unlock_bh(&q->dev->queue_lock);
net/pkt_sched.h:	spin_lock_bh(&tp->q->dev->queue_lock);
net/pkt_sched.h:	spin_unlock_bh(&tp->q->dev->queue_lock);
net/pkt_sched.h:   10msec resolution -> <50Kbit/sec.
net/pkt_sched.h:   The result: [34]86 is not good choice for QoS router :-(
net/pkt_sched.h:#define PSCHED_US2JIFFIE(usecs) (((usecs)+(1000000/HZ-1))/(1000000/HZ))
net/pkt_sched.h:#define PSCHED_GET_TIME(stamp) ((stamp) = psched_time_base + (((unsigned long)(jiffies-psched_time_mark))<<PSCHED_JSCALE))
net/pkt_sched.h:#define PSCHED_US2JIFFIE(delay) (((delay)+(1<<PSCHED_JSCALE)-1)>>PSCHED_JSCALE)
net/pkt_sched.h:#define PSCHED_US2JIFFIE(delay) (((delay)+psched_clock_per_hz-1)/psched_clock_per_hz)
net/pkt_sched.h:	   int __delta_sec = (tv1).tv_sec - (tv2).tv_sec; \
net/pkt_sched.h:	   int __delta = (tv1).tv_usec - (tv2).tv_usec; \
net/pkt_sched.h:	   int __delta_sec = (tv1).tv_sec - (tv2).tv_sec; \
net/pkt_sched.h:	   int __delta = (tv1).tv_usec - (tv2).tv_usec; \
net/pkt_sched.h:	   if (__delta > 1000000) { (tv_res).tv_sec++; __delta -= 1000000; } \
net/pkt_sched.h:		 (tv).tv_usec -= 1000000; } \
net/pkt_sched.h:#define PSCHED_TDIFF(tv1, tv2) (long)((tv1) - (tv2))
net/pkt_sched.h:	   long long __delta = (tv1) - (tv2); \
net/pkt_sched.h:	if (p && --p->refcnt == 0)
net/pkt_sched.h:	unsigned mtu = dev->mtu;
net/pkt_sched.h:	return dev->hard_header ? mtu + dev->hard_header_len : mtu;
net/dn_nsp.h:    (c) 1995-1998 E.M. Serrat		emserrat@geocities.com
net/dn_nsp.h:#define NSP_REASON_TP 8		/* Third-Party abort */
net/dn_nsp.h:#define NSP_REASON_LL 32	/* Node lacks logical-link resources */
net/dn_nsp.h:#define NSP_REASON_LE 33	/* End user lacks logical-link resources */
net/dn_nsp.h:#define NSP_REASON_NL 41	/* No-link message */
net/dn_nsp.h:/*------------------------- NSP - messages ------------------------------*/
net/dn_nsp.h:/*---------------*/
net/dn_nsp.h:        return (int)((seq1 - seq2) & 0x0fff) > 2048;
net/dn_nsp.h:        return (int)((seq2 - seq1) & 0x0fff) > 2048;
net/dn_nsp.h:        return atomic_read(&sk->rmem_alloc) > (sk->rcvbuf >> 1);
net/profile.h:	rdtsc(pstamp->tv_usec, pstamp->tv_sec);
net/profile.h:			      : "=r" (acc->tv_usec), "=r" (acc->tv_sec)
net/profile.h:			      : "g" (entered->tv_usec), "g" (entered->tv_sec),
net/profile.h:			      "g" (leaved->tv_usec), "g" (leaved->tv_sec),
net/profile.h:			      "0" (acc->tv_usec), "1" (acc->tv_sec));
net/profile.h:			      : "=r" (acc->tv_usec), "=r" (acc->tv_sec)
net/profile.h:			      : "g" (sub->tv_usec), "g" (sub->tv_sec),
net/profile.h:			      "0" (acc->tv_usec), "1" (acc->tv_sec));
net/profile.h:			      : "=r" (acc->tv_usec), "=r" (acc->tv_sec)
net/profile.h:			      : "g" (add->tv_usec), "g" (add->tv_sec),
net/profile.h:			      "0" (acc->tv_usec), "1" (acc->tv_sec));
net/profile.h:/* On alpha cycle counter has only 32 bits :-( :-( */
net/profile.h:	pstamp->tv_sec = alpha_hi;
net/profile.h:	pstamp->tv_usec = alpha_lo;
net/profile.h:	time_t usecs = acc->tv_usec + leaved->tv_usec - entered->tv_usec
net/profile.h:		- net_profile_adjust.tv_usec;
net/profile.h:	time_t secs = acc->tv_sec + leaved->tv_sec - entered->tv_sec;
net/profile.h:		usecs -= 0x100000000L;
net/profile.h:	} else if (usecs < -0x100000000L) {
net/profile.h:		secs -= 2;
net/profile.h:		secs--;
net/profile.h:	acc->tv_sec = secs;
net/profile.h:	acc->tv_usec = usecs;
net/profile.h:	time_t usecs = leaved->tv_usec - entered->tv_usec;
net/profile.h:	time_t secs = leaved->tv_sec - entered->tv_sec;
net/profile.h:		secs--;
net/profile.h:	leaved->tv_sec = secs;
net/profile.h:	leaved->tv_usec = usecs;
net/profile.h:	time_t usecs = leaved->tv_usec + entered->tv_usec;
net/profile.h:	time_t secs = leaved->tv_sec + entered->tv_sec;
net/profile.h:		usecs -= 0x100000000L;
net/profile.h:	leaved->tv_sec = secs;
net/profile.h:	leaved->tv_usec = usecs;
net/profile.h:	   situation. do_gettimeofday still says something on slow-slow-slow
net/profile.h:	   investigation :-) :-)
net/profile.h:	time_t usecs = acc->tv_usec + leaved->tv_usec - entered->tv_usec
net/profile.h:		- net_profile_adjust.tv_usec;
net/profile.h:	time_t secs = acc->tv_sec + leaved->tv_sec - entered->tv_sec;
net/profile.h:		usecs -= 1000000;
net/profile.h:	} else if (usecs < -1000000) {
net/profile.h:		secs -= 2;
net/profile.h:		secs--;
net/profile.h:	acc->tv_sec = secs;
net/profile.h:	acc->tv_usec = usecs;
net/profile.h:	time_t usecs = leaved->tv_usec - entered->tv_usec;
net/profile.h:	time_t secs = leaved->tv_sec - entered->tv_sec;
net/profile.h:		secs--;
net/profile.h:	leaved->tv_sec = secs;
net/profile.h:	leaved->tv_usec = usecs;
net/profile.h:	time_t usecs = leaved->tv_usec + entered->tv_usec;
net/profile.h:	time_t secs = leaved->tv_sec + entered->tv_sec;
net/profile.h:		usecs -= 1000000;
net/profile.h:	leaved->tv_sec = secs;
net/profile.h:	leaved->tv_usec = usecs;
net/profile.h:	if (s->active++ == 0) {
net/profile.h:		net_profile_stamp(&s->entered);
net/profile.h:	if (--s->active <= 0) {
net/profile.h:		if (s->active == 0) {
net/profile.h:			net_profile_accumulate(&s->entered, &curr_pstamp, &s->accumulator);
net/profile.h:				net_profile_irq_adjust(&s->entered, &curr_pstamp);
net/profile.h:			s->underflow++;
net/profile.h:	s->hits++;
net/profile.h:	if (--s->active <= 0) {
net/profile.h:		if (s->active == 0) {
net/profile.h:			net_profile_accumulate(&s->entered, &curr_pstamp, &s->accumulator);
net/profile.h:			s->underflow++;
net/profile.h:	s->hits++;
net/profile.h: skb->pstamp.tv_usec = 0; \
net/profile.h: net_profile_stamp(&skb->pstamp); \
net/profile.h: if (skb->pstamp.tv_usec) { \
net/profile.h:   struct timeval cur_pstamp = skb->pstamp; \
net/profile.h:   net_profile_stamp(&skb->pstamp); \
net/profile.h:   net_profile_accumulate(&cur_pstamp, &skb->pstamp, &net_prof_##slot.accumulator); \
net/neighbour.h: *		- Add neighbour cache statistics like rtstat
net/neighbour.h:		((tbl)->stats[smp_processor_id()].field++)
net/neighbour.h:	unsigned char		ha[(MAX_ADDR_LEN+sizeof(unsigned long)-1)&~(sizeof(unsigned long)-1)];
net/neighbour.h:	if (atomic_dec_and_test(&neigh->refcnt))
net/neighbour.h:		atomic_inc(&neigh->refcnt);
net/neighbour.h:#define neigh_hold(n)	atomic_inc(&(n)->refcnt)
net/neighbour.h:		neigh->confirmed = jiffies;
net/neighbour.h:	return neigh->nud_state&NUD_CONNECTED;
net/neighbour.h:	return neigh->nud_state&NUD_VALID;
net/neighbour.h:	neigh->used = jiffies;
net/neighbour.h:	if (!(neigh->nud_state&(NUD_CONNECTED|NUD_DELAY|NUD_PROBE)))
net/inet_ecn.h:#define	INET_ECN_xmit(sk) do { (sk)->protinfo.af_inet.tos |= 2; } while (0)
net/inet_ecn.h:#define	INET_ECN_dontxmit(sk) do { (sk)->protinfo.af_inet.tos &= ~3; } while (0)
net/inet_ecn.h:	if (INET_ECN_is_capable((sk)->protinfo.af_inet.tos))	\
net/inet_ecn.h:	u32 check = iph->check;
net/inet_ecn.h:	iph->check = check + (check>=0xFFFF);
net/inet_ecn.h:	iph->tos |= 1;
net/bluetooth/rfcomm.h:   RPN support    -    Dirk Husemann <hud@zurich.ibm.com>
net/bluetooth/rfcomm.h:/* ---- Core structures, flags etc ---- */
net/bluetooth/rfcomm.h:#define RFCOMM_CFC_UNKNOWN  -1
net/bluetooth/rfcomm.h:/* ---- RFCOMM DLCs (channels) ---- */
net/bluetooth/rfcomm.h:#define rfcomm_dlc_lock(d)	spin_lock(&d->lock)
net/bluetooth/rfcomm.h:#define rfcomm_dlc_unlock(d)	spin_unlock(&d->lock)
net/bluetooth/rfcomm.h:	atomic_inc(&d->refcnt);
net/bluetooth/rfcomm.h:	if (atomic_dec_and_test(&d->refcnt))
net/bluetooth/rfcomm.h:	if (!test_and_set_bit(RFCOMM_RX_THROTTLED, &d->flags))
net/bluetooth/rfcomm.h:	if (test_and_clear_bit(RFCOMM_RX_THROTTLED, &d->flags))
net/bluetooth/rfcomm.h:/* ---- RFCOMM sessions ---- */
net/bluetooth/rfcomm.h:	atomic_inc(&s->refcnt);
net/bluetooth/rfcomm.h:	if (atomic_dec_and_test(&s->refcnt))
net/bluetooth/rfcomm.h:/* ---- RFCOMM chechsum ---- */
net/bluetooth/rfcomm.h:/* ---- RFCOMM sockets ---- */
net/bluetooth/rfcomm.h:#define rfcomm_pi(sk)	((struct rfcomm_pinfo *) &sk->tp_pinfo)
net/bluetooth/rfcomm.h:/* ---- RFCOMM TTY ---- */
net/bluetooth/hci.h:   BlueZ - Bluetooth protocol stack for Linux
net/bluetooth/hci.h:   Copyright (C) 2000-2001 Qualcomm Incorporated
net/bluetooth/hci.h:/* -----  HCI Commands ----- */
net/bluetooth/hci.h:/* ---- HCI Events ---- */
net/bluetooth/hci.h:/* --------  HCI Packet structures  -------- */
net/bluetooth/sco.h:   BlueZ - Bluetooth protocol stack for Linux
net/bluetooth/sco.h:   Copyright (C) 2000-2001 Qualcomm Incorporated
net/bluetooth/sco.h:/* ---- SCO connections ---- */
net/bluetooth/sco.h:#define sco_conn_lock(c)	spin_lock(&c->lock);
net/bluetooth/sco.h:#define sco_conn_unlock(c)	spin_unlock(&c->lock);
net/bluetooth/sco.h:/* ----- SCO socket info ----- */
net/bluetooth/sco.h:#define sco_pi(sk)   ((struct sco_pinfo *) &sk->tp_pinfo)
net/bluetooth/bluetooth.h:   BlueZ - Bluetooth protocol stack for Linux
net/bluetooth/bluetooth.h:   Copyright (C) 2000-2001 Qualcomm Incorporated
net/bluetooth/bluetooth.h:#define bluez_pi(sk) ((struct bluez_pinfo *) &sk->protinfo)
net/bluetooth/bluetooth.h:	((void *)pi - (unsigned long)(&((struct sock *)0)->protinfo)))
net/bluetooth/bluetooth.h:#define bluez_cb(skb)	((struct bluez_skb_cb *)(skb->cb)) 
net/bluetooth/bluetooth.h:		bluez_cb(skb)->incomming  = 0;
net/bluetooth/bluetooth.h:		bluez_cb(skb)->incomming  = 0;
net/bluetooth/bluetooth.h:	register struct sk_buff *frag = skb_shinfo(skb)->frag_list;
net/bluetooth/bluetooth.h:	for (; frag; frag=frag->next, n++);
net/bluetooth/bluetooth.h:	for (pos = (head)->next, n = pos->next; pos != (head); \
net/bluetooth/bluetooth.h:		pos = n, n = pos->next)
net/bluetooth/l2cap.h:   BlueZ - Bluetooth protocol stack for Linux
net/bluetooth/l2cap.h:   Copyright (C) 2000-2001 Qualcomm Incorporated
net/bluetooth/l2cap.h:/* ----- L2CAP connections ----- */
net/bluetooth/l2cap.h:/* ----- L2CAP channel and socket info ----- */
net/bluetooth/l2cap.h:#define l2cap_pi(sk)   ((struct l2cap_pinfo *) &sk->tp_pinfo)
net/bluetooth/hci_core.h:   BlueZ - Bluetooth protocol stack for Linux
net/bluetooth/hci_core.h:   Copyright (C) 2000-2001 Qualcomm Incorporated
net/bluetooth/hci_core.h:/* ----- Inquiry cache ----- */
net/bluetooth/hci_core.h:#define inquiry_cache_lock(c)		spin_lock(&c->lock)
net/bluetooth/hci_core.h:#define inquiry_cache_unlock(c)		spin_unlock(&c->lock)
net/bluetooth/hci_core.h:#define inquiry_cache_lock_bh(c)	spin_lock_bh(&c->lock)
net/bluetooth/hci_core.h:#define inquiry_cache_unlock_bh(c)	spin_unlock_bh(&c->lock)
net/bluetooth/hci_core.h:	struct inquiry_cache *c = &hdev->inq_cache;
net/bluetooth/hci_core.h:	spin_lock_init(&c->lock);
net/bluetooth/hci_core.h:	c->list = NULL;
net/bluetooth/hci_core.h:	struct inquiry_cache *c = &hdev->inq_cache;
net/bluetooth/hci_core.h:	return (c->list == NULL);
net/bluetooth/hci_core.h:	struct inquiry_cache *c = &hdev->inq_cache;
net/bluetooth/hci_core.h:	return jiffies - c->timestamp;
net/bluetooth/hci_core.h:	return jiffies - e->timestamp;
net/bluetooth/hci_core.h:/* ----- HCI Connections ----- */
net/bluetooth/hci_core.h:#define hci_conn_lock(c)	spin_lock(&c->lock)
net/bluetooth/hci_core.h:#define hci_conn_unlock(c)	spin_unlock(&c->lock)
net/bluetooth/hci_core.h:#define hci_conn_lock_bh(c)	spin_lock_bh(&c->lock)
net/bluetooth/hci_core.h:#define hci_conn_unlock_bh(c)	spin_unlock_bh(&c->lock)
net/bluetooth/hci_core.h:#define conn_hash_lock(d)	spin_lock(&d->conn_hash->lock)
net/bluetooth/hci_core.h:#define conn_hash_unlock(d)	spin_unlock(&d->conn_hash->lock)
net/bluetooth/hci_core.h:#define conn_hash_lock_bh(d)	spin_lock_bh(&d->conn_hash->lock)
net/bluetooth/hci_core.h:#define conn_hash_unlock_bh(d)	spin_unlock_bh(&d->conn_hash->lock)
net/bluetooth/hci_core.h:	struct conn_hash *h = &hdev->conn_hash;
net/bluetooth/hci_core.h:	INIT_LIST_HEAD(&h->list);
net/bluetooth/hci_core.h:	spin_lock_init(&h->lock);
net/bluetooth/hci_core.h:	h->num = 0;	
net/bluetooth/hci_core.h:	struct conn_hash *h = &hdev->conn_hash;
net/bluetooth/hci_core.h:	list_add(&c->list, &h->list);
net/bluetooth/hci_core.h:	h->num++;
net/bluetooth/hci_core.h:	struct conn_hash *h = &hdev->conn_hash;
net/bluetooth/hci_core.h:	list_del(&c->list);
net/bluetooth/hci_core.h:	h->num--;
net/bluetooth/hci_core.h:	register struct conn_hash *h = &hdev->conn_hash;
net/bluetooth/hci_core.h:	list_for_each(p, &h->list) {
net/bluetooth/hci_core.h:		if (c->handle == handle)
net/bluetooth/hci_core.h:	register struct conn_hash *h = &hdev->conn_hash;
net/bluetooth/hci_core.h:	list_for_each(p, &h->list) {
net/bluetooth/hci_core.h:		if (c->type == type && !bacmp(&c->dst, ba))
net/bluetooth/hci_core.h:	mod_timer(&conn->timer, jiffies + timeout);
net/bluetooth/hci_core.h:	del_timer(&conn->timer);
net/bluetooth/hci_core.h:	atomic_inc(&conn->refcnt);
net/bluetooth/hci_core.h:	if (atomic_dec_and_test(&conn->refcnt)) {
net/bluetooth/hci_core.h:		if (conn->type == ACL_LINK) {
net/bluetooth/hci_core.h:			unsigned long timeo = (conn->out) ?
net/bluetooth/hci_core.h:/* ----- HCI Devices ----- */
net/bluetooth/hci_core.h:	if (atomic_dec_and_test(&d->refcnt))
net/bluetooth/hci_core.h:		d->destruct(d);
net/bluetooth/hci_core.h:#define hci_dev_hold(d)		atomic_inc(&d->refcnt)
net/bluetooth/hci_core.h:#define hci_dev_lock(d)		spin_lock(&d->lock)
net/bluetooth/hci_core.h:#define hci_dev_unlock(d)	spin_unlock(&d->lock)
net/bluetooth/hci_core.h:#define hci_dev_lock_bh(d)	spin_lock_bh(&d->lock)
net/bluetooth/hci_core.h:#define hci_dev_unlock_bh(d)	spin_unlock_bh(&d->lock)
net/bluetooth/hci_core.h:/* ----- LMP capabilities ----- */
net/bluetooth/hci_core.h:#define lmp_rswitch_capable(dev) (dev->features[0] & LMP_RSWITCH)
net/bluetooth/hci_core.h:#define lmp_encrypt_capable(dev) (dev->features[0] & LMP_ENCRYPT)
net/bluetooth/hci_core.h:/* ----- HCI tasks ----- */
net/bluetooth/hci_core.h:	tasklet_schedule(&hdev->cmd_task);
net/bluetooth/hci_core.h:	tasklet_schedule(&hdev->rx_task);
net/bluetooth/hci_core.h:	tasklet_schedule(&hdev->tx_task);
net/bluetooth/hci_core.h:/* ----- HCI protocols ----- */
net/bluetooth/hci_core.h:	if (hp && hp->connect_ind)
net/bluetooth/hci_core.h:		mask |= hp->connect_ind(hdev, bdaddr, type);
net/bluetooth/hci_core.h:	if (hp && hp->connect_ind)
net/bluetooth/hci_core.h:		mask |= hp->connect_ind(hdev, bdaddr, type);
net/bluetooth/hci_core.h:	if (hp && hp->connect_cfm)
net/bluetooth/hci_core.h:		hp->connect_cfm(conn, status);
net/bluetooth/hci_core.h:	if (hp && hp->connect_cfm)
net/bluetooth/hci_core.h:		hp->connect_cfm(conn, status);
net/bluetooth/hci_core.h:	if (hp && hp->disconn_ind)
net/bluetooth/hci_core.h:		hp->disconn_ind(conn, reason);
net/bluetooth/hci_core.h:	if (hp && hp->disconn_ind)
net/bluetooth/hci_core.h:		hp->disconn_ind(conn, reason);
net/bluetooth/hci_core.h:	if (hp && hp->auth_cfm)
net/bluetooth/hci_core.h:		hp->auth_cfm(conn, status);
net/bluetooth/hci_core.h:	if (hp && hp->auth_cfm)
net/bluetooth/hci_core.h:		hp->auth_cfm(conn, status);
net/bluetooth/hci_core.h:	if (hp && hp->encrypt_cfm)
net/bluetooth/hci_core.h:		hp->encrypt_cfm(conn, status);
net/bluetooth/hci_core.h:	if (hp && hp->encrypt_cfm)
net/bluetooth/hci_core.h:		hp->encrypt_cfm(conn, status);
net/bluetooth/hci_core.h:/* ----- HCI Sockets ----- */
net/bluetooth/hci_core.h:#define hci_pi(sk)	((struct hci_pinfo *) &sk->tp_pinfo)
net/bluetooth/hci_core.h:/* ----- HCI requests ----- */
net/bluetooth/hci_core.h:#define hci_req_lock(d)		down(&d->req_lock)
net/bluetooth/hci_core.h:#define hci_req_unlock(d)	up(&d->req_lock)
net/dn_route.h:    (c) 1995-1998 E.M. Serrat		emserrat@geocities.com
net/dn_route.h:#define DN_RT_F_RQR 0x08 /* Return packet to sender upon non-delivery */
net/dn_route.h:	struct net_device *dev = skb->dev;
net/dn_route.h:	if ((dev->type != ARPHRD_ETHER) && (dev->type != ARPHRD_LOOPBACK))
net/dn_route.h:	if (!dev->hard_header || (dev->hard_header(skb, dev, ETH_P_DNA_RT,
net/dn_route.h:			dst, NULL, skb->len) >= 0))
net/dn_route.h:	struct sock *sk = skb->sk;
net/dn_route.h:	struct dn_scp *scp = &sk->protinfo.dn;
net/dn_route.h:	skb->h.raw = skb->data;
net/dn_route.h:	scp->stamp = jiffies;
net/dn_route.h:	if ((dst = sk->dst_cache) && !dst->obsolete) {
net/dn_route.h:		skb->dst = dst_clone(dst);
net/dn_route.h:		dst->output(skb);
net/dn_route.h:	dst_release(xchg(&sk->dst_cache, NULL));
net/dn_route.h:	if (dn_route_output(&sk->dst_cache, dn_saddr2dn(&scp->peer), dn_saddr2dn(&scp->addr), 0) == 0) {
net/dn_route.h:		dst = sk->dst_cache;
net/dn_route.h:	sk->err = EHOSTUNREACH;
net/dn_route.h:	if (!sk->dead)
net/dn_route.h:		sk->state_change(sk);
net/ip_vs.h:	struct list_head	f_list;   /* for fwmark-based service table */
net/ip_vs.h:	struct list_head	destinations;  /* real server d-linked list */
net/ip_vs.h:	struct list_head        n_list;   /* d-linked list head */
net/ip_vs.h:	struct list_head        n_list;   /* d-linked list head */
net/ip_vs.h:#define IP_VS_CONN_TAB_MASK     (IP_VS_CONN_TAB_SIZE - 1)
net/ip_vs.h:	atomic_dec(&cp->refcnt);
net/ip_vs.h:	struct ip_vs_conn *ctl_cp = cp->control;
net/ip_vs.h:			  NIPQUAD(cp->caddr),ntohs(cp->cport),
net/ip_vs.h:			  NIPQUAD(cp->vaddr),ntohs(cp->vport));
net/ip_vs.h:		  NIPQUAD(cp->caddr),ntohs(cp->cport),
net/ip_vs.h:		  NIPQUAD(ctl_cp->caddr),ntohs(ctl_cp->cport));
net/ip_vs.h:	cp->control = NULL;
net/ip_vs.h:	if (atomic_read(&ctl_cp->n_control) == 0) {
net/ip_vs.h:			  NIPQUAD(cp->caddr),ntohs(cp->cport),
net/ip_vs.h:			  NIPQUAD(cp->vaddr),ntohs(cp->vport));
net/ip_vs.h:	atomic_dec(&ctl_cp->n_control);
net/ip_vs.h:	if (cp->control) {
net/ip_vs.h:			  NIPQUAD(cp->caddr),ntohs(cp->cport),
net/ip_vs.h:			  NIPQUAD(cp->vaddr),ntohs(cp->vport));
net/ip_vs.h:		  NIPQUAD(cp->caddr),ntohs(cp->cport),
net/ip_vs.h:		  NIPQUAD(ctl_cp->caddr),ntohs(ctl_cp->cport));
net/ip_vs.h:	cp->control = ctl_cp;
net/ip_vs.h:	atomic_inc(&ctl_cp->n_control);
net/ip_vs.h:	atomic_dec(&svc->usecnt);
net/ip_vs.h:	if (--ip_vs_drop_counter > 0) return 0;
net/ip_vs.h:#define IP_VS_FWD_METHOD(cp)  (cp->flags & IP_VS_CONN_F_FWD_MASK)
net/ip_vs.h:		return -1;
net/ip_vs.h:	old_dst = dest->dst_cache;
net/ip_vs.h:	dest->dst_cache = dst;
net/ip_vs.h:	dest->dst_rtos = rtos;
net/ip_vs.h:	old_dst = dest->dst_cache;
net/ip_vs.h:	dest->dst_cache = NULL;
net/ip_vs.h:	struct dst_entry *dst = dest->dst_cache;
net/ip_vs.h:	if ((dst->obsolete || rtos != dest->dst_rtos) &&
net/ip_vs.h:	    dst->ops->check(dst, cookie) == NULL) {
net/ip_vs.h:		dest->dst_cache = 0;
net/ip_vs.h:	struct ip_vs_dest *dest = cp->dest;
net/ip_vs.h:		spin_lock(&dest->dst_lock);
net/ip_vs.h:			if (ip_route_output(&rt, dest->addr, 0, rtos, 0)) {
net/ip_vs.h:				spin_unlock(&dest->dst_lock);
net/ip_vs.h:					     NIPQUAD(dest->addr));
net/ip_vs.h:			__ip_vs_dst_set(dest, rtos, dst_clone(&rt->u.dst));
net/ip_vs.h:				  NIPQUAD(dest->addr),
net/ip_vs.h:				  atomic_read(&rt->u.dst.__refcnt), rtos);
net/ip_vs.h:		spin_unlock(&dest->dst_lock);
net/ip_vs.h:		if (ip_route_output(&rt, cp->daddr, 0, rtos, 0)) {
net/ip_vs.h:				     "%u.%u.%u.%u\n", NIPQUAD(cp->daddr));
net/ip_vs.h:		checkp = &h->th->check;
net/ip_vs.h:		checkp = &h->uh->check;
net/ip_vs.h:	int delta = (headroom > 16 ? headroom : 16) - skb_headroom(skb);
net/ip_vs.h:			return -ENOMEM;
net/ip_vs.h:		*iph_p = skb->nh.iph;
net/ip_vs.h:		*t_p = (char*) (*iph_p) + (*iph_p)->ihl * 4;
net/atmclip.h:/* net/atm/atmarp.h - RFC1577 ATM ARP */
net/atmclip.h:/* Written 1995-2000 by Werner Almesberger, EPFL LRC/ICA */
net/atmclip.h:#define CLIP_VCC(vcc) ((struct clip_vcc *) ((vcc)->user_back))
net/atmclip.h:#define NEIGH2ENTRY(neigh) ((struct atmarp_entry *) (neigh)->primary_key)
net/atmclip.h:	struct neighbour *neigh;	/* neighbour back-pointer */
pcmcia/ds.h:    ((l) && ((l->state & ~DEV_BUSY) == (DEV_CONFIG|DEV_PRESENT)))
pcmcia/ss.h: *  Calls to set up low-level "Socket Services" drivers
pcmcia/mem_op.h:   to copy between a card and kernel memory.  These routines do 32-bit
pcmcia/mem_op.h:   safe versions defined here will do only 8-bit and 16-bit accesses.
pcmcia/mem_op.h:    n -= odd;
pcmcia/mem_op.h:	(char *)from += 4; (char *)to += 4; n -= 4;
pcmcia/mem_op.h:    while (odd--)
pcmcia/mem_op.h:    n -= odd;
pcmcia/mem_op.h:	(char *)to += 4; (char *)from += 4; n -= 4;
pcmcia/mem_op.h:    while (odd--) {
pcmcia/mem_op.h:    n -= odd;
pcmcia/mem_op.h:	n -= 2;
pcmcia/mem_op.h:    n -= odd;
pcmcia/mem_op.h:	n -= 2;
pcmcia/mem_op.h:    n -= odd;
pcmcia/mem_op.h:	n -= 2;
pcmcia/mem_op.h:    n -= odd;
pcmcia/mem_op.h:	n -= 2;
pcmcia/bus_ops.h:#define bus_inb(b,p)		(b)->b_in((b),(p),0)
pcmcia/bus_ops.h:#define bus_inw(b,p)		(b)->b_in((b),(p),1)
pcmcia/bus_ops.h:#define bus_inl(b,p)		(b)->b_in((b),(p),2)
pcmcia/bus_ops.h:#define bus_inw_ns(b,p)		(b)->b_in((b),(p),-1)
pcmcia/bus_ops.h:#define bus_inl_ns(b,p)		(b)->b_in((b),(p),-2)
pcmcia/bus_ops.h:#define bus_insb(b,p,a,c)	(b)->b_ins((b),(p),(a),(c),0)
pcmcia/bus_ops.h:#define bus_insw(b,p,a,c)	(b)->b_ins((b),(p),(a),(c),1)
pcmcia/bus_ops.h:#define bus_insl(b,p,a,c)	(b)->b_ins((b),(p),(a),(c),2)
pcmcia/bus_ops.h:#define bus_insw_ns(b,p,a,c)	(b)->b_ins((b),(p),(a),(c),-1)
pcmcia/bus_ops.h:#define bus_insl_ns(b,p,a,c)	(b)->b_ins((b),(p),(a),(c),-2)
pcmcia/bus_ops.h:#define bus_outb(b,v,p)		(b)->b_out((b),(v),(p),0)
pcmcia/bus_ops.h:#define bus_outw(b,v,p)		(b)->b_out((b),(v),(p),1)
pcmcia/bus_ops.h:#define bus_outl(b,v,p)		(b)->b_out((b),(v),(p),2)
pcmcia/bus_ops.h:#define bus_outw_ns(b,v,p)	(b)->b_out((b),(v),(p),-1)
pcmcia/bus_ops.h:#define bus_outl_ns(b,v,p)	(b)->b_out((b),(v),(p),-2)
pcmcia/bus_ops.h:#define bus_outsb(b,p,a,c)	(b)->b_outs((b),(p),(a),(c),0)
pcmcia/bus_ops.h:#define bus_outsw(b,p,a,c)	(b)->b_outs((b),(p),(a),(c),1)
pcmcia/bus_ops.h:#define bus_outsl(b,p,a,c)	(b)->b_outs((b),(p),(a),(c),2)
pcmcia/bus_ops.h:#define bus_outsw_ns(b,p,a,c)	(b)->b_outs((b),(p),(a),(c),-1)
pcmcia/bus_ops.h:#define bus_outsl_ns(b,p,a,c)	(b)->b_outs((b),(p),(a),(c),-2)
pcmcia/bus_ops.h:#define bus_readb(b,a)		(b)->b_read((b),(a),0)
pcmcia/bus_ops.h:#define bus_readw(b,a)		(b)->b_read((b),(a),1)
pcmcia/bus_ops.h:#define bus_readl(b,a)		(b)->b_read((b),(a),2)
pcmcia/bus_ops.h:#define bus_readw_ns(b,a)	(b)->b_read((b),(a),-1)
pcmcia/bus_ops.h:#define bus_readl_ns(b,a)	(b)->b_read((b),(a),-2)
pcmcia/bus_ops.h:#define bus_writeb(b,v,a)	(b)->b_write((b),(v),(a),0)
pcmcia/bus_ops.h:#define bus_writew(b,v,a)	(b)->b_write((b),(v),(a),1)
pcmcia/bus_ops.h:#define bus_writel(b,v,a)	(b)->b_write((b),(v),(a),2)
pcmcia/bus_ops.h:#define bus_writew_ns(b,v,a)	(b)->b_write((b),(v),(a),-1)
pcmcia/bus_ops.h:#define bus_writel_ns(b,v,a)	(b)->b_write((b),(v),(a),-2)
pcmcia/bus_ops.h:#define bus_ioremap(b,s,n)	(b)->b_ioremap((b),(s),(n))
pcmcia/bus_ops.h:#define bus_iounmap(b,a)	(b)->b_iounmap((b),(a))
pcmcia/bus_ops.h:#define bus_memcpy_fromio(b,d,s,n) (b)->b_copy_from((b),(d),(s),(n))
pcmcia/bus_ops.h:#define bus_memcpy_toio(b,d,s,n) (b)->b_copy_to((b),(d),(s),(n))
pcmcia/bus_ops.h:				(b)->b_request_irq((b),(i),(h),(f),(n),(d))
pcmcia/bus_ops.h:#define bus_free_irq(b,i,d)	(b)->b_free_irq((b),(i),(d))
scsi/scsicam.h: * scsicam.h - SCSI CAM support functions, use for HDIO_GETGEO, etc.
scsi/scsicam.h: *	+1 (303) 786-7975
scsi/scsicam.h: * For more information, please consult the SCSI-CAM draft.
scsi/sg.h:*       Copyright (C) 1998 - 2003 Douglas Gilbert
scsi/sg.h:	- fix side effect introduced by last "off by one" fix
scsi/sg.h:	- off by one fix for last scatter gather element
scsi/sg.h:	- zero buffer obtained for non-root users
scsi/sg.h:	- change EACCES to EPERM when O_RDONLY is insufficient
scsi/sg.h:	- suppress newlines in host string ( /proc/scsi/sg/host_strs output)
scsi/sg.h:	- fix xfer direction, old interface, short reply_len [Travers Carter]
scsi/sg.h:    	- add support for SG_FLAG_MMAP_IO [permit mmap() on sg devices]
scsi/sg.h:    	- update documentation pointers in this header
scsi/sg.h:    	- put KERNEL_VERSION macros around code that breaks early 2.4 series
scsi/sg.h:    	- fix use count for multiple queued requests on closed fd
scsi/sg.h:    	- switch back to alloc_kiovec()
scsi/sg.h:	- use alloc_kiovec_sz() to speed dio [set num_buffer_heads==0]
scsi/sg.h:	- changes to cope with larger scatter gather element sizes
scsi/sg.h:	- clean up some printk()s
scsi/sg.h:	- add MODULE_LICENSE("GPL") [in a 3.1.20 subversion]
scsi/sg.h:	- fix race around generic_unplug_device() [in a 3.1.20 subversion]
scsi/sg.h:	- add SG_GET_ACCESS_COUNT ioctl 
scsi/sg.h:	- make open() increment and close() decrement access_count
scsi/sg.h:	- only register first 256 devices, reject subsequent devices
scsi/sg.h:	- fix bug that caused long wait when large buffer requested
scsi/sg.h:	- fix leak in error case of sg_new_read() [report: Eric Barton]
scsi/sg.h:	- add 'online' column to /proc/scsi/sg/devices
scsi/sg.h:    	- add CAP_SYS_RAWIO capability for sensitive stuff
scsi/sg.h:    	- compile in dio stuff, procfs 'allow_dio' defaulted off (0)
scsi/sg.h:	- make premature close and detach more robust
scsi/sg.h:	- lun masked into commands <= SCSI_2
scsi/sg.h:	- poll() and async notification now yield POLL_HUP on detach
scsi/sg.h:	- various 3rd party tweaks tracking lk 2.4 internal changes
scsi/sg.h:       ----------        ----------------------------------
scsi/sg.h:	- SG_IO ioctl() combines function if write() and read()
scsi/sg.h:	- new interface (sg_io_hdr_t) but still supports old interface
scsi/sg.h:	- scatter/gather in user space, direct IO, and mmap supported
scsi/sg.h: Historical note: this SCSI pass-through driver has been known as "sg" for 
scsi/sg.h:	http://www.torque.net/sg/p/scsi-generic.txt
scsi/sg.h:	http://www.torque.net/sg/p/scsi-generic_long.txt
scsi/sg.h:        /usr/src/linux/Documentation/scsi-generic.txt .
scsi/sg.h: 	http://www.linuxdoc.org/HOWTO/SCSI-2.4-HOWTO
scsi/sg.h:{                       /* call. It defines one scatter-gather element. */
scsi/sg.h:    unsigned int timeout;       /* [i] MAX_UINT->no timeout (unit: millisec) */
scsi/sg.h:    unsigned int flags;         /* [i] 0 -> default, see SG_FLAG... */
scsi/sg.h:    int pack_id;                /* [i->o] unused internally (normally) */
scsi/sg.h:    void * usr_ptr;             /* [i->o] unused internally */
scsi/sg.h:    int resid;                  /* [o] dxfer_len - actual_transferred */
scsi/sg.h:#define SG_DXFER_NONE (-1)      /* e.g. a SCSI Test Unit Ready command */
scsi/sg.h:#define SG_DXFER_TO_DEV (-2)    /* e.g. a SCSI WRITE command */
scsi/sg.h:#define SG_DXFER_FROM_DEV (-3)  /* e.g. a SCSI READ command */
scsi/sg.h:#define SG_DXFER_TO_FROM_DEV (-4) /* treated like SG_DXFER_FROM_DEV with the
scsi/sg.h:#define SG_DXFER_UNKNOWN (-5)   /* Unknown data direction */
scsi/sg.h:/* following flag values can be "or"-ed together */
scsi/sg.h:/* following 'info' values are "or"-ed together */
scsi/sg.h:    char req_state;     /* 0 -> not used, 1 -> written, 2 -> ready to read */
scsi/sg.h:    char orphan;        /* 0 -> normal request, 1 -> from interruped SG_IO */
scsi/sg.h:    char sg_io_owned;   /* 0 -> complete with read(), 1 -> owned by SG_IO */
scsi/sg.h:    char problem;       /* 0 -> no problem detected, 1 -> error to report */
scsi/sg.h:/* Only supported by the ide-scsi driver */
scsi/sg.h:#define SG_SET_FORCE_LOW_DMA 0x2279  /* 0-> use adapter setting, 1-> force */
scsi/sg.h:#define SG_GET_LOW_DMA 0x227a   /* 0-> use all ram for dma; 1-> low dma ram */
scsi/sg.h:   If pack_id is -1 then read oldest waiting. When ...FORCE_PACK_ID set to 0
scsi/sg.h:#define SG_GET_PACK_ID 0x227c /* Yields oldest readable pack_id (or -1) */
scsi/sg.h:/* Returns -EBUSY if occupied. 3rd argument pointer to int (see next) */
scsi/sg.h:#define SG_SET_KEEP_ORPHAN 0x2287 /* 1 -> hold for read(), 0 -> drop (def) */
scsi/sg.h:/* Largest size (in bytes) a single scatter-gather list element can have.
scsi/sg.h:   i386]. The minimum value is PAGE_SIZE. If scatter-gather not supported
scsi/sg.h:#define SG_DEF_FORCE_LOW_DMA 0  /* was 1 -> memory below 16MB on i386 */
scsi/sg.h:#define SG_SET_DEBUG 0x227e    /* 0 -> turn off debug */
scsi/scsi.h:    $Header: /home/cvsroot/RT288x_SDK/source/linux-2.4.x/include/ack,v 1.1.1.1 2006-10-13 02:42:37 steven Exp $
scsi/scsi.h: *  SCSI Architecture Model (SAM) Status codes. Taken from SAM-3 draft
scsi/scsi.h: *  T10/1561-D Revision 4 Draft dated 7th November 2002.
scsi/scsi.h:#define SAM_STAT_COMMAND_TERMINATED 0x22        /* obsolete in SAM-3 */
scsi/scsi.h:#define TYPE_MOD            0x07    /* Magneto-optical disk - 
scsi/scsi.h:				     * - treated as TYPE_DISK */
scsi/scsi.h: * standard mode-select header prepended to all mode-select commands
scsi/scsi.h: * moved here from cdrom.h -- kraxel
scsi/scsi.h:    u_char  medium; /* device-specific medium type */
scsi/scsi.h:    u_char  density; /* device-specific density code */
scsi/scsi.h:#define     EXTENDED_EXTENDED_IDENTIFY      0x02    /* SCSI-I only */
scsi/scsi.h:#define INITIATE_RECOVERY   0x0f            /* SCSI-II only */
scsi/scsi.h:#define RELEASE_RECOVERY    0x10            /* SCSI-II only */
scsi/scsi.h:/* Note that include/linux/cdrom.h also defines IOCTL 0x5300 - 0x5395 */
scsi/scsi.h: * ---------------------------------------------------------------------------
scsi/scsi.h: * c-indent-level: 4 
scsi/scsi.h: * c-brace-imaginary-offset: 0
scsi/scsi.h: * c-brace-offset: -4
scsi/scsi.h: * c-argdecl-indent: 4
scsi/scsi.h: * c-label-offset: -4
scsi/scsi.h: * c-continued-statement-offset: 4
scsi/scsi.h: * c-continued-brace-offset: 0
scsi/scsi.h: * indent-tabs-mode: nil
scsi/scsi.h: * tab-width: 8
video/fbcon.h: *  linux/drivers/video/fbcon.h -- Low level frame buffer based console driver
video/fbcon.h:    unsigned int fontwidthmask;      /* 1 at (1 << (width - 1)) if width is supported */
video/fbcon.h:    *    This is the interface between the low-level console driver and the
video/fbcon.h:    *    low-level frame buffer device
video/fbcon.h:    /* Filled in by the low-level console driver */
video/fbcon.h:#define fontheight(p) ((p)->_fontheight)
video/fbcon.h:#define fontheightlog(p) ((p)->_fontheightlog)
video/fbcon.h:#define FONTWIDTH(w)	(1 << ((8) - 1))
video/fbcon.h:/* fontwidths w1-w2 inclusive are supported by dispsw */
video/fbcon.h:#define FONTWIDTH(w)	(1 << ((w) - 1))
video/fbcon.h:/* fontwidths w1-w2 inclusive are supported by dispsw */
video/fbcon.h:#define FONTWIDTHRANGE(w1,w2)	(FONTWIDTH(w2+1) - FONTWIDTH(w1))
video/fbcon.h:#define fontwidth(p) ((p)->_fontwidth)
video/fbcon.h:#define fontwidthlog(p) ((p)->_fontwidthlog)
video/fbcon.h:	(((s) >> ((p)->fgshift)) & 0x0f)
video/fbcon.h:	(((s) >> ((p)->bgshift)) & 0x0f)
video/fbcon.h:	((conp) ? (((conp)->vc_video_erase_char >> ((p)->bgshift)) & 0x0f) : 0)
video/fbcon.h:	(((s) & 0x800) ^ ((p)->inverse ? 0x800 : 0))
video/fbcon.h:   and even better if your card can do fonting (1->8/32bit painting),
video/fbcon.h:   all lines on the screen are filled completely with non-space characters,
video/fbcon.h:/* We map all of our framebuffers such that big-endian accesses
video/fbcon.h: * would be faster. I suspect not for simple text system - not much
video/fbcon.h: * Unaligned read/write used requires 68020+ - think this is a problem?
video/fbcon.h:         "lsrl   #1,%1 ; jcc 1f ; moveb %2,%0@-\n\t"
video/fbcon.h:      "1: lsrl   #1,%1 ; jcc 1f ; movew %2,%0@-\n\t"
video/fbcon.h:      "1: lsrl   #1,%1 ; jcc 1f ; movel %2,%0@-\n\t"
video/fbcon.h:      "1: lsrl   #1,%1 ; jcc 1f ; movel %2,%0@- ; movel %2,%0@-\n\t"
video/fbcon.h:      "2: moveml %2/%%d4/%%d5/%%d6,%0@-\n\t"
video/fbcon.h:         "lsrl   #1,%1 ; jcc 1f ; moveb %2,%0@-\n\t"
video/fbcon.h:      "1: lsrl   #1,%1 ; jcc 1f ; movew %2,%0@-\n\t"
video/fbcon.h:      "1: lsrl   #1,%1 ; jcc 1f ; movel %2,%0@-\n\t"
video/fbcon.h:      "1: lsrl   #1,%1 ; jcc 1f ; movel %2,%0@- ; movel %2,%0@-\n\t"
video/fbcon.h:         : "d" (-1), "0" ((char *)s+count), "1" (count)
video/fbcon.h:      "2: moveml %2/%%d4/%%d5/%%d6,%0@-\n\t"
video/fbcon.h:         : "d" (-1), "0" (s), "1" (count)
video/fbcon.h:            "2: movew  %2,%-; lsrl #2,%2 ; jeq 6f\n\t"
video/fbcon.h:               "lsrl   #1,%2 ; jcc 1f ; moveb %1@-,%0@-\n\t"
video/fbcon.h:            "1: lsrl   #1,%2 ; jcc 1f ; movew %1@-,%0@-\n\t"
video/fbcon.h:            "1: lsrl   #1,%2 ; jcc 1f ; movel %1@-,%0@-\n\t"
video/fbcon.h:            "1: lsrl   #1,%2 ; jcc 1f ; movel %1@-,%0@- ; movel %1@-,%0@-\n\t"
video/fbcon.h:               "lsrl   #1,%3 ; jcc 1f ; moveb %1@-,%0@- ; subqw #1,%2\n\t"
video/fbcon.h:               "movew  %1@-,%0@-  ; subqw  #2,%2 ; jra 2f\n\t"
video/fbcon.h:               "movew  %1@-,%0@-  ; subqw  #2,%2\n\t"
video/fbcon.h:            "2: movew %2,%-; lsrl #2,%2 ; jeq 6f\n\t"
video/fbcon.h:               "lsrl   #1,%2 ; jcc 3f ; movel %1@-,%0@-\n\t"
video/fbcon.h:            "3: lsrl   #1,%2 ; jcc 4f ; movel %1@-,%0@- ; movel %1@-,%0@-\n\t"
video/fbcon.h:            "5: movel %1@-,%0@-;movel %1@-,%0@-\n\t"
video/fbcon.h:               "movel %1@-,%0@-;movel %1@-,%0@-\n\t"
video/fbcon.h:            "6: movew %+,%2; btst #1,%2 ; jeq 7f ; movew %1@-,%0@-\n\t"
video/fbcon.h:            "7:              ; btst #0,%2 ; jeq 8f ; moveb %1@-,%0@-\n\t"
video/fbcon.h:       : "0" (src), "1" (dst), "2" (size / 16 - 1)
video/fbcon.h:       "  moveml %/d0/%/d1/%/a0/%/a1,%1@-\n"
video/fbcon.h:       : "0" (src + size), "1" (dst + size), "2" (size / 16 - 1)
video/fbcon.h:	    ((char *) d)[count-i-1] = ((char *) s)[count-i-1];
video/fbcon.h:    while (count--)
video/fbcon.h:	count--;
video/fbcon.h:	count -= 2;
video/fbcon.h:	count -= 4;
video/fbcon.h:    while (count--)
video/fbcon.h:	count--;
video/fbcon.h:	count -= 2;
video/fbcon.h:	count -= 4;
video/fbcon.h:    while (count--)
video/fbcon.h:	:"0"(count),"1"(count-4+(long)d),"2"(count-4+(long)s)
video/fbcon.h:	    count--;
video/fbcon.h:	    count -= 2;
video/fbcon.h:	    count -= 4;
video/fbcon.h:	while (count--)
video/fbcon.h:	    src--;
video/fbcon.h:	    dst--;
video/fbcon.h:	    count--;
video/fbcon.h:	    src -= 2;
video/fbcon.h:	    dst -= 2;
video/fbcon.h:	    count -= 2;
video/fbcon.h:	    src -= 4;
video/fbcon.h:	    dst -= 4;
video/fbcon.h:	    count -= 4;
video/fbcon.h:	while (count--) {
video/fbcon.h:	    src--;
video/fbcon.h:	    dst--;
video/fbcon.h:	    count--;
video/fbcon.h:	    count -= 2;
video/fbcon.h:	    count -= 4;
video/fbcon.h:	while (count--)
video/fbcon.h:	    src--;
video/fbcon.h:	    dst--;
video/fbcon.h:	    count--;
video/fbcon.h:	    src -= 2;
video/fbcon.h:	    dst -= 2;
video/fbcon.h:	    count -= 2;
video/fbcon.h:	    src -= 4;
video/fbcon.h:	    dst -= 4;
video/fbcon.h:	    count -= 4;
video/fbcon.h:	while (count--) {
video/fbcon.h:	    src--;
video/fbcon.h:	    dst--;
video/sbusfb.h:	struct	fbcurpos chot;  /* hot-spot */
video/sbusfb.h:#define SBUS_MMAP_FBSIZE(n) (-n)
video/sbusfb.h:#define sbusfbinfod(disp) ((struct fb_info_sbusfb *)(disp->fb_info))
video/sbusfb.h:#define SBUSFBINIT_SIZECHANGE ((char *)-1)
video/fbcon-iplan2p2.h: *  FBcon low-level driver for Atari interleaved bitplanes (2 planes) (iplan2p2)
video/fbcon-iplan2p4.h: *  FBcon low-level driver for Atari interleaved bitplanes (4 planes) (iplan2p4)
video/fbcon-iplan2p8.h: *  FBcon low-level driver for Atari interleaved bitplanes (8 planes) (iplan2p8)
video/macmodes.h: *  linux/drivers/video/macmodes.h -- Standard MacOS video modes
video/macmodes.h:#define CMODE_NVRAM		-1
video/macmodes.h:#define CMODE_CHOOSE		-2
video/font.h: *  font.h -- `Soft' font definitions
video/fbcon-afb.h: *  FBcon low-level driver for Amiga bitplanes (afb)
video/fbcon-hga.h: *  FBcon low-level driver for Hercules Graphics Adaptor (hga)
video/fbcon-mac.h: *  FBcon low-level driver for Mac variable bpp packed pixels (mac)
video/fbcon-mfb.h: *  FBcon low-level driver for Monochrome (mfb)
video/fbcon-cfb2.h: *  FBcon low-level driver for 2 bpp packed pixel (cfb2)
video/fbcon-cfb4.h: *  FBcon low-level driver for 4 bpp packed pixel (cfb4)
video/fbcon-cfb8.h: *  FBcon low-level driver for 8 bpp packed pixel (cfb8)
video/fbcon-vga.h: *  FBcon low-level driver for VGA characters/attributes
video/e1356fb.h: *	e1356fb.h  --  Epson SED1356 Framebuffer Driver IOCTL Interface
video/fbcon-ilbm.h: *  FBcon low-level driver for Amiga interleaved bitplanes (ilbm)
video/fbcon-cfb16.h: *  FBcon low-level driver for 16 bpp packed pixel (cfb16)
video/fbcon-cfb24.h: *  FBcon low-level driver for 24 bpp packed pixel (cfb24)
video/fbcon-cfb32.h: *  FBcon low-level driver for 32 bpp packed pixel (cfb32)
video/newport.h: * Ulf Carlsson - Compability with the IRIX structures added
video/newport.h:#define NPORT_DMODE1_PFENAB      0x04000000 /* Pre-fetch enable */
video/newport.h:	npfreg_t _xstart;	/* X-start point (current) */
video/newport.h:	npfreg_t _ystart;	/* Y-start point (current) */
video/newport.h:	npfreg_t _xend;		/* x-end point */
video/newport.h:	npfreg_t _yend;		/* y-end point */
video/newport.h:	regs->set.dcbmode = (NPORT_DMODE_AVC2 | VC2_REGADDR_INDEX | NPORT_DMODE_W3 |
video/newport.h:	regs->set.dcbdata0.byword = (vc2ireg << 24) | (val << 8);
video/newport.h:	regs->set.dcbmode = (NPORT_DMODE_AVC2 | VC2_REGADDR_INDEX | NPORT_DMODE_W1 |
video/newport.h:	regs->set.dcbdata0.bybytes.b3 = vc2ireg;
video/newport.h:	regs->set.dcbmode = (NPORT_DMODE_AVC2 | VC2_REGADDR_IREG | NPORT_DMODE_W2 |
video/newport.h:	return regs->set.dcbdata0.byshort.s1;
video/newport.h:	regs->set.dcbmode = (NPORT_DMODE_ACMALL | NCMAP_PROTOCOL |
video/newport.h:	regs->set.dcbdata0.byshort.s1 = addr;
video/newport.h:	regs->set.dcbmode = (NPORT_DMODE_ACMALL | NCMAP_PROTOCOL |
video/newport.h:	regs->set.dcbdata0.byword =
video/newport.h:	while (t--)
video/newport.h:		if (!(regs->cset.status & NPORT_STAT_GBUSY))
video/newport.h:	while (t--)
video/newport.h:		if(!(regs->cset.status & NPORT_STAT_BBUSY))
video/newport.h:/*   XMAP9 -- registers as seen on the DCBMODE register*/
video/newport.h:        rex->set.dcbmode = DCB_XMAP0 | XM9_CRS_FIFO_AVAIL |
video/newport.h:        while ((rex->set.dcbdata0.bybytes.b3 & 3) != XM9_FIFO_EMPTY)
video/newport.h:            rex->set.dcbmode = DCB_XMAP_ALL | XM9_CRS_MODE_REG_DATA |
video/newport.h:            rex->set.dcbmode = DCB_XMAP_ALL | XM9_CRS_MODE_REG_DATA |
video/newport.h:            rex->set.dcbmode = DCB_XMAP_ALL | XM9_CRS_MODE_REG_DATA |
video/newport.h:        rex->set.dcbdata0.byword = ((modereg) << 24) | (data24 & 0xffffff);
video/fbcon-vga-planes.h: *  FBcon low-level driver for VGA 4-plane modes
